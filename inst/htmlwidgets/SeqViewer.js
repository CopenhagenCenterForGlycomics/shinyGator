!function(g){var I={};function C(n){if(I[n])return I[n].exports;var A=I[n]={i:n,l:!1,exports:{}};return g[n].call(A.exports,A,A.exports,C),A.l=!0,A.exports}C.m=g,C.c=I,C.d=function(g,I,n){C.o(g,I)||Object.defineProperty(g,I,{enumerable:!0,get:n})},C.r=function(g){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})},C.t=function(g,I){if(1&I&&(g=C(g)),8&I)return g;if(4&I&&"object"==typeof g&&g&&g.__esModule)return g;var n=Object.create(null);if(C.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:g}),2&I&&"string"!=typeof g)for(var A in g)C.d(n,A,function(I){return g[I]}.bind(null,A));return n},C.n=function(g){var I=g&&g.__esModule?function(){return g.default}:function(){return g};return C.d(I,"a",I),I},C.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},C.p="",C(C.s=0)}({"../gator/js/bean.js":
/*!***************************!*\
  !*** ../gator/js/bean.js ***!
  \***************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/*!\n  * bean.js - copyright Jacob Thornton 2011\n  * https://github.com/fat/bean\n  * MIT License\n  * special thanks to:\n  * dean edwards: http://dean.edwards.name/\n  * dperini: https://github.com/dperini/nwevents\n  * the entire mootools team: github.com/mootools/mootools-core\n  */\nconst bean = function (context) {\n  var __uid = 1,\n      registry = {},\n      collected = {},\n      overOut = /over|out/,\n      namespace = /[^\\.]*(?=\\..*)\\.|.*/,\n      stripName = /\\..*/,\n      addEvent = 'addEventListener',\n      attachEvent = 'attachEvent',\n      removeEvent = 'removeEventListener',\n      detachEvent = 'detachEvent',\n      doc = context.document || {},\n      root = doc.documentElement || {},\n      W3C_MODEL = root[addEvent],\n      eventSupport = W3C_MODEL ? addEvent : attachEvent,\n      isDescendant = function isDescendant(parent, child) {\n    var node = child.parentNode;\n\n    while (node !== null) {\n      if (node == parent) {\n        return true;\n      }\n\n      node = node.parentNode;\n    }\n  },\n      retrieveUid = function retrieveUid(obj, uid) {\n    return obj.__uid = uid && uid + '::' + __uid++ || obj.__uid || __uid++;\n  },\n      retrieveEvents = function retrieveEvents(element) {\n    var uid = retrieveUid(element);\n    return registry[uid] = registry[uid] || {};\n  },\n      listener = W3C_MODEL ? function (element, type, fn, add) {\n    element[add ? addEvent : removeEvent](type, fn, false);\n  } : function (element, type, fn, add, custom) {\n    custom && add && (element['_on' + custom] = element['_on' + custom] || 0);\n    element[add ? attachEvent : detachEvent]('on' + type, fn);\n  },\n      nativeHandler = function nativeHandler(element, fn, args) {\n    return function (event, arg) {\n      event = fixEvent(event || ((this.ownerDocument || this.document || this).parentWindow || context).event);\n      return fn.apply(element, [event].concat(args).concat(arg));\n    };\n  },\n      customHandler = function customHandler(element, fn, type, condition, args) {\n    return function (e) {\n      if (condition ? condition.apply(this, arguments) : W3C_MODEL ? true : e && e.propertyName == '_on' + type || !e) {\n        fn.apply(element, Array.prototype.slice.call(arguments, e ? 0 : 1).concat(args));\n      }\n    };\n  },\n      addListener = function addListener(element, orgType, _fn, args) {\n    var type = orgType.replace(stripName, ''),\n        events = retrieveEvents(element),\n        handlers = events[type] || (events[type] = {}),\n        originalFn = _fn,\n        uid = retrieveUid(_fn, orgType.replace(namespace, ''));\n\n    if (handlers[uid]) {\n      return element;\n    }\n\n    var custom = customEvents[type];\n\n    if (custom) {\n      _fn = custom.condition ? customHandler(element, _fn, type, custom.condition) : _fn;\n      type = custom.base || type;\n    }\n\n    var isNative = nativeEvents[type];\n    _fn = isNative ? nativeHandler(element, _fn, args) : customHandler(element, _fn, type, false, args);\n    isNative = W3C_MODEL || isNative;\n\n    if (type == 'unload') {\n      var org = _fn;\n\n      _fn = function fn() {\n        removeListener(element, type, _fn) && org();\n      };\n    }\n\n    element[eventSupport] && listener(element, isNative ? type : 'propertychange', _fn, true, !isNative && type);\n    handlers[uid] = _fn;\n    _fn.__uid = uid;\n    _fn.__originalFn = originalFn;\n    return type == 'unload' ? element : collected[retrieveUid(element)] = element;\n  },\n      removeListener = function removeListener(element, orgType, handler) {\n    var uid,\n        names,\n        uids,\n        i,\n        events = retrieveEvents(element),\n        type = orgType.replace(stripName, '');\n\n    if (!events || !events[type]) {\n      return element;\n    }\n\n    names = orgType.replace(namespace, '');\n    uids = names ? names.split('.') : [handler.__uid];\n\n    function destroyHandler(uid) {\n      handler = events[type][uid];\n\n      if (!handler) {\n        return;\n      }\n\n      delete events[type][uid];\n\n      if (element[eventSupport]) {\n        type = customEvents[type] ? customEvents[type].base : type;\n        var isNative = W3C_MODEL || nativeEvents[type];\n        listener(element, isNative ? type : 'propertychange', handler, false, !isNative && type);\n      }\n    }\n\n    destroyHandler(names); //get combos\n\n    for (i = uids.length; i--; destroyHandler(uids[i])) {} //get singles\n\n\n    return element;\n  },\n      del = function del(selector, fn, $) {\n    return function (e) {\n      var array = typeof selector == 'string' ? $(selector, this) : selector;\n\n      for (var target = e.target; target && target != this; target = target.parentNode) {\n        for (var i = array.length; i--;) {\n          if (array[i] == target) {\n            return fn.apply(target, arguments);\n          }\n        }\n      }\n    };\n  },\n      add = function add(element, events, fn, delfn, $) {\n    if (typeof events == 'object' && !fn) {\n      for (var type in events) {\n        events.hasOwnProperty(type) && add(element, type, events[type]);\n      }\n    } else {\n      var isDel = typeof fn == 'string',\n          types = (isDel ? fn : events).split(' ');\n      fn = isDel ? del(events, delfn, $) : fn;\n\n      for (var i = types.length; i--;) {\n        addListener(element, types[i], fn, Array.prototype.slice.call(arguments, isDel ? 4 : 3));\n      }\n    }\n\n    return element;\n  },\n      remove = function remove(element, orgEvents, fn) {\n    var k,\n        m,\n        type,\n        events,\n        i,\n        isString = typeof orgEvents == 'string',\n        names = isString && orgEvents.replace(namespace, ''),\n        names = names && names.split('.'),\n        rm = removeListener,\n        attached = retrieveEvents(element);\n\n    if (isString && /\\s/.test(orgEvents)) {\n      orgEvents = orgEvents.split(' ');\n      i = orgEvents.length - 1;\n\n      while (remove(element, orgEvents[i]) && i--) {}\n\n      return element;\n    }\n\n    events = isString ? orgEvents.replace(stripName, '') : orgEvents;\n\n    if (!attached || names || isString && !attached[events]) {\n      for (k in attached) {\n        if (attached.hasOwnProperty(k)) {\n          for (i in attached[k]) {\n            for (m = names.length; m--;) {\n              attached[k].hasOwnProperty(i) && new RegExp('^' + names[m] + '::\\\\d*(\\\\..*)?$').test(i) && rm(element, [k, i].join('.'));\n            }\n          }\n        }\n      }\n\n      return element;\n    }\n\n    if (typeof fn == 'function') {\n      rm(element, events, fn);\n    } else if (names) {\n      rm(element, orgEvents);\n    } else {\n      rm = events ? rm : remove;\n      type = isString && events;\n      events = events ? fn || attached[events] || events : attached;\n\n      for (k in events) {\n        if (events.hasOwnProperty(k)) {\n          rm(element, type || k, events[k]);\n          delete events[k]; // remove unused leaf keys\n        }\n      }\n    }\n\n    return element;\n  },\n      fire = function fire(element, type, args) {\n    var evt,\n        k,\n        i,\n        m,\n        types = type.split(' ');\n\n    for (i = types.length; i--;) {\n      type = types[i].replace(stripName, '');\n      var isNative = nativeEvents[type],\n          isNamespace = types[i].replace(namespace, ''),\n          handlers = retrieveEvents(element)[type];\n\n      if (isNamespace) {\n        isNamespace = isNamespace.split('.');\n\n        for (k = isNamespace.length; k--;) {\n          for (m in handlers) {\n            handlers.hasOwnProperty(m) && new RegExp('^' + isNamespace[k] + '::\\\\d*(\\\\..*)?$').test(m) && handlers[m].apply(element, [false].concat(args));\n          }\n        }\n      } else if (!args && element[eventSupport]) {\n        fireListener(isNative, type, element);\n      } else {\n        for (k in handlers) {\n          handlers.hasOwnProperty(k) && handlers[k].apply(element, [false].concat(args));\n        }\n      }\n    }\n\n    return element;\n  },\n      fireListener = W3C_MODEL ? function (isNative, type, element) {\n    evt = document.createEvent(isNative ? \"HTMLEvents\" : \"UIEvents\");\n    evt[isNative ? 'initEvent' : 'initUIEvent'](type, true, true, context, 1);\n    element.dispatchEvent(evt);\n  } : function (isNative, type, element) {\n    isNative ? element.fireEvent('on' + type, document.createEventObject()) : element['_on' + type]++;\n  },\n      clone = function clone(element, from, type) {\n    var events = retrieveEvents(from),\n        obj,\n        k;\n    var uid = retrieveUid(element);\n    obj = type ? events[type] : events;\n\n    for (k in obj) {\n      obj.hasOwnProperty(k) && (type ? add : clone)(element, type || from, type ? obj[k].__originalFn : k);\n    }\n\n    return element;\n  },\n      fixEvent = function fixEvent(e) {\n    var result = {};\n\n    if (!e) {\n      return result;\n    }\n\n    var type = e.type,\n        target = e.target || e.srcElement;\n    result.preventDefault = fixEvent.preventDefault(e);\n    result.stopPropagation = fixEvent.stopPropagation(e);\n    result.target = target && target.nodeType == 3 ? target.parentNode : target;\n\n    if (type && type.indexOf('key')) {\n      result.keyCode = e.which || e.keyCode;\n    } else if (/click|mouse|menu/i.test(type)) {\n      result.rightClick = e.which == 3 || e.button == 2;\n      result.pos = {\n        x: 0,\n        y: 0\n      };\n\n      if (e.pageX || e.pageY) {\n        result.clientX = e.pageX;\n        result.clientY = e.pageY;\n      } else if (e.clientX || e.clientY) {\n        result.clientX = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;\n        result.clientY = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;\n      }\n\n      overOut.test(type) && (result.relatedTarget = e.relatedTarget || e[(type == 'mouseover' ? 'from' : 'to') + 'Element']);\n    }\n\n    for (var k in e) {\n      if (!(k in result)) {\n        result[k] = e[k];\n      }\n    }\n\n    return result;\n  };\n\n  fixEvent.preventDefault = function (e) {\n    return function () {\n      if (e.preventDefault) {\n        e.preventDefault();\n      } else {\n        e.returnValue = false;\n      }\n    };\n  };\n\n  fixEvent.stopPropagation = function (e) {\n    return function () {\n      if (e.stopPropagation) {\n        e.stopPropagation();\n      } else {\n        e.cancelBubble = true;\n      }\n    };\n  };\n\n  var nativeEvents = {\n    click: 1,\n    dblclick: 1,\n    mouseup: 1,\n    mousedown: 1,\n    contextmenu: 1,\n    //mouse buttons\n    mousewheel: 1,\n    DOMMouseScroll: 1,\n    //mouse wheel\n    mouseover: 1,\n    mouseout: 1,\n    mousemove: 1,\n    selectstart: 1,\n    selectend: 1,\n    //mouse movement\n    keydown: 1,\n    keypress: 1,\n    keyup: 1,\n    //keyboard\n    orientationchange: 1,\n    // mobile\n    touchstart: 1,\n    touchmove: 1,\n    touchend: 1,\n    touchcancel: 1,\n    // touch\n    gesturestart: 1,\n    gesturechange: 1,\n    gestureend: 1,\n    // gesture\n    focus: 1,\n    blur: 1,\n    change: 1,\n    reset: 1,\n    select: 1,\n    submit: 1,\n    //form elements\n    load: 1,\n    unload: 1,\n    beforeunload: 1,\n    resize: 1,\n    move: 1,\n    DOMContentLoaded: 1,\n    readystatechange: 1,\n    //window\n    error: 0,\n    abort: 1,\n    scroll: 1\n  }; //misc\n\n  function check(event) {\n    var related = event.relatedTarget;\n\n    if (!related) {\n      return related === null;\n    }\n\n    return related != this && related.prefix != 'xul' && !/document/.test(this.toString()) && !isDescendant(this, related);\n  }\n\n  var customEvents = {\n    mouseenter: {\n      base: 'mouseover',\n      condition: check\n    },\n    mouseleave: {\n      base: 'mouseout',\n      condition: check //    mousewheel: { base: /Firefox/.test(navigator.userAgent) ? 'DOMMouseScroll' : 'mousewheel' }\n\n    }\n  };\n  var bean = {\n    add: add,\n    remove: remove,\n    clone: clone,\n    fire: fire\n  };\n\n  var clean = function clean(el) {\n    var uid = remove(el).__uid;\n\n    if (uid) {\n      delete collected[uid];\n      delete registry[uid];\n    }\n  };\n\n  if (context[attachEvent]) {\n    add(context, 'unload', function () {\n      for (var k in collected) {\n        collected.hasOwnProperty(k) && clean(collected[k]);\n      }\n\n      context.CollectGarbage && CollectGarbage();\n    });\n  }\n\n  var oldBean = context.bean;\n\n  bean.noConflict = function () {\n    context.bean = oldBean;\n    return this;\n  };\n\n   true && module.exports ? module.exports = bean : context['bean'] = bean;\n  return bean;\n}({});\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (bean);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../shinyGator/node_modules/.registry.npmjs.org/webpack/4.29.6/node_modules/webpack/buildin/harmony-module.js */ \"./node_modules/.registry.npmjs.org/webpack/4.29.6/node_modules/webpack/buildin/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vZ2F0b3IvanMvYmVhbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9nYXRvci9qcy9iZWFuLmpzPzFmYzciXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gICogYmVhbi5qcyAtIGNvcHlyaWdodCBKYWNvYiBUaG9ybnRvbiAyMDExXG4gICogaHR0cHM6Ly9naXRodWIuY29tL2ZhdC9iZWFuXG4gICogTUlUIExpY2Vuc2VcbiAgKiBzcGVjaWFsIHRoYW5rcyB0bzpcbiAgKiBkZWFuIGVkd2FyZHM6IGh0dHA6Ly9kZWFuLmVkd2FyZHMubmFtZS9cbiAgKiBkcGVyaW5pOiBodHRwczovL2dpdGh1Yi5jb20vZHBlcmluaS9ud2V2ZW50c1xuICAqIHRoZSBlbnRpcmUgbW9vdG9vbHMgdGVhbTogZ2l0aHViLmNvbS9tb290b29scy9tb290b29scy1jb3JlXG4gICovXG5jb25zdCBiZWFuID0gKGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIHZhciBfX3VpZCA9IDEsXG4gICAgICByZWdpc3RyeSA9IHt9LFxuICAgICAgY29sbGVjdGVkID0ge30sXG4gICAgICBvdmVyT3V0ID0gL292ZXJ8b3V0LyxcbiAgICAgIG5hbWVzcGFjZSA9IC9bXlxcLl0qKD89XFwuLiopXFwufC4qLyxcbiAgICAgIHN0cmlwTmFtZSA9IC9cXC4uKi8sXG4gICAgICBhZGRFdmVudCA9ICdhZGRFdmVudExpc3RlbmVyJyxcbiAgICAgIGF0dGFjaEV2ZW50ID0gJ2F0dGFjaEV2ZW50JyxcbiAgICAgIHJlbW92ZUV2ZW50ID0gJ3JlbW92ZUV2ZW50TGlzdGVuZXInLFxuICAgICAgZGV0YWNoRXZlbnQgPSAnZGV0YWNoRXZlbnQnLFxuICAgICAgZG9jID0gY29udGV4dC5kb2N1bWVudCB8fCB7fSxcbiAgICAgIHJvb3QgPSBkb2MuZG9jdW1lbnRFbGVtZW50IHx8IHt9LFxuICAgICAgVzNDX01PREVMID0gcm9vdFthZGRFdmVudF0sXG4gICAgICBldmVudFN1cHBvcnQgPSBXM0NfTU9ERUwgPyBhZGRFdmVudCA6IGF0dGFjaEV2ZW50LFxuXG4gIGlzRGVzY2VuZGFudCA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkKSB7XG4gICAgdmFyIG5vZGUgPSBjaGlsZC5wYXJlbnROb2RlO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAobm9kZSA9PSBwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgfSxcblxuICByZXRyaWV2ZVVpZCA9IGZ1bmN0aW9uIChvYmosIHVpZCkge1xuICAgIHJldHVybiAob2JqLl9fdWlkID0gdWlkICYmICh1aWQgKyAnOjonICsgX191aWQrKykgfHwgb2JqLl9fdWlkIHx8IF9fdWlkKyspO1xuICB9LFxuXG4gIHJldHJpZXZlRXZlbnRzID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICB2YXIgdWlkID0gcmV0cmlldmVVaWQoZWxlbWVudCk7XG4gICAgcmV0dXJuIChyZWdpc3RyeVt1aWRdID0gcmVnaXN0cnlbdWlkXSB8fCB7fSk7XG4gIH0sXG5cbiAgbGlzdGVuZXIgPSBXM0NfTU9ERUwgPyBmdW5jdGlvbiAoZWxlbWVudCwgdHlwZSwgZm4sIGFkZCkge1xuICAgIGVsZW1lbnRbYWRkID8gYWRkRXZlbnQgOiByZW1vdmVFdmVudF0odHlwZSwgZm4sIGZhbHNlKTtcbiAgfSA6IGZ1bmN0aW9uIChlbGVtZW50LCB0eXBlLCBmbiwgYWRkLCBjdXN0b20pIHtcbiAgICBjdXN0b20gJiYgYWRkICYmIChlbGVtZW50Wydfb24nICsgY3VzdG9tXSA9IGVsZW1lbnRbJ19vbicgKyBjdXN0b21dIHx8IDApO1xuICAgIGVsZW1lbnRbYWRkID8gYXR0YWNoRXZlbnQgOiBkZXRhY2hFdmVudF0oJ29uJyArIHR5cGUsIGZuKTtcbiAgfSxcblxuICBuYXRpdmVIYW5kbGVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIGZuLGFyZ3MpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50LGFyZykge1xuICAgICAgZXZlbnQgPSBmaXhFdmVudChldmVudCB8fCAoKHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLmRvY3VtZW50IHx8IHRoaXMpLnBhcmVudFdpbmRvdyB8fCBjb250ZXh0KS5ldmVudCk7XG4gICAgICByZXR1cm4gZm4uYXBwbHkoZWxlbWVudCwgW2V2ZW50XS5jb25jYXQoYXJncykuY29uY2F0KGFyZykpO1xuICAgIH07XG4gIH0sXG5cbiAgY3VzdG9tSGFuZGxlciA9IGZ1bmN0aW9uIChlbGVtZW50LCBmbiwgdHlwZSwgY29uZGl0aW9uLCBhcmdzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoY29uZGl0aW9uID8gY29uZGl0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBXM0NfTU9ERUwgPyB0cnVlIDogZSAmJiBlLnByb3BlcnR5TmFtZSA9PSAnX29uJyArIHR5cGUgfHwgIWUpIHtcbiAgICAgICAgZm4uYXBwbHkoZWxlbWVudCwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCBlID8gMCA6IDEpLmNvbmNhdChhcmdzKSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcblxuICBhZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcmdUeXBlLCBmbiwgYXJncykge1xuICAgIHZhciB0eXBlID0gb3JnVHlwZS5yZXBsYWNlKHN0cmlwTmFtZSwgJycpLFxuICAgICAgICBldmVudHMgPSByZXRyaWV2ZUV2ZW50cyhlbGVtZW50KSxcbiAgICAgICAgaGFuZGxlcnMgPSBldmVudHNbdHlwZV0gfHwgKGV2ZW50c1t0eXBlXSA9IHt9KSxcbiAgICAgICAgb3JpZ2luYWxGbiA9IGZuLFxuICAgICAgICB1aWQgPSByZXRyaWV2ZVVpZChmbiwgb3JnVHlwZS5yZXBsYWNlKG5hbWVzcGFjZSwgJycpKTtcbiAgICBpZiAoaGFuZGxlcnNbdWlkXSkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICAgIHZhciBjdXN0b20gPSBjdXN0b21FdmVudHNbdHlwZV07XG4gICAgaWYgKGN1c3RvbSkge1xuICAgICAgZm4gPSBjdXN0b20uY29uZGl0aW9uID8gY3VzdG9tSGFuZGxlcihlbGVtZW50LCBmbiwgdHlwZSwgY3VzdG9tLmNvbmRpdGlvbikgOiBmbjtcbiAgICAgIHR5cGUgPSBjdXN0b20uYmFzZSB8fCB0eXBlO1xuICAgIH1cbiAgICB2YXIgaXNOYXRpdmUgPSBuYXRpdmVFdmVudHNbdHlwZV07XG4gICAgZm4gPSBpc05hdGl2ZSA/IG5hdGl2ZUhhbmRsZXIoZWxlbWVudCwgZm4sIGFyZ3MpIDogY3VzdG9tSGFuZGxlcihlbGVtZW50LCBmbiwgdHlwZSwgZmFsc2UsIGFyZ3MpO1xuICAgIGlzTmF0aXZlID0gVzNDX01PREVMIHx8IGlzTmF0aXZlO1xuICAgIGlmICh0eXBlID09ICd1bmxvYWQnKSB7XG4gICAgICB2YXIgb3JnID0gZm47XG4gICAgICBmbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIoZWxlbWVudCwgdHlwZSwgZm4pICYmIG9yZygpO1xuICAgICAgfTtcbiAgICB9XG4gICAgZWxlbWVudFtldmVudFN1cHBvcnRdICYmIGxpc3RlbmVyKGVsZW1lbnQsIGlzTmF0aXZlID8gdHlwZSA6ICdwcm9wZXJ0eWNoYW5nZScsIGZuLCB0cnVlLCAhaXNOYXRpdmUgJiYgdHlwZSk7XG4gICAgaGFuZGxlcnNbdWlkXSA9IGZuO1xuICAgIGZuLl9fdWlkID0gdWlkO1xuICAgIGZuLl9fb3JpZ2luYWxGbiA9IG9yaWdpbmFsRm47XG4gICAgcmV0dXJuIHR5cGUgPT0gJ3VubG9hZCcgPyBlbGVtZW50IDogKGNvbGxlY3RlZFtyZXRyaWV2ZVVpZChlbGVtZW50KV0gPSBlbGVtZW50KTtcbiAgfSxcblxuICByZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcmdUeXBlLCBoYW5kbGVyKSB7XG4gICAgdmFyIHVpZCwgbmFtZXMsIHVpZHMsIGksIGV2ZW50cyA9IHJldHJpZXZlRXZlbnRzKGVsZW1lbnQpLCB0eXBlID0gb3JnVHlwZS5yZXBsYWNlKHN0cmlwTmFtZSwgJycpO1xuICAgIGlmICghZXZlbnRzIHx8ICFldmVudHNbdHlwZV0pIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbiAgICBuYW1lcyA9IG9yZ1R5cGUucmVwbGFjZShuYW1lc3BhY2UsICcnKTtcbiAgICB1aWRzID0gbmFtZXMgPyBuYW1lcy5zcGxpdCgnLicpIDogW2hhbmRsZXIuX191aWRdO1xuXG4gICAgZnVuY3Rpb24gZGVzdHJveUhhbmRsZXIodWlkKSB7XG4gICAgICBoYW5kbGVyID0gZXZlbnRzW3R5cGVdW3VpZF07XG4gICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXVt1aWRdO1xuICAgICAgaWYgKGVsZW1lbnRbZXZlbnRTdXBwb3J0XSkge1xuICAgICAgICB0eXBlID0gY3VzdG9tRXZlbnRzW3R5cGVdID8gY3VzdG9tRXZlbnRzW3R5cGVdLmJhc2UgOiB0eXBlO1xuICAgICAgICB2YXIgaXNOYXRpdmUgPSBXM0NfTU9ERUwgfHwgbmF0aXZlRXZlbnRzW3R5cGVdO1xuICAgICAgICBsaXN0ZW5lcihlbGVtZW50LCBpc05hdGl2ZSA/IHR5cGUgOiAncHJvcGVydHljaGFuZ2UnLCBoYW5kbGVyLCBmYWxzZSwgIWlzTmF0aXZlICYmIHR5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRlc3Ryb3lIYW5kbGVyKG5hbWVzKTsgLy9nZXQgY29tYm9zXG4gICAgZm9yIChpID0gdWlkcy5sZW5ndGg7IGktLTsgZGVzdHJveUhhbmRsZXIodWlkc1tpXSkpIHt9IC8vZ2V0IHNpbmdsZXNcblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9LFxuXG4gIGRlbCA9IGZ1bmN0aW9uIChzZWxlY3RvciwgZm4sICQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBhcnJheSA9IHR5cGVvZiBzZWxlY3RvciA9PSAnc3RyaW5nJyA/ICQoc2VsZWN0b3IsIHRoaXMpIDogc2VsZWN0b3I7XG4gICAgICBmb3IgKHZhciB0YXJnZXQgPSBlLnRhcmdldDsgdGFyZ2V0ICYmIHRhcmdldCAhPSB0aGlzOyB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gYXJyYXkubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgaWYgKGFycmF5W2ldID09IHRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRhcmdldCwgYXJndW1lbnRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9LFxuXG4gIGFkZCA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudHMsIGZuLCBkZWxmbiwgJCkge1xuICAgIGlmICh0eXBlb2YgZXZlbnRzID09ICdvYmplY3QnICYmICFmbikge1xuICAgICAgZm9yICh2YXIgdHlwZSBpbiBldmVudHMpIHtcbiAgICAgICAgZXZlbnRzLmhhc093blByb3BlcnR5KHR5cGUpICYmIGFkZChlbGVtZW50LCB0eXBlLCBldmVudHNbdHlwZV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXNEZWwgPSB0eXBlb2YgZm4gPT0gJ3N0cmluZycsIHR5cGVzID0gKGlzRGVsID8gZm4gOiBldmVudHMpLnNwbGl0KCcgJyk7XG4gICAgICBmbiA9IGlzRGVsID8gZGVsKGV2ZW50cywgZGVsZm4sICQpIDogZm47XG4gICAgICBmb3IgKHZhciBpID0gdHlwZXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgIGFkZExpc3RlbmVyKGVsZW1lbnQsIHR5cGVzW2ldLCBmbiwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCBpc0RlbCA/IDQgOiAzKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xuICB9LFxuXG4gIHJlbW92ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcmdFdmVudHMsIGZuKSB7XG4gICAgdmFyIGssIG0sIHR5cGUsIGV2ZW50cywgaSxcbiAgICAgICAgaXNTdHJpbmcgPSB0eXBlb2Yob3JnRXZlbnRzKSA9PSAnc3RyaW5nJyxcbiAgICAgICAgbmFtZXMgPSBpc1N0cmluZyAmJiBvcmdFdmVudHMucmVwbGFjZShuYW1lc3BhY2UsICcnKSxcbiAgICAgICAgbmFtZXMgPSBuYW1lcyAmJiBuYW1lcy5zcGxpdCgnLicpLFxuICAgICAgICBybSA9IHJlbW92ZUxpc3RlbmVyLFxuICAgICAgICBhdHRhY2hlZCA9IHJldHJpZXZlRXZlbnRzKGVsZW1lbnQpO1xuICAgIGlmIChpc1N0cmluZyAmJiAvXFxzLy50ZXN0KG9yZ0V2ZW50cykpIHtcbiAgICAgIG9yZ0V2ZW50cyA9IG9yZ0V2ZW50cy5zcGxpdCgnICcpO1xuICAgICAgaSA9IG9yZ0V2ZW50cy5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKHJlbW92ZShlbGVtZW50LCBvcmdFdmVudHNbaV0pICYmIGktLSkge31cbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbiAgICBldmVudHMgPSBpc1N0cmluZyA/IG9yZ0V2ZW50cy5yZXBsYWNlKHN0cmlwTmFtZSwgJycpIDogb3JnRXZlbnRzO1xuICAgIGlmICghYXR0YWNoZWQgfHwgbmFtZXMgfHwgKGlzU3RyaW5nICYmICFhdHRhY2hlZFtldmVudHNdKSkge1xuICAgICAgZm9yIChrIGluIGF0dGFjaGVkKSB7XG4gICAgICAgIGlmIChhdHRhY2hlZC5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgIGZvciAoaSBpbiBhdHRhY2hlZFtrXSkge1xuICAgICAgICAgICAgZm9yIChtID0gbmFtZXMubGVuZ3RoOyBtLS07KSB7XG4gICAgICAgICAgICAgIGF0dGFjaGVkW2tdLmhhc093blByb3BlcnR5KGkpICYmIG5ldyBSZWdFeHAoJ14nICsgbmFtZXNbbV0gKyAnOjpcXFxcZCooXFxcXC4uKik/JCcpLnRlc3QoaSkgJiYgcm0oZWxlbWVudCwgW2ssIGldLmpvaW4oJy4nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBybShlbGVtZW50LCBldmVudHMsIGZuKTtcbiAgICB9IGVsc2UgaWYgKG5hbWVzKSB7XG4gICAgICBybShlbGVtZW50LCBvcmdFdmVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSA9IGV2ZW50cyA/IHJtIDogcmVtb3ZlO1xuICAgICAgdHlwZSA9IGlzU3RyaW5nICYmIGV2ZW50cztcbiAgICAgIGV2ZW50cyA9IGV2ZW50cyA/IChmbiB8fCBhdHRhY2hlZFtldmVudHNdIHx8IGV2ZW50cykgOiBhdHRhY2hlZDtcbiAgICAgIGZvciAoayBpbiBldmVudHMpIHtcbiAgICAgICAgaWYgKGV2ZW50cy5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgIHJtKGVsZW1lbnQsIHR5cGUgfHwgaywgZXZlbnRzW2tdKTtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW2tdOyAvLyByZW1vdmUgdW51c2VkIGxlYWYga2V5c1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xuICB9LFxuXG4gIGZpcmUgPSBmdW5jdGlvbiAoZWxlbWVudCwgdHlwZSwgYXJncykge1xuICAgIHZhciBldnQsIGssIGksIG0sIHR5cGVzID0gdHlwZS5zcGxpdCgnICcpO1xuICAgIGZvciAoaSA9IHR5cGVzLmxlbmd0aDsgaS0tOykge1xuICAgICAgdHlwZSA9IHR5cGVzW2ldLnJlcGxhY2Uoc3RyaXBOYW1lLCAnJyk7XG4gICAgICB2YXIgaXNOYXRpdmUgPSBuYXRpdmVFdmVudHNbdHlwZV0sXG4gICAgICAgICAgaXNOYW1lc3BhY2UgPSB0eXBlc1tpXS5yZXBsYWNlKG5hbWVzcGFjZSwgJycpLFxuICAgICAgICAgIGhhbmRsZXJzID0gcmV0cmlldmVFdmVudHMoZWxlbWVudClbdHlwZV07XG4gICAgICBpZiAoaXNOYW1lc3BhY2UpIHtcbiAgICAgICAgaXNOYW1lc3BhY2UgPSBpc05hbWVzcGFjZS5zcGxpdCgnLicpO1xuICAgICAgICBmb3IgKGsgPSBpc05hbWVzcGFjZS5sZW5ndGg7IGstLTspIHtcbiAgICAgICAgICBmb3IgKG0gaW4gaGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGhhbmRsZXJzLmhhc093blByb3BlcnR5KG0pICYmIG5ldyBSZWdFeHAoJ14nICsgaXNOYW1lc3BhY2Vba10gKyAnOjpcXFxcZCooXFxcXC4uKik/JCcpLnRlc3QobSkgJiYgaGFuZGxlcnNbbV0uYXBwbHkoZWxlbWVudCwgW2ZhbHNlXS5jb25jYXQoYXJncykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghYXJncyAmJiBlbGVtZW50W2V2ZW50U3VwcG9ydF0pIHtcbiAgICAgICAgZmlyZUxpc3RlbmVyKGlzTmF0aXZlLCB0eXBlLCBlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoayBpbiBoYW5kbGVycykge1xuICAgICAgICAgIGhhbmRsZXJzLmhhc093blByb3BlcnR5KGspICYmIGhhbmRsZXJzW2tdLmFwcGx5KGVsZW1lbnQsIFtmYWxzZV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfSxcblxuICBmaXJlTGlzdGVuZXIgPSBXM0NfTU9ERUwgPyBmdW5jdGlvbiAoaXNOYXRpdmUsIHR5cGUsIGVsZW1lbnQpIHtcbiAgICBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChpc05hdGl2ZSA/IFwiSFRNTEV2ZW50c1wiIDogXCJVSUV2ZW50c1wiKTtcbiAgICBldnRbaXNOYXRpdmUgPyAnaW5pdEV2ZW50JyA6ICdpbml0VUlFdmVudCddKHR5cGUsIHRydWUsIHRydWUsIGNvbnRleHQsIDEpO1xuICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldnQpO1xuICB9IDogZnVuY3Rpb24gKGlzTmF0aXZlLCB0eXBlLCBlbGVtZW50KSB7XG4gICAgaXNOYXRpdmUgPyBlbGVtZW50LmZpcmVFdmVudCgnb24nICsgdHlwZSwgZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QoKSkgOiBlbGVtZW50Wydfb24nICsgdHlwZV0rKztcbiAgfSxcblxuICBjbG9uZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBmcm9tLCB0eXBlKSB7XG4gICAgdmFyIGV2ZW50cyA9IHJldHJpZXZlRXZlbnRzKGZyb20pLCBvYmosIGs7XG4gICAgdmFyIHVpZCA9IHJldHJpZXZlVWlkKGVsZW1lbnQpO1xuICAgIG9iaiA9IHR5cGUgPyBldmVudHNbdHlwZV0gOiBldmVudHM7XG4gICAgZm9yIChrIGluIG9iaikge1xuICAgICAgb2JqLmhhc093blByb3BlcnR5KGspICYmICh0eXBlID8gYWRkIDogY2xvbmUpKGVsZW1lbnQsIHR5cGUgfHwgZnJvbSwgdHlwZSA/IG9ialtrXS5fX29yaWdpbmFsRm4gOiBrKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0sXG5cbiAgZml4RXZlbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAoIWUpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHZhciB0eXBlID0gZS50eXBlLCB0YXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XG4gICAgcmVzdWx0LnByZXZlbnREZWZhdWx0ID0gZml4RXZlbnQucHJldmVudERlZmF1bHQoZSk7XG4gICAgcmVzdWx0LnN0b3BQcm9wYWdhdGlvbiA9IGZpeEV2ZW50LnN0b3BQcm9wYWdhdGlvbihlKTtcbiAgICByZXN1bHQudGFyZ2V0ID0gdGFyZ2V0ICYmIHRhcmdldC5ub2RlVHlwZSA9PSAzID8gdGFyZ2V0LnBhcmVudE5vZGUgOiB0YXJnZXQ7XG4gICAgaWYgKHR5cGUgJiYgdHlwZS5pbmRleE9mKCdrZXknKSkge1xuICAgICAgcmVzdWx0LmtleUNvZGUgPSBlLndoaWNoIHx8IGUua2V5Q29kZTtcbiAgICB9IGVsc2UgaWYgKCgvY2xpY2t8bW91c2V8bWVudS9pKS50ZXN0KHR5cGUpKSB7XG4gICAgICByZXN1bHQucmlnaHRDbGljayA9IGUud2hpY2ggPT0gMyB8fCBlLmJ1dHRvbiA9PSAyO1xuICAgICAgcmVzdWx0LnBvcyA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgaWYgKGUucGFnZVggfHwgZS5wYWdlWSkge1xuICAgICAgICByZXN1bHQuY2xpZW50WCA9IGUucGFnZVg7XG4gICAgICAgIHJlc3VsdC5jbGllbnRZID0gZS5wYWdlWTtcbiAgICAgIH0gZWxzZSBpZiAoZS5jbGllbnRYIHx8IGUuY2xpZW50WSkge1xuICAgICAgICByZXN1bHQuY2xpZW50WCA9IGUuY2xpZW50WCArIGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCArIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0O1xuICAgICAgICByZXN1bHQuY2xpZW50WSA9IGUuY2xpZW50WSArIGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wICsgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgIH1cbiAgICAgIG92ZXJPdXQudGVzdCh0eXBlKSAmJiAocmVzdWx0LnJlbGF0ZWRUYXJnZXQgPSBlLnJlbGF0ZWRUYXJnZXQgfHwgZVsodHlwZSA9PSAnbW91c2VvdmVyJyA/ICdmcm9tJyA6ICd0bycpICsgJ0VsZW1lbnQnXSk7XG4gICAgfVxuICAgIGZvciAodmFyIGsgaW4gZSkge1xuICAgICAgaWYgKCEoayBpbiByZXN1bHQpKSB7XG4gICAgICAgIHJlc3VsdFtrXSA9IGVba107XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgZml4RXZlbnQucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgZml4RXZlbnQuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGUuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICB2YXIgbmF0aXZlRXZlbnRzID0geyBjbGljazogMSwgZGJsY2xpY2s6IDEsIG1vdXNldXA6IDEsIG1vdXNlZG93bjogMSwgY29udGV4dG1lbnU6IDEsIC8vbW91c2UgYnV0dG9uc1xuICAgIG1vdXNld2hlZWw6IDEsIERPTU1vdXNlU2Nyb2xsOiAxLCAvL21vdXNlIHdoZWVsXG4gICAgbW91c2VvdmVyOiAxLCBtb3VzZW91dDogMSwgbW91c2Vtb3ZlOiAxLCBzZWxlY3RzdGFydDogMSwgc2VsZWN0ZW5kOiAxLCAvL21vdXNlIG1vdmVtZW50XG4gICAga2V5ZG93bjogMSwga2V5cHJlc3M6IDEsIGtleXVwOiAxLCAvL2tleWJvYXJkXG4gICAgb3JpZW50YXRpb25jaGFuZ2U6IDEsIC8vIG1vYmlsZVxuICAgIHRvdWNoc3RhcnQ6IDEsIHRvdWNobW92ZTogMSwgdG91Y2hlbmQ6IDEsIHRvdWNoY2FuY2VsOiAxLCAvLyB0b3VjaFxuICAgIGdlc3R1cmVzdGFydDogMSwgZ2VzdHVyZWNoYW5nZTogMSwgZ2VzdHVyZWVuZDogMSwgLy8gZ2VzdHVyZVxuICAgIGZvY3VzOiAxLCBibHVyOiAxLCBjaGFuZ2U6IDEsIHJlc2V0OiAxLCBzZWxlY3Q6IDEsIHN1Ym1pdDogMSwgLy9mb3JtIGVsZW1lbnRzXG4gICAgbG9hZDogMSwgdW5sb2FkOiAxLCBiZWZvcmV1bmxvYWQ6IDEsIHJlc2l6ZTogMSwgbW92ZTogMSwgRE9NQ29udGVudExvYWRlZDogMSwgcmVhZHlzdGF0ZWNoYW5nZTogMSwgLy93aW5kb3dcbiAgICBlcnJvcjogMCwgYWJvcnQ6IDEsIHNjcm9sbDogMSB9OyAvL21pc2NcblxuICBmdW5jdGlvbiBjaGVjayhldmVudCkge1xuICAgIHZhciByZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICBpZiAoIXJlbGF0ZWQpIHtcbiAgICAgIHJldHVybiByZWxhdGVkID09PSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKHJlbGF0ZWQgIT0gdGhpcyAmJiByZWxhdGVkLnByZWZpeCAhPSAneHVsJyAmJiAhL2RvY3VtZW50Ly50ZXN0KHRoaXMudG9TdHJpbmcoKSkgJiYgIWlzRGVzY2VuZGFudCh0aGlzLCByZWxhdGVkKSk7XG4gIH1cblxuICB2YXIgY3VzdG9tRXZlbnRzID0ge1xuICAgIG1vdXNlZW50ZXI6IHsgYmFzZTogJ21vdXNlb3ZlcicsIGNvbmRpdGlvbjogY2hlY2sgfSxcbiAgICBtb3VzZWxlYXZlOiB7IGJhc2U6ICdtb3VzZW91dCcsIGNvbmRpdGlvbjogY2hlY2sgfVxuLy8gICAgbW91c2V3aGVlbDogeyBiYXNlOiAvRmlyZWZveC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSA/ICdET01Nb3VzZVNjcm9sbCcgOiAnbW91c2V3aGVlbCcgfVxuICB9O1xuXG4gIHZhciBiZWFuID0geyBhZGQ6IGFkZCwgcmVtb3ZlOiByZW1vdmUsIGNsb25lOiBjbG9uZSwgZmlyZTogZmlyZSB9O1xuXG4gIHZhciBjbGVhbiA9IGZ1bmN0aW9uIChlbCkge1xuICAgIHZhciB1aWQgPSByZW1vdmUoZWwpLl9fdWlkO1xuICAgIGlmICh1aWQpIHtcbiAgICAgIGRlbGV0ZSBjb2xsZWN0ZWRbdWlkXTtcbiAgICAgIGRlbGV0ZSByZWdpc3RyeVt1aWRdO1xuICAgIH1cbiAgfTtcblxuICBpZiAoY29udGV4dFthdHRhY2hFdmVudF0pIHtcbiAgICBhZGQoY29udGV4dCwgJ3VubG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGsgaW4gY29sbGVjdGVkKSB7XG4gICAgICAgIGNvbGxlY3RlZC5oYXNPd25Qcm9wZXJ0eShrKSAmJiBjbGVhbihjb2xsZWN0ZWRba10pO1xuICAgICAgfVxuICAgICAgY29udGV4dC5Db2xsZWN0R2FyYmFnZSAmJiBDb2xsZWN0R2FyYmFnZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIG9sZEJlYW4gPSBjb250ZXh0LmJlYW47XG4gIGJlYW4ubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb250ZXh0LmJlYW4gPSBvbGRCZWFuO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykgP1xuICAgIChtb2R1bGUuZXhwb3J0cyA9IGJlYW4pIDpcbiAgICAoY29udGV4dFsnYmVhbiddID0gYmVhbik7XG5cbiAgICByZXR1cm4gYmVhbjtcblxufSkoe30pO1xuXG5leHBvcnQgZGVmYXVsdCBiZWFuO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWdCQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQXZCQTtBQTBCQTtBQUNBO0FBM0JBO0FBOEJBO0FBQ0E7QUFDQTtBQWhDQTtBQW1DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdkNBO0FBMENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE5Q0E7QUFpREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdERBO0FBeURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwRkE7QUF1RkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUEvR0E7QUFrSEE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBNUhBO0FBK0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBM0lBO0FBOElBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBdkxBO0FBMExBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBaE5BO0FBbU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXhOQTtBQTJOQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFsT0E7QUFxT0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQVRBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBRkE7QUFNQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../gator/js/bean.js\n")},"../gator/js/hammer.js":
/*!*****************************!*\
  !*** ../gator/js/hammer.js ***!
  \*****************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/*! Hammer.JS - v1.0.7dev - 2014-01-15\n * http://eightmedia.github.com/hammer.js\n *\n * Copyright (c) 2014 Jorik Tangelder <j.tangelder@gmail.com>;\n * Licensed under the MIT license */\nconst Hammer = function (window, undefined) {\n  'use strict';\n  /**\n   * Hammer\n   * use this to create instances\n   * @param   {HTMLElement}   element\n   * @param   {Object}        options\n   * @returns {Hammer.Instance}\n   * @constructor\n   */\n\n  var Hammer = function Hammer(element, options) {\n    return new Hammer.Instance(element, options || {});\n  }; // default settings\n\n\n  Hammer.defaults = {\n    // add styles and attributes to the element to prevent the browser from doing\n    // its native behavior. this doesnt prevent the scrolling, but cancels\n    // the contextmenu, tap highlighting etc\n    // set to false to disable this\n    stop_browser_behavior: {\n      // this also triggers onselectstart=false for IE\n      userSelect: 'none',\n      // this makes the element blocking in IE10 >, you could experiment with the value\n      // see for more options this issue; https://github.com/EightMedia/hammer.js/issues/241\n      touchAction: 'none',\n      touchCallout: 'none',\n      contentZooming: 'none',\n      userDrag: 'none',\n      tapHighlightColor: 'rgba(0,0,0,0)' //\n      // more settings are defined per gesture at gestures.js\n      //\n\n    }\n  }; // detect touchevents\n\n  Hammer.HAS_POINTEREVENTS = window.navigator.pointerEnabled || window.navigator.msPointerEnabled;\n  Hammer.HAS_TOUCHEVENTS = 'ontouchstart' in window; // dont use mouseevents on mobile devices\n\n  Hammer.MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android|silk/i;\n  Hammer.NO_MOUSEEVENTS = Hammer.HAS_TOUCHEVENTS && window.navigator.userAgent.match(Hammer.MOBILE_REGEX); // eventtypes per touchevent (start, move, end)\n  // are filled by Hammer.event.determineEventTypes on setup\n\n  Hammer.EVENT_TYPES = {}; // direction defines\n\n  Hammer.DIRECTION_DOWN = 'down';\n  Hammer.DIRECTION_LEFT = 'left';\n  Hammer.DIRECTION_UP = 'up';\n  Hammer.DIRECTION_RIGHT = 'right'; // pointer type\n\n  Hammer.POINTER_MOUSE = 'mouse';\n  Hammer.POINTER_TOUCH = 'touch';\n  Hammer.POINTER_PEN = 'pen'; // touch event defines\n\n  Hammer.EVENT_START = 'start';\n  Hammer.EVENT_MOVE = 'move';\n  Hammer.EVENT_END = 'end'; // hammer document where the base events are added at\n\n  Hammer.DOCUMENT = window.document; // plugins and gestures namespaces\n\n  Hammer.plugins = Hammer.plugins || {};\n  Hammer.gestures = Hammer.gestures || {}; // if the window events are set...\n\n  Hammer.READY = false;\n  /**\n   * setup events to detect gestures on the document\n   */\n\n  function setup() {\n    if (Hammer.READY) {\n      return;\n    } // find what eventtypes we add listeners to\n\n\n    Hammer.event.determineEventTypes(); // Register all gestures inside Hammer.gestures\n\n    Hammer.utils.each(Hammer.gestures, function (gesture) {\n      Hammer.detection.register(gesture);\n    }); // Add touch events on the document\n\n    Hammer.event.onTouch(Hammer.DOCUMENT, Hammer.EVENT_MOVE, Hammer.detection.detect);\n    Hammer.event.onTouch(Hammer.DOCUMENT, Hammer.EVENT_END, Hammer.detection.detect); // Hammer is ready...!\n\n    Hammer.READY = true;\n  }\n\n  Hammer.utils = {\n    /**\n     * extend method,\n     * also used for cloning when dest is an empty object\n     * @param   {Object}    dest\n     * @param   {Object}    src\n     * @parm  {Boolean}  merge    do a merge\n     * @returns {Object}    dest\n     */\n    extend: function extend(dest, src, merge) {\n      for (var key in src) {\n        if (dest[key] !== undefined && merge) {\n          continue;\n        }\n\n        dest[key] = src[key];\n      }\n\n      return dest;\n    },\n\n    /**\n     * for each\n     * @param obj\n     * @param iterator\n     */\n    each: function each(obj, iterator, context) {\n      var i, length; // native forEach on arrays\n\n      if ('forEach' in obj) {\n        obj.forEach(iterator, context);\n      } // arrays\n      else if (obj.length !== undefined) {\n          for (i = 0, length = obj.length; i < length; i++) {\n            if (iterator.call(context, obj[i], i, obj) === false) {\n              return;\n            }\n          }\n        } // objects\n        else {\n            for (i in obj) {\n              if (obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj) === false) {\n                return;\n              }\n            }\n          }\n    },\n\n    /**\n     * find if a node is in the given parent\n     * used for event delegation tricks\n     * @param   {HTMLElement}   node\n     * @param   {HTMLElement}   parent\n     * @returns {boolean}       has_parent\n     */\n    hasParent: function hasParent(node, parent) {\n      while (node) {\n        if (node == parent) {\n          return true;\n        }\n\n        node = node.parentNode;\n      }\n\n      return false;\n    },\n\n    /**\n     * get the center of all the touches\n     * @param   {Array}     touches\n     * @returns {Object}    center\n     */\n    getCenter: function getCenter(touches) {\n      var valuesX = [],\n          valuesY = [];\n      Hammer.utils.each(touches, function (touch) {\n        // I prefer clientX because it ignore the scrolling position\n        valuesX.push(typeof touch.clientX !== 'undefined' ? touch.clientX : touch.pageX);\n        valuesY.push(typeof touch.clientY !== 'undefined' ? touch.clientY : touch.pageY);\n      });\n      return {\n        pageX: (Math.min.apply(Math, valuesX) + Math.max.apply(Math, valuesX)) / 2,\n        pageY: (Math.min.apply(Math, valuesY) + Math.max.apply(Math, valuesY)) / 2\n      };\n    },\n\n    /**\n     * calculate the velocity between two points\n     * @param   {Number}    delta_time\n     * @param   {Number}    delta_x\n     * @param   {Number}    delta_y\n     * @returns {Object}    velocity\n     */\n    getVelocity: function getVelocity(delta_time, delta_x, delta_y) {\n      return {\n        x: Math.abs(delta_x / delta_time) || 0,\n        y: Math.abs(delta_y / delta_time) || 0\n      };\n    },\n\n    /**\n     * calculate the angle between two coordinates\n     * @param   {Touch}     touch1\n     * @param   {Touch}     touch2\n     * @returns {Number}    angle\n     */\n    getAngle: function getAngle(touch1, touch2) {\n      var y = touch2.pageY - touch1.pageY,\n          x = touch2.pageX - touch1.pageX;\n      return Math.atan2(y, x) * 180 / Math.PI;\n    },\n\n    /**\n     * angle to direction define\n     * @param   {Touch}     touch1\n     * @param   {Touch}     touch2\n     * @returns {String}    direction constant, like Hammer.DIRECTION_LEFT\n     */\n    getDirection: function getDirection(touch1, touch2) {\n      var x = Math.abs(touch1.pageX - touch2.pageX),\n          y = Math.abs(touch1.pageY - touch2.pageY);\n\n      if (x >= y) {\n        return touch1.pageX - touch2.pageX > 0 ? Hammer.DIRECTION_LEFT : Hammer.DIRECTION_RIGHT;\n      } else {\n        return touch1.pageY - touch2.pageY > 0 ? Hammer.DIRECTION_UP : Hammer.DIRECTION_DOWN;\n      }\n    },\n\n    /**\n     * calculate the distance between two touches\n     * @param   {Touch}     touch1\n     * @param   {Touch}     touch2\n     * @returns {Number}    distance\n     */\n    getDistance: function getDistance(touch1, touch2) {\n      var x = touch2.pageX - touch1.pageX,\n          y = touch2.pageY - touch1.pageY;\n      return Math.sqrt(x * x + y * y);\n    },\n\n    /**\n     * calculate the scale factor between two touchLists (fingers)\n     * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n     * @param   {Array}     start\n     * @param   {Array}     end\n     * @returns {Number}    scale\n     */\n    getScale: function getScale(start, end) {\n      // need two fingers...\n      if (start.length >= 2 && end.length >= 2) {\n        return this.getDistance(end[0], end[1]) / this.getDistance(start[0], start[1]);\n      }\n\n      return 1;\n    },\n\n    /**\n     * calculate the rotation degrees between two touchLists (fingers)\n     * @param   {Array}     start\n     * @param   {Array}     end\n     * @returns {Number}    rotation\n     */\n    getRotation: function getRotation(start, end) {\n      // need two fingers\n      if (start.length >= 2 && end.length >= 2) {\n        return this.getAngle(end[1], end[0]) - this.getAngle(start[1], start[0]);\n      }\n\n      return 0;\n    },\n\n    /**\n     * boolean if the direction is vertical\n     * @param    {String}    direction\n     * @returns  {Boolean}   is_vertical\n     */\n    isVertical: function isVertical(direction) {\n      return direction == Hammer.DIRECTION_UP || direction == Hammer.DIRECTION_DOWN;\n    },\n\n    /**\n     * stop browser default behavior with css props\n     * @param   {HtmlElement}   element\n     * @param   {Object}        css_props\n     */\n    stopDefaultBrowserBehavior: function stopDefaultBrowserBehavior(element, css_props) {\n      if (!css_props || !element || !element.style) {\n        return;\n      } // with css properties for modern browsers\n\n\n      Hammer.utils.each(['webkit', 'khtml', 'moz', 'Moz', 'ms', 'o', ''], function (vendor) {\n        Hammer.utils.each(css_props, function (value, prop) {\n          // vender prefix at the property\n          if (vendor) {\n            prop = vendor + prop.substring(0, 1).toUpperCase() + prop.substring(1);\n          } // set the style\n\n\n          if (prop in element.style) {\n            element.style[prop] = value;\n          }\n        });\n      }); // also the disable onselectstart\n\n      if (css_props.userSelect == 'none') {\n        element.onselectstart = function () {\n          return false;\n        };\n      } // and disable ondragstart\n\n\n      if (css_props.userDrag == 'none') {\n        element.ondragstart = function () {\n          return false;\n        };\n      }\n    }\n  };\n  /**\n   * create new hammer instance\n   * all methods should return the instance itself, so it is chainable.\n   * @param   {HTMLElement}       element\n   * @param   {Object}            [options={}]\n   * @returns {Hammer.Instance}\n   * @constructor\n   */\n\n  Hammer.Instance = function (element, options) {\n    var self = this; // setup HammerJS window events and register all gestures\n    // this also sets up the default options\n\n    setup();\n    this.element = element; // start/stop detection option\n\n    this.enabled = true; // merge options\n\n    this.options = Hammer.utils.extend(Hammer.utils.extend({}, Hammer.defaults), options || {}); // add some css to the element to prevent the browser from doing its native behavoir\n\n    if (this.options.stop_browser_behavior) {\n      Hammer.utils.stopDefaultBrowserBehavior(this.element, this.options.stop_browser_behavior);\n    } // start detection on touchstart\n\n\n    Hammer.event.onTouch(element, Hammer.EVENT_START, function (ev) {\n      if (self.enabled) {\n        Hammer.detection.startDetect(self, ev);\n      }\n    }); // return instance\n\n    return this;\n  };\n\n  Hammer.Instance.prototype = {\n    /**\n     * bind events to the instance\n     * @param   {String}      gesture\n     * @param   {Function}    handler\n     * @returns {Hammer.Instance}\n     */\n    on: function onEvent(gesture, handler) {\n      var gestures = gesture.split(' ');\n      Hammer.utils.each(gestures, function (gesture) {\n        this.element.addEventListener(gesture, handler, false);\n      }, this);\n      return this;\n    },\n\n    /**\n     * unbind events to the instance\n     * @param   {String}      gesture\n     * @param   {Function}    handler\n     * @returns {Hammer.Instance}\n     */\n    off: function offEvent(gesture, handler) {\n      var gestures = gesture.split(' ');\n      Hammer.utils.each(gestures, function (gesture) {\n        this.element.removeEventListener(gesture, handler, false);\n      }, this);\n      return this;\n    },\n\n    /**\n     * trigger gesture event\n     * @param   {String}      gesture\n     * @param   {Object}      [eventData]\n     * @returns {Hammer.Instance}\n     */\n    trigger: function triggerEvent(gesture, eventData) {\n      // optional\n      if (!eventData) {\n        eventData = {};\n      } // create DOM event\n\n\n      var event = Hammer.DOCUMENT.createEvent('Event');\n      event.initEvent(gesture, true, true);\n      event.gesture = eventData; // trigger on the target if it is in the instance element,\n      // this is for event delegation tricks\n\n      var element = this.element;\n\n      if (Hammer.utils.hasParent(eventData.target, element)) {\n        element = eventData.target;\n      }\n\n      element.dispatchEvent(event);\n      return this;\n    },\n\n    /**\n     * enable of disable hammer.js detection\n     * @param   {Boolean}   state\n     * @returns {Hammer.Instance}\n     */\n    enable: function enable(state) {\n      this.enabled = state;\n      return this;\n    }\n  };\n  /**\n   * this holds the last move event,\n   * used to fix empty touchend issue\n   * see the onTouch event for an explanation\n   * @type {Object}\n   */\n\n  var last_move_event = null;\n  /**\n   * when the mouse is hold down, this is true\n   * @type {Boolean}\n   */\n\n  var enable_detect = false;\n  /**\n   * when touch events have been fired, this is true\n   * @type {Boolean}\n   */\n\n  var touch_triggered = false;\n  Hammer.event = {\n    /**\n     * simple addEventListener\n     * @param   {HTMLElement}   element\n     * @param   {String}        type\n     * @param   {Function}      handler\n     */\n    bindDom: function bindDom(element, type, handler) {\n      var types = type.split(' ');\n      Hammer.utils.each(types, function (type) {\n        element.addEventListener(type, handler, false);\n      });\n    },\n\n    /**\n     * touch events with mouse fallback\n     * @param   {HTMLElement}   element\n     * @param   {String}        eventType        like Hammer.EVENT_MOVE\n     * @param   {Function}      handler\n     */\n    onTouch: function onTouch(element, eventType, handler) {\n      var self = this;\n      this.bindDom(element, Hammer.EVENT_TYPES[eventType], function bindDomOnTouch(ev) {\n        var sourceEventType = ev.type.toLowerCase(); // onmouseup, but when touchend has been fired we do nothing.\n        // this is for touchdevices which also fire a mouseup on touchend\n\n        if (sourceEventType.match(/mouse/) && touch_triggered) {\n          return;\n        } // mousebutton must be down or a touch event\n        else if (sourceEventType.match(/touch/) || // touch events are always on screen\n          sourceEventType.match(/pointerdown/) || // pointerevents touch\n          sourceEventType.match(/mouse/) && ev.which === 1 // mouse is pressed\n          ) {\n              enable_detect = true;\n            } // mouse isn't pressed\n          else if (sourceEventType.match(/mouse/) && !ev.which) {\n              enable_detect = false;\n            } // we are in a touch event, set the touch triggered bool to true,\n        // this for the conflicts that may occur on ios and android\n\n\n        if (sourceEventType.match(/touch|pointer/)) {\n          touch_triggered = true;\n        } // count the total touches on the screen\n\n\n        var count_touches = 0; // when touch has been triggered in this detection session\n        // and we are now handling a mouse event, we stop that to prevent conflicts\n\n        if (enable_detect) {\n          // update pointerevent\n          if (Hammer.HAS_POINTEREVENTS && eventType != Hammer.EVENT_END) {\n            count_touches = Hammer.PointerEvent.updatePointer(eventType, ev);\n          } // touch\n          else if (sourceEventType.match(/touch/)) {\n              count_touches = ev.touches.length;\n            } // mouse\n            else if (!touch_triggered) {\n                count_touches = sourceEventType.match(/up/) ? 0 : 1;\n              } // if we are in a end event, but when we remove one touch and\n          // we still have enough, set eventType to move\n\n\n          if (count_touches > 0 && eventType == Hammer.EVENT_END) {\n            eventType = Hammer.EVENT_MOVE;\n          } // no touches, force the end event\n          else if (!count_touches) {\n              eventType = Hammer.EVENT_END;\n            } // store the last move event\n\n\n          if (count_touches || last_move_event === null) {\n            last_move_event = ev;\n          } // trigger the handler\n\n\n          handler.call(Hammer.detection, self.collectEventData(element, eventType, self.getTouchList(last_move_event, eventType), ev)); // remove pointerevent from list\n\n          if (Hammer.HAS_POINTEREVENTS && eventType == Hammer.EVENT_END) {\n            count_touches = Hammer.PointerEvent.updatePointer(eventType, ev);\n          }\n        } // on the end we reset everything\n\n\n        if (!count_touches) {\n          last_move_event = null;\n          enable_detect = false;\n          touch_triggered = false;\n          Hammer.PointerEvent.reset();\n        }\n      }, {\n        passive: true\n      }); // FIXME - PASSIVE\n    },\n\n    /**\n     * we have different events for each device/browser\n     * determine what we need and set them in the Hammer.EVENT_TYPES constant\n     */\n    determineEventTypes: function determineEventTypes() {\n      // determine the eventtype we want to set\n      var types; // pointerEvents magic\n\n      if (Hammer.HAS_POINTEREVENTS) {\n        types = Hammer.PointerEvent.getEvents();\n      } // on Android, iOS, blackberry, windows mobile we dont want any mouseevents\n      else if (Hammer.NO_MOUSEEVENTS) {\n          types = ['touchstart', 'touchmove', 'touchend touchcancel'];\n        } // for non pointer events browsers and mixed browsers,\n        // like chrome on windows8 touch laptop\n        else {\n            types = ['touchstart mousedown', 'touchmove mousemove', 'touchend touchcancel mouseup'];\n          }\n\n      Hammer.EVENT_TYPES[Hammer.EVENT_START] = types[0];\n      Hammer.EVENT_TYPES[Hammer.EVENT_MOVE] = types[1];\n      Hammer.EVENT_TYPES[Hammer.EVENT_END] = types[2];\n    },\n\n    /**\n     * create touchlist depending on the event\n     * @param   {Object}    ev\n     * @param   {String}    eventType   used by the fakemultitouch plugin\n     */\n    getTouchList: function getTouchList(ev\n    /*, eventType*/\n    ) {\n      // get the fake pointerEvent touchlist\n      if (Hammer.HAS_POINTEREVENTS) {\n        return Hammer.PointerEvent.getTouchList();\n      } // get the touchlist\n      else if (ev.touches) {\n          return ev.touches;\n        } // make fake touchlist from mouse position\n        else {\n            ev.identifier = 1;\n            return [ev];\n          }\n    },\n\n    /**\n     * collect event data for Hammer js\n     * @param   {HTMLElement}   element\n     * @param   {String}        eventType        like Hammer.EVENT_MOVE\n     * @param   {Object}        eventData\n     */\n    collectEventData: function collectEventData(element, eventType, touches, ev) {\n      // find out pointerType\n      var pointerType = Hammer.POINTER_TOUCH;\n\n      if (ev.type.match(/mouse/) || Hammer.PointerEvent.matchType(Hammer.POINTER_MOUSE, ev)) {\n        pointerType = Hammer.POINTER_MOUSE;\n      }\n\n      return {\n        center: Hammer.utils.getCenter(touches),\n        timeStamp: new Date().getTime(),\n        target: ev.target,\n        touches: touches,\n        eventType: eventType,\n        pointerType: pointerType,\n        srcEvent: ev,\n\n        /**\n         * prevent the browser default actions\n         * mostly used to disable scrolling of the browser\n         */\n        preventDefault: function preventDefault() {\n          if (this.srcEvent.preventManipulation) {\n            this.srcEvent.preventManipulation();\n          }\n\n          if (this.srcEvent.preventDefault) {\n            this.srcEvent.preventDefault();\n          }\n        },\n\n        /**\n         * stop bubbling the event up to its parents\n         */\n        stopPropagation: function stopPropagation() {\n          this.srcEvent.stopPropagation();\n        },\n\n        /**\n         * immediately stop gesture detection\n         * might be useful after a swipe was detected\n         * @return {*}\n         */\n        stopDetect: function stopDetect() {\n          return Hammer.detection.stopDetect();\n        }\n      };\n    }\n  };\n  Hammer.PointerEvent = {\n    /**\n     * holds all pointers\n     * @type {Object}\n     */\n    pointers: {},\n\n    /**\n     * get a list of pointers\n     * @returns {Array}     touchlist\n     */\n    getTouchList: function getTouchList() {\n      var self = this;\n      var touchlist = []; // we can use forEach since pointerEvents only is in IE10\n\n      Hammer.utils.each(self.pointers, function (pointer) {\n        touchlist.push(pointer);\n      });\n      return touchlist;\n    },\n\n    /**\n     * update the position of a pointer\n     * @param   {String}   type             Hammer.EVENT_END\n     * @param   {Object}   pointerEvent\n     */\n    updatePointer: function updatePointer(type, pointerEvent) {\n      if (type == Hammer.EVENT_END) {\n        this.pointers = {};\n      } else {\n        pointerEvent.identifier = pointerEvent.pointerId;\n        this.pointers[pointerEvent.pointerId] = pointerEvent;\n      }\n\n      return Object.keys(this.pointers).length;\n    },\n\n    /**\n     * check if ev matches pointertype\n     * @param   {String}        pointerType     Hammer.POINTER_MOUSE\n     * @param   {PointerEvent}  ev\n     */\n    matchType: function matchType(pointerType, ev) {\n      if (!ev.pointerType) {\n        return false;\n      }\n\n      var pt = ev.pointerType,\n          types = {};\n      types[Hammer.POINTER_MOUSE] = pt === ev.MSPOINTER_TYPE_MOUSE || pt === Hammer.POINTER_MOUSE;\n      types[Hammer.POINTER_TOUCH] = pt === ev.MSPOINTER_TYPE_TOUCH || pt === Hammer.POINTER_TOUCH;\n      types[Hammer.POINTER_PEN] = pt === ev.MSPOINTER_TYPE_PEN || pt === Hammer.POINTER_PEN;\n      return types[pointerType];\n    },\n\n    /**\n     * get events\n     */\n    getEvents: function getEvents() {\n      return ['pointerdown MSPointerDown', 'pointermove MSPointerMove', 'pointerup pointercancel MSPointerUp MSPointerCancel'];\n    },\n\n    /**\n     * reset the list\n     */\n    reset: function reset() {\n      this.pointers = {};\n    }\n  };\n  Hammer.detection = {\n    // contains all registred Hammer.gestures in the correct order\n    gestures: [],\n    // data of the current Hammer.gesture detection session\n    current: null,\n    // the previous Hammer.gesture session data\n    // is a full clone of the previous gesture.current object\n    previous: null,\n    // when this becomes true, no gestures are fired\n    stopped: false,\n\n    /**\n     * start Hammer.gesture detection\n     * @param   {Hammer.Instance}   inst\n     * @param   {Object}            eventData\n     */\n    startDetect: function startDetect(inst, eventData) {\n      // already busy with a Hammer.gesture detection on an element\n      if (this.current) {\n        return;\n      }\n\n      this.stopped = false;\n      this.current = {\n        inst: inst,\n        // reference to HammerInstance we're working for\n        startEvent: Hammer.utils.extend({}, eventData),\n        // start eventData for distances, timing etc\n        lastEvent: false,\n        // last eventData\n        name: '' // current gesture we're in/detected, can be 'tap', 'hold' etc\n\n      };\n      this.detect(eventData);\n    },\n\n    /**\n     * Hammer.gesture detection\n     * @param   {Object}    eventData\n     */\n    detect: function detect(eventData) {\n      if (!this.current || this.stopped) {\n        return;\n      } // extend event data with calculations about scale, distance etc\n\n\n      eventData = this.extendEventData(eventData); // instance options\n\n      var inst_options = this.current.inst.options; // call Hammer.gesture handlers\n\n      Hammer.utils.each(this.gestures, function (gesture) {\n        // only when the instance options have enabled this gesture\n        if (!this.stopped && inst_options[gesture.name] !== false) {\n          // if a handler returns false, we stop with the detection\n          if (gesture.handler.call(gesture, eventData, this.current.inst) === false) {\n            this.stopDetect();\n            return false;\n          }\n        }\n      }, this); // store as previous event event\n\n      if (this.current) {\n        this.current.lastEvent = eventData;\n      } // endevent, but not the last touch, so dont stop\n\n\n      if (eventData.eventType == Hammer.EVENT_END && !eventData.touches.length - 1) {\n        this.stopDetect();\n      }\n\n      return eventData;\n    },\n\n    /**\n     * clear the Hammer.gesture vars\n     * this is called on endDetect, but can also be used when a final Hammer.gesture has been detected\n     * to stop other Hammer.gestures from being fired\n     */\n    stopDetect: function stopDetect() {\n      // clone current data to the store as the previous gesture\n      // used for the double tap gesture, since this is an other gesture detect session\n      this.previous = Hammer.utils.extend({}, this.current); // reset the current\n\n      this.current = null; // stopped!\n\n      this.stopped = true;\n    },\n\n    /**\n     * extend eventData for Hammer.gestures\n     * @param   {Object}   ev\n     * @returns {Object}   ev\n     */\n    extendEventData: function extendEventData(ev) {\n      var startEv = this.current.startEvent; // if the touches change, set the new touches over the startEvent touches\n      // this because touchevents don't have all the touches on touchstart, or the\n      // user must place his fingers at the EXACT same time on the screen, which is not realistic\n      // but, sometimes it happens that both fingers are touching at the EXACT same time\n\n      if (startEv && (ev.touches.length != startEv.touches.length || ev.touches === startEv.touches)) {\n        // extend 1 level deep to get the touchlist with the touch objects\n        startEv.touches = [];\n        Hammer.utils.each(ev.touches, function (touch) {\n          startEv.touches.push(Hammer.utils.extend({}, touch));\n        });\n      }\n\n      var delta_time = ev.timeStamp - startEv.timeStamp,\n          delta_x = ev.center.pageX - startEv.center.pageX,\n          delta_y = ev.center.pageY - startEv.center.pageY,\n          velocity = Hammer.utils.getVelocity(delta_time, delta_x, delta_y),\n          interimAngle,\n          interimDirection; // end events (e.g. dragend) don't have useful values for interimDirection & interimAngle\n      // because the previous event has exactly the same coordinates\n      // so for end events, take the previous values of interimDirection & interimAngle\n      // instead of recalculating them and getting a spurious '0'\n\n      if (ev.eventType === 'end') {\n        interimAngle = this.current.lastEvent && this.current.lastEvent.interimAngle;\n        interimDirection = this.current.lastEvent && this.current.lastEvent.interimDirection;\n      } else {\n        interimAngle = this.current.lastEvent && Hammer.utils.getAngle(this.current.lastEvent.center, ev.center);\n        interimDirection = this.current.lastEvent && Hammer.utils.getDirection(this.current.lastEvent.center, ev.center);\n      }\n\n      Hammer.utils.extend(ev, {\n        deltaTime: delta_time,\n        deltaX: delta_x,\n        deltaY: delta_y,\n        velocityX: velocity.x,\n        velocityY: velocity.y,\n        distance: Hammer.utils.getDistance(startEv.center, ev.center),\n        angle: Hammer.utils.getAngle(startEv.center, ev.center),\n        interimAngle: interimAngle,\n        direction: Hammer.utils.getDirection(startEv.center, ev.center),\n        interimDirection: interimDirection,\n        scale: Hammer.utils.getScale(startEv.touches, ev.touches),\n        rotation: Hammer.utils.getRotation(startEv.touches, ev.touches),\n        startEvent: startEv\n      });\n      return ev;\n    },\n\n    /**\n     * register new gesture\n     * @param   {Object}    gesture object, see gestures.js for documentation\n     * @returns {Array}     gestures\n     */\n    register: function register(gesture) {\n      // add an enable gesture options if there is no given\n      var options = gesture.defaults || {};\n\n      if (options[gesture.name] === undefined) {\n        options[gesture.name] = true;\n      } // extend Hammer default options with the Hammer.gesture options\n\n\n      Hammer.utils.extend(Hammer.defaults, options, true); // set its index\n\n      gesture.index = gesture.index || 1000; // add Hammer.gesture to the list\n\n      this.gestures.push(gesture); // sort the list by index\n\n      this.gestures.sort(function (a, b) {\n        if (a.index < b.index) {\n          return -1;\n        }\n\n        if (a.index > b.index) {\n          return 1;\n        }\n\n        return 0;\n      });\n      return this.gestures;\n    }\n  };\n  /**\n   * Drag\n   * Move with x fingers (default 1) around on the page. Blocking the scrolling when\n   * moving left and right is a good practice. When all the drag events are blocking\n   * you disable scrolling on that area.\n   * @events  drag, drapleft, dragright, dragup, dragdown\n   */\n\n  Hammer.gestures.Drag = {\n    name: 'drag',\n    index: 50,\n    defaults: {\n      drag_min_distance: 10,\n      // Set correct_for_drag_min_distance to true to make the starting point of the drag\n      // be calculated from where the drag was triggered, not from where the touch started.\n      // Useful to avoid a jerk-starting drag, which can make fine-adjustments\n      // through dragging difficult, and be visually unappealing.\n      correct_for_drag_min_distance: true,\n      // set 0 for unlimited, but this can conflict with transform\n      drag_max_touches: 1,\n      // prevent default browser behavior when dragging occurs\n      // be careful with it, it makes the element a blocking element\n      // when you are using the drag gesture, it is a good practice to set this true\n      drag_block_horizontal: false,\n      drag_block_vertical: false,\n      // drag_lock_to_axis keeps the drag gesture on the axis that it started on,\n      // It disallows vertical directions if the initial direction was horizontal, and vice versa.\n      drag_lock_to_axis: false,\n      // drag lock only kicks in when distance > drag_lock_min_distance\n      // This way, locking occurs only when the distance has become large enough to reliably determine the direction\n      drag_lock_min_distance: 25\n    },\n    triggered: false,\n    handler: function dragGesture(ev, inst) {\n      // current gesture isnt drag, but dragged is true\n      // this means an other gesture is busy. now call dragend\n      if (Hammer.detection.current.name != this.name && this.triggered) {\n        inst.trigger(this.name + 'end', ev);\n        this.triggered = false;\n        return;\n      } // max touches\n\n\n      if (inst.options.drag_max_touches > 0 && ev.touches.length > inst.options.drag_max_touches) {\n        return;\n      }\n\n      switch (ev.eventType) {\n        case Hammer.EVENT_START:\n          this.triggered = false;\n          break;\n\n        case Hammer.EVENT_MOVE:\n          // when the distance we moved is too small we skip this gesture\n          // or we can be already in dragging\n          if (ev.distance < inst.options.drag_min_distance && Hammer.detection.current.name != this.name) {\n            return;\n          } // we are dragging!\n\n\n          if (Hammer.detection.current.name != this.name) {\n            Hammer.detection.current.name = this.name;\n\n            if (inst.options.correct_for_drag_min_distance && ev.distance > 0) {\n              // When a drag is triggered, set the event center to drag_min_distance pixels from the original event center.\n              // Without this correction, the dragged distance would jumpstart at drag_min_distance pixels instead of at 0.\n              // It might be useful to save the original start point somewhere\n              var factor = Math.abs(inst.options.drag_min_distance / ev.distance);\n              Hammer.detection.current.startEvent.center.pageX += ev.deltaX * factor;\n              Hammer.detection.current.startEvent.center.pageY += ev.deltaY * factor; // recalculate event data using new start point\n\n              ev = Hammer.detection.extendEventData(ev);\n            }\n          } // lock drag to axis?\n\n\n          if (Hammer.detection.current.lastEvent.drag_locked_to_axis || inst.options.drag_lock_to_axis && inst.options.drag_lock_min_distance <= ev.distance) {\n            ev.drag_locked_to_axis = true;\n          }\n\n          var last_direction = Hammer.detection.current.lastEvent.direction;\n\n          if (ev.drag_locked_to_axis && last_direction !== ev.direction) {\n            // keep direction on the axis that the drag gesture started on\n            if (Hammer.utils.isVertical(last_direction)) {\n              ev.direction = ev.deltaY < 0 ? Hammer.DIRECTION_UP : Hammer.DIRECTION_DOWN;\n            } else {\n              ev.direction = ev.deltaX < 0 ? Hammer.DIRECTION_LEFT : Hammer.DIRECTION_RIGHT;\n            }\n          } // first time, trigger dragstart event\n\n\n          if (!this.triggered) {\n            inst.trigger(this.name + 'start', ev);\n            this.triggered = true;\n          } // trigger normal event\n\n\n          inst.trigger(this.name, ev); // direction event, like dragdown\n\n          inst.trigger(this.name + ev.direction, ev); // block the browser events\n\n          if (inst.options.drag_block_vertical && Hammer.utils.isVertical(ev.direction) || inst.options.drag_block_horizontal && !Hammer.utils.isVertical(ev.direction)) {\n            ev.preventDefault();\n          }\n\n          break;\n\n        case Hammer.EVENT_END:\n          // trigger dragend\n          if (this.triggered) {\n            inst.trigger(this.name + 'end', ev);\n          }\n\n          this.triggered = false;\n          break;\n      }\n    }\n  };\n  /**\n   * Hold\n   * Touch stays at the same place for x time\n   * @events  hold\n   */\n\n  Hammer.gestures.Hold = {\n    name: 'hold',\n    index: 10,\n    defaults: {\n      hold_timeout: 500,\n      hold_threshold: 1\n    },\n    timer: null,\n    handler: function holdGesture(ev, inst) {\n      switch (ev.eventType) {\n        case Hammer.EVENT_START:\n          // clear any running timers\n          clearTimeout(this.timer); // set the gesture so we can check in the timeout if it still is\n\n          Hammer.detection.current.name = this.name; // set timer and if after the timeout it still is hold,\n          // we trigger the hold event\n\n          this.timer = setTimeout(function () {\n            if (Hammer.detection.current.name == 'hold') {\n              inst.trigger('hold', ev);\n            }\n          }, inst.options.hold_timeout);\n          break;\n        // when you move or end we clear the timer\n\n        case Hammer.EVENT_MOVE:\n          if (ev.distance > inst.options.hold_threshold) {\n            clearTimeout(this.timer);\n          }\n\n          break;\n\n        case Hammer.EVENT_END:\n          clearTimeout(this.timer);\n          break;\n      }\n    }\n  };\n  /**\n   * Release\n   * Called as last, tells the user has released the screen\n   * @events  release\n   */\n\n  Hammer.gestures.Release = {\n    name: 'release',\n    index: Infinity,\n    handler: function releaseGesture(ev, inst) {\n      if (ev.eventType == Hammer.EVENT_END) {\n        inst.trigger(this.name, ev);\n      }\n    }\n  };\n  /**\n   * Swipe\n   * triggers swipe events when the end velocity is above the threshold\n   * @events  swipe, swipeleft, swiperight, swipeup, swipedown\n   */\n\n  Hammer.gestures.Swipe = {\n    name: 'swipe',\n    index: 40,\n    defaults: {\n      // set 0 for unlimited, but this can conflict with transform\n      swipe_min_touches: 1,\n      swipe_max_touches: 1,\n      swipe_velocity: 0.7\n    },\n    handler: function swipeGesture(ev, inst) {\n      if (ev.eventType == Hammer.EVENT_END) {\n        // max touches\n        if (inst.options.swipe_max_touches > 0 && ev.touches.length < inst.options.swipe_min_touches && ev.touches.length > inst.options.swipe_max_touches) {\n          return;\n        } // when the distance we moved is too small we skip this gesture\n        // or we can be already in dragging\n\n\n        if (ev.velocityX > inst.options.swipe_velocity || ev.velocityY > inst.options.swipe_velocity) {\n          // trigger swipe events\n          inst.trigger(this.name, ev);\n          inst.trigger(this.name + ev.direction, ev);\n        }\n      }\n    }\n  };\n  /**\n   * Tap/DoubleTap\n   * Quick touch at a place or double at the same place\n   * @events  tap, doubletap\n   */\n\n  Hammer.gestures.Tap = {\n    name: 'tap',\n    index: 100,\n    defaults: {\n      tap_max_touchtime: 250,\n      tap_max_distance: 10,\n      tap_always: true,\n      doubletap_distance: 20,\n      doubletap_interval: 300\n    },\n    handler: function tapGesture(ev, inst) {\n      if (ev.eventType == Hammer.EVENT_END && ev.srcEvent.type != 'touchcancel') {\n        // previous gesture, for the double tap since these are two different gesture detections\n        var prev = Hammer.detection.previous,\n            did_doubletap = false; // when the touchtime is higher then the max touch time\n        // or when the moving distance is too much\n\n        if (ev.deltaTime > inst.options.tap_max_touchtime || ev.distance > inst.options.tap_max_distance) {\n          return;\n        } // check if double tap\n\n\n        if (prev && prev.name == 'tap' && ev.timeStamp - prev.lastEvent.timeStamp < inst.options.doubletap_interval && ev.distance < inst.options.doubletap_distance) {\n          inst.trigger('doubletap', ev);\n          did_doubletap = true;\n        } // do a single tap\n\n\n        if (!did_doubletap || inst.options.tap_always) {\n          Hammer.detection.current.name = 'tap';\n          inst.trigger(Hammer.detection.current.name, ev);\n        }\n      }\n    }\n  };\n  /**\n   * Touch\n   * Called as first, tells the user has touched the screen\n   * @events  touch\n   */\n\n  Hammer.gestures.Touch = {\n    name: 'touch',\n    index: -Infinity,\n    defaults: {\n      // call preventDefault at touchstart, and makes the element blocking by\n      // disabling the scrolling of the page, but it improves gestures like\n      // transforming and dragging.\n      // be careful with using this, it can be very annoying for users to be stuck\n      // on the page\n      prevent_default: false,\n      // disable mouse events, so only touch (or pen!) input triggers events\n      prevent_mouseevents: false\n    },\n    handler: function touchGesture(ev, inst) {\n      if (inst.options.prevent_mouseevents && ev.pointerType == Hammer.POINTER_MOUSE) {\n        ev.stopDetect();\n        return;\n      }\n\n      if (inst.options.prevent_default) {\n        ev.preventDefault();\n      }\n\n      if (ev.eventType == Hammer.EVENT_START) {\n        inst.trigger(this.name, ev);\n      }\n    }\n  };\n  /**\n   * Transform\n   * User want to scale or rotate with 2 fingers\n   * @events  transform, pinch, pinchin, pinchout, rotate\n   */\n\n  Hammer.gestures.Transform = {\n    name: 'transform',\n    index: 45,\n    defaults: {\n      // factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1\n      transform_min_scale: 0.01,\n      // rotation in degrees\n      transform_min_rotation: 1,\n      // prevent default browser behavior when two touches are on the screen\n      // but it makes the element a blocking element\n      // when you are using the transform gesture, it is a good practice to set this true\n      transform_always_block: false\n    },\n    triggered: false,\n    handler: function transformGesture(ev, inst) {\n      // current gesture isnt drag, but dragged is true\n      // this means an other gesture is busy. now call dragend\n      if (Hammer.detection.current.name != this.name && this.triggered) {\n        inst.trigger(this.name + 'end', ev);\n        this.triggered = false;\n        return;\n      } // atleast multitouch\n\n\n      if (ev.touches.length < 2) {\n        return;\n      } // prevent default when two fingers are on the screen\n\n\n      if (inst.options.transform_always_block) {\n        ev.preventDefault();\n      }\n\n      switch (ev.eventType) {\n        case Hammer.EVENT_START:\n          this.triggered = false;\n          break;\n\n        case Hammer.EVENT_MOVE:\n          var scale_threshold = Math.abs(1 - ev.scale);\n          var rotation_threshold = Math.abs(ev.rotation); // when the distance we moved is too small we skip this gesture\n          // or we can be already in dragging\n\n          if (scale_threshold < inst.options.transform_min_scale && rotation_threshold < inst.options.transform_min_rotation) {\n            return;\n          } // we are transforming!\n\n\n          Hammer.detection.current.name = this.name; // first time, trigger dragstart event\n\n          if (!this.triggered) {\n            inst.trigger(this.name + 'start', ev);\n            this.triggered = true;\n          }\n\n          inst.trigger(this.name, ev); // basic transform event\n          // trigger rotate event\n\n          if (rotation_threshold > inst.options.transform_min_rotation) {\n            inst.trigger('rotate', ev);\n          } // trigger pinch event\n\n\n          if (scale_threshold > inst.options.transform_min_scale) {\n            inst.trigger('pinch', ev);\n            inst.trigger('pinch' + (ev.scale < 1 ? 'in' : 'out'), ev);\n          }\n\n          break;\n\n        case Hammer.EVENT_END:\n          // trigger dragend\n          if (this.triggered) {\n            inst.trigger(this.name + 'end', ev);\n          }\n\n          this.triggered = false;\n          break;\n      }\n    }\n  }; // Based off Lo-Dash's excellent UMD wrapper (slightly modified) - https://github.com/bestiejs/lodash/blob/master/lodash.js#L5515-L5543\n  // some AMD build optimizers, like r.js, check for specific condition patterns like the following:\n\n  if (typeof define == 'function' && __webpack_require__(/*! !webpack amd options */ \"./node_modules/.registry.npmjs.org/webpack/4.29.6/node_modules/webpack/buildin/amd-options.js\")) {\n    // define as an anonymous module\n    define(function () {\n      return Hammer;\n    });\n  } // check for `exports` after `define` in case a build optimizer adds an `exports` object\n  else if ( true && module.exports) {\n      module.exports = Hammer;\n    } else {\n      window.Hammer = Hammer;\n    }\n\n  return Hammer;\n}(window);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Hammer);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../shinyGator/node_modules/.registry.npmjs.org/webpack/4.29.6/node_modules/webpack/buildin/harmony-module.js */ \"./node_modules/.registry.npmjs.org/webpack/4.29.6/node_modules/webpack/buildin/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vZ2F0b3IvanMvaGFtbWVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL2dhdG9yL2pzL2hhbW1lci5qcz83OTVlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBIYW1tZXIuSlMgLSB2MS4wLjdkZXYgLSAyMDE0LTAxLTE1XG4gKiBodHRwOi8vZWlnaHRtZWRpYS5naXRodWIuY29tL2hhbW1lci5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNCBKb3JpayBUYW5nZWxkZXIgPGoudGFuZ2VsZGVyQGdtYWlsLmNvbT47XG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgKi9cblxuY29uc3QgSGFtbWVyID0gKGZ1bmN0aW9uKHdpbmRvdywgdW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBIYW1tZXJcbiAqIHVzZSB0aGlzIHRvIGNyZWF0ZSBpbnN0YW5jZXNcbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gICBlbGVtZW50XG4gKiBAcGFyYW0gICB7T2JqZWN0fSAgICAgICAgb3B0aW9uc1xuICogQHJldHVybnMge0hhbW1lci5JbnN0YW5jZX1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgSGFtbWVyID0gZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IEhhbW1lci5JbnN0YW5jZShlbGVtZW50LCBvcHRpb25zIHx8IHt9KTtcbn07XG5cbi8vIGRlZmF1bHQgc2V0dGluZ3NcbkhhbW1lci5kZWZhdWx0cyA9IHtcbiAgLy8gYWRkIHN0eWxlcyBhbmQgYXR0cmlidXRlcyB0byB0aGUgZWxlbWVudCB0byBwcmV2ZW50IHRoZSBicm93c2VyIGZyb20gZG9pbmdcbiAgLy8gaXRzIG5hdGl2ZSBiZWhhdmlvci4gdGhpcyBkb2VzbnQgcHJldmVudCB0aGUgc2Nyb2xsaW5nLCBidXQgY2FuY2Vsc1xuICAvLyB0aGUgY29udGV4dG1lbnUsIHRhcCBoaWdobGlnaHRpbmcgZXRjXG4gIC8vIHNldCB0byBmYWxzZSB0byBkaXNhYmxlIHRoaXNcbiAgc3RvcF9icm93c2VyX2JlaGF2aW9yOiB7XG4gICAgLy8gdGhpcyBhbHNvIHRyaWdnZXJzIG9uc2VsZWN0c3RhcnQ9ZmFsc2UgZm9yIElFXG4gICAgdXNlclNlbGVjdCAgICAgICA6ICdub25lJyxcbiAgICAvLyB0aGlzIG1ha2VzIHRoZSBlbGVtZW50IGJsb2NraW5nIGluIElFMTAgPiwgeW91IGNvdWxkIGV4cGVyaW1lbnQgd2l0aCB0aGUgdmFsdWVcbiAgICAvLyBzZWUgZm9yIG1vcmUgb3B0aW9ucyB0aGlzIGlzc3VlOyBodHRwczovL2dpdGh1Yi5jb20vRWlnaHRNZWRpYS9oYW1tZXIuanMvaXNzdWVzLzI0MVxuICAgIHRvdWNoQWN0aW9uICAgICAgOiAnbm9uZScsXG4gICAgdG91Y2hDYWxsb3V0ICAgICA6ICdub25lJyxcbiAgICBjb250ZW50Wm9vbWluZyAgIDogJ25vbmUnLFxuICAgIHVzZXJEcmFnICAgICAgICAgOiAnbm9uZScsXG4gICAgdGFwSGlnaGxpZ2h0Q29sb3I6ICdyZ2JhKDAsMCwwLDApJ1xuICB9XG5cbiAgLy9cbiAgLy8gbW9yZSBzZXR0aW5ncyBhcmUgZGVmaW5lZCBwZXIgZ2VzdHVyZSBhdCBnZXN0dXJlcy5qc1xuICAvL1xufTtcblxuLy8gZGV0ZWN0IHRvdWNoZXZlbnRzXG5IYW1tZXIuSEFTX1BPSU5URVJFVkVOVFMgPSB3aW5kb3cubmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkIHx8IHdpbmRvdy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZDtcbkhhbW1lci5IQVNfVE9VQ0hFVkVOVFMgPSAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KTtcblxuLy8gZG9udCB1c2UgbW91c2VldmVudHMgb24gbW9iaWxlIGRldmljZXNcbkhhbW1lci5NT0JJTEVfUkVHRVggPSAvbW9iaWxlfHRhYmxldHxpcChhZHxob25lfG9kKXxhbmRyb2lkfHNpbGsvaTtcbkhhbW1lci5OT19NT1VTRUVWRU5UUyA9IEhhbW1lci5IQVNfVE9VQ0hFVkVOVFMgJiYgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goSGFtbWVyLk1PQklMRV9SRUdFWCk7XG5cbi8vIGV2ZW50dHlwZXMgcGVyIHRvdWNoZXZlbnQgKHN0YXJ0LCBtb3ZlLCBlbmQpXG4vLyBhcmUgZmlsbGVkIGJ5IEhhbW1lci5ldmVudC5kZXRlcm1pbmVFdmVudFR5cGVzIG9uIHNldHVwXG5IYW1tZXIuRVZFTlRfVFlQRVMgPSB7fTtcblxuLy8gZGlyZWN0aW9uIGRlZmluZXNcbkhhbW1lci5ESVJFQ1RJT05fRE9XTiA9ICdkb3duJztcbkhhbW1lci5ESVJFQ1RJT05fTEVGVCA9ICdsZWZ0JztcbkhhbW1lci5ESVJFQ1RJT05fVVAgPSAndXAnO1xuSGFtbWVyLkRJUkVDVElPTl9SSUdIVCA9ICdyaWdodCc7XG5cbi8vIHBvaW50ZXIgdHlwZVxuSGFtbWVyLlBPSU5URVJfTU9VU0UgPSAnbW91c2UnO1xuSGFtbWVyLlBPSU5URVJfVE9VQ0ggPSAndG91Y2gnO1xuSGFtbWVyLlBPSU5URVJfUEVOID0gJ3Blbic7XG5cbi8vIHRvdWNoIGV2ZW50IGRlZmluZXNcbkhhbW1lci5FVkVOVF9TVEFSVCA9ICdzdGFydCc7XG5IYW1tZXIuRVZFTlRfTU9WRSA9ICdtb3ZlJztcbkhhbW1lci5FVkVOVF9FTkQgPSAnZW5kJztcblxuLy8gaGFtbWVyIGRvY3VtZW50IHdoZXJlIHRoZSBiYXNlIGV2ZW50cyBhcmUgYWRkZWQgYXRcbkhhbW1lci5ET0NVTUVOVCA9IHdpbmRvdy5kb2N1bWVudDtcblxuLy8gcGx1Z2lucyBhbmQgZ2VzdHVyZXMgbmFtZXNwYWNlc1xuSGFtbWVyLnBsdWdpbnMgPSBIYW1tZXIucGx1Z2lucyB8fCB7fTtcbkhhbW1lci5nZXN0dXJlcyA9IEhhbW1lci5nZXN0dXJlcyB8fCB7fTtcblxuLy8gaWYgdGhlIHdpbmRvdyBldmVudHMgYXJlIHNldC4uLlxuSGFtbWVyLlJFQURZID0gZmFsc2U7XG5cbi8qKlxuICogc2V0dXAgZXZlbnRzIHRvIGRldGVjdCBnZXN0dXJlcyBvbiB0aGUgZG9jdW1lbnRcbiAqL1xuZnVuY3Rpb24gc2V0dXAoKSB7XG4gIGlmKEhhbW1lci5SRUFEWSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGZpbmQgd2hhdCBldmVudHR5cGVzIHdlIGFkZCBsaXN0ZW5lcnMgdG9cbiAgSGFtbWVyLmV2ZW50LmRldGVybWluZUV2ZW50VHlwZXMoKTtcblxuICAvLyBSZWdpc3RlciBhbGwgZ2VzdHVyZXMgaW5zaWRlIEhhbW1lci5nZXN0dXJlc1xuICBIYW1tZXIudXRpbHMuZWFjaChIYW1tZXIuZ2VzdHVyZXMsIGZ1bmN0aW9uKGdlc3R1cmUpe1xuICAgIEhhbW1lci5kZXRlY3Rpb24ucmVnaXN0ZXIoZ2VzdHVyZSk7XG4gIH0pO1xuXG4gIC8vIEFkZCB0b3VjaCBldmVudHMgb24gdGhlIGRvY3VtZW50XG4gIEhhbW1lci5ldmVudC5vblRvdWNoKEhhbW1lci5ET0NVTUVOVCwgSGFtbWVyLkVWRU5UX01PVkUsIEhhbW1lci5kZXRlY3Rpb24uZGV0ZWN0KTtcbiAgSGFtbWVyLmV2ZW50Lm9uVG91Y2goSGFtbWVyLkRPQ1VNRU5ULCBIYW1tZXIuRVZFTlRfRU5ELCBIYW1tZXIuZGV0ZWN0aW9uLmRldGVjdCk7XG5cbiAgLy8gSGFtbWVyIGlzIHJlYWR5Li4uIVxuICBIYW1tZXIuUkVBRFkgPSB0cnVlO1xufVxuXG5IYW1tZXIudXRpbHMgPSB7XG4gIC8qKlxuICAgKiBleHRlbmQgbWV0aG9kLFxuICAgKiBhbHNvIHVzZWQgZm9yIGNsb25pbmcgd2hlbiBkZXN0IGlzIGFuIGVtcHR5IG9iamVjdFxuICAgKiBAcGFyYW0gICB7T2JqZWN0fSAgICBkZXN0XG4gICAqIEBwYXJhbSAgIHtPYmplY3R9ICAgIHNyY1xuICAgKiBAcGFybSAge0Jvb2xlYW59ICBtZXJnZSAgICBkbyBhIG1lcmdlXG4gICAqIEByZXR1cm5zIHtPYmplY3R9ICAgIGRlc3RcbiAgICovXG4gIGV4dGVuZDogZnVuY3Rpb24gZXh0ZW5kKGRlc3QsIHNyYywgbWVyZ2UpIHtcbiAgICBmb3IodmFyIGtleSBpbiBzcmMpIHtcbiAgICAgIGlmKGRlc3Rba2V5XSAhPT0gdW5kZWZpbmVkICYmIG1lcmdlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZGVzdFtrZXldID0gc3JjW2tleV07XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIGZvciBlYWNoXG4gICAqIEBwYXJhbSBvYmpcbiAgICogQHBhcmFtIGl0ZXJhdG9yXG4gICAqL1xuICBlYWNoOiBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIGksIGxlbmd0aDtcbiAgICAvLyBuYXRpdmUgZm9yRWFjaCBvbiBhcnJheXNcbiAgICBpZiAoJ2ZvckVhY2gnIGluIG9iaikge1xuICAgICAgb2JqLmZvckVhY2goaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgIH1cbiAgICAvLyBhcnJheXNcbiAgICBlbHNlIGlmKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gb2JqZWN0c1xuICAgIGVsc2Uge1xuICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpICYmIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogZmluZCBpZiBhIG5vZGUgaXMgaW4gdGhlIGdpdmVuIHBhcmVudFxuICAgKiB1c2VkIGZvciBldmVudCBkZWxlZ2F0aW9uIHRyaWNrc1xuICAgKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9ICAgbm9kZVxuICAgKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9ICAgcGFyZW50XG4gICAqIEByZXR1cm5zIHtib29sZWFufSAgICAgICBoYXNfcGFyZW50XG4gICAqL1xuICBoYXNQYXJlbnQ6IGZ1bmN0aW9uKG5vZGUsIHBhcmVudCkge1xuICAgIHdoaWxlKG5vZGUpIHtcbiAgICAgIGlmKG5vZGUgPT0gcGFyZW50KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIGdldCB0aGUgY2VudGVyIG9mIGFsbCB0aGUgdG91Y2hlc1xuICAgKiBAcGFyYW0gICB7QXJyYXl9ICAgICB0b3VjaGVzXG4gICAqIEByZXR1cm5zIHtPYmplY3R9ICAgIGNlbnRlclxuICAgKi9cbiAgZ2V0Q2VudGVyOiBmdW5jdGlvbiBnZXRDZW50ZXIodG91Y2hlcykge1xuICAgIHZhciB2YWx1ZXNYID0gW10sIHZhbHVlc1kgPSBbXTtcblxuICAgIEhhbW1lci51dGlscy5lYWNoKHRvdWNoZXMsIGZ1bmN0aW9uKHRvdWNoKSB7XG4gICAgICAvLyBJIHByZWZlciBjbGllbnRYIGJlY2F1c2UgaXQgaWdub3JlIHRoZSBzY3JvbGxpbmcgcG9zaXRpb25cbiAgICAgIHZhbHVlc1gucHVzaCh0eXBlb2YgdG91Y2guY2xpZW50WCAhPT0gJ3VuZGVmaW5lZCcgPyB0b3VjaC5jbGllbnRYIDogdG91Y2gucGFnZVggKTtcbiAgICAgIHZhbHVlc1kucHVzaCh0eXBlb2YgdG91Y2guY2xpZW50WSAhPT0gJ3VuZGVmaW5lZCcgPyB0b3VjaC5jbGllbnRZIDogdG91Y2gucGFnZVkgKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICBwYWdlWDogKChNYXRoLm1pbi5hcHBseShNYXRoLCB2YWx1ZXNYKSArIE1hdGgubWF4LmFwcGx5KE1hdGgsIHZhbHVlc1gpKSAvIDIpLFxuICAgICAgcGFnZVk6ICgoTWF0aC5taW4uYXBwbHkoTWF0aCwgdmFsdWVzWSkgKyBNYXRoLm1heC5hcHBseShNYXRoLCB2YWx1ZXNZKSkgLyAyKVxuICAgIH07XG4gIH0sXG5cblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSB2ZWxvY2l0eSBiZXR3ZWVuIHR3byBwb2ludHNcbiAgICogQHBhcmFtICAge051bWJlcn0gICAgZGVsdGFfdGltZVxuICAgKiBAcGFyYW0gICB7TnVtYmVyfSAgICBkZWx0YV94XG4gICAqIEBwYXJhbSAgIHtOdW1iZXJ9ICAgIGRlbHRhX3lcbiAgICogQHJldHVybnMge09iamVjdH0gICAgdmVsb2NpdHlcbiAgICovXG4gIGdldFZlbG9jaXR5OiBmdW5jdGlvbiBnZXRWZWxvY2l0eShkZWx0YV90aW1lLCBkZWx0YV94LCBkZWx0YV95KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IE1hdGguYWJzKGRlbHRhX3ggLyBkZWx0YV90aW1lKSB8fCAwLFxuICAgICAgeTogTWF0aC5hYnMoZGVsdGFfeSAvIGRlbHRhX3RpbWUpIHx8IDBcbiAgICB9O1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgYW5nbGUgYmV0d2VlbiB0d28gY29vcmRpbmF0ZXNcbiAgICogQHBhcmFtICAge1RvdWNofSAgICAgdG91Y2gxXG4gICAqIEBwYXJhbSAgIHtUb3VjaH0gICAgIHRvdWNoMlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSAgICBhbmdsZVxuICAgKi9cbiAgZ2V0QW5nbGU6IGZ1bmN0aW9uIGdldEFuZ2xlKHRvdWNoMSwgdG91Y2gyKSB7XG4gICAgdmFyIHkgPSB0b3VjaDIucGFnZVkgLSB0b3VjaDEucGFnZVksXG4gICAgICB4ID0gdG91Y2gyLnBhZ2VYIC0gdG91Y2gxLnBhZ2VYO1xuICAgIHJldHVybiBNYXRoLmF0YW4yKHksIHgpICogMTgwIC8gTWF0aC5QSTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBhbmdsZSB0byBkaXJlY3Rpb24gZGVmaW5lXG4gICAqIEBwYXJhbSAgIHtUb3VjaH0gICAgIHRvdWNoMVxuICAgKiBAcGFyYW0gICB7VG91Y2h9ICAgICB0b3VjaDJcbiAgICogQHJldHVybnMge1N0cmluZ30gICAgZGlyZWN0aW9uIGNvbnN0YW50LCBsaWtlIEhhbW1lci5ESVJFQ1RJT05fTEVGVFxuICAgKi9cbiAgZ2V0RGlyZWN0aW9uOiBmdW5jdGlvbiBnZXREaXJlY3Rpb24odG91Y2gxLCB0b3VjaDIpIHtcbiAgICB2YXIgeCA9IE1hdGguYWJzKHRvdWNoMS5wYWdlWCAtIHRvdWNoMi5wYWdlWCksXG4gICAgICB5ID0gTWF0aC5hYnModG91Y2gxLnBhZ2VZIC0gdG91Y2gyLnBhZ2VZKTtcblxuICAgIGlmKHggPj0geSkge1xuICAgICAgcmV0dXJuIHRvdWNoMS5wYWdlWCAtIHRvdWNoMi5wYWdlWCA+IDAgPyBIYW1tZXIuRElSRUNUSU9OX0xFRlQgOiBIYW1tZXIuRElSRUNUSU9OX1JJR0hUO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiB0b3VjaDEucGFnZVkgLSB0b3VjaDIucGFnZVkgPiAwID8gSGFtbWVyLkRJUkVDVElPTl9VUCA6IEhhbW1lci5ESVJFQ1RJT05fRE9XTjtcbiAgICB9XG4gIH0sXG5cblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byB0b3VjaGVzXG4gICAqIEBwYXJhbSAgIHtUb3VjaH0gICAgIHRvdWNoMVxuICAgKiBAcGFyYW0gICB7VG91Y2h9ICAgICB0b3VjaDJcbiAgICogQHJldHVybnMge051bWJlcn0gICAgZGlzdGFuY2VcbiAgICovXG4gIGdldERpc3RhbmNlOiBmdW5jdGlvbiBnZXREaXN0YW5jZSh0b3VjaDEsIHRvdWNoMikge1xuICAgIHZhciB4ID0gdG91Y2gyLnBhZ2VYIC0gdG91Y2gxLnBhZ2VYLFxuICAgICAgeSA9IHRvdWNoMi5wYWdlWSAtIHRvdWNoMS5wYWdlWTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KCh4ICogeCkgKyAoeSAqIHkpKTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdGhlIHNjYWxlIGZhY3RvciBiZXR3ZWVuIHR3byB0b3VjaExpc3RzIChmaW5nZXJzKVxuICAgKiBubyBzY2FsZSBpcyAxLCBhbmQgZ29lcyBkb3duIHRvIDAgd2hlbiBwaW5jaGVkIHRvZ2V0aGVyLCBhbmQgYmlnZ2VyIHdoZW4gcGluY2hlZCBvdXRcbiAgICogQHBhcmFtICAge0FycmF5fSAgICAgc3RhcnRcbiAgICogQHBhcmFtICAge0FycmF5fSAgICAgZW5kXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9ICAgIHNjYWxlXG4gICAqL1xuICBnZXRTY2FsZTogZnVuY3Rpb24gZ2V0U2NhbGUoc3RhcnQsIGVuZCkge1xuICAgIC8vIG5lZWQgdHdvIGZpbmdlcnMuLi5cbiAgICBpZihzdGFydC5sZW5ndGggPj0gMiAmJiBlbmQubGVuZ3RoID49IDIpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldERpc3RhbmNlKGVuZFswXSwgZW5kWzFdKSAvXG4gICAgICAgIHRoaXMuZ2V0RGlzdGFuY2Uoc3RhcnRbMF0sIHN0YXJ0WzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIDE7XG4gIH0sXG5cblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSByb3RhdGlvbiBkZWdyZWVzIGJldHdlZW4gdHdvIHRvdWNoTGlzdHMgKGZpbmdlcnMpXG4gICAqIEBwYXJhbSAgIHtBcnJheX0gICAgIHN0YXJ0XG4gICAqIEBwYXJhbSAgIHtBcnJheX0gICAgIGVuZFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSAgICByb3RhdGlvblxuICAgKi9cbiAgZ2V0Um90YXRpb246IGZ1bmN0aW9uIGdldFJvdGF0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAvLyBuZWVkIHR3byBmaW5nZXJzXG4gICAgaWYoc3RhcnQubGVuZ3RoID49IDIgJiYgZW5kLmxlbmd0aCA+PSAyKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRBbmdsZShlbmRbMV0sIGVuZFswXSkgLVxuICAgICAgICB0aGlzLmdldEFuZ2xlKHN0YXJ0WzFdLCBzdGFydFswXSk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIGJvb2xlYW4gaWYgdGhlIGRpcmVjdGlvbiBpcyB2ZXJ0aWNhbFxuICAgKiBAcGFyYW0gICAge1N0cmluZ30gICAgZGlyZWN0aW9uXG4gICAqIEByZXR1cm5zICB7Qm9vbGVhbn0gICBpc192ZXJ0aWNhbFxuICAgKi9cbiAgaXNWZXJ0aWNhbDogZnVuY3Rpb24gaXNWZXJ0aWNhbChkaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gKGRpcmVjdGlvbiA9PSBIYW1tZXIuRElSRUNUSU9OX1VQIHx8IGRpcmVjdGlvbiA9PSBIYW1tZXIuRElSRUNUSU9OX0RPV04pO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIHN0b3AgYnJvd3NlciBkZWZhdWx0IGJlaGF2aW9yIHdpdGggY3NzIHByb3BzXG4gICAqIEBwYXJhbSAgIHtIdG1sRWxlbWVudH0gICBlbGVtZW50XG4gICAqIEBwYXJhbSAgIHtPYmplY3R9ICAgICAgICBjc3NfcHJvcHNcbiAgICovXG4gIHN0b3BEZWZhdWx0QnJvd3NlckJlaGF2aW9yOiBmdW5jdGlvbiBzdG9wRGVmYXVsdEJyb3dzZXJCZWhhdmlvcihlbGVtZW50LCBjc3NfcHJvcHMpIHtcbiAgICBpZighY3NzX3Byb3BzIHx8ICFlbGVtZW50IHx8ICFlbGVtZW50LnN0eWxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gd2l0aCBjc3MgcHJvcGVydGllcyBmb3IgbW9kZXJuIGJyb3dzZXJzXG4gICAgSGFtbWVyLnV0aWxzLmVhY2goWyd3ZWJraXQnLCAna2h0bWwnLCAnbW96JywgJ01veicsICdtcycsICdvJywgJyddLCBmdW5jdGlvbih2ZW5kb3IpIHtcbiAgICAgIEhhbW1lci51dGlscy5lYWNoKGNzc19wcm9wcywgZnVuY3Rpb24odmFsdWUsIHByb3ApIHtcbiAgICAgICAgICAvLyB2ZW5kZXIgcHJlZml4IGF0IHRoZSBwcm9wZXJ0eVxuICAgICAgICAgIGlmKHZlbmRvcikge1xuICAgICAgICAgICAgcHJvcCA9IHZlbmRvciArIHByb3Auc3Vic3RyaW5nKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnN1YnN0cmluZygxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gc2V0IHRoZSBzdHlsZVxuICAgICAgICAgIGlmKHByb3AgaW4gZWxlbWVudC5zdHlsZSkge1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gYWxzbyB0aGUgZGlzYWJsZSBvbnNlbGVjdHN0YXJ0XG4gICAgaWYoY3NzX3Byb3BzLnVzZXJTZWxlY3QgPT0gJ25vbmUnKSB7XG4gICAgICBlbGVtZW50Lm9uc2VsZWN0c3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBhbmQgZGlzYWJsZSBvbmRyYWdzdGFydFxuICAgIGlmKGNzc19wcm9wcy51c2VyRHJhZyA9PSAnbm9uZScpIHtcbiAgICAgIGVsZW1lbnQub25kcmFnc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBjcmVhdGUgbmV3IGhhbW1lciBpbnN0YW5jZVxuICogYWxsIG1ldGhvZHMgc2hvdWxkIHJldHVybiB0aGUgaW5zdGFuY2UgaXRzZWxmLCBzbyBpdCBpcyBjaGFpbmFibGUuXG4gKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9ICAgICAgIGVsZW1lbnRcbiAqIEBwYXJhbSAgIHtPYmplY3R9ICAgICAgICAgICAgW29wdGlvbnM9e31dXG4gKiBAcmV0dXJucyB7SGFtbWVyLkluc3RhbmNlfVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbkhhbW1lci5JbnN0YW5jZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8vIHNldHVwIEhhbW1lckpTIHdpbmRvdyBldmVudHMgYW5kIHJlZ2lzdGVyIGFsbCBnZXN0dXJlc1xuICAvLyB0aGlzIGFsc28gc2V0cyB1cCB0aGUgZGVmYXVsdCBvcHRpb25zXG4gIHNldHVwKCk7XG5cbiAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcblxuICAvLyBzdGFydC9zdG9wIGRldGVjdGlvbiBvcHRpb25cbiAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcblxuICAvLyBtZXJnZSBvcHRpb25zXG4gIHRoaXMub3B0aW9ucyA9IEhhbW1lci51dGlscy5leHRlbmQoXG4gICAgSGFtbWVyLnV0aWxzLmV4dGVuZCh7fSwgSGFtbWVyLmRlZmF1bHRzKSxcbiAgICBvcHRpb25zIHx8IHt9KTtcblxuICAvLyBhZGQgc29tZSBjc3MgdG8gdGhlIGVsZW1lbnQgdG8gcHJldmVudCB0aGUgYnJvd3NlciBmcm9tIGRvaW5nIGl0cyBuYXRpdmUgYmVoYXZvaXJcbiAgaWYodGhpcy5vcHRpb25zLnN0b3BfYnJvd3Nlcl9iZWhhdmlvcikge1xuICAgIEhhbW1lci51dGlscy5zdG9wRGVmYXVsdEJyb3dzZXJCZWhhdmlvcih0aGlzLmVsZW1lbnQsIHRoaXMub3B0aW9ucy5zdG9wX2Jyb3dzZXJfYmVoYXZpb3IpO1xuICB9XG5cbiAgLy8gc3RhcnQgZGV0ZWN0aW9uIG9uIHRvdWNoc3RhcnRcbiAgSGFtbWVyLmV2ZW50Lm9uVG91Y2goZWxlbWVudCwgSGFtbWVyLkVWRU5UX1NUQVJULCBmdW5jdGlvbihldikge1xuICAgIGlmKHNlbGYuZW5hYmxlZCkge1xuICAgICAgSGFtbWVyLmRldGVjdGlvbi5zdGFydERldGVjdChzZWxmLCBldik7XG4gICAgfVxuICB9KTtcblxuICAvLyByZXR1cm4gaW5zdGFuY2VcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbkhhbW1lci5JbnN0YW5jZS5wcm90b3R5cGUgPSB7XG4gIC8qKlxuICAgKiBiaW5kIGV2ZW50cyB0byB0aGUgaW5zdGFuY2VcbiAgICogQHBhcmFtICAge1N0cmluZ30gICAgICBnZXN0dXJlXG4gICAqIEBwYXJhbSAgIHtGdW5jdGlvbn0gICAgaGFuZGxlclxuICAgKiBAcmV0dXJucyB7SGFtbWVyLkluc3RhbmNlfVxuICAgKi9cbiAgb246IGZ1bmN0aW9uIG9uRXZlbnQoZ2VzdHVyZSwgaGFuZGxlcikge1xuICAgIHZhciBnZXN0dXJlcyA9IGdlc3R1cmUuc3BsaXQoJyAnKTtcbiAgICBIYW1tZXIudXRpbHMuZWFjaChnZXN0dXJlcywgZnVuY3Rpb24oZ2VzdHVyZSkge1xuICAgICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZ2VzdHVyZSwgaGFuZGxlciwgZmFsc2UpO1xuICAgIH0sIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIHVuYmluZCBldmVudHMgdG8gdGhlIGluc3RhbmNlXG4gICAqIEBwYXJhbSAgIHtTdHJpbmd9ICAgICAgZ2VzdHVyZVxuICAgKiBAcGFyYW0gICB7RnVuY3Rpb259ICAgIGhhbmRsZXJcbiAgICogQHJldHVybnMge0hhbW1lci5JbnN0YW5jZX1cbiAgICovXG4gIG9mZjogZnVuY3Rpb24gb2ZmRXZlbnQoZ2VzdHVyZSwgaGFuZGxlcikge1xuICAgIHZhciBnZXN0dXJlcyA9IGdlc3R1cmUuc3BsaXQoJyAnKTtcbiAgICBIYW1tZXIudXRpbHMuZWFjaChnZXN0dXJlcywgZnVuY3Rpb24oZ2VzdHVyZSkge1xuICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZ2VzdHVyZSwgaGFuZGxlciwgZmFsc2UpO1xuICAgIH0sIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIHRyaWdnZXIgZ2VzdHVyZSBldmVudFxuICAgKiBAcGFyYW0gICB7U3RyaW5nfSAgICAgIGdlc3R1cmVcbiAgICogQHBhcmFtICAge09iamVjdH0gICAgICBbZXZlbnREYXRhXVxuICAgKiBAcmV0dXJucyB7SGFtbWVyLkluc3RhbmNlfVxuICAgKi9cbiAgdHJpZ2dlcjogZnVuY3Rpb24gdHJpZ2dlckV2ZW50KGdlc3R1cmUsIGV2ZW50RGF0YSkge1xuICAgIC8vIG9wdGlvbmFsXG4gICAgaWYoIWV2ZW50RGF0YSkge1xuICAgICAgZXZlbnREYXRhID0ge307XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIERPTSBldmVudFxuICAgIHZhciBldmVudCA9IEhhbW1lci5ET0NVTUVOVC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBldmVudC5pbml0RXZlbnQoZ2VzdHVyZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZXZlbnQuZ2VzdHVyZSA9IGV2ZW50RGF0YTtcblxuICAgIC8vIHRyaWdnZXIgb24gdGhlIHRhcmdldCBpZiBpdCBpcyBpbiB0aGUgaW5zdGFuY2UgZWxlbWVudCxcbiAgICAvLyB0aGlzIGlzIGZvciBldmVudCBkZWxlZ2F0aW9uIHRyaWNrc1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgIGlmKEhhbW1lci51dGlscy5oYXNQYXJlbnQoZXZlbnREYXRhLnRhcmdldCwgZWxlbWVudCkpIHtcbiAgICAgIGVsZW1lbnQgPSBldmVudERhdGEudGFyZ2V0O1xuICAgIH1cblxuICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cblxuICAvKipcbiAgICogZW5hYmxlIG9mIGRpc2FibGUgaGFtbWVyLmpzIGRldGVjdGlvblxuICAgKiBAcGFyYW0gICB7Qm9vbGVhbn0gICBzdGF0ZVxuICAgKiBAcmV0dXJucyB7SGFtbWVyLkluc3RhbmNlfVxuICAgKi9cbiAgZW5hYmxlOiBmdW5jdGlvbiBlbmFibGUoc3RhdGUpIHtcbiAgICB0aGlzLmVuYWJsZWQgPSBzdGF0ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcblxuXG4vKipcbiAqIHRoaXMgaG9sZHMgdGhlIGxhc3QgbW92ZSBldmVudCxcbiAqIHVzZWQgdG8gZml4IGVtcHR5IHRvdWNoZW5kIGlzc3VlXG4gKiBzZWUgdGhlIG9uVG91Y2ggZXZlbnQgZm9yIGFuIGV4cGxhbmF0aW9uXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgbGFzdF9tb3ZlX2V2ZW50ID0gbnVsbDtcblxuXG4vKipcbiAqIHdoZW4gdGhlIG1vdXNlIGlzIGhvbGQgZG93biwgdGhpcyBpcyB0cnVlXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqL1xudmFyIGVuYWJsZV9kZXRlY3QgPSBmYWxzZTtcblxuXG4vKipcbiAqIHdoZW4gdG91Y2ggZXZlbnRzIGhhdmUgYmVlbiBmaXJlZCwgdGhpcyBpcyB0cnVlXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqL1xudmFyIHRvdWNoX3RyaWdnZXJlZCA9IGZhbHNlO1xuXG5cbkhhbW1lci5ldmVudCA9IHtcbiAgLyoqXG4gICAqIHNpbXBsZSBhZGRFdmVudExpc3RlbmVyXG4gICAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gICBlbGVtZW50XG4gICAqIEBwYXJhbSAgIHtTdHJpbmd9ICAgICAgICB0eXBlXG4gICAqIEBwYXJhbSAgIHtGdW5jdGlvbn0gICAgICBoYW5kbGVyXG4gICAqL1xuICBiaW5kRG9tOiBmdW5jdGlvbihlbGVtZW50LCB0eXBlLCBoYW5kbGVyKSB7XG4gICAgdmFyIHR5cGVzID0gdHlwZS5zcGxpdCgnICcpO1xuICAgIEhhbW1lci51dGlscy5lYWNoKHR5cGVzLCBmdW5jdGlvbih0eXBlKXtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgfSk7XG4gIH0sXG5cblxuICAvKipcbiAgICogdG91Y2ggZXZlbnRzIHdpdGggbW91c2UgZmFsbGJhY2tcbiAgICogQHBhcmFtICAge0hUTUxFbGVtZW50fSAgIGVsZW1lbnRcbiAgICogQHBhcmFtICAge1N0cmluZ30gICAgICAgIGV2ZW50VHlwZSAgICAgICAgbGlrZSBIYW1tZXIuRVZFTlRfTU9WRVxuICAgKiBAcGFyYW0gICB7RnVuY3Rpb259ICAgICAgaGFuZGxlclxuICAgKi9cbiAgb25Ub3VjaDogZnVuY3Rpb24gb25Ub3VjaChlbGVtZW50LCBldmVudFR5cGUsIGhhbmRsZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLmJpbmREb20oZWxlbWVudCwgSGFtbWVyLkVWRU5UX1RZUEVTW2V2ZW50VHlwZV0sIGZ1bmN0aW9uIGJpbmREb21PblRvdWNoKGV2KSB7XG4gICAgICB2YXIgc291cmNlRXZlbnRUeXBlID0gZXYudHlwZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAvLyBvbm1vdXNldXAsIGJ1dCB3aGVuIHRvdWNoZW5kIGhhcyBiZWVuIGZpcmVkIHdlIGRvIG5vdGhpbmcuXG4gICAgICAvLyB0aGlzIGlzIGZvciB0b3VjaGRldmljZXMgd2hpY2ggYWxzbyBmaXJlIGEgbW91c2V1cCBvbiB0b3VjaGVuZFxuICAgICAgaWYoc291cmNlRXZlbnRUeXBlLm1hdGNoKC9tb3VzZS8pICYmIHRvdWNoX3RyaWdnZXJlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIG1vdXNlYnV0dG9uIG11c3QgYmUgZG93biBvciBhIHRvdWNoIGV2ZW50XG4gICAgICBlbHNlIGlmKHNvdXJjZUV2ZW50VHlwZS5tYXRjaCgvdG91Y2gvKSB8fCAgIC8vIHRvdWNoIGV2ZW50cyBhcmUgYWx3YXlzIG9uIHNjcmVlblxuICAgICAgICBzb3VyY2VFdmVudFR5cGUubWF0Y2goL3BvaW50ZXJkb3duLykgfHwgLy8gcG9pbnRlcmV2ZW50cyB0b3VjaFxuICAgICAgICAoc291cmNlRXZlbnRUeXBlLm1hdGNoKC9tb3VzZS8pICYmIGV2LndoaWNoID09PSAxKSAgIC8vIG1vdXNlIGlzIHByZXNzZWRcbiAgICAgICAgKSB7XG4gICAgICAgIGVuYWJsZV9kZXRlY3QgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBtb3VzZSBpc24ndCBwcmVzc2VkXG4gICAgICBlbHNlIGlmKHNvdXJjZUV2ZW50VHlwZS5tYXRjaCgvbW91c2UvKSAmJiAhZXYud2hpY2gpIHtcbiAgICAgICAgZW5hYmxlX2RldGVjdCA9IGZhbHNlO1xuICAgICAgfVxuXG5cbiAgICAgIC8vIHdlIGFyZSBpbiBhIHRvdWNoIGV2ZW50LCBzZXQgdGhlIHRvdWNoIHRyaWdnZXJlZCBib29sIHRvIHRydWUsXG4gICAgICAvLyB0aGlzIGZvciB0aGUgY29uZmxpY3RzIHRoYXQgbWF5IG9jY3VyIG9uIGlvcyBhbmQgYW5kcm9pZFxuICAgICAgaWYoc291cmNlRXZlbnRUeXBlLm1hdGNoKC90b3VjaHxwb2ludGVyLykpIHtcbiAgICAgICAgdG91Y2hfdHJpZ2dlcmVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gY291bnQgdGhlIHRvdGFsIHRvdWNoZXMgb24gdGhlIHNjcmVlblxuICAgICAgdmFyIGNvdW50X3RvdWNoZXMgPSAwO1xuXG4gICAgICAvLyB3aGVuIHRvdWNoIGhhcyBiZWVuIHRyaWdnZXJlZCBpbiB0aGlzIGRldGVjdGlvbiBzZXNzaW9uXG4gICAgICAvLyBhbmQgd2UgYXJlIG5vdyBoYW5kbGluZyBhIG1vdXNlIGV2ZW50LCB3ZSBzdG9wIHRoYXQgdG8gcHJldmVudCBjb25mbGljdHNcbiAgICAgIGlmKGVuYWJsZV9kZXRlY3QpIHtcbiAgICAgICAgLy8gdXBkYXRlIHBvaW50ZXJldmVudFxuICAgICAgICBpZihIYW1tZXIuSEFTX1BPSU5URVJFVkVOVFMgJiYgZXZlbnRUeXBlICE9IEhhbW1lci5FVkVOVF9FTkQpIHtcbiAgICAgICAgICBjb3VudF90b3VjaGVzID0gSGFtbWVyLlBvaW50ZXJFdmVudC51cGRhdGVQb2ludGVyKGV2ZW50VHlwZSwgZXYpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRvdWNoXG4gICAgICAgIGVsc2UgaWYoc291cmNlRXZlbnRUeXBlLm1hdGNoKC90b3VjaC8pKSB7XG4gICAgICAgICAgY291bnRfdG91Y2hlcyA9IGV2LnRvdWNoZXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1vdXNlXG4gICAgICAgIGVsc2UgaWYoIXRvdWNoX3RyaWdnZXJlZCkge1xuICAgICAgICAgIGNvdW50X3RvdWNoZXMgPSBzb3VyY2VFdmVudFR5cGUubWF0Y2goL3VwLykgPyAwIDogMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHdlIGFyZSBpbiBhIGVuZCBldmVudCwgYnV0IHdoZW4gd2UgcmVtb3ZlIG9uZSB0b3VjaCBhbmRcbiAgICAgICAgLy8gd2Ugc3RpbGwgaGF2ZSBlbm91Z2gsIHNldCBldmVudFR5cGUgdG8gbW92ZVxuICAgICAgICBpZihjb3VudF90b3VjaGVzID4gMCAmJiBldmVudFR5cGUgPT0gSGFtbWVyLkVWRU5UX0VORCkge1xuICAgICAgICAgIGV2ZW50VHlwZSA9IEhhbW1lci5FVkVOVF9NT1ZFO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vIHRvdWNoZXMsIGZvcmNlIHRoZSBlbmQgZXZlbnRcbiAgICAgICAgZWxzZSBpZighY291bnRfdG91Y2hlcykge1xuICAgICAgICAgIGV2ZW50VHlwZSA9IEhhbW1lci5FVkVOVF9FTkQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzdG9yZSB0aGUgbGFzdCBtb3ZlIGV2ZW50XG4gICAgICAgIGlmKGNvdW50X3RvdWNoZXMgfHwgbGFzdF9tb3ZlX2V2ZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgbGFzdF9tb3ZlX2V2ZW50ID0gZXY7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cmlnZ2VyIHRoZSBoYW5kbGVyXG4gICAgICAgIGhhbmRsZXIuY2FsbChIYW1tZXIuZGV0ZWN0aW9uLCBzZWxmLmNvbGxlY3RFdmVudERhdGEoZWxlbWVudCwgZXZlbnRUeXBlLCBzZWxmLmdldFRvdWNoTGlzdChsYXN0X21vdmVfZXZlbnQsIGV2ZW50VHlwZSksIGV2KSk7XG5cbiAgICAgICAgLy8gcmVtb3ZlIHBvaW50ZXJldmVudCBmcm9tIGxpc3RcbiAgICAgICAgaWYoSGFtbWVyLkhBU19QT0lOVEVSRVZFTlRTICYmIGV2ZW50VHlwZSA9PSBIYW1tZXIuRVZFTlRfRU5EKSB7XG4gICAgICAgICAgY291bnRfdG91Y2hlcyA9IEhhbW1lci5Qb2ludGVyRXZlbnQudXBkYXRlUG9pbnRlcihldmVudFR5cGUsIGV2KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBvbiB0aGUgZW5kIHdlIHJlc2V0IGV2ZXJ5dGhpbmdcbiAgICAgIGlmKCFjb3VudF90b3VjaGVzKSB7XG4gICAgICAgIGxhc3RfbW92ZV9ldmVudCA9IG51bGw7XG4gICAgICAgIGVuYWJsZV9kZXRlY3QgPSBmYWxzZTtcbiAgICAgICAgdG91Y2hfdHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgICAgIEhhbW1lci5Qb2ludGVyRXZlbnQucmVzZXQoKTtcbiAgICAgIH1cbiAgICB9LHtwYXNzaXZlOnRydWV9KTtcbiAgICAvLyBGSVhNRSAtIFBBU1NJVkVcbiAgfSxcblxuXG4gIC8qKlxuICAgKiB3ZSBoYXZlIGRpZmZlcmVudCBldmVudHMgZm9yIGVhY2ggZGV2aWNlL2Jyb3dzZXJcbiAgICogZGV0ZXJtaW5lIHdoYXQgd2UgbmVlZCBhbmQgc2V0IHRoZW0gaW4gdGhlIEhhbW1lci5FVkVOVF9UWVBFUyBjb25zdGFudFxuICAgKi9cbiAgZGV0ZXJtaW5lRXZlbnRUeXBlczogZnVuY3Rpb24gZGV0ZXJtaW5lRXZlbnRUeXBlcygpIHtcbiAgICAvLyBkZXRlcm1pbmUgdGhlIGV2ZW50dHlwZSB3ZSB3YW50IHRvIHNldFxuICAgIHZhciB0eXBlcztcblxuICAgIC8vIHBvaW50ZXJFdmVudHMgbWFnaWNcbiAgICBpZihIYW1tZXIuSEFTX1BPSU5URVJFVkVOVFMpIHtcbiAgICAgIHR5cGVzID0gSGFtbWVyLlBvaW50ZXJFdmVudC5nZXRFdmVudHMoKTtcbiAgICB9XG4gICAgLy8gb24gQW5kcm9pZCwgaU9TLCBibGFja2JlcnJ5LCB3aW5kb3dzIG1vYmlsZSB3ZSBkb250IHdhbnQgYW55IG1vdXNlZXZlbnRzXG4gICAgZWxzZSBpZihIYW1tZXIuTk9fTU9VU0VFVkVOVFMpIHtcbiAgICAgIHR5cGVzID0gW1xuICAgICAgICAndG91Y2hzdGFydCcsXG4gICAgICAgICd0b3VjaG1vdmUnLFxuICAgICAgICAndG91Y2hlbmQgdG91Y2hjYW5jZWwnXTtcbiAgICB9XG4gICAgLy8gZm9yIG5vbiBwb2ludGVyIGV2ZW50cyBicm93c2VycyBhbmQgbWl4ZWQgYnJvd3NlcnMsXG4gICAgLy8gbGlrZSBjaHJvbWUgb24gd2luZG93czggdG91Y2ggbGFwdG9wXG4gICAgZWxzZSB7XG4gICAgICB0eXBlcyA9IFtcbiAgICAgICAgJ3RvdWNoc3RhcnQgbW91c2Vkb3duJyxcbiAgICAgICAgJ3RvdWNobW92ZSBtb3VzZW1vdmUnLFxuICAgICAgICAndG91Y2hlbmQgdG91Y2hjYW5jZWwgbW91c2V1cCddO1xuICAgIH1cblxuICAgIEhhbW1lci5FVkVOVF9UWVBFU1tIYW1tZXIuRVZFTlRfU1RBUlRdID0gdHlwZXNbMF07XG4gICAgSGFtbWVyLkVWRU5UX1RZUEVTW0hhbW1lci5FVkVOVF9NT1ZFXSA9IHR5cGVzWzFdO1xuICAgIEhhbW1lci5FVkVOVF9UWVBFU1tIYW1tZXIuRVZFTlRfRU5EXSA9IHR5cGVzWzJdO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIGNyZWF0ZSB0b3VjaGxpc3QgZGVwZW5kaW5nIG9uIHRoZSBldmVudFxuICAgKiBAcGFyYW0gICB7T2JqZWN0fSAgICBldlxuICAgKiBAcGFyYW0gICB7U3RyaW5nfSAgICBldmVudFR5cGUgICB1c2VkIGJ5IHRoZSBmYWtlbXVsdGl0b3VjaCBwbHVnaW5cbiAgICovXG4gIGdldFRvdWNoTGlzdDogZnVuY3Rpb24gZ2V0VG91Y2hMaXN0KGV2LyosIGV2ZW50VHlwZSovKSB7XG4gICAgLy8gZ2V0IHRoZSBmYWtlIHBvaW50ZXJFdmVudCB0b3VjaGxpc3RcbiAgICBpZihIYW1tZXIuSEFTX1BPSU5URVJFVkVOVFMpIHtcbiAgICAgIHJldHVybiBIYW1tZXIuUG9pbnRlckV2ZW50LmdldFRvdWNoTGlzdCgpO1xuICAgIH1cbiAgICAvLyBnZXQgdGhlIHRvdWNobGlzdFxuICAgIGVsc2UgaWYoZXYudG91Y2hlcykge1xuICAgICAgcmV0dXJuIGV2LnRvdWNoZXM7XG4gICAgfVxuICAgIC8vIG1ha2UgZmFrZSB0b3VjaGxpc3QgZnJvbSBtb3VzZSBwb3NpdGlvblxuICAgIGVsc2Uge1xuICAgICAgZXYuaWRlbnRpZmllciA9IDE7XG4gICAgICByZXR1cm4gW2V2XTtcbiAgICB9XG4gIH0sXG5cblxuICAvKipcbiAgICogY29sbGVjdCBldmVudCBkYXRhIGZvciBIYW1tZXIganNcbiAgICogQHBhcmFtICAge0hUTUxFbGVtZW50fSAgIGVsZW1lbnRcbiAgICogQHBhcmFtICAge1N0cmluZ30gICAgICAgIGV2ZW50VHlwZSAgICAgICAgbGlrZSBIYW1tZXIuRVZFTlRfTU9WRVxuICAgKiBAcGFyYW0gICB7T2JqZWN0fSAgICAgICAgZXZlbnREYXRhXG4gICAqL1xuICBjb2xsZWN0RXZlbnREYXRhOiBmdW5jdGlvbiBjb2xsZWN0RXZlbnREYXRhKGVsZW1lbnQsIGV2ZW50VHlwZSwgdG91Y2hlcywgZXYpIHtcbiAgICAvLyBmaW5kIG91dCBwb2ludGVyVHlwZVxuICAgIHZhciBwb2ludGVyVHlwZSA9IEhhbW1lci5QT0lOVEVSX1RPVUNIO1xuICAgIGlmKGV2LnR5cGUubWF0Y2goL21vdXNlLykgfHwgSGFtbWVyLlBvaW50ZXJFdmVudC5tYXRjaFR5cGUoSGFtbWVyLlBPSU5URVJfTU9VU0UsIGV2KSkge1xuICAgICAgcG9pbnRlclR5cGUgPSBIYW1tZXIuUE9JTlRFUl9NT1VTRTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY2VudGVyICAgICA6IEhhbW1lci51dGlscy5nZXRDZW50ZXIodG91Y2hlcyksXG4gICAgICB0aW1lU3RhbXAgIDogbmV3IERhdGUoKS5nZXRUaW1lKCksXG4gICAgICB0YXJnZXQgICAgIDogZXYudGFyZ2V0LFxuICAgICAgdG91Y2hlcyAgICA6IHRvdWNoZXMsXG4gICAgICBldmVudFR5cGUgIDogZXZlbnRUeXBlLFxuICAgICAgcG9pbnRlclR5cGU6IHBvaW50ZXJUeXBlLFxuICAgICAgc3JjRXZlbnQgICA6IGV2LFxuXG4gICAgICAvKipcbiAgICAgICAqIHByZXZlbnQgdGhlIGJyb3dzZXIgZGVmYXVsdCBhY3Rpb25zXG4gICAgICAgKiBtb3N0bHkgdXNlZCB0byBkaXNhYmxlIHNjcm9sbGluZyBvZiB0aGUgYnJvd3NlclxuICAgICAgICovXG4gICAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmKHRoaXMuc3JjRXZlbnQucHJldmVudE1hbmlwdWxhdGlvbikge1xuICAgICAgICAgIHRoaXMuc3JjRXZlbnQucHJldmVudE1hbmlwdWxhdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5zcmNFdmVudC5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgIHRoaXMuc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBzdG9wIGJ1YmJsaW5nIHRoZSBldmVudCB1cCB0byBpdHMgcGFyZW50c1xuICAgICAgICovXG4gICAgICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNyY0V2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBpbW1lZGlhdGVseSBzdG9wIGdlc3R1cmUgZGV0ZWN0aW9uXG4gICAgICAgKiBtaWdodCBiZSB1c2VmdWwgYWZ0ZXIgYSBzd2lwZSB3YXMgZGV0ZWN0ZWRcbiAgICAgICAqIEByZXR1cm4geyp9XG4gICAgICAgKi9cbiAgICAgIHN0b3BEZXRlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gSGFtbWVyLmRldGVjdGlvbi5zdG9wRGV0ZWN0KCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcblxuSGFtbWVyLlBvaW50ZXJFdmVudCA9IHtcbiAgLyoqXG4gICAqIGhvbGRzIGFsbCBwb2ludGVyc1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgcG9pbnRlcnM6IHt9LFxuXG4gIC8qKlxuICAgKiBnZXQgYSBsaXN0IG9mIHBvaW50ZXJzXG4gICAqIEByZXR1cm5zIHtBcnJheX0gICAgIHRvdWNobGlzdFxuICAgKi9cbiAgZ2V0VG91Y2hMaXN0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHRvdWNobGlzdCA9IFtdO1xuXG4gICAgLy8gd2UgY2FuIHVzZSBmb3JFYWNoIHNpbmNlIHBvaW50ZXJFdmVudHMgb25seSBpcyBpbiBJRTEwXG4gICAgSGFtbWVyLnV0aWxzLmVhY2goc2VsZi5wb2ludGVycywgZnVuY3Rpb24ocG9pbnRlcil7XG4gICAgICB0b3VjaGxpc3QucHVzaChwb2ludGVyKTtcbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gdG91Y2hsaXN0O1xuICB9LFxuXG4gIC8qKlxuICAgKiB1cGRhdGUgdGhlIHBvc2l0aW9uIG9mIGEgcG9pbnRlclxuICAgKiBAcGFyYW0gICB7U3RyaW5nfSAgIHR5cGUgICAgICAgICAgICAgSGFtbWVyLkVWRU5UX0VORFxuICAgKiBAcGFyYW0gICB7T2JqZWN0fSAgIHBvaW50ZXJFdmVudFxuICAgKi9cbiAgdXBkYXRlUG9pbnRlcjogZnVuY3Rpb24odHlwZSwgcG9pbnRlckV2ZW50KSB7XG4gICAgaWYodHlwZSA9PSBIYW1tZXIuRVZFTlRfRU5EKSB7XG4gICAgICB0aGlzLnBvaW50ZXJzID0ge307XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcG9pbnRlckV2ZW50LmlkZW50aWZpZXIgPSBwb2ludGVyRXZlbnQucG9pbnRlcklkO1xuICAgICAgdGhpcy5wb2ludGVyc1twb2ludGVyRXZlbnQucG9pbnRlcklkXSA9IHBvaW50ZXJFdmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5wb2ludGVycykubGVuZ3RoO1xuICB9LFxuXG4gIC8qKlxuICAgKiBjaGVjayBpZiBldiBtYXRjaGVzIHBvaW50ZXJ0eXBlXG4gICAqIEBwYXJhbSAgIHtTdHJpbmd9ICAgICAgICBwb2ludGVyVHlwZSAgICAgSGFtbWVyLlBPSU5URVJfTU9VU0VcbiAgICogQHBhcmFtICAge1BvaW50ZXJFdmVudH0gIGV2XG4gICAqL1xuICBtYXRjaFR5cGU6IGZ1bmN0aW9uKHBvaW50ZXJUeXBlLCBldikge1xuICAgIGlmKCFldi5wb2ludGVyVHlwZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBwdCA9IGV2LnBvaW50ZXJUeXBlLFxuICAgICAgdHlwZXMgPSB7fTtcbiAgICB0eXBlc1tIYW1tZXIuUE9JTlRFUl9NT1VTRV0gPSAocHQgPT09IGV2Lk1TUE9JTlRFUl9UWVBFX01PVVNFIHx8IHB0ID09PSBIYW1tZXIuUE9JTlRFUl9NT1VTRSk7XG4gICAgdHlwZXNbSGFtbWVyLlBPSU5URVJfVE9VQ0hdID0gKHB0ID09PSBldi5NU1BPSU5URVJfVFlQRV9UT1VDSCB8fCBwdCA9PT0gSGFtbWVyLlBPSU5URVJfVE9VQ0gpO1xuICAgIHR5cGVzW0hhbW1lci5QT0lOVEVSX1BFTl0gPSAocHQgPT09IGV2Lk1TUE9JTlRFUl9UWVBFX1BFTiB8fCBwdCA9PT0gSGFtbWVyLlBPSU5URVJfUEVOKTtcbiAgICByZXR1cm4gdHlwZXNbcG9pbnRlclR5cGVdO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIGdldCBldmVudHNcbiAgICovXG4gIGdldEV2ZW50czogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICdwb2ludGVyZG93biBNU1BvaW50ZXJEb3duJyxcbiAgICAgICdwb2ludGVybW92ZSBNU1BvaW50ZXJNb3ZlJyxcbiAgICAgICdwb2ludGVydXAgcG9pbnRlcmNhbmNlbCBNU1BvaW50ZXJVcCBNU1BvaW50ZXJDYW5jZWwnXG4gICAgXTtcbiAgfSxcblxuICAvKipcbiAgICogcmVzZXQgdGhlIGxpc3RcbiAgICovXG4gIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnBvaW50ZXJzID0ge307XG4gIH1cbn07XG5cblxuSGFtbWVyLmRldGVjdGlvbiA9IHtcbiAgLy8gY29udGFpbnMgYWxsIHJlZ2lzdHJlZCBIYW1tZXIuZ2VzdHVyZXMgaW4gdGhlIGNvcnJlY3Qgb3JkZXJcbiAgZ2VzdHVyZXM6IFtdLFxuXG4gIC8vIGRhdGEgb2YgdGhlIGN1cnJlbnQgSGFtbWVyLmdlc3R1cmUgZGV0ZWN0aW9uIHNlc3Npb25cbiAgY3VycmVudCA6IG51bGwsXG5cbiAgLy8gdGhlIHByZXZpb3VzIEhhbW1lci5nZXN0dXJlIHNlc3Npb24gZGF0YVxuICAvLyBpcyBhIGZ1bGwgY2xvbmUgb2YgdGhlIHByZXZpb3VzIGdlc3R1cmUuY3VycmVudCBvYmplY3RcbiAgcHJldmlvdXM6IG51bGwsXG5cbiAgLy8gd2hlbiB0aGlzIGJlY29tZXMgdHJ1ZSwgbm8gZ2VzdHVyZXMgYXJlIGZpcmVkXG4gIHN0b3BwZWQgOiBmYWxzZSxcblxuXG4gIC8qKlxuICAgKiBzdGFydCBIYW1tZXIuZ2VzdHVyZSBkZXRlY3Rpb25cbiAgICogQHBhcmFtICAge0hhbW1lci5JbnN0YW5jZX0gICBpbnN0XG4gICAqIEBwYXJhbSAgIHtPYmplY3R9ICAgICAgICAgICAgZXZlbnREYXRhXG4gICAqL1xuICBzdGFydERldGVjdDogZnVuY3Rpb24gc3RhcnREZXRlY3QoaW5zdCwgZXZlbnREYXRhKSB7XG4gICAgLy8gYWxyZWFkeSBidXN5IHdpdGggYSBIYW1tZXIuZ2VzdHVyZSBkZXRlY3Rpb24gb24gYW4gZWxlbWVudFxuICAgIGlmKHRoaXMuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc3RvcHBlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5jdXJyZW50ID0ge1xuICAgICAgaW5zdCAgICAgIDogaW5zdCwgLy8gcmVmZXJlbmNlIHRvIEhhbW1lckluc3RhbmNlIHdlJ3JlIHdvcmtpbmcgZm9yXG4gICAgICBzdGFydEV2ZW50OiBIYW1tZXIudXRpbHMuZXh0ZW5kKHt9LCBldmVudERhdGEpLCAvLyBzdGFydCBldmVudERhdGEgZm9yIGRpc3RhbmNlcywgdGltaW5nIGV0Y1xuICAgICAgbGFzdEV2ZW50IDogZmFsc2UsIC8vIGxhc3QgZXZlbnREYXRhXG4gICAgICBuYW1lICAgICAgOiAnJyAvLyBjdXJyZW50IGdlc3R1cmUgd2UncmUgaW4vZGV0ZWN0ZWQsIGNhbiBiZSAndGFwJywgJ2hvbGQnIGV0Y1xuICAgIH07XG5cbiAgICB0aGlzLmRldGVjdChldmVudERhdGEpO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIEhhbW1lci5nZXN0dXJlIGRldGVjdGlvblxuICAgKiBAcGFyYW0gICB7T2JqZWN0fSAgICBldmVudERhdGFcbiAgICovXG4gIGRldGVjdDogZnVuY3Rpb24gZGV0ZWN0KGV2ZW50RGF0YSkge1xuICAgIGlmKCF0aGlzLmN1cnJlbnQgfHwgdGhpcy5zdG9wcGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZXh0ZW5kIGV2ZW50IGRhdGEgd2l0aCBjYWxjdWxhdGlvbnMgYWJvdXQgc2NhbGUsIGRpc3RhbmNlIGV0Y1xuICAgIGV2ZW50RGF0YSA9IHRoaXMuZXh0ZW5kRXZlbnREYXRhKGV2ZW50RGF0YSk7XG5cbiAgICAvLyBpbnN0YW5jZSBvcHRpb25zXG4gICAgdmFyIGluc3Rfb3B0aW9ucyA9IHRoaXMuY3VycmVudC5pbnN0Lm9wdGlvbnM7XG5cbiAgICAvLyBjYWxsIEhhbW1lci5nZXN0dXJlIGhhbmRsZXJzXG4gICAgSGFtbWVyLnV0aWxzLmVhY2godGhpcy5nZXN0dXJlcywgZnVuY3Rpb24oZ2VzdHVyZSkge1xuICAgICAgLy8gb25seSB3aGVuIHRoZSBpbnN0YW5jZSBvcHRpb25zIGhhdmUgZW5hYmxlZCB0aGlzIGdlc3R1cmVcbiAgICAgIGlmKCF0aGlzLnN0b3BwZWQgJiYgaW5zdF9vcHRpb25zW2dlc3R1cmUubmFtZV0gIT09IGZhbHNlKSB7XG4gICAgICAgIC8vIGlmIGEgaGFuZGxlciByZXR1cm5zIGZhbHNlLCB3ZSBzdG9wIHdpdGggdGhlIGRldGVjdGlvblxuICAgICAgICBpZihnZXN0dXJlLmhhbmRsZXIuY2FsbChnZXN0dXJlLCBldmVudERhdGEsIHRoaXMuY3VycmVudC5pbnN0KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLnN0b3BEZXRlY3QoKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIC8vIHN0b3JlIGFzIHByZXZpb3VzIGV2ZW50IGV2ZW50XG4gICAgaWYodGhpcy5jdXJyZW50KSB7XG4gICAgICB0aGlzLmN1cnJlbnQubGFzdEV2ZW50ID0gZXZlbnREYXRhO1xuICAgIH1cblxuICAgIC8vIGVuZGV2ZW50LCBidXQgbm90IHRoZSBsYXN0IHRvdWNoLCBzbyBkb250IHN0b3BcbiAgICBpZihldmVudERhdGEuZXZlbnRUeXBlID09IEhhbW1lci5FVkVOVF9FTkQgJiYgIWV2ZW50RGF0YS50b3VjaGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHRoaXMuc3RvcERldGVjdCgpO1xuICAgIH1cblxuICAgIHJldHVybiBldmVudERhdGE7XG4gIH0sXG5cblxuICAvKipcbiAgICogY2xlYXIgdGhlIEhhbW1lci5nZXN0dXJlIHZhcnNcbiAgICogdGhpcyBpcyBjYWxsZWQgb24gZW5kRGV0ZWN0LCBidXQgY2FuIGFsc28gYmUgdXNlZCB3aGVuIGEgZmluYWwgSGFtbWVyLmdlc3R1cmUgaGFzIGJlZW4gZGV0ZWN0ZWRcbiAgICogdG8gc3RvcCBvdGhlciBIYW1tZXIuZ2VzdHVyZXMgZnJvbSBiZWluZyBmaXJlZFxuICAgKi9cbiAgc3RvcERldGVjdDogZnVuY3Rpb24gc3RvcERldGVjdCgpIHtcbiAgICAvLyBjbG9uZSBjdXJyZW50IGRhdGEgdG8gdGhlIHN0b3JlIGFzIHRoZSBwcmV2aW91cyBnZXN0dXJlXG4gICAgLy8gdXNlZCBmb3IgdGhlIGRvdWJsZSB0YXAgZ2VzdHVyZSwgc2luY2UgdGhpcyBpcyBhbiBvdGhlciBnZXN0dXJlIGRldGVjdCBzZXNzaW9uXG4gICAgdGhpcy5wcmV2aW91cyA9IEhhbW1lci51dGlscy5leHRlbmQoe30sIHRoaXMuY3VycmVudCk7XG5cbiAgICAvLyByZXNldCB0aGUgY3VycmVudFxuICAgIHRoaXMuY3VycmVudCA9IG51bGw7XG5cbiAgICAvLyBzdG9wcGVkIVxuICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XG4gIH0sXG5cblxuICAvKipcbiAgICogZXh0ZW5kIGV2ZW50RGF0YSBmb3IgSGFtbWVyLmdlc3R1cmVzXG4gICAqIEBwYXJhbSAgIHtPYmplY3R9ICAgZXZcbiAgICogQHJldHVybnMge09iamVjdH0gICBldlxuICAgKi9cbiAgZXh0ZW5kRXZlbnREYXRhOiBmdW5jdGlvbiBleHRlbmRFdmVudERhdGEoZXYpIHtcbiAgICB2YXIgc3RhcnRFdiA9IHRoaXMuY3VycmVudC5zdGFydEV2ZW50O1xuXG4gICAgLy8gaWYgdGhlIHRvdWNoZXMgY2hhbmdlLCBzZXQgdGhlIG5ldyB0b3VjaGVzIG92ZXIgdGhlIHN0YXJ0RXZlbnQgdG91Y2hlc1xuICAgIC8vIHRoaXMgYmVjYXVzZSB0b3VjaGV2ZW50cyBkb24ndCBoYXZlIGFsbCB0aGUgdG91Y2hlcyBvbiB0b3VjaHN0YXJ0LCBvciB0aGVcbiAgICAvLyB1c2VyIG11c3QgcGxhY2UgaGlzIGZpbmdlcnMgYXQgdGhlIEVYQUNUIHNhbWUgdGltZSBvbiB0aGUgc2NyZWVuLCB3aGljaCBpcyBub3QgcmVhbGlzdGljXG4gICAgLy8gYnV0LCBzb21ldGltZXMgaXQgaGFwcGVucyB0aGF0IGJvdGggZmluZ2VycyBhcmUgdG91Y2hpbmcgYXQgdGhlIEVYQUNUIHNhbWUgdGltZVxuICAgIGlmKHN0YXJ0RXYgJiYgKGV2LnRvdWNoZXMubGVuZ3RoICE9IHN0YXJ0RXYudG91Y2hlcy5sZW5ndGggfHwgZXYudG91Y2hlcyA9PT0gc3RhcnRFdi50b3VjaGVzKSkge1xuICAgICAgLy8gZXh0ZW5kIDEgbGV2ZWwgZGVlcCB0byBnZXQgdGhlIHRvdWNobGlzdCB3aXRoIHRoZSB0b3VjaCBvYmplY3RzXG4gICAgICBzdGFydEV2LnRvdWNoZXMgPSBbXTtcbiAgICAgIEhhbW1lci51dGlscy5lYWNoKGV2LnRvdWNoZXMsIGZ1bmN0aW9uKHRvdWNoKSB7XG4gICAgICAgIHN0YXJ0RXYudG91Y2hlcy5wdXNoKEhhbW1lci51dGlscy5leHRlbmQoe30sIHRvdWNoKSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgZGVsdGFfdGltZSA9IGV2LnRpbWVTdGFtcCAtIHN0YXJ0RXYudGltZVN0YW1wXG4gICAgICAsIGRlbHRhX3ggPSBldi5jZW50ZXIucGFnZVggLSBzdGFydEV2LmNlbnRlci5wYWdlWFxuICAgICAgLCBkZWx0YV95ID0gZXYuY2VudGVyLnBhZ2VZIC0gc3RhcnRFdi5jZW50ZXIucGFnZVlcbiAgICAgICwgdmVsb2NpdHkgPSBIYW1tZXIudXRpbHMuZ2V0VmVsb2NpdHkoZGVsdGFfdGltZSwgZGVsdGFfeCwgZGVsdGFfeSlcbiAgICAgICwgaW50ZXJpbUFuZ2xlXG4gICAgICAsIGludGVyaW1EaXJlY3Rpb247XG5cbiAgICAvLyBlbmQgZXZlbnRzIChlLmcuIGRyYWdlbmQpIGRvbid0IGhhdmUgdXNlZnVsIHZhbHVlcyBmb3IgaW50ZXJpbURpcmVjdGlvbiAmIGludGVyaW1BbmdsZVxuICAgIC8vIGJlY2F1c2UgdGhlIHByZXZpb3VzIGV2ZW50IGhhcyBleGFjdGx5IHRoZSBzYW1lIGNvb3JkaW5hdGVzXG4gICAgLy8gc28gZm9yIGVuZCBldmVudHMsIHRha2UgdGhlIHByZXZpb3VzIHZhbHVlcyBvZiBpbnRlcmltRGlyZWN0aW9uICYgaW50ZXJpbUFuZ2xlXG4gICAgLy8gaW5zdGVhZCBvZiByZWNhbGN1bGF0aW5nIHRoZW0gYW5kIGdldHRpbmcgYSBzcHVyaW91cyAnMCdcbiAgICBpZihldi5ldmVudFR5cGUgPT09ICdlbmQnKSB7XG4gICAgICBpbnRlcmltQW5nbGUgPSB0aGlzLmN1cnJlbnQubGFzdEV2ZW50ICYmIHRoaXMuY3VycmVudC5sYXN0RXZlbnQuaW50ZXJpbUFuZ2xlO1xuICAgICAgaW50ZXJpbURpcmVjdGlvbiA9IHRoaXMuY3VycmVudC5sYXN0RXZlbnQgJiYgdGhpcy5jdXJyZW50Lmxhc3RFdmVudC5pbnRlcmltRGlyZWN0aW9uO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGludGVyaW1BbmdsZSA9IHRoaXMuY3VycmVudC5sYXN0RXZlbnQgJiYgSGFtbWVyLnV0aWxzLmdldEFuZ2xlKHRoaXMuY3VycmVudC5sYXN0RXZlbnQuY2VudGVyLCBldi5jZW50ZXIpO1xuICAgICAgaW50ZXJpbURpcmVjdGlvbiA9IHRoaXMuY3VycmVudC5sYXN0RXZlbnQgJiYgSGFtbWVyLnV0aWxzLmdldERpcmVjdGlvbih0aGlzLmN1cnJlbnQubGFzdEV2ZW50LmNlbnRlciwgZXYuY2VudGVyKTtcbiAgICB9XG5cbiAgICBIYW1tZXIudXRpbHMuZXh0ZW5kKGV2LCB7XG4gICAgICBkZWx0YVRpbWU6IGRlbHRhX3RpbWUsXG5cbiAgICAgIGRlbHRhWDogZGVsdGFfeCxcbiAgICAgIGRlbHRhWTogZGVsdGFfeSxcblxuICAgICAgdmVsb2NpdHlYOiB2ZWxvY2l0eS54LFxuICAgICAgdmVsb2NpdHlZOiB2ZWxvY2l0eS55LFxuXG4gICAgICBkaXN0YW5jZTogSGFtbWVyLnV0aWxzLmdldERpc3RhbmNlKHN0YXJ0RXYuY2VudGVyLCBldi5jZW50ZXIpLFxuXG4gICAgICBhbmdsZTogSGFtbWVyLnV0aWxzLmdldEFuZ2xlKHN0YXJ0RXYuY2VudGVyLCBldi5jZW50ZXIpLFxuICAgICAgaW50ZXJpbUFuZ2xlOiBpbnRlcmltQW5nbGUsXG5cbiAgICAgIGRpcmVjdGlvbjogSGFtbWVyLnV0aWxzLmdldERpcmVjdGlvbihzdGFydEV2LmNlbnRlciwgZXYuY2VudGVyKSxcbiAgICAgIGludGVyaW1EaXJlY3Rpb246IGludGVyaW1EaXJlY3Rpb24sXG5cbiAgICAgIHNjYWxlOiBIYW1tZXIudXRpbHMuZ2V0U2NhbGUoc3RhcnRFdi50b3VjaGVzLCBldi50b3VjaGVzKSxcbiAgICAgIHJvdGF0aW9uOiBIYW1tZXIudXRpbHMuZ2V0Um90YXRpb24oc3RhcnRFdi50b3VjaGVzLCBldi50b3VjaGVzKSxcblxuICAgICAgc3RhcnRFdmVudDogc3RhcnRFdlxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGV2O1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIHJlZ2lzdGVyIG5ldyBnZXN0dXJlXG4gICAqIEBwYXJhbSAgIHtPYmplY3R9ICAgIGdlc3R1cmUgb2JqZWN0LCBzZWUgZ2VzdHVyZXMuanMgZm9yIGRvY3VtZW50YXRpb25cbiAgICogQHJldHVybnMge0FycmF5fSAgICAgZ2VzdHVyZXNcbiAgICovXG4gIHJlZ2lzdGVyOiBmdW5jdGlvbiByZWdpc3RlcihnZXN0dXJlKSB7XG4gICAgLy8gYWRkIGFuIGVuYWJsZSBnZXN0dXJlIG9wdGlvbnMgaWYgdGhlcmUgaXMgbm8gZ2l2ZW5cbiAgICB2YXIgb3B0aW9ucyA9IGdlc3R1cmUuZGVmYXVsdHMgfHwge307XG4gICAgaWYob3B0aW9uc1tnZXN0dXJlLm5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnNbZ2VzdHVyZS5uYW1lXSA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gZXh0ZW5kIEhhbW1lciBkZWZhdWx0IG9wdGlvbnMgd2l0aCB0aGUgSGFtbWVyLmdlc3R1cmUgb3B0aW9uc1xuICAgIEhhbW1lci51dGlscy5leHRlbmQoSGFtbWVyLmRlZmF1bHRzLCBvcHRpb25zLCB0cnVlKTtcblxuICAgIC8vIHNldCBpdHMgaW5kZXhcbiAgICBnZXN0dXJlLmluZGV4ID0gZ2VzdHVyZS5pbmRleCB8fCAxMDAwO1xuXG4gICAgLy8gYWRkIEhhbW1lci5nZXN0dXJlIHRvIHRoZSBsaXN0XG4gICAgdGhpcy5nZXN0dXJlcy5wdXNoKGdlc3R1cmUpO1xuXG4gICAgLy8gc29ydCB0aGUgbGlzdCBieSBpbmRleFxuICAgIHRoaXMuZ2VzdHVyZXMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICBpZihhLmluZGV4IDwgYi5pbmRleCkgeyByZXR1cm4gLTE7IH1cbiAgICAgIGlmKGEuaW5kZXggPiBiLmluZGV4KSB7IHJldHVybiAxOyB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLmdlc3R1cmVzO1xuICB9XG59O1xuXG5cbi8qKlxuICogRHJhZ1xuICogTW92ZSB3aXRoIHggZmluZ2VycyAoZGVmYXVsdCAxKSBhcm91bmQgb24gdGhlIHBhZ2UuIEJsb2NraW5nIHRoZSBzY3JvbGxpbmcgd2hlblxuICogbW92aW5nIGxlZnQgYW5kIHJpZ2h0IGlzIGEgZ29vZCBwcmFjdGljZS4gV2hlbiBhbGwgdGhlIGRyYWcgZXZlbnRzIGFyZSBibG9ja2luZ1xuICogeW91IGRpc2FibGUgc2Nyb2xsaW5nIG9uIHRoYXQgYXJlYS5cbiAqIEBldmVudHMgIGRyYWcsIGRyYXBsZWZ0LCBkcmFncmlnaHQsIGRyYWd1cCwgZHJhZ2Rvd25cbiAqL1xuSGFtbWVyLmdlc3R1cmVzLkRyYWcgPSB7XG4gIG5hbWUgICAgIDogJ2RyYWcnLFxuICBpbmRleCAgICA6IDUwLFxuICBkZWZhdWx0cyA6IHtcbiAgICBkcmFnX21pbl9kaXN0YW5jZSAgICAgICAgICAgIDogMTAsXG5cbiAgICAvLyBTZXQgY29ycmVjdF9mb3JfZHJhZ19taW5fZGlzdGFuY2UgdG8gdHJ1ZSB0byBtYWtlIHRoZSBzdGFydGluZyBwb2ludCBvZiB0aGUgZHJhZ1xuICAgIC8vIGJlIGNhbGN1bGF0ZWQgZnJvbSB3aGVyZSB0aGUgZHJhZyB3YXMgdHJpZ2dlcmVkLCBub3QgZnJvbSB3aGVyZSB0aGUgdG91Y2ggc3RhcnRlZC5cbiAgICAvLyBVc2VmdWwgdG8gYXZvaWQgYSBqZXJrLXN0YXJ0aW5nIGRyYWcsIHdoaWNoIGNhbiBtYWtlIGZpbmUtYWRqdXN0bWVudHNcbiAgICAvLyB0aHJvdWdoIGRyYWdnaW5nIGRpZmZpY3VsdCwgYW5kIGJlIHZpc3VhbGx5IHVuYXBwZWFsaW5nLlxuICAgIGNvcnJlY3RfZm9yX2RyYWdfbWluX2Rpc3RhbmNlOiB0cnVlLFxuXG4gICAgLy8gc2V0IDAgZm9yIHVubGltaXRlZCwgYnV0IHRoaXMgY2FuIGNvbmZsaWN0IHdpdGggdHJhbnNmb3JtXG4gICAgZHJhZ19tYXhfdG91Y2hlcyAgICAgICAgICAgICA6IDEsXG5cbiAgICAvLyBwcmV2ZW50IGRlZmF1bHQgYnJvd3NlciBiZWhhdmlvciB3aGVuIGRyYWdnaW5nIG9jY3Vyc1xuICAgIC8vIGJlIGNhcmVmdWwgd2l0aCBpdCwgaXQgbWFrZXMgdGhlIGVsZW1lbnQgYSBibG9ja2luZyBlbGVtZW50XG4gICAgLy8gd2hlbiB5b3UgYXJlIHVzaW5nIHRoZSBkcmFnIGdlc3R1cmUsIGl0IGlzIGEgZ29vZCBwcmFjdGljZSB0byBzZXQgdGhpcyB0cnVlXG4gICAgZHJhZ19ibG9ja19ob3Jpem9udGFsICAgICAgICA6IGZhbHNlLFxuICAgIGRyYWdfYmxvY2tfdmVydGljYWwgICAgICAgICAgOiBmYWxzZSxcblxuICAgIC8vIGRyYWdfbG9ja190b19heGlzIGtlZXBzIHRoZSBkcmFnIGdlc3R1cmUgb24gdGhlIGF4aXMgdGhhdCBpdCBzdGFydGVkIG9uLFxuICAgIC8vIEl0IGRpc2FsbG93cyB2ZXJ0aWNhbCBkaXJlY3Rpb25zIGlmIHRoZSBpbml0aWFsIGRpcmVjdGlvbiB3YXMgaG9yaXpvbnRhbCwgYW5kIHZpY2UgdmVyc2EuXG4gICAgZHJhZ19sb2NrX3RvX2F4aXMgICAgICAgICAgICA6IGZhbHNlLFxuXG4gICAgLy8gZHJhZyBsb2NrIG9ubHkga2lja3MgaW4gd2hlbiBkaXN0YW5jZSA+IGRyYWdfbG9ja19taW5fZGlzdGFuY2VcbiAgICAvLyBUaGlzIHdheSwgbG9ja2luZyBvY2N1cnMgb25seSB3aGVuIHRoZSBkaXN0YW5jZSBoYXMgYmVjb21lIGxhcmdlIGVub3VnaCB0byByZWxpYWJseSBkZXRlcm1pbmUgdGhlIGRpcmVjdGlvblxuICAgIGRyYWdfbG9ja19taW5fZGlzdGFuY2UgICAgICAgOiAyNVxuICB9LFxuXG4gIHRyaWdnZXJlZDogZmFsc2UsXG4gIGhhbmRsZXIgIDogZnVuY3Rpb24gZHJhZ0dlc3R1cmUoZXYsIGluc3QpIHtcbiAgICAvLyBjdXJyZW50IGdlc3R1cmUgaXNudCBkcmFnLCBidXQgZHJhZ2dlZCBpcyB0cnVlXG4gICAgLy8gdGhpcyBtZWFucyBhbiBvdGhlciBnZXN0dXJlIGlzIGJ1c3kuIG5vdyBjYWxsIGRyYWdlbmRcbiAgICBpZihIYW1tZXIuZGV0ZWN0aW9uLmN1cnJlbnQubmFtZSAhPSB0aGlzLm5hbWUgJiYgdGhpcy50cmlnZ2VyZWQpIHtcbiAgICAgIGluc3QudHJpZ2dlcih0aGlzLm5hbWUgKyAnZW5kJywgZXYpO1xuICAgICAgdGhpcy50cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBtYXggdG91Y2hlc1xuICAgIGlmKGluc3Qub3B0aW9ucy5kcmFnX21heF90b3VjaGVzID4gMCAmJlxuICAgICAgZXYudG91Y2hlcy5sZW5ndGggPiBpbnN0Lm9wdGlvbnMuZHJhZ19tYXhfdG91Y2hlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN3aXRjaChldi5ldmVudFR5cGUpIHtcbiAgICAgIGNhc2UgSGFtbWVyLkVWRU5UX1NUQVJUOlxuICAgICAgICB0aGlzLnRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBIYW1tZXIuRVZFTlRfTU9WRTpcbiAgICAgICAgLy8gd2hlbiB0aGUgZGlzdGFuY2Ugd2UgbW92ZWQgaXMgdG9vIHNtYWxsIHdlIHNraXAgdGhpcyBnZXN0dXJlXG4gICAgICAgIC8vIG9yIHdlIGNhbiBiZSBhbHJlYWR5IGluIGRyYWdnaW5nXG4gICAgICAgIGlmKGV2LmRpc3RhbmNlIDwgaW5zdC5vcHRpb25zLmRyYWdfbWluX2Rpc3RhbmNlICYmXG4gICAgICAgICAgSGFtbWVyLmRldGVjdGlvbi5jdXJyZW50Lm5hbWUgIT0gdGhpcy5uYW1lKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2UgYXJlIGRyYWdnaW5nIVxuICAgICAgICBpZihIYW1tZXIuZGV0ZWN0aW9uLmN1cnJlbnQubmFtZSAhPSB0aGlzLm5hbWUpIHtcbiAgICAgICAgICBIYW1tZXIuZGV0ZWN0aW9uLmN1cnJlbnQubmFtZSA9IHRoaXMubmFtZTtcbiAgICAgICAgICBpZihpbnN0Lm9wdGlvbnMuY29ycmVjdF9mb3JfZHJhZ19taW5fZGlzdGFuY2UgJiYgZXYuZGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAvLyBXaGVuIGEgZHJhZyBpcyB0cmlnZ2VyZWQsIHNldCB0aGUgZXZlbnQgY2VudGVyIHRvIGRyYWdfbWluX2Rpc3RhbmNlIHBpeGVscyBmcm9tIHRoZSBvcmlnaW5hbCBldmVudCBjZW50ZXIuXG4gICAgICAgICAgICAvLyBXaXRob3V0IHRoaXMgY29ycmVjdGlvbiwgdGhlIGRyYWdnZWQgZGlzdGFuY2Ugd291bGQganVtcHN0YXJ0IGF0IGRyYWdfbWluX2Rpc3RhbmNlIHBpeGVscyBpbnN0ZWFkIG9mIGF0IDAuXG4gICAgICAgICAgICAvLyBJdCBtaWdodCBiZSB1c2VmdWwgdG8gc2F2ZSB0aGUgb3JpZ2luYWwgc3RhcnQgcG9pbnQgc29tZXdoZXJlXG4gICAgICAgICAgICB2YXIgZmFjdG9yID0gTWF0aC5hYnMoaW5zdC5vcHRpb25zLmRyYWdfbWluX2Rpc3RhbmNlIC8gZXYuZGlzdGFuY2UpO1xuICAgICAgICAgICAgSGFtbWVyLmRldGVjdGlvbi5jdXJyZW50LnN0YXJ0RXZlbnQuY2VudGVyLnBhZ2VYICs9IGV2LmRlbHRhWCAqIGZhY3RvcjtcbiAgICAgICAgICAgIEhhbW1lci5kZXRlY3Rpb24uY3VycmVudC5zdGFydEV2ZW50LmNlbnRlci5wYWdlWSArPSBldi5kZWx0YVkgKiBmYWN0b3I7XG5cbiAgICAgICAgICAgIC8vIHJlY2FsY3VsYXRlIGV2ZW50IGRhdGEgdXNpbmcgbmV3IHN0YXJ0IHBvaW50XG4gICAgICAgICAgICBldiA9IEhhbW1lci5kZXRlY3Rpb24uZXh0ZW5kRXZlbnREYXRhKGV2KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsb2NrIGRyYWcgdG8gYXhpcz9cbiAgICAgICAgaWYoSGFtbWVyLmRldGVjdGlvbi5jdXJyZW50Lmxhc3RFdmVudC5kcmFnX2xvY2tlZF90b19heGlzIHx8IChpbnN0Lm9wdGlvbnMuZHJhZ19sb2NrX3RvX2F4aXMgJiYgaW5zdC5vcHRpb25zLmRyYWdfbG9ja19taW5fZGlzdGFuY2UgPD0gZXYuZGlzdGFuY2UpKSB7XG4gICAgICAgICAgZXYuZHJhZ19sb2NrZWRfdG9fYXhpcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxhc3RfZGlyZWN0aW9uID0gSGFtbWVyLmRldGVjdGlvbi5jdXJyZW50Lmxhc3RFdmVudC5kaXJlY3Rpb247XG4gICAgICAgIGlmKGV2LmRyYWdfbG9ja2VkX3RvX2F4aXMgJiYgbGFzdF9kaXJlY3Rpb24gIT09IGV2LmRpcmVjdGlvbikge1xuICAgICAgICAgIC8vIGtlZXAgZGlyZWN0aW9uIG9uIHRoZSBheGlzIHRoYXQgdGhlIGRyYWcgZ2VzdHVyZSBzdGFydGVkIG9uXG4gICAgICAgICAgaWYoSGFtbWVyLnV0aWxzLmlzVmVydGljYWwobGFzdF9kaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICBldi5kaXJlY3Rpb24gPSAoZXYuZGVsdGFZIDwgMCkgPyBIYW1tZXIuRElSRUNUSU9OX1VQIDogSGFtbWVyLkRJUkVDVElPTl9ET1dOO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV2LmRpcmVjdGlvbiA9IChldi5kZWx0YVggPCAwKSA/IEhhbW1lci5ESVJFQ1RJT05fTEVGVCA6IEhhbW1lci5ESVJFQ1RJT05fUklHSFQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlyc3QgdGltZSwgdHJpZ2dlciBkcmFnc3RhcnQgZXZlbnRcbiAgICAgICAgaWYoIXRoaXMudHJpZ2dlcmVkKSB7XG4gICAgICAgICAgaW5zdC50cmlnZ2VyKHRoaXMubmFtZSArICdzdGFydCcsIGV2KTtcbiAgICAgICAgICB0aGlzLnRyaWdnZXJlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cmlnZ2VyIG5vcm1hbCBldmVudFxuICAgICAgICBpbnN0LnRyaWdnZXIodGhpcy5uYW1lLCBldik7XG5cbiAgICAgICAgLy8gZGlyZWN0aW9uIGV2ZW50LCBsaWtlIGRyYWdkb3duXG4gICAgICAgIGluc3QudHJpZ2dlcih0aGlzLm5hbWUgKyBldi5kaXJlY3Rpb24sIGV2KTtcblxuICAgICAgICAvLyBibG9jayB0aGUgYnJvd3NlciBldmVudHNcbiAgICAgICAgaWYoKGluc3Qub3B0aW9ucy5kcmFnX2Jsb2NrX3ZlcnRpY2FsICYmIEhhbW1lci51dGlscy5pc1ZlcnRpY2FsKGV2LmRpcmVjdGlvbikpIHx8XG4gICAgICAgICAgKGluc3Qub3B0aW9ucy5kcmFnX2Jsb2NrX2hvcml6b250YWwgJiYgIUhhbW1lci51dGlscy5pc1ZlcnRpY2FsKGV2LmRpcmVjdGlvbikpKSB7XG4gICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBIYW1tZXIuRVZFTlRfRU5EOlxuICAgICAgICAvLyB0cmlnZ2VyIGRyYWdlbmRcbiAgICAgICAgaWYodGhpcy50cmlnZ2VyZWQpIHtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIodGhpcy5uYW1lICsgJ2VuZCcsIGV2KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBIb2xkXG4gKiBUb3VjaCBzdGF5cyBhdCB0aGUgc2FtZSBwbGFjZSBmb3IgeCB0aW1lXG4gKiBAZXZlbnRzICBob2xkXG4gKi9cbkhhbW1lci5nZXN0dXJlcy5Ib2xkID0ge1xuICBuYW1lICAgIDogJ2hvbGQnLFxuICBpbmRleCAgIDogMTAsXG4gIGRlZmF1bHRzOiB7XG4gICAgaG9sZF90aW1lb3V0ICA6IDUwMCxcbiAgICBob2xkX3RocmVzaG9sZDogMVxuICB9LFxuICB0aW1lciAgIDogbnVsbCxcbiAgaGFuZGxlciA6IGZ1bmN0aW9uIGhvbGRHZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgc3dpdGNoKGV2LmV2ZW50VHlwZSkge1xuICAgICAgY2FzZSBIYW1tZXIuRVZFTlRfU1RBUlQ6XG4gICAgICAgIC8vIGNsZWFyIGFueSBydW5uaW5nIHRpbWVyc1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG5cbiAgICAgICAgLy8gc2V0IHRoZSBnZXN0dXJlIHNvIHdlIGNhbiBjaGVjayBpbiB0aGUgdGltZW91dCBpZiBpdCBzdGlsbCBpc1xuICAgICAgICBIYW1tZXIuZGV0ZWN0aW9uLmN1cnJlbnQubmFtZSA9IHRoaXMubmFtZTtcblxuICAgICAgICAvLyBzZXQgdGltZXIgYW5kIGlmIGFmdGVyIHRoZSB0aW1lb3V0IGl0IHN0aWxsIGlzIGhvbGQsXG4gICAgICAgIC8vIHdlIHRyaWdnZXIgdGhlIGhvbGQgZXZlbnRcbiAgICAgICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYoSGFtbWVyLmRldGVjdGlvbi5jdXJyZW50Lm5hbWUgPT0gJ2hvbGQnKSB7XG4gICAgICAgICAgICBpbnN0LnRyaWdnZXIoJ2hvbGQnLCBldik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBpbnN0Lm9wdGlvbnMuaG9sZF90aW1lb3V0KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIC8vIHdoZW4geW91IG1vdmUgb3IgZW5kIHdlIGNsZWFyIHRoZSB0aW1lclxuICAgICAgY2FzZSBIYW1tZXIuRVZFTlRfTU9WRTpcbiAgICAgICAgaWYoZXYuZGlzdGFuY2UgPiBpbnN0Lm9wdGlvbnMuaG9sZF90aHJlc2hvbGQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgSGFtbWVyLkVWRU5UX0VORDpcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmVsZWFzZVxuICogQ2FsbGVkIGFzIGxhc3QsIHRlbGxzIHRoZSB1c2VyIGhhcyByZWxlYXNlZCB0aGUgc2NyZWVuXG4gKiBAZXZlbnRzICByZWxlYXNlXG4gKi9cbkhhbW1lci5nZXN0dXJlcy5SZWxlYXNlID0ge1xuICBuYW1lICAgOiAncmVsZWFzZScsXG4gIGluZGV4ICA6IEluZmluaXR5LFxuICBoYW5kbGVyOiBmdW5jdGlvbiByZWxlYXNlR2VzdHVyZShldiwgaW5zdCkge1xuICAgIGlmKGV2LmV2ZW50VHlwZSA9PSBIYW1tZXIuRVZFTlRfRU5EKSB7XG4gICAgICBpbnN0LnRyaWdnZXIodGhpcy5uYW1lLCBldik7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFN3aXBlXG4gKiB0cmlnZ2VycyBzd2lwZSBldmVudHMgd2hlbiB0aGUgZW5kIHZlbG9jaXR5IGlzIGFib3ZlIHRoZSB0aHJlc2hvbGRcbiAqIEBldmVudHMgIHN3aXBlLCBzd2lwZWxlZnQsIHN3aXBlcmlnaHQsIHN3aXBldXAsIHN3aXBlZG93blxuICovXG5IYW1tZXIuZ2VzdHVyZXMuU3dpcGUgPSB7XG4gIG5hbWUgICAgOiAnc3dpcGUnLFxuICBpbmRleCAgIDogNDAsXG4gIGRlZmF1bHRzOiB7XG4gICAgLy8gc2V0IDAgZm9yIHVubGltaXRlZCwgYnV0IHRoaXMgY2FuIGNvbmZsaWN0IHdpdGggdHJhbnNmb3JtXG4gICAgc3dpcGVfbWluX3RvdWNoZXM6IDEsXG4gICAgc3dpcGVfbWF4X3RvdWNoZXM6IDEsXG4gICAgc3dpcGVfdmVsb2NpdHkgICA6IDAuN1xuICB9LFxuICBoYW5kbGVyIDogZnVuY3Rpb24gc3dpcGVHZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgaWYoZXYuZXZlbnRUeXBlID09IEhhbW1lci5FVkVOVF9FTkQpIHtcbiAgICAgIC8vIG1heCB0b3VjaGVzXG4gICAgICBpZihpbnN0Lm9wdGlvbnMuc3dpcGVfbWF4X3RvdWNoZXMgPiAwICYmXG4gICAgICAgIGV2LnRvdWNoZXMubGVuZ3RoIDwgaW5zdC5vcHRpb25zLnN3aXBlX21pbl90b3VjaGVzICYmXG4gICAgICAgIGV2LnRvdWNoZXMubGVuZ3RoID4gaW5zdC5vcHRpb25zLnN3aXBlX21heF90b3VjaGVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gd2hlbiB0aGUgZGlzdGFuY2Ugd2UgbW92ZWQgaXMgdG9vIHNtYWxsIHdlIHNraXAgdGhpcyBnZXN0dXJlXG4gICAgICAvLyBvciB3ZSBjYW4gYmUgYWxyZWFkeSBpbiBkcmFnZ2luZ1xuICAgICAgaWYoZXYudmVsb2NpdHlYID4gaW5zdC5vcHRpb25zLnN3aXBlX3ZlbG9jaXR5IHx8XG4gICAgICAgIGV2LnZlbG9jaXR5WSA+IGluc3Qub3B0aW9ucy5zd2lwZV92ZWxvY2l0eSkge1xuICAgICAgICAvLyB0cmlnZ2VyIHN3aXBlIGV2ZW50c1xuICAgICAgICBpbnN0LnRyaWdnZXIodGhpcy5uYW1lLCBldik7XG4gICAgICAgIGluc3QudHJpZ2dlcih0aGlzLm5hbWUgKyBldi5kaXJlY3Rpb24sIGV2KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogVGFwL0RvdWJsZVRhcFxuICogUXVpY2sgdG91Y2ggYXQgYSBwbGFjZSBvciBkb3VibGUgYXQgdGhlIHNhbWUgcGxhY2VcbiAqIEBldmVudHMgIHRhcCwgZG91YmxldGFwXG4gKi9cbkhhbW1lci5nZXN0dXJlcy5UYXAgPSB7XG4gIG5hbWUgICAgOiAndGFwJyxcbiAgaW5kZXggICA6IDEwMCxcbiAgZGVmYXVsdHM6IHtcbiAgICB0YXBfbWF4X3RvdWNodGltZSA6IDI1MCxcbiAgICB0YXBfbWF4X2Rpc3RhbmNlICA6IDEwLFxuICAgIHRhcF9hbHdheXMgICAgICAgIDogdHJ1ZSxcbiAgICBkb3VibGV0YXBfZGlzdGFuY2U6IDIwLFxuICAgIGRvdWJsZXRhcF9pbnRlcnZhbDogMzAwXG4gIH0sXG4gIGhhbmRsZXIgOiBmdW5jdGlvbiB0YXBHZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgaWYoZXYuZXZlbnRUeXBlID09IEhhbW1lci5FVkVOVF9FTkQgJiYgZXYuc3JjRXZlbnQudHlwZSAhPSAndG91Y2hjYW5jZWwnKSB7XG4gICAgICAvLyBwcmV2aW91cyBnZXN0dXJlLCBmb3IgdGhlIGRvdWJsZSB0YXAgc2luY2UgdGhlc2UgYXJlIHR3byBkaWZmZXJlbnQgZ2VzdHVyZSBkZXRlY3Rpb25zXG4gICAgICB2YXIgcHJldiA9IEhhbW1lci5kZXRlY3Rpb24ucHJldmlvdXMsXG4gICAgICAgIGRpZF9kb3VibGV0YXAgPSBmYWxzZTtcblxuICAgICAgLy8gd2hlbiB0aGUgdG91Y2h0aW1lIGlzIGhpZ2hlciB0aGVuIHRoZSBtYXggdG91Y2ggdGltZVxuICAgICAgLy8gb3Igd2hlbiB0aGUgbW92aW5nIGRpc3RhbmNlIGlzIHRvbyBtdWNoXG4gICAgICBpZihldi5kZWx0YVRpbWUgPiBpbnN0Lm9wdGlvbnMudGFwX21heF90b3VjaHRpbWUgfHxcbiAgICAgICAgZXYuZGlzdGFuY2UgPiBpbnN0Lm9wdGlvbnMudGFwX21heF9kaXN0YW5jZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGlmIGRvdWJsZSB0YXBcbiAgICAgIGlmKHByZXYgJiYgcHJldi5uYW1lID09ICd0YXAnICYmXG4gICAgICAgIChldi50aW1lU3RhbXAgLSBwcmV2Lmxhc3RFdmVudC50aW1lU3RhbXApIDwgaW5zdC5vcHRpb25zLmRvdWJsZXRhcF9pbnRlcnZhbCAmJlxuICAgICAgICBldi5kaXN0YW5jZSA8IGluc3Qub3B0aW9ucy5kb3VibGV0YXBfZGlzdGFuY2UpIHtcbiAgICAgICAgaW5zdC50cmlnZ2VyKCdkb3VibGV0YXAnLCBldik7XG4gICAgICAgIGRpZF9kb3VibGV0YXAgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBkbyBhIHNpbmdsZSB0YXBcbiAgICAgIGlmKCFkaWRfZG91YmxldGFwIHx8IGluc3Qub3B0aW9ucy50YXBfYWx3YXlzKSB7XG4gICAgICAgIEhhbW1lci5kZXRlY3Rpb24uY3VycmVudC5uYW1lID0gJ3RhcCc7XG4gICAgICAgIGluc3QudHJpZ2dlcihIYW1tZXIuZGV0ZWN0aW9uLmN1cnJlbnQubmFtZSwgZXYpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBUb3VjaFxuICogQ2FsbGVkIGFzIGZpcnN0LCB0ZWxscyB0aGUgdXNlciBoYXMgdG91Y2hlZCB0aGUgc2NyZWVuXG4gKiBAZXZlbnRzICB0b3VjaFxuICovXG5IYW1tZXIuZ2VzdHVyZXMuVG91Y2ggPSB7XG4gIG5hbWUgICAgOiAndG91Y2gnLFxuICBpbmRleCAgIDogLUluZmluaXR5LFxuICBkZWZhdWx0czoge1xuICAgIC8vIGNhbGwgcHJldmVudERlZmF1bHQgYXQgdG91Y2hzdGFydCwgYW5kIG1ha2VzIHRoZSBlbGVtZW50IGJsb2NraW5nIGJ5XG4gICAgLy8gZGlzYWJsaW5nIHRoZSBzY3JvbGxpbmcgb2YgdGhlIHBhZ2UsIGJ1dCBpdCBpbXByb3ZlcyBnZXN0dXJlcyBsaWtlXG4gICAgLy8gdHJhbnNmb3JtaW5nIGFuZCBkcmFnZ2luZy5cbiAgICAvLyBiZSBjYXJlZnVsIHdpdGggdXNpbmcgdGhpcywgaXQgY2FuIGJlIHZlcnkgYW5ub3lpbmcgZm9yIHVzZXJzIHRvIGJlIHN0dWNrXG4gICAgLy8gb24gdGhlIHBhZ2VcbiAgICBwcmV2ZW50X2RlZmF1bHQgICAgOiBmYWxzZSxcblxuICAgIC8vIGRpc2FibGUgbW91c2UgZXZlbnRzLCBzbyBvbmx5IHRvdWNoIChvciBwZW4hKSBpbnB1dCB0cmlnZ2VycyBldmVudHNcbiAgICBwcmV2ZW50X21vdXNlZXZlbnRzOiBmYWxzZVxuICB9LFxuICBoYW5kbGVyIDogZnVuY3Rpb24gdG91Y2hHZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgaWYoaW5zdC5vcHRpb25zLnByZXZlbnRfbW91c2VldmVudHMgJiYgZXYucG9pbnRlclR5cGUgPT0gSGFtbWVyLlBPSU5URVJfTU9VU0UpIHtcbiAgICAgIGV2LnN0b3BEZXRlY3QoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZihpbnN0Lm9wdGlvbnMucHJldmVudF9kZWZhdWx0KSB7XG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIGlmKGV2LmV2ZW50VHlwZSA9PSBIYW1tZXIuRVZFTlRfU1RBUlQpIHtcbiAgICAgIGluc3QudHJpZ2dlcih0aGlzLm5hbWUsIGV2KTtcbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBUcmFuc2Zvcm1cbiAqIFVzZXIgd2FudCB0byBzY2FsZSBvciByb3RhdGUgd2l0aCAyIGZpbmdlcnNcbiAqIEBldmVudHMgIHRyYW5zZm9ybSwgcGluY2gsIHBpbmNoaW4sIHBpbmNob3V0LCByb3RhdGVcbiAqL1xuSGFtbWVyLmdlc3R1cmVzLlRyYW5zZm9ybSA9IHtcbiAgbmFtZSAgICAgOiAndHJhbnNmb3JtJyxcbiAgaW5kZXggICAgOiA0NSxcbiAgZGVmYXVsdHMgOiB7XG4gICAgLy8gZmFjdG9yLCBubyBzY2FsZSBpcyAxLCB6b29taW4gaXMgdG8gMCBhbmQgem9vbW91dCB1bnRpbCBoaWdoZXIgdGhlbiAxXG4gICAgdHJhbnNmb3JtX21pbl9zY2FsZSAgIDogMC4wMSxcbiAgICAvLyByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgdHJhbnNmb3JtX21pbl9yb3RhdGlvbjogMSxcbiAgICAvLyBwcmV2ZW50IGRlZmF1bHQgYnJvd3NlciBiZWhhdmlvciB3aGVuIHR3byB0b3VjaGVzIGFyZSBvbiB0aGUgc2NyZWVuXG4gICAgLy8gYnV0IGl0IG1ha2VzIHRoZSBlbGVtZW50IGEgYmxvY2tpbmcgZWxlbWVudFxuICAgIC8vIHdoZW4geW91IGFyZSB1c2luZyB0aGUgdHJhbnNmb3JtIGdlc3R1cmUsIGl0IGlzIGEgZ29vZCBwcmFjdGljZSB0byBzZXQgdGhpcyB0cnVlXG4gICAgdHJhbnNmb3JtX2Fsd2F5c19ibG9jazogZmFsc2VcbiAgfSxcbiAgdHJpZ2dlcmVkOiBmYWxzZSxcbiAgaGFuZGxlciAgOiBmdW5jdGlvbiB0cmFuc2Zvcm1HZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgLy8gY3VycmVudCBnZXN0dXJlIGlzbnQgZHJhZywgYnV0IGRyYWdnZWQgaXMgdHJ1ZVxuICAgIC8vIHRoaXMgbWVhbnMgYW4gb3RoZXIgZ2VzdHVyZSBpcyBidXN5LiBub3cgY2FsbCBkcmFnZW5kXG4gICAgaWYoSGFtbWVyLmRldGVjdGlvbi5jdXJyZW50Lm5hbWUgIT0gdGhpcy5uYW1lICYmIHRoaXMudHJpZ2dlcmVkKSB7XG4gICAgICBpbnN0LnRyaWdnZXIodGhpcy5uYW1lICsgJ2VuZCcsIGV2KTtcbiAgICAgIHRoaXMudHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYXRsZWFzdCBtdWx0aXRvdWNoXG4gICAgaWYoZXYudG91Y2hlcy5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gcHJldmVudCBkZWZhdWx0IHdoZW4gdHdvIGZpbmdlcnMgYXJlIG9uIHRoZSBzY3JlZW5cbiAgICBpZihpbnN0Lm9wdGlvbnMudHJhbnNmb3JtX2Fsd2F5c19ibG9jaykge1xuICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBzd2l0Y2goZXYuZXZlbnRUeXBlKSB7XG4gICAgICBjYXNlIEhhbW1lci5FVkVOVF9TVEFSVDpcbiAgICAgICAgdGhpcy50cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgSGFtbWVyLkVWRU5UX01PVkU6XG4gICAgICAgIHZhciBzY2FsZV90aHJlc2hvbGQgPSBNYXRoLmFicygxIC0gZXYuc2NhbGUpO1xuICAgICAgICB2YXIgcm90YXRpb25fdGhyZXNob2xkID0gTWF0aC5hYnMoZXYucm90YXRpb24pO1xuXG4gICAgICAgIC8vIHdoZW4gdGhlIGRpc3RhbmNlIHdlIG1vdmVkIGlzIHRvbyBzbWFsbCB3ZSBza2lwIHRoaXMgZ2VzdHVyZVxuICAgICAgICAvLyBvciB3ZSBjYW4gYmUgYWxyZWFkeSBpbiBkcmFnZ2luZ1xuICAgICAgICBpZihzY2FsZV90aHJlc2hvbGQgPCBpbnN0Lm9wdGlvbnMudHJhbnNmb3JtX21pbl9zY2FsZSAmJlxuICAgICAgICAgIHJvdGF0aW9uX3RocmVzaG9sZCA8IGluc3Qub3B0aW9ucy50cmFuc2Zvcm1fbWluX3JvdGF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2UgYXJlIHRyYW5zZm9ybWluZyFcbiAgICAgICAgSGFtbWVyLmRldGVjdGlvbi5jdXJyZW50Lm5hbWUgPSB0aGlzLm5hbWU7XG5cbiAgICAgICAgLy8gZmlyc3QgdGltZSwgdHJpZ2dlciBkcmFnc3RhcnQgZXZlbnRcbiAgICAgICAgaWYoIXRoaXMudHJpZ2dlcmVkKSB7XG4gICAgICAgICAgaW5zdC50cmlnZ2VyKHRoaXMubmFtZSArICdzdGFydCcsIGV2KTtcbiAgICAgICAgICB0aGlzLnRyaWdnZXJlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpbnN0LnRyaWdnZXIodGhpcy5uYW1lLCBldik7IC8vIGJhc2ljIHRyYW5zZm9ybSBldmVudFxuXG4gICAgICAgIC8vIHRyaWdnZXIgcm90YXRlIGV2ZW50XG4gICAgICAgIGlmKHJvdGF0aW9uX3RocmVzaG9sZCA+IGluc3Qub3B0aW9ucy50cmFuc2Zvcm1fbWluX3JvdGF0aW9uKSB7XG4gICAgICAgICAgaW5zdC50cmlnZ2VyKCdyb3RhdGUnLCBldik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cmlnZ2VyIHBpbmNoIGV2ZW50XG4gICAgICAgIGlmKHNjYWxlX3RocmVzaG9sZCA+IGluc3Qub3B0aW9ucy50cmFuc2Zvcm1fbWluX3NjYWxlKSB7XG4gICAgICAgICAgaW5zdC50cmlnZ2VyKCdwaW5jaCcsIGV2KTtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIoJ3BpbmNoJyArICgoZXYuc2NhbGUgPCAxKSA/ICdpbicgOiAnb3V0JyksIGV2KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBIYW1tZXIuRVZFTlRfRU5EOlxuICAgICAgICAvLyB0cmlnZ2VyIGRyYWdlbmRcbiAgICAgICAgaWYodGhpcy50cmlnZ2VyZWQpIHtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIodGhpcy5uYW1lICsgJ2VuZCcsIGV2KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufTtcblxuICAvLyBCYXNlZCBvZmYgTG8tRGFzaCdzIGV4Y2VsbGVudCBVTUQgd3JhcHBlciAoc2xpZ2h0bHkgbW9kaWZpZWQpIC0gaHR0cHM6Ly9naXRodWIuY29tL2Jlc3RpZWpzL2xvZGFzaC9ibG9iL21hc3Rlci9sb2Rhc2guanMjTDU1MTUtTDU1NDNcbiAgLy8gc29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zIGxpa2UgdGhlIGZvbGxvd2luZzpcbiAgaWYodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBkZWZpbmUgYXMgYW4gYW5vbnltb3VzIG1vZHVsZVxuICAgIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIEhhbW1lcjsgfSk7XG4gIH1cblxuICAvLyBjaGVjayBmb3IgYGV4cG9ydHNgIGFmdGVyIGBkZWZpbmVgIGluIGNhc2UgYSBidWlsZCBvcHRpbWl6ZXIgYWRkcyBhbiBgZXhwb3J0c2Agb2JqZWN0XG4gIGVsc2UgaWYodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEhhbW1lcjtcbiAgfVxuXG4gIGVsc2Uge1xuICAgIHdpbmRvdy5IYW1tZXIgPSBIYW1tZXI7XG4gIH1cblxuICByZXR1cm4gSGFtbWVyO1xufSkod2luZG93KTtcblxuZXhwb3J0IGRlZmF1bHQgSGFtbWVyOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTs7Ozs7QUFNQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFmQTtBQUxBO0FBQ0E7QUFzQkE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUtBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFFQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcE9BO0FBd09BOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBcEVBO0FBd0VBOzs7Ozs7O0FBTUE7QUFHQTs7Ozs7QUFJQTtBQUdBOzs7OztBQUlBO0FBR0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBTUE7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRkE7QUFNQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBTEE7QUFTQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7QUFJQTtBQUVBO0FBUEE7QUFTQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFyQ0E7QUF1Q0E7QUF4TkE7QUEyTkE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQTNFQTtBQStFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQXBCQTtBQXVCQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQWxNQTtBQXNNQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBeEJBO0FBMkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXRFQTtBQXdFQTtBQXRIQTtBQXlIQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTFCQTtBQTRCQTtBQXJDQTtBQXdDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBVUE7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBM0JBO0FBOEJBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFJQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXJDQTtBQXdDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBVEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBM0JBO0FBK0JBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE5Q0E7QUFnREE7QUFqRkE7QUFxRkE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUhBO0FBT0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../gator/js/hammer.js\n")},"../gator/js/index.js":
/*!****************************!*\
  !*** ../gator/js/index.js ***!
  \****************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib_ClustalRunner__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/ClustalRunner */ "../gator/js/lib/ClustalRunner.js");\n/* harmony import */ var _lib_UniprotReader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/UniprotReader */ "../gator/js/lib/UniprotReader.js");\n/* harmony import */ var _lib_UserdataReader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/UserdataReader */ "../gator/js/lib/UserdataReader.js");\n/* harmony import */ var _lib_GenomeReader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/GenomeReader */ "../gator/js/lib/GenomeReader.js");\n/* harmony import */ var _lib_GatorDataReader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/GatorDataReader */ "../gator/js/lib/GatorDataReader.js");\n/* harmony import */ var _lib_Service__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/Service */ "../gator/js/lib/Service.js");\n/* harmony import */ var _lib_MASCP__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/MASCP */ "../gator/js/lib/MASCP.js");\n/* harmony import */ var _lib_CondensedSequenceRenderer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/CondensedSequenceRenderer */ "../gator/js/lib/CondensedSequenceRenderer.js");\n/* harmony import */ var _lib_Dragger__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/Dragger */ "../gator/js/lib/Dragger.js");\n/* harmony import */ var _lib_GatorComponent__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/GatorComponent */ "../gator/js/lib/GatorComponent.js");\n/* harmony import */ var _lib_GeneComponent__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./lib/GeneComponent */ "../gator/js/lib/GeneComponent.js");\n/* harmony import */ var _lib_TrackRendererComponent__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./lib/TrackRendererComponent */ "../gator/js/lib/TrackRendererComponent.js");\n\n\n\n\n\n\n\n\n\n_lib_MASCP__WEBPACK_IMPORTED_MODULE_6__["default"].ClustalRunner = _lib_ClustalRunner__WEBPACK_IMPORTED_MODULE_0__["default"];\n_lib_MASCP__WEBPACK_IMPORTED_MODULE_6__["default"].UniprotReader = _lib_UniprotReader__WEBPACK_IMPORTED_MODULE_1__["default"];\n_lib_MASCP__WEBPACK_IMPORTED_MODULE_6__["default"].UserdataReader = _lib_UserdataReader__WEBPACK_IMPORTED_MODULE_2__["default"];\n_lib_MASCP__WEBPACK_IMPORTED_MODULE_6__["default"].GenomeReader = _lib_GenomeReader__WEBPACK_IMPORTED_MODULE_3__["default"];\n_lib_MASCP__WEBPACK_IMPORTED_MODULE_6__["default"].GatorDataReader = _lib_GatorDataReader__WEBPACK_IMPORTED_MODULE_4__["default"];\n\n\n\n_lib_MASCP__WEBPACK_IMPORTED_MODULE_6__["default"].GatorComponent = _lib_GatorComponent__WEBPACK_IMPORTED_MODULE_9__["default"];\n_lib_MASCP__WEBPACK_IMPORTED_MODULE_6__["default"].GeneComponent = _lib_GeneComponent__WEBPACK_IMPORTED_MODULE_10__["default"];\n_lib_MASCP__WEBPACK_IMPORTED_MODULE_6__["default"].TrackComponent = _lib_TrackRendererComponent__WEBPACK_IMPORTED_MODULE_11__["default"];\n/* harmony default export */ __webpack_exports__["default"] = (_lib_MASCP__WEBPACK_IMPORTED_MODULE_6__["default"]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vZ2F0b3IvanMvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vZ2F0b3IvanMvaW5kZXguanM/NjYyNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ2x1c3RhbFJ1bm5lciBmcm9tICcuL2xpYi9DbHVzdGFsUnVubmVyJztcbmltcG9ydCBVbmlwcm90UmVhZGVyIGZyb20gJy4vbGliL1VuaXByb3RSZWFkZXInO1xuaW1wb3J0IFVzZXJkYXRhUmVhZGVyIGZyb20gJy4vbGliL1VzZXJkYXRhUmVhZGVyJztcbmltcG9ydCBHZW5vbWVSZWFkZXIgZnJvbSAnLi9saWIvR2Vub21lUmVhZGVyJztcbmltcG9ydCBHYXRvckRhdGFSZWFkZXIgZnJvbSAnLi9saWIvR2F0b3JEYXRhUmVhZGVyJztcbmltcG9ydCBTZXJ2aWNlIGZyb20gJy4vbGliL1NlcnZpY2UnO1xuXG5cbmltcG9ydCBNQVNDUCBmcm9tICcuL2xpYi9NQVNDUCc7XG5pbXBvcnQgQ29uZGVuc2VkU2VxdWVuY2VSZW5kZXJlciBmcm9tICcuL2xpYi9Db25kZW5zZWRTZXF1ZW5jZVJlbmRlcmVyJztcblxuXG5pbXBvcnQgRHJhZ2dlciBmcm9tICcuL2xpYi9EcmFnZ2VyJztcblxuTUFTQ1AuQ2x1c3RhbFJ1bm5lciA9IENsdXN0YWxSdW5uZXI7XG5NQVNDUC5Vbmlwcm90UmVhZGVyID0gVW5pcHJvdFJlYWRlcjtcbk1BU0NQLlVzZXJkYXRhUmVhZGVyICA9IFVzZXJkYXRhUmVhZGVyIDtcbk1BU0NQLkdlbm9tZVJlYWRlciA9IEdlbm9tZVJlYWRlcjtcbk1BU0NQLkdhdG9yRGF0YVJlYWRlciA9IEdhdG9yRGF0YVJlYWRlcjtcblxuaW1wb3J0IEdhdG9yQ29tcG9uZW50IGZyb20gJy4vbGliL0dhdG9yQ29tcG9uZW50JztcblxuaW1wb3J0IEdlbmVDb21wb25lbnQgZnJvbSAnLi9saWIvR2VuZUNvbXBvbmVudCc7XG5cbmltcG9ydCBUcmFja0NvbXBvbmVudCBmcm9tICcuL2xpYi9UcmFja1JlbmRlcmVyQ29tcG9uZW50JztcblxuTUFTQ1AuR2F0b3JDb21wb25lbnQgPSBHYXRvckNvbXBvbmVudDtcbk1BU0NQLkdlbmVDb21wb25lbnQgPSBHZW5lQ29tcG9uZW50O1xuTUFTQ1AuVHJhY2tDb21wb25lbnQgPSBUcmFja0NvbXBvbmVudDtcblxuXG5leHBvcnQgZGVmYXVsdCBNQVNDUDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUdBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../gator/js/index.js\n')},"../gator/js/jsandbox.js":
/*!*******************************!*\
  !*** ../gator/js/jsandbox.js ***!
  \*******************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/*\n * JSandbox JavaScript Library v0.2.3\n *\n * With modifications to create a worker function inline so that\n * we can just include this single file\n *\n * 2009-01-25\n * By Elijah Grey, http://eligrey.com\n * Licensed under the X11/MIT License\n *   See LICENSE.md\n */\n\n/*global self */\n\n/*jslint undef: true, nomen: true, eqeqeq: true, bitwise: true, regexp: true,\nnewcap: true, immed: true, maxerr: 1000, strict: true */\n\n/*! @source http://purl.eligrey.com/github/jsandbox/blob/master/src/jsandbox.js*/\n\n\nvar JSandbox = function (self) {\n  var undef_type = "undefined",\n      doc = self.document,\n      Worker = self.Worker;\n\n  if (typeof Worker === undef_type) {\n    return;\n  }\n\n  var // repeatedly used properties/strings (for minification)\n  $eval = "eval",\n      $exec = "exec",\n      $load = "load",\n      $requests = "requests",\n      $input = "input",\n      $terminate = "terminate",\n      $data = "data",\n      $callback = "callback",\n      $onerror = "onerror",\n      $worker = "worker",\n      $onresponse = "onresponse",\n      $prototype = "prototype",\n      $call = "call",\n      str_type = "string",\n      fun_type = "function",\n      Sandbox = function Sandbox() {\n    var sandbox = this;\n\n    if (!(sandbox instanceof Sandbox)) {\n      return new Sandbox();\n    }\n\n    try {\n      sandbox[$worker] = new Worker(Sandbox.url);\n    } catch (exception) {\n      // Internet Explorer closes the BLOB before we can use it\n      if (exception.name === "SecurityError") {\n        sandbox[$worker] = new Worker(window.URL.createObjectURL(new Blob([\'(\' + default_worker_function.toString() + \'(self,eval))\'], {\n          \'type\': \'text/javascript\'\n        })));\n      }\n    }\n\n    sandbox[$requests] = {};\n\n    sandbox[$worker].onmessage = function (event) {\n      var data = event[$data],\n          request;\n\n      if (typeof data !== "object") {\n        return;\n      }\n\n      if (data.id == "log") {\n        console.log(data.message);\n        return;\n      }\n\n      request = sandbox[$requests][data.id];\n\n      if (request) {\n        if (data.error) {\n          if (typeof sandbox[$onerror] === fun_type) {\n            sandbox[$onerror](data, request);\n          }\n\n          if (typeof request[$onerror] === fun_type) {\n            request[$onerror][$call](sandbox, data.error);\n          }\n        } else {\n          if (typeof sandbox[$onresponse] === fun_type) {\n            sandbox[$onresponse](data, request);\n          }\n\n          if (typeof request[$callback] === fun_type) {\n            request[$callback][$call](sandbox, data.results);\n          }\n        }\n\n        delete sandbox[$requests][data.id];\n      }\n    };\n  },\n      proto = Sandbox[$prototype],\n      createRequestMethod = function createRequestMethod(method) {\n    proto[method] = function (options, callback, input, onerror) {\n      if (typeof options === str_type || Object[$prototype].toString[$call](options) === "[object Array]" || arguments.length > 1) {\n        // called in (data, callback, input, onerror) style\n        options = {\n          data: options,\n          input: input,\n          callback: callback,\n          onerror: onerror\n        };\n      }\n\n      if (method === $load && typeof options[$data] === str_type) {\n        options[$data] = [options[$data]];\n      }\n\n      var data = options[$data],\n          id = this.createRequestID();\n      input = options[$input];\n      delete options[$data];\n      delete options[$input];\n      this[$requests][id] = options;\n      this[$worker].postMessage({\n        id: id,\n        method: method,\n        data: data,\n        input: input\n      });\n      return id;\n    };\n\n    Sandbox[method] = function () {\n      var sandbox = new Sandbox();\n\n      sandbox[$onresponse] = sandbox[$onerror] = function () {\n        sandbox[$terminate]();\n        sandbox = null;\n      };\n\n      Sandbox[$prototype][method].apply(sandbox, Array[$prototype].slice[$call](arguments));\n      return Sandbox;\n    };\n  },\n      methods = [$eval, $load, $exec],\n      i = 3; // methods.length\n\n\n  while (i--) {\n    createRequestMethod(methods[i]);\n  }\n\n  proto[$terminate] = function () {\n    this[$requests] = {};\n    this[$worker].onmessage = null;\n    this[$worker][$terminate]();\n  };\n\n  proto.abort = function (id) {\n    delete this[$requests][id];\n  };\n\n  proto.createRequestID = function () {\n    var id = Math.random().toString();\n\n    if (id in this[$requests]) {\n      return this.createRequestID();\n    }\n\n    return id;\n  };\n\n  if (typeof doc !== undef_type) {\n    var linkElems = doc.getElementsByTagName("link");\n    i = linkElems.length;\n\n    while (i--) {\n      if (linkElems[i].getAttribute("rel") === "jsandbox") {\n        Sandbox.url = linkElems[i].getAttribute("href");\n        break;\n      }\n    }\n  }\n\n  var default_worker_function = function default_worker_function(self, globalEval) {\n    "use strict";\n\n    var postMessage = self.postMessage,\n        importScripts = self.importScripts,\n        messageEventType = "message",\n        messageHandler = function messageHandler(event) {\n      var request = event.data,\n          response = {};\n      response.id = request.id;\n      var data = request.data;\n      self.input = request.input || {};\n\n      try {\n        switch (request.method) {\n          case "eval":\n            // JSLint has something against indenting cases\n            response.results = globalEval(data);\n            break;\n\n          case "exec":\n            importScripts("data:application/javascript," + encodeURIComponent(data));\n            break;\n\n          case "load":\n            importScripts.apply(self, data);\n            break;\n        }\n      } catch (e) {\n        response.code = e.message;\n        response.error = e.stack;\n        response.line = e.lineNumber;\n        response.fileName = e.fileName;\n      }\n\n      delete self.input;\n\n      try {\n        delete self.onmessage; // in case the code defined it\n      } catch (e) {}\n\n      postMessage(response);\n    };\n\n    if (self.addEventListener) {\n      self.addEventListener(messageEventType, messageHandler, false);\n    } else if (self.attachEvent) {\n      // for future compatibility with IE\n      self.attachEvent("on" + messageEventType, messageHandler);\n    }\n\n    self.window = self; // provide a window object for scripts\n\n    self.console = {\n      log: function log(message) {\n        postMessage({\n          "id": "log",\n          "message": message\n        });\n      }\n    }; // dereference unsafe functions\n    // some might not be dereferenced: https://bugzilla.mozilla.org/show_bug.cgi?id=512464\n\n    self.Worker = self.addEventListener = self.removeEventListener = self.importScripts = self.XMLHttpRequest = self.postMessage = //self.dispatchEvent       =\n    // in case IE implements web workers\n    self.attachEvent = self.detachEvent = self.ActiveXObject = undefined;\n  };\n\n  if (!Sandbox.url) {\n    Sandbox.url = window.URL.createObjectURL(new Blob([\'(\' + default_worker_function.toString() + \'(self,eval))\'], {\n      \'type\': \'text/javascript\'\n    }));\n  }\n\n  return Sandbox;\n}(self),\n    Sandbox = JSandbox;\n\n/* harmony default export */ __webpack_exports__["default"] = (JSandbox);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vZ2F0b3IvanMvanNhbmRib3guanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vZ2F0b3IvanMvanNhbmRib3guanM/Y2JiMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogSlNhbmRib3ggSmF2YVNjcmlwdCBMaWJyYXJ5IHYwLjIuM1xuICpcbiAqIFdpdGggbW9kaWZpY2F0aW9ucyB0byBjcmVhdGUgYSB3b3JrZXIgZnVuY3Rpb24gaW5saW5lIHNvIHRoYXRcbiAqIHdlIGNhbiBqdXN0IGluY2x1ZGUgdGhpcyBzaW5nbGUgZmlsZVxuICpcbiAqIDIwMDktMDEtMjVcbiAqIEJ5IEVsaWphaCBHcmV5LCBodHRwOi8vZWxpZ3JleS5jb21cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBYMTEvTUlUIExpY2Vuc2VcbiAqICAgU2VlIExJQ0VOU0UubWRcbiAqL1xuXG4vKmdsb2JhbCBzZWxmICovXG5cbi8qanNsaW50IHVuZGVmOiB0cnVlLCBub21lbjogdHJ1ZSwgZXFlcWVxOiB0cnVlLCBiaXR3aXNlOiB0cnVlLCByZWdleHA6IHRydWUsXG5uZXdjYXA6IHRydWUsIGltbWVkOiB0cnVlLCBtYXhlcnI6IDEwMDAsIHN0cmljdDogdHJ1ZSAqL1xuXG4vKiEgQHNvdXJjZSBodHRwOi8vcHVybC5lbGlncmV5LmNvbS9naXRodWIvanNhbmRib3gvYmxvYi9tYXN0ZXIvc3JjL2pzYW5kYm94LmpzKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBKU2FuZGJveCA9IChmdW5jdGlvbiAoc2VsZikge1xuXHR2YXIgdW5kZWZfdHlwZSA9IFwidW5kZWZpbmVkXCIsXG5cdGRvYyAgICAgICAgICAgID0gc2VsZi5kb2N1bWVudCxcblx0V29ya2VyICAgICAgICAgPSBzZWxmLldvcmtlcjtcblx0XG5cdGlmICh0eXBlb2YgV29ya2VyID09PSB1bmRlZl90eXBlKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdFxuXHR2YXJcblx0Ly8gcmVwZWF0ZWRseSB1c2VkIHByb3BlcnRpZXMvc3RyaW5ncyAoZm9yIG1pbmlmaWNhdGlvbilcblx0JGV2YWwgICAgICAgPSBcImV2YWxcIixcblx0JGV4ZWMgICAgICAgPSBcImV4ZWNcIixcblx0JGxvYWQgICAgICAgPSBcImxvYWRcIixcblx0JHJlcXVlc3RzICAgPSBcInJlcXVlc3RzXCIsXG5cdCRpbnB1dCAgICAgID0gXCJpbnB1dFwiLFxuXHQkdGVybWluYXRlICA9IFwidGVybWluYXRlXCIsXG5cdCRkYXRhICAgICAgID0gXCJkYXRhXCIsXG5cdCRjYWxsYmFjayAgID0gXCJjYWxsYmFja1wiLFxuXHQkb25lcnJvciAgICA9IFwib25lcnJvclwiLFxuXHQkd29ya2VyICAgICA9IFwid29ya2VyXCIsXG5cdCRvbnJlc3BvbnNlID0gXCJvbnJlc3BvbnNlXCIsXG5cdCRwcm90b3R5cGUgID0gXCJwcm90b3R5cGVcIixcblx0JGNhbGwgICAgICAgPSBcImNhbGxcIixcblx0XG5cdHN0cl90eXBlICAgPSBcInN0cmluZ1wiLFxuXHRmdW5fdHlwZSAgID0gXCJmdW5jdGlvblwiLFxuXHRcblx0XG5cdFNhbmRib3ggPSBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHNhbmRib3ggPSB0aGlzO1xuXHRcdFxuXHRcdGlmICghKHNhbmRib3ggaW5zdGFuY2VvZiBTYW5kYm94KSkge1xuXHRcdFx0cmV0dXJuIG5ldyBTYW5kYm94KCk7XG5cdFx0fVxuXHRcdHRyeSB7XG5cdFx0XHRzYW5kYm94WyR3b3JrZXJdID0gbmV3IFdvcmtlcihTYW5kYm94LnVybCk7XG5cdFx0fSBjYXRjaChleGNlcHRpb24pIHtcblx0XHRcdC8vIEludGVybmV0IEV4cGxvcmVyIGNsb3NlcyB0aGUgQkxPQiBiZWZvcmUgd2UgY2FuIHVzZSBpdFxuXHRcdFx0aWYgKGV4Y2VwdGlvbi5uYW1lID09PSBcIlNlY3VyaXR5RXJyb3JcIikge1xuXHRcdFx0XHRzYW5kYm94WyR3b3JrZXJdID0gbmV3IFdvcmtlcih3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbJygnK2RlZmF1bHRfd29ya2VyX2Z1bmN0aW9uLnRvU3RyaW5nKCkrJyhzZWxmLGV2YWwpKSddLCB7J3R5cGUnIDogJ3RleHQvamF2YXNjcmlwdCd9KSkpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRzYW5kYm94WyRyZXF1ZXN0c10gPSB7fTtcblx0XHRcblx0XHRzYW5kYm94WyR3b3JrZXJdLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdFx0dmFyIGRhdGEgPSBldmVudFskZGF0YV0sIHJlcXVlc3Q7XG5cdFx0XHRpZiAodHlwZW9mIGRhdGEgIT09IFwib2JqZWN0XCIpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGRhdGEuaWQgPT0gXCJsb2dcIikge1xuXHRcdFx0XHRjb25zb2xlLmxvZyhkYXRhLm1lc3NhZ2UpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRyZXF1ZXN0ID0gc2FuZGJveFskcmVxdWVzdHNdW2RhdGEuaWRdO1xuXHRcdFx0aWYgKHJlcXVlc3QpIHtcblx0XHRcdFx0aWYgKGRhdGEuZXJyb3IpIHtcblx0XHRcdFx0XHRpZiAodHlwZW9mIHNhbmRib3hbJG9uZXJyb3JdID09PSBmdW5fdHlwZSkge1xuXHRcdFx0XHRcdFx0c2FuZGJveFskb25lcnJvcl0oZGF0YSwgcmVxdWVzdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0eXBlb2YgcmVxdWVzdFskb25lcnJvcl0gPT09IGZ1bl90eXBlKSB7XG5cdFx0XHRcdFx0XHRyZXF1ZXN0WyRvbmVycm9yXVskY2FsbF0oc2FuZGJveCwgZGF0YS5lcnJvcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICh0eXBlb2Ygc2FuZGJveFskb25yZXNwb25zZV0gPT09IGZ1bl90eXBlKSB7XG5cdFx0XHRcdFx0XHRzYW5kYm94WyRvbnJlc3BvbnNlXShkYXRhLCByZXF1ZXN0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRcdGlmICh0eXBlb2YgcmVxdWVzdFskY2FsbGJhY2tdID09PSBmdW5fdHlwZSkge1xuXHRcdFx0XHRcdFx0cmVxdWVzdFskY2FsbGJhY2tdWyRjYWxsXShzYW5kYm94LCBkYXRhLnJlc3VsdHMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRkZWxldGUgc2FuZGJveFskcmVxdWVzdHNdW2RhdGEuaWRdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0sXG5cdHByb3RvID0gU2FuZGJveFskcHJvdG90eXBlXSxcblx0XG5cdGNyZWF0ZVJlcXVlc3RNZXRob2QgPSBmdW5jdGlvbiAobWV0aG9kKSB7XG5cdFx0cHJvdG9bbWV0aG9kXSA9IGZ1bmN0aW9uIChvcHRpb25zLCBjYWxsYmFjaywgaW5wdXQsIG9uZXJyb3IpIHtcblx0XHRcdGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gc3RyX3R5cGUgfHxcblx0XHRcdCAgICBPYmplY3RbJHByb3RvdHlwZV0udG9TdHJpbmdbJGNhbGxdKG9wdGlvbnMpID09PSBcIltvYmplY3QgQXJyYXldXCIgfHxcblx0XHRcdCAgICBhcmd1bWVudHMubGVuZ3RoID4gMSlcblx0XHRcdHsgLy8gY2FsbGVkIGluIChkYXRhLCBjYWxsYmFjaywgaW5wdXQsIG9uZXJyb3IpIHN0eWxlXG5cdFx0XHRcdG9wdGlvbnMgPSB7XG5cdFx0XHRcdFx0ZGF0YSAgICAgOiBvcHRpb25zLFxuXHRcdFx0XHRcdGlucHV0ICAgIDogaW5wdXQsXG5cdFx0XHRcdFx0Y2FsbGJhY2sgOiBjYWxsYmFjayxcblx0XHRcdFx0XHRvbmVycm9yICA6IG9uZXJyb3Jcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKG1ldGhvZCA9PT0gJGxvYWQgJiYgdHlwZW9mIG9wdGlvbnNbJGRhdGFdID09PSBzdHJfdHlwZSkge1xuXHRcdFx0XHRvcHRpb25zWyRkYXRhXSA9IFtvcHRpb25zWyRkYXRhXV07XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHZhciBkYXRhICA9IG9wdGlvbnNbJGRhdGFdLFxuXHRcdFx0XHRpZCAgICA9IHRoaXMuY3JlYXRlUmVxdWVzdElEKCk7XG5cdFx0XHRcblx0XHRcdGlucHV0ID0gb3B0aW9uc1skaW5wdXRdO1xuXHRcdFx0XG5cdFx0XHRkZWxldGUgb3B0aW9uc1skZGF0YV07XG5cdFx0XHRkZWxldGUgb3B0aW9uc1skaW5wdXRdO1xuXHRcdFx0XG5cdFx0XHR0aGlzWyRyZXF1ZXN0c11baWRdID0gb3B0aW9ucztcblx0XHRcdFxuXHRcdFx0dGhpc1skd29ya2VyXS5wb3N0TWVzc2FnZSh7XG5cdFx0XHRcdGlkICAgICAgIDogaWQsXG5cdFx0XHRcdG1ldGhvZCAgIDogbWV0aG9kLFxuXHRcdFx0XHRkYXRhICAgICA6IGRhdGEsXG5cdFx0XHRcdGlucHV0ICAgIDogaW5wdXRcblx0XHRcdH0pO1xuXHRcdFxuXHRcdFx0cmV0dXJuIGlkO1xuXHRcdH07XG5cdFx0U2FuZGJveFttZXRob2RdID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHNhbmRib3ggPSBuZXcgU2FuZGJveCgpO1xuXHRcdFxuXHRcdFx0c2FuZGJveFskb25yZXNwb25zZV0gPSBzYW5kYm94WyRvbmVycm9yXSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0c2FuZGJveFskdGVybWluYXRlXSgpO1xuXHRcdFx0XHRzYW5kYm94ID0gbnVsbDtcblx0XHRcdH07XG5cdFx0XG5cdFx0XHRTYW5kYm94WyRwcm90b3R5cGVdW21ldGhvZF0uYXBwbHkoXG5cdFx0XHRcdHNhbmRib3gsXG5cdFx0XHRcdEFycmF5WyRwcm90b3R5cGVdLnNsaWNlWyRjYWxsXShhcmd1bWVudHMpXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIFNhbmRib3g7XG5cdFx0fTtcblx0fSxcblx0bWV0aG9kcyA9IFskZXZhbCwgJGxvYWQsICRleGVjXSxcblx0aSA9IDM7IC8vIG1ldGhvZHMubGVuZ3RoXG5cdFxuXHR3aGlsZSAoaS0tKSB7XG5cdFx0Y3JlYXRlUmVxdWVzdE1ldGhvZChtZXRob2RzW2ldKTtcblx0fVxuXHRcblx0cHJvdG9bJHRlcm1pbmF0ZV0gPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpc1skcmVxdWVzdHNdID0ge307XG5cdFx0dGhpc1skd29ya2VyXS5vbm1lc3NhZ2UgPSBudWxsO1xuXHRcdHRoaXNbJHdvcmtlcl1bJHRlcm1pbmF0ZV0oKTtcblx0fTtcblx0XG5cdHByb3RvLmFib3J0ID0gZnVuY3Rpb24gKGlkKSB7XG5cdFx0ZGVsZXRlIHRoaXNbJHJlcXVlc3RzXVtpZF07XG5cdH07XG5cdFxuXHRwcm90by5jcmVhdGVSZXF1ZXN0SUQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGlkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygpO1xuXHRcdGlmIChpZCBpbiB0aGlzWyRyZXF1ZXN0c10pIHtcblx0XHRcdHJldHVybiB0aGlzLmNyZWF0ZVJlcXVlc3RJRCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gaWQ7XG5cdH07XG5cdFxuXHRpZiAodHlwZW9mIGRvYyAhPT0gdW5kZWZfdHlwZSkge1xuXHRcdHZhciBsaW5rRWxlbXMgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJsaW5rXCIpO1xuXHRcdGkgPSBsaW5rRWxlbXMubGVuZ3RoO1xuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdGlmIChsaW5rRWxlbXNbaV0uZ2V0QXR0cmlidXRlKFwicmVsXCIpID09PSBcImpzYW5kYm94XCIpXG5cdFx0XHR7XG5cdFx0XHRcdFNhbmRib3gudXJsID0gbGlua0VsZW1zW2ldLmdldEF0dHJpYnV0ZShcImhyZWZcIik7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHZhciBkZWZhdWx0X3dvcmtlcl9mdW5jdGlvbiA9IGZ1bmN0aW9uIChzZWxmLCBnbG9iYWxFdmFsKSB7XG5cdFx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFx0XG5cdFx0dmFyXG5cdFx0cG9zdE1lc3NhZ2UgICA9IHNlbGYucG9zdE1lc3NhZ2UsXG5cdFx0aW1wb3J0U2NyaXB0cyA9IHNlbGYuaW1wb3J0U2NyaXB0cyxcblx0XHRcblx0XHRtZXNzYWdlRXZlbnRUeXBlICA9IFwibWVzc2FnZVwiLFxuXHRcdFxuXHRcdG1lc3NhZ2VIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0XHR2YXIgcmVxdWVzdCA9IGV2ZW50LmRhdGEsXG5cdFx0XHRyZXNwb25zZSA9IHtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJlc3BvbnNlLmlkID0gcmVxdWVzdC5pZDtcblx0XHRcdFxuXHRcdFx0dmFyIGRhdGEgPSByZXF1ZXN0LmRhdGE7XG5cdFx0XHRzZWxmLmlucHV0ID0gcmVxdWVzdC5pbnB1dCB8fCB7fTtcblx0XHRcdFxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0c3dpdGNoIChyZXF1ZXN0Lm1ldGhvZCkge1xuXHRcdFx0XHRcblx0XHRcdFx0Y2FzZSBcImV2YWxcIjogLy8gSlNMaW50IGhhcyBzb21ldGhpbmcgYWdhaW5zdCBpbmRlbnRpbmcgY2FzZXNcblx0XHRcdFx0XHRyZXNwb25zZS5yZXN1bHRzID0gZ2xvYmFsRXZhbChkYXRhKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImV4ZWNcIjpcblx0XHRcdFx0XHRpbXBvcnRTY3JpcHRzKFwiZGF0YTphcHBsaWNhdGlvbi9qYXZhc2NyaXB0LFwiICtcblx0XHRcdFx0XHQgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChkYXRhKSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJsb2FkXCI6XG5cdFx0XHRcdFx0aW1wb3J0U2NyaXB0cy5hcHBseShzZWxmLCBkYXRhKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0cmVzcG9uc2UuY29kZSA9IGUubWVzc2FnZTtcblx0XHRcdFx0cmVzcG9uc2UuZXJyb3IgPSBlLnN0YWNrO1xuXHRcdFx0XHRyZXNwb25zZS5saW5lID0gZS5saW5lTnVtYmVyO1xuXHRcdFx0XHRyZXNwb25zZS5maWxlTmFtZSA9IGUuZmlsZU5hbWU7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGRlbGV0ZSBzZWxmLmlucHV0O1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGVsZXRlIHNlbGYub25tZXNzYWdlOyAvLyBpbiBjYXNlIHRoZSBjb2RlIGRlZmluZWQgaXRcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cG9zdE1lc3NhZ2UocmVzcG9uc2UpO1xuXHRcdH07XG5cdFx0XG5cdFx0aWYgKHNlbGYuYWRkRXZlbnRMaXN0ZW5lcikge1xuXHRcdFx0c2VsZi5hZGRFdmVudExpc3RlbmVyKG1lc3NhZ2VFdmVudFR5cGUsIG1lc3NhZ2VIYW5kbGVyLCBmYWxzZSk7XG5cdFx0fSBlbHNlIGlmIChzZWxmLmF0dGFjaEV2ZW50KSB7IC8vIGZvciBmdXR1cmUgY29tcGF0aWJpbGl0eSB3aXRoIElFXG5cdFx0XHRzZWxmLmF0dGFjaEV2ZW50KFwib25cIiArIG1lc3NhZ2VFdmVudFR5cGUsIG1lc3NhZ2VIYW5kbGVyKTtcblx0XHR9XG5cdFx0XG5cdFx0c2VsZi53aW5kb3cgPSBzZWxmOyAvLyBwcm92aWRlIGEgd2luZG93IG9iamVjdCBmb3Igc2NyaXB0c1xuXHRcdHNlbGYuY29uc29sZSA9IHsgbG9nIDogZnVuY3Rpb24obWVzc2FnZSkgeyBwb3N0TWVzc2FnZSh7IFwiaWRcIiA6IFwibG9nXCIsIFwibWVzc2FnZVwiIDogbWVzc2FnZSAgfSk7IH0gfTtcblx0XHRcblx0XHQvLyBkZXJlZmVyZW5jZSB1bnNhZmUgZnVuY3Rpb25zXG5cdFx0Ly8gc29tZSBtaWdodCBub3QgYmUgZGVyZWZlcmVuY2VkOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD01MTI0NjRcblx0XHRzZWxmLldvcmtlciAgICAgICAgICAgICAgPVxuXHRcdHNlbGYuYWRkRXZlbnRMaXN0ZW5lciAgICA9IFxuXHRcdHNlbGYucmVtb3ZlRXZlbnRMaXN0ZW5lciA9XG5cdFx0c2VsZi5pbXBvcnRTY3JpcHRzICAgICAgID1cblx0XHRzZWxmLlhNTEh0dHBSZXF1ZXN0ICAgICAgPVxuXHRcdHNlbGYucG9zdE1lc3NhZ2UgICAgICAgICA9XG5cdFx0Ly9zZWxmLmRpc3BhdGNoRXZlbnQgICAgICAgPVxuXHRcdC8vIGluIGNhc2UgSUUgaW1wbGVtZW50cyB3ZWIgd29ya2Vyc1xuXHRcdHNlbGYuYXR0YWNoRXZlbnQgICAgICAgICA9XG5cdFx0c2VsZi5kZXRhY2hFdmVudCAgICAgICAgID1cblx0XHRzZWxmLkFjdGl2ZVhPYmplY3QgICAgICAgPVxuXHRcdFxuXHRcdHVuZGVmaW5lZDtcblx0XG5cdH07XG5cblxuXHRpZiAoICEgU2FuZGJveC51cmwgKSB7XG5cdFx0U2FuZGJveC51cmwgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbJygnK2RlZmF1bHRfd29ya2VyX2Z1bmN0aW9uLnRvU3RyaW5nKCkrJyhzZWxmLGV2YWwpKSddLCB7J3R5cGUnIDogJ3RleHQvamF2YXNjcmlwdCd9KSk7XG5cdH1cblx0cmV0dXJuIFNhbmRib3g7XG59KHNlbGYpKSxcblNhbmRib3ggPSBKU2FuZGJveDtcblxuZXhwb3J0IGRlZmF1bHQgSlNhbmRib3g7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTs7O0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFsRUE7QUFBQTtBQXNFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUF4SEE7QUFBQTtBQUNBO0FBQ0E7QUEwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFPQTtBQUFBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBWEE7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFPQTtBQUNBO0FBTUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUF6UEE7QUFDQTtBQTJQQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../gator/js/jsandbox.js\n')},"../gator/js/lib/ClustalRunner.js":
/*!****************************************!*\
  !*** ../gator/js/lib/ClustalRunner.js ***!
  \****************************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Service */ \"../gator/js/lib/Service.js\");\n/* harmony import */ var _bean__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../bean */ \"../gator/js/bean.js\");\n/** @fileOverview   Classes for reading data from the Clustal tool\n */\n\n\n/** Default class constructor\n *  @class      Service class that will retrieve data from Clustal for given sequences\n *  @param      {String} endpointURL    Endpoint URL for this service\n *  @extends    MASCP.Service\n */\n\nconst ClustalRunner = _Service__WEBPACK_IMPORTED_MODULE_0__[\"default\"].buildService(function (data) {\n  this._raw_data = data;\n\n  if (data && typeof data == 'string') {\n    this._raw_data = {\n      'data': {\n        'sequences': this.getSequences(),\n        'alignment': this.getAlignment()\n      }\n    };\n  }\n\n  return this;\n});\nClustalRunner.SERVICE_URL = 'http://www.ebi.ac.uk/Tools/services/rest/clustalw2/run/';\n\nClustalRunner.hash = function (str) {\n  var hash = 0;\n\n  for (i = 0; i < str.length; i++) {\n    char = str.charCodeAt(i);\n    hash = char + (hash << 6) + (hash << 16) - hash;\n  }\n\n  return hash;\n};\n\nClustalRunner.prototype.requestData = function () {\n  var sequences = [].concat(this.sequences || []);\n  var self = this;\n  this.agi = ClustalRunner.hash(this.sequences.join(',')) + '';\n\n  if (!ClustalRunner.SERVICE_URL.match(/ebi/)) {\n    return {\n      type: \"POST\",\n      dataType: \"json\",\n      api_key: MASCP.GATOR_CLIENT_ID,\n      data: {\n        'sequences': sequences.join(\",\")\n      }\n    };\n  }\n\n  _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire(self, 'running');\n\n  if (this.job_id) {\n    return {\n      type: \"GET\",\n      dataType: \"txt\",\n      url: 'http://www.ebi.ac.uk/Tools/services/rest/clustalw2/status/' + this.job_id\n    };\n  }\n\n  if (this.result_id) {\n    return {\n      type: \"GET\",\n      dataType: \"txt\",\n      url: 'http://www.ebi.ac.uk/Tools/services/rest/clustalw2/result/' + this.result_id + '/aln-clustalw'\n    };\n  }\n\n  for (var i = 0; i < sequences.length; i++) {\n    sequences[i] = \">seq\" + i + \"\\n\" + sequences[i];\n  }\n\n  return {\n    type: \"POST\",\n    dataType: \"txt\",\n    data: {\n      'sequence': escape(sequences.join(\"\\n\") + \"\\n\"),\n      'email': 'joshi%40sund.ku.dk'\n    }\n  };\n};\n\n(function (serv) {\n  var defaultDataReceived = serv.prototype._dataReceived;\n\n  serv.prototype._dataReceived = function (data, status) {\n    if (data === null) {\n      return defaultDataReceived.call(this, null, status);\n    }\n\n    if (typeof data == \"object\") {\n      if (data.status && data.status == \"RUNNING\") {\n        var self = this;\n        _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire(self, \"running\");\n        setTimeout(function () {\n          self.retrieve(self.agi);\n        }, 5000);\n        console.log(\"Got back running status\");\n        return;\n      }\n\n      return defaultDataReceived.call(this, data, status);\n    }\n\n    if (typeof data == \"string\" && data.match(/^clustalw/)) {\n      this.job_id = data;\n      this.retrieve(this.agi);\n      return;\n    }\n\n    if (data.match(/FINISHED/)) {\n      this.result_id = this.job_id;\n      this.job_id = null;\n      var self = this;\n      setTimeout(function () {\n        self.retrieve(self.agi);\n      }, 500);\n      return;\n    }\n\n    if (data.match(/RUNNING/)) {\n      var self = this;\n      setTimeout(function () {\n        self.retrieve(self.agi);\n      }, 500);\n      return;\n    }\n\n    return defaultDataReceived.call(this, data, status);\n  };\n})(ClustalRunner);\n\n(function () {\n  var normalise_insertions = function normalise_insertions(inserts) {\n    var pos;\n    var positions = [];\n    var result_data = {};\n\n    for (pos in inserts) {\n      if (inserts.hasOwnProperty(pos) && parseInt(pos) >= -1) {\n        positions.push(parseInt(pos));\n      }\n    }\n\n    positions = positions.sort(function sortfunction(a, b) {\n      return a - b;\n    }); // From highest to lowest position, loop through and\n    // subtract the lengths of previous subtratctions from\n    // the final position value.\n\n    for (var i = positions.length - 1; i >= 0; i--) {\n      var j = i - 1;\n      pos = parseInt(positions[i]);\n      var value = inserts[pos];\n\n      while (j >= 0) {\n        pos -= inserts[positions[j]].length;\n        j--;\n      }\n\n      if (!value.match(/^\\s+$/)) {\n        result_data[pos + 1] = value + (result_data[pos + 1] || '');\n      }\n    } //    delete result_data[0];\n\n\n    return result_data;\n  };\n\n  var splice_char = function splice_char(seqs, index, insertions) {\n    for (var i = 0; i < seqs.length; i++) {\n      var seq = seqs[i].toString();\n\n      if (seq.charAt(index) != '-') {\n        if (!insertions[i]) {\n          insertions[i] = {};\n          insertions[i][-1] = '';\n        }\n\n        insertions[i][index - 1] = seq.charAt(index);\n\n        if (insertions[i][index] && insertions[i][index].match(/\\w/)) {\n          insertions[i][index - 1] += insertions[i][index];\n          delete insertions[i][index];\n        }\n      } else {\n        if (insertions[i]) {\n          insertions[i][index - 1] = ' ';\n\n          if ((insertions[i][index] || '').match(/^\\s+$/)) {\n            insertions[i][index - 1] += insertions[i][index];\n            delete insertions[i][index];\n          }\n        }\n      }\n\n      seqs[i] = seq.slice(0, index) + seq.slice(index + 1);\n    }\n  };\n\n  ClustalRunner.Result.prototype.alignToSequence = function (seq_index) {\n    if (!this._orig_raw_data) {\n      this._orig_raw_data = JSON.stringify(this._raw_data);\n    } else {\n      this._raw_data = JSON.parse(this._orig_raw_data);\n    }\n\n    var seqs = this._raw_data.data.sequences.concat([this._raw_data.data.alignment]);\n\n    var insertions = [];\n    var aligning_seq = seqs[seq_index],\n        i = aligning_seq.length - 1;\n\n    for (i; i >= 0; i--) {\n      if (aligning_seq.charAt(i) == '-') {\n        splice_char(seqs, i, insertions);\n      }\n    }\n\n    for (i = 0; i < seqs.length; i++) {\n      if (insertions[i] && i != seq_index) {\n        insertions[i] = normalise_insertions(insertions[i]);\n        var seq = seqs[i];\n        seqs[i] = {\n          'sequence': seq,\n          'insertions': insertions[i]\n        };\n\n        seqs[i].toString = function () {\n          return this.sequence;\n        };\n      }\n    }\n\n    this._raw_data.data.alignment = seqs.pop();\n    this._raw_data.data.sequences = seqs;\n  };\n  /*\n  \n  Test suite for calculating positions\n  \n  var aligner = 0;\n  foo = new ClustalRunner.Result();\n  foo._raw_data = {\"data\" : { \"alignment\" : \"****************\" , \"sequences\" : [ \"----12345678----\", \"XXXXXXXXXXXXXXXX\", \"ABCDABC---ABCDAB\" ] }};\n  foo.alignToSequence(aligner);\n  console.log(foo.getSequences());\n  console.log(foo.calculatePositionForSequence(0,1));\n  console.log(foo.calculatePositionForSequence(0,2));\n  console.log(foo.calculatePositionForSequence(0,3));\n  console.log(foo.calculatePositionForSequence(0,4));\n  console.log(foo.calculatePositionForSequence(0,5));\n  console.log(foo.calculatePositionForSequence(0,6));\n  console.log(foo.calculatePositionForSequence(0,7));\n  console.log(foo.calculatePositionForSequence(0,8));\n  \n  */\n\n\n  ClustalRunner.Result.prototype.calculatePositionForSequence = function (idx, pos) {\n    var inserts = this._raw_data.data.sequences[idx].insertions || {};\n    var result = pos;\n    var actual_position = 0;\n\n    var seq = this._raw_data.data.sequences[idx].toString();\n\n    for (var i = 0; i < seq.length; i++) {\n      if (inserts[i]) {\n        actual_position += inserts[i].length;\n      }\n\n      actual_position += 1;\n\n      if (seq.charAt(i) == '-') {\n        actual_position -= 1;\n      }\n\n      if (pos <= actual_position) {\n        if (pos == actual_position) {\n          return i + 1;\n        } else {\n          if (i == 0) {\n            i = 1;\n          }\n\n          return -1 * i;\n        }\n      }\n    }\n\n    return -1 * seq.length;\n  };\n\n  ClustalRunner.Result.prototype.calculateSequencePositionFromPosition = function (idx, pos) {\n    var inserts = this._raw_data.data.sequences[idx].insertions || {};\n    var result = pos;\n    var actual_position = 0;\n\n    var seq = this._raw_data.data.sequences[idx].toString();\n\n    for (var i = 0; i < pos; i++) {\n      if (inserts[i]) {\n        actual_position += inserts[i].length;\n      }\n\n      actual_position += 1;\n\n      if (seq.charAt(i) == '-') {\n        actual_position -= 1;\n      }\n    }\n\n    if (actual_position == 0) {\n      actual_position += 1;\n    }\n\n    return actual_position;\n  };\n})(); //1265 (P)\n\n\nClustalRunner.prototype.setupSequenceRenderer = function (renderer) {\n  var self = this;\n  renderer.sequences = self.sequences;\n  renderer.addAxisScale('clustal', function (pos, layer, inverse) {\n    let idx = null;\n    let seq_identifiers = self.sequences.map(function (seq) {\n      return seq.agi;\n    });\n\n    while (seq_identifiers.length > 0) {\n      idx = idx || 0;\n      let acc = seq_identifiers.shift();\n\n      if (layer.scales.has(acc)) {\n        break;\n      }\n\n      idx++;\n\n      if (seq_identifiers.length === 0) {\n        idx = null;\n      }\n    }\n\n    if (layer.name === 'primarySequence') {\n      idx = self.result.aligned_idx;\n    }\n\n    if (idx === null) {\n      return pos;\n    }\n\n    if (inverse) {\n      return self.result.calculateSequencePositionFromPosition(idx, pos);\n    }\n\n    return self.result.calculatePositionForSequence(idx, pos);\n  });\n  var rendered_bits = [];\n  var controller_name = 'isoforms';\n  var group_name = 'isoforms';\n\n  var draw_discontinuity = function draw_discontinuity(canvas, size) {\n    var top = -3;\n    var left = -2;\n    var group = canvas.group();\n    var line;\n    line = canvas.line(left + 1, top + 4, left + 3, top + 1);\n    line.setAttribute('stroke', '#fcc');\n    line.setAttribute('stroke-width', '10');\n    group.push(line);\n    line = canvas.line(left + 1, top + 6, left + 3, top + 3);\n    line.setAttribute('stroke', '#fcc');\n    line.setAttribute('stroke-width', '10');\n    group.push(line);\n    line = canvas.line(left + 1, top + 4, left + 3, top + 3);\n    line.setAttribute('stroke', '#fcc');\n    line.setAttribute('stroke-width', '5');\n    group.push(line);\n    line = canvas.line(left + 1, top + 5.3, left + 1, top + 5.8);\n    line.setAttribute('stroke', '#fcc');\n    line.setAttribute('stroke-width', '10');\n    group.push(line);\n    line = canvas.line(left + 1, top + 5.9, left + 1.5, top + 5.9);\n    line.setAttribute('stroke', '#fcc');\n    line.setAttribute('stroke-width', '10');\n    group.push(line);\n    var circle = canvas.circle(left + 2.8, top + 1.75, 1);\n    circle.setAttribute('fill', '#fff');\n    circle.setAttribute('stroke', '#ccc');\n    circle.setAttribute('stroke-width', '10');\n    group.push(circle);\n    var minus = canvas.text(left + 2.25, top + 2.25, (size || '÷') + \"\");\n    minus.setAttribute('fill', '#ccc');\n    minus.setAttribute('font-size', 75);\n    group.push(minus);\n    canvas.firstChild.nextSibling.appendChild(group);\n    return group;\n  };\n\n  var check_values = function check_values(seq, idx, seqs) {\n    var positives = 0;\n    var aa = seq.toString().charAt(idx);\n\n    for (var i = 1; i < seqs.length; i++) {\n      if (seqs[i].toString().charAt(idx) == aa) {\n        positives += 1;\n      }\n    }\n\n    return positives / (seqs.length - 1);\n  };\n\n  var redraw_alignments = function redraw_alignments(sequence_index) {\n    var result = self.result;\n\n    while (rendered_bits.length > 0) {\n      var bit = rendered_bits.shift();\n      renderer.remove(bit.layer, bit);\n    }\n\n    result.alignToSequence(sequence_index || 0);\n    var aligned = result.getSequences();\n\n    if (!renderer.sequence) {\n      renderer.setSequence(aligned[sequence_index])(function () {\n        renderer.sequences = self.sequences;\n        MASCP.registerGroup(group_name, 'Aligned');\n        MASCP.registerLayer(controller_name, {\n          'fullname': 'Conservation',\n          'color': '#000000'\n        });\n\n        if (renderer.trackOrder.indexOf(controller_name) < 0) {\n          renderer.trackOrder = renderer.trackOrder.concat([controller_name]);\n        }\n\n        renderer.showLayer(controller_name);\n        renderer.createGroupController(controller_name, group_name);\n        redraw_alignments(sequence_index);\n      });\n      return;\n    } else {\n      renderer.sequence = aligned[sequence_index];\n      renderer.redrawAxis();\n    }\n\n    var alignments = result.getAlignment().split('');\n    rendered_bits = rendered_bits.concat(renderer.renderTextTrack(controller_name, result.getAlignment().replace(/ /g, ' ')));\n    rendered_bits.slice(-1)[0].setAttribute('data-spaces', 'true');\n    rendered_bits.slice(-1)[0].layer = controller_name;\n    var idxs = [\"*\", \":\", \".\", \" \"].reverse();\n\n    for (var i = 0; i < alignments.length; i++) {\n      rendered_bits.push(renderer.getAA(i + 1, controller_name).addBoxOverlay(controller_name, 1, idxs.indexOf(alignments[i]) / 4, {\n        \"merge\": true\n      }));\n      rendered_bits.slice(-1)[0].layer = controller_name;\n    }\n\n    for (var i = 0; i < aligned.length; i++) {\n      var layname = self.sequences[i].agi.toUpperCase() || \"missing\" + i;\n      var lay = MASCP.registerLayer(layname, {\n        'fullname': self.sequences[i].name || layname.toUpperCase(),\n        'group': group_name,\n        'color': '#ff0000',\n        'accession': self.sequences[i].agi\n      });\n      lay.scales.clear();\n      lay.scales.add(self.sequences[i].agi);\n      lay.fullname = self.sequences[i].name || layname.toUpperCase();\n      var text_array = renderer.renderTextTrack(layname, aligned[i].toString());\n      rendered_bits = rendered_bits.concat(text_array);\n      rendered_bits.slice(-1)[0].layer = layname;\n\n      if (renderer.trackOrder.indexOf(layname.toUpperCase()) < 0) {\n        renderer.trackOrder = renderer.trackOrder.concat([group_name]);\n      }\n\n      var name = \"Isoform \" + (i + 1);\n\n      if (aligned[i].insertions) {\n        for (var insert in aligned[i].insertions) {\n          var insertions = aligned[i].insertions;\n\n          if (insert == 0 && insertions[insert] == \"\") {\n            continue;\n          }\n\n          if (insertions[insert].length < 1) {\n            continue;\n          }\n\n          var size = insertions[insert].length;\n\n          if (insert == 0) {\n            insert = 1;\n          }\n\n          var content = draw_discontinuity(renderer._canvas, size);\n          content.setAttribute('fill', '#ffff00');\n          var an_anno = renderer.getAA(insert, controller_name).addToLayer(layname, {\n            'content': content,\n            //'+'+insertions[insert].length,\n            'bare_element': true,\n            'height': 10,\n            'offset': -5,\n            'no_tracer': true\n          })[1];\n          an_anno.container.setAttribute('height', '300');\n          an_anno.container.setAttribute('viewBox', '-50 -100 200 300');\n          rendered_bits.push(an_anno);\n          rendered_bits.slice(-1)[0].layer = layname;\n        }\n      }\n    }\n\n    renderer.zoom = 1;\n    renderer.showGroup(group_name);\n    renderer.refresh();\n  };\n\n  this.bind('resultReceived', function () {\n    var self = this;\n    redraw_alignments(0);\n    self.result.aligned_idx = 0;\n    var accs = [];\n    self.sequences.forEach(function (seq) {\n      accs.push(seq.agi.toUpperCase());\n    });\n    var current_order = [];\n    renderer.bind('orderChanged', function (order) {\n      if (self.result) {\n        var new_order = order.slice(order.indexOf(controller_name) + 1, order.length).filter(function (track) {\n          return accs.indexOf(track) >= 0;\n        });\n\n        if (new_order.join(',') == current_order.join(',')) {\n          return;\n        }\n\n        current_order = new_order;\n        self.result.aligned_idx = accs.indexOf(current_order[0]);\n        redraw_alignments(self.result.aligned_idx);\n        renderer.refreshScale();\n      }\n    });\n  });\n};\n\nClustalRunner.Result.prototype.getSequences = function () {\n  if (this._raw_data && this._raw_data.data && this._raw_data.data.sequences) {\n    return [].concat(this._raw_data.data.sequences);\n  }\n\n  var bits = this._raw_data.match(/seq\\d+(.*)/g);\n\n  var results = [];\n\n  for (var i = 0; i < bits.length; i++) {\n    var seqbits = bits[i].match(/seq(\\d+)\\s+(.*)/);\n\n    if (!results[seqbits[1]]) {\n      results[seqbits[1]] = '';\n    }\n\n    results[seqbits[1]] += seqbits[2];\n  }\n\n  return results;\n};\n\nClustalRunner.Result.prototype.getAlignment = function () {\n  if (this._raw_data && this._raw_data.data && this._raw_data.data.alignment) {\n    return this._raw_data.data.alignment.toString();\n  }\n\n  this._text_data = this._raw_data;\n  var re = / {16}(.*)/g;\n  var result = \"\";\n  var match = re.exec(this._raw_data);\n\n  while (match !== null) {\n    result += match[1];\n    match = re.exec(this._raw_data);\n  }\n\n  return result;\n};\n\nlet onlyUnique = (val, idx, arr) => arr.indexOf(val) === idx;\n\nlet clustal_emulator = sequences => {\n  if (sequences.length == 0) {\n    return {\n      data: {\n        sequences: [],\n        alignment: \"\"\n      }\n    };\n  }\n\n  let all_aas = sequences.map(seq => seq.split(''));\n  let alignment = all_aas[0].map((aa, pos) => all_aas.map(aas => aas[pos]).filter(onlyUnique).length == 1 ? '*' : ':').join('');\n  return {\n    data: {\n      sequences: sequences,\n      alignment: alignment\n    }\n  };\n};\n\nClustalRunner.EmulatedClustalRunner = function (renderer) {\n  let runner = new ClustalRunner();\n\n  runner.retrieve = function () {\n    let datablock = clustal_emulator(this.sequences || []);\n\n    this._dataReceived(datablock);\n\n    this.sequences = this.sequences.map((seq, idx) => {\n      return {\n        agi: 'seq' + idx,\n        toString: () => seq\n      };\n    });\n    this.gotResult();\n    this.requestComplete();\n  };\n\n  if (renderer) {\n    runner.registerSequenceRenderer(renderer);\n  }\n\n  return runner;\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (ClustalRunner);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vZ2F0b3IvanMvbGliL0NsdXN0YWxSdW5uZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vZ2F0b3IvanMvbGliL0NsdXN0YWxSdW5uZXIuanM/YmMyZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGZpbGVPdmVydmlldyAgIENsYXNzZXMgZm9yIHJlYWRpbmcgZGF0YSBmcm9tIHRoZSBDbHVzdGFsIHRvb2xcbiAqL1xuaW1wb3J0IFNlcnZpY2UgZnJvbSAnLi9TZXJ2aWNlJztcbmltcG9ydCBiZWFuIGZyb20gJy4uL2JlYW4nO1xuXG5cbi8qKiBEZWZhdWx0IGNsYXNzIGNvbnN0cnVjdG9yXG4gKiAgQGNsYXNzICAgICAgU2VydmljZSBjbGFzcyB0aGF0IHdpbGwgcmV0cmlldmUgZGF0YSBmcm9tIENsdXN0YWwgZm9yIGdpdmVuIHNlcXVlbmNlc1xuICogIEBwYXJhbSAgICAgIHtTdHJpbmd9IGVuZHBvaW50VVJMICAgIEVuZHBvaW50IFVSTCBmb3IgdGhpcyBzZXJ2aWNlXG4gKiAgQGV4dGVuZHMgICAgTUFTQ1AuU2VydmljZVxuICovXG5jb25zdCBDbHVzdGFsUnVubmVyID0gU2VydmljZS5idWlsZFNlcnZpY2UoZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmF3X2RhdGEgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEgJiYgdHlwZW9mIGRhdGEgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yYXdfZGF0YSA9IHsgJ2RhdGEnIDogeyAnc2VxdWVuY2VzJyA6IHRoaXMuZ2V0U2VxdWVuY2VzKCksICdhbGlnbm1lbnQnIDogdGhpcy5nZXRBbGlnbm1lbnQoKSB9IH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbkNsdXN0YWxSdW5uZXIuU0VSVklDRV9VUkwgPSAnaHR0cDovL3d3dy5lYmkuYWMudWsvVG9vbHMvc2VydmljZXMvcmVzdC9jbHVzdGFsdzIvcnVuLyc7XG5cbkNsdXN0YWxSdW5uZXIuaGFzaCA9IGZ1bmN0aW9uKHN0cil7XG4gICAgdmFyIGhhc2ggPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hhciA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBoYXNoID0gY2hhciArIChoYXNoIDw8IDYpICsgKGhhc2ggPDwgMTYpIC0gaGFzaDtcbiAgICB9XG4gICAgcmV0dXJuIGhhc2g7XG59O1xuXG5DbHVzdGFsUnVubmVyLnByb3RvdHlwZS5yZXF1ZXN0RGF0YSA9IGZ1bmN0aW9uKClcbntcbiAgICB2YXIgc2VxdWVuY2VzID0gW10uY29uY2F0KHRoaXMuc2VxdWVuY2VzIHx8IFtdKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5hZ2kgPSBDbHVzdGFsUnVubmVyLmhhc2godGhpcy5zZXF1ZW5jZXMuam9pbignLCcpKSsnJztcbiAgICBpZiAoISBDbHVzdGFsUnVubmVyLlNFUlZJQ0VfVVJMLm1hdGNoKC9lYmkvKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJQT1NUXCIsXG4gICAgICAgICAgICBkYXRhVHlwZTogXCJqc29uXCIsXG4gICAgICAgICAgICBhcGlfa2V5OiBNQVNDUC5HQVRPUl9DTElFTlRfSUQsXG4gICAgICAgICAgICBkYXRhIDoge1xuICAgICAgICAgICAgICAgICdzZXF1ZW5jZXMnIDogc2VxdWVuY2VzLmpvaW4oXCIsXCIpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGJlYW4uZmlyZShzZWxmLCdydW5uaW5nJyk7XG4gICAgaWYgKHRoaXMuam9iX2lkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIkdFVFwiLFxuICAgICAgICAgICAgZGF0YVR5cGU6IFwidHh0XCIsXG4gICAgICAgICAgICB1cmw6ICdodHRwOi8vd3d3LmViaS5hYy51ay9Ub29scy9zZXJ2aWNlcy9yZXN0L2NsdXN0YWx3Mi9zdGF0dXMvJyt0aGlzLmpvYl9pZFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5yZXN1bHRfaWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXG4gICAgICAgICAgICBkYXRhVHlwZTogXCJ0eHRcIixcbiAgICAgICAgICAgIHVybDogJ2h0dHA6Ly93d3cuZWJpLmFjLnVrL1Rvb2xzL3NlcnZpY2VzL3Jlc3QvY2x1c3RhbHcyL3Jlc3VsdC8nK3RoaXMucmVzdWx0X2lkKycvYWxuLWNsdXN0YWx3J1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VxdWVuY2VzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICBzZXF1ZW5jZXNbaV0gPSBcIj5zZXFcIitpK1wiXFxuXCIrc2VxdWVuY2VzW2ldO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIlBPU1RcIixcbiAgICAgICAgZGF0YVR5cGU6IFwidHh0XCIsXG4gICAgICAgIGRhdGE6IHsgJ3NlcXVlbmNlJyA6IGVzY2FwZShzZXF1ZW5jZXMuam9pbihcIlxcblwiKStcIlxcblwiKSxcbiAgICAgICAgICAgICAgICAnZW1haWwnICAgIDogJ2pvc2hpJTQwc3VuZC5rdS5kaydcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG4oZnVuY3Rpb24oc2Vydikge1xuICAgIHZhciBkZWZhdWx0RGF0YVJlY2VpdmVkID0gc2Vydi5wcm90b3R5cGUuX2RhdGFSZWNlaXZlZDtcblxuICAgIHNlcnYucHJvdG90eXBlLl9kYXRhUmVjZWl2ZWQgPSBmdW5jdGlvbihkYXRhLHN0YXR1cylcbiAgICB7XG4gICAgICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdERhdGFSZWNlaXZlZC5jYWxsKHRoaXMsbnVsbCxzdGF0dXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5zdGF0dXMgJiYgZGF0YS5zdGF0dXMgPT0gXCJSVU5OSU5HXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgYmVhbi5maXJlKHNlbGYsXCJydW5uaW5nXCIpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucmV0cmlldmUoc2VsZi5hZ2kpO1xuICAgICAgICAgICAgICAgIH0sNTAwMCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJHb3QgYmFjayBydW5uaW5nIHN0YXR1c1wiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdERhdGFSZWNlaXZlZC5jYWxsKHRoaXMsZGF0YSxzdGF0dXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09IFwic3RyaW5nXCIgJiYgZGF0YS5tYXRjaCgvXmNsdXN0YWx3LykpIHtcbiAgICAgICAgICAgIHRoaXMuam9iX2lkID0gZGF0YTtcbiAgICAgICAgICAgIHRoaXMucmV0cmlldmUodGhpcy5hZ2kpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLm1hdGNoKC9GSU5JU0hFRC8pKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdF9pZCA9IHRoaXMuam9iX2lkO1xuICAgICAgICAgICAgdGhpcy5qb2JfaWQgPSBudWxsO1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnJldHJpZXZlKHNlbGYuYWdpKTtcbiAgICAgICAgICAgIH0sNTAwKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5tYXRjaCgvUlVOTklORy8pKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYucmV0cmlldmUoc2VsZi5hZ2kpO1xuICAgICAgICAgICAgfSw1MDApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhUmVjZWl2ZWQuY2FsbCh0aGlzLGRhdGEsc3RhdHVzKTtcbiAgICB9O1xuXG59KShDbHVzdGFsUnVubmVyKTtcblxuKGZ1bmN0aW9uKCkge1xudmFyIG5vcm1hbGlzZV9pbnNlcnRpb25zID0gZnVuY3Rpb24oaW5zZXJ0cykge1xuICAgIHZhciBwb3M7XG4gICAgdmFyIHBvc2l0aW9ucyA9IFtdO1xuICAgIHZhciByZXN1bHRfZGF0YSA9IHt9O1xuICAgIGZvciAocG9zIGluIGluc2VydHMpIHtcbiAgICAgICAgaWYgKGluc2VydHMuaGFzT3duUHJvcGVydHkocG9zKSAmJiBwYXJzZUludChwb3MpID49IC0xKSB7XG4gICAgICAgICAgICBwb3NpdGlvbnMucHVzaChwYXJzZUludChwb3MpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwb3NpdGlvbnMgPSBwb3NpdGlvbnMuc29ydChmdW5jdGlvbiBzb3J0ZnVuY3Rpb24oYSwgYil7XG4gICAgICAgIHJldHVybiAoYSAtIGIpO1xuICAgIH0pO1xuXG4gICAgLy8gRnJvbSBoaWdoZXN0IHRvIGxvd2VzdCBwb3NpdGlvbiwgbG9vcCB0aHJvdWdoIGFuZFxuICAgIC8vIHN1YnRyYWN0IHRoZSBsZW5ndGhzIG9mIHByZXZpb3VzIHN1YnRyYXRjdGlvbnMgZnJvbVxuICAgIC8vIHRoZSBmaW5hbCBwb3NpdGlvbiB2YWx1ZS5cblxuICAgIGZvciAodmFyIGkgPSBwb3NpdGlvbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIGogPSBpIC0gMTtcbiAgICAgICAgcG9zID0gcGFyc2VJbnQocG9zaXRpb25zW2ldKTtcbiAgICAgICAgdmFyIHZhbHVlID0gaW5zZXJ0c1twb3NdO1xuICAgICAgICB3aGlsZSAoaiA+PSAwKSB7XG4gICAgICAgICAgICBwb3MgLT0gaW5zZXJ0c1twb3NpdGlvbnNbal1dLmxlbmd0aDtcbiAgICAgICAgICAgIGotLTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISB2YWx1ZS5tYXRjaCgvXlxccyskLykpIHtcbiAgICAgICAgICAgIHJlc3VsdF9kYXRhW3BvcysxXSA9IHZhbHVlICsgKHJlc3VsdF9kYXRhW3BvcysxXSB8fCAnJyk7XG4gICAgICAgIH1cbiAgICB9XG4vLyAgICBkZWxldGUgcmVzdWx0X2RhdGFbMF07XG4gICAgcmV0dXJuIHJlc3VsdF9kYXRhO1xufTtcblxudmFyIHNwbGljZV9jaGFyID0gZnVuY3Rpb24oc2VxcyxpbmRleCxpbnNlcnRpb25zKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzZXEgPSBzZXFzW2ldLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChzZXEuY2hhckF0KGluZGV4KSAhPSAnLScpIHtcbiAgICAgICAgICAgIGlmICggISBpbnNlcnRpb25zW2ldICkge1xuICAgICAgICAgICAgICAgIGluc2VydGlvbnNbaV0gPSB7fTtcbiAgICAgICAgICAgICAgICBpbnNlcnRpb25zW2ldWy0xXSA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5zZXJ0aW9uc1tpXVtpbmRleCAtIDFdID0gc2VxLmNoYXJBdChpbmRleCk7XG4gICAgICAgICAgICBpZiAoaW5zZXJ0aW9uc1tpXVtpbmRleF0gJiYgaW5zZXJ0aW9uc1tpXVtpbmRleF0ubWF0Y2goL1xcdy8pKSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0aW9uc1tpXVtpbmRleC0xXSArPSBpbnNlcnRpb25zW2ldW2luZGV4XTtcbiAgICAgICAgICAgICAgICBkZWxldGUgaW5zZXJ0aW9uc1tpXVtpbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIGluc2VydGlvbnNbaV0gKSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0aW9uc1tpXVtpbmRleCAtIDFdID0gJyAnO1xuICAgICAgICAgICAgICAgIGlmICgoaW5zZXJ0aW9uc1tpXVtpbmRleF0gfHwgJycpLm1hdGNoKC9eXFxzKyQvKSkge1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnRpb25zW2ldW2luZGV4LTFdICs9IGluc2VydGlvbnNbaV1baW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgaW5zZXJ0aW9uc1tpXVtpbmRleF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNlcXNbaV0gPSBzZXEuc2xpY2UoMCxpbmRleCkgKyBzZXEuc2xpY2UoaW5kZXgrMSk7XG4gICAgfVxufVxuXG5DbHVzdGFsUnVubmVyLlJlc3VsdC5wcm90b3R5cGUuYWxpZ25Ub1NlcXVlbmNlID0gZnVuY3Rpb24oc2VxX2luZGV4KSB7XG4gICAgaWYgKCAhIHRoaXMuX29yaWdfcmF3X2RhdGEgKSB7XG4gICAgICAgIHRoaXMuX29yaWdfcmF3X2RhdGEgPSBKU09OLnN0cmluZ2lmeSh0aGlzLl9yYXdfZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmF3X2RhdGEgPSBKU09OLnBhcnNlKHRoaXMuX29yaWdfcmF3X2RhdGEpO1xuICAgIH1cbiAgICB2YXIgc2VxcyA9IHRoaXMuX3Jhd19kYXRhLmRhdGEuc2VxdWVuY2VzLmNvbmNhdChbdGhpcy5fcmF3X2RhdGEuZGF0YS5hbGlnbm1lbnRdKTtcbiAgICB2YXIgaW5zZXJ0aW9ucyA9IFtdO1xuICAgIHZhciBhbGlnbmluZ19zZXEgPSBzZXFzW3NlcV9pbmRleF0sIGkgPSBhbGlnbmluZ19zZXEubGVuZ3RoIC0gMTtcbiAgICBmb3IgKGk7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmIChhbGlnbmluZ19zZXEuY2hhckF0KGkpID09ICctJykge1xuICAgICAgICAgICAgc3BsaWNlX2NoYXIoc2VxcyxpLGluc2VydGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBzZXFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpbnNlcnRpb25zW2ldICYmIGkgIT0gc2VxX2luZGV4KSB7XG4gICAgICAgICAgICBpbnNlcnRpb25zW2ldID0gbm9ybWFsaXNlX2luc2VydGlvbnMoaW5zZXJ0aW9uc1tpXSk7XG4gICAgICAgICAgICB2YXIgc2VxID0gc2Vxc1tpXTtcbiAgICAgICAgICAgIHNlcXNbaV0gPSB7ICdzZXF1ZW5jZScgOiBzZXEsICdpbnNlcnRpb25zJyA6IGluc2VydGlvbnNbaV0gfTtcbiAgICAgICAgICAgIHNlcXNbaV0udG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXF1ZW5jZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fcmF3X2RhdGEuZGF0YS5hbGlnbm1lbnQgPSBzZXFzLnBvcCgpO1xuICAgIHRoaXMuX3Jhd19kYXRhLmRhdGEuc2VxdWVuY2VzID0gc2Vxcztcbn07XG5cbi8qXG5cblRlc3Qgc3VpdGUgZm9yIGNhbGN1bGF0aW5nIHBvc2l0aW9uc1xuXG52YXIgYWxpZ25lciA9IDA7XG5mb28gPSBuZXcgQ2x1c3RhbFJ1bm5lci5SZXN1bHQoKTtcbmZvby5fcmF3X2RhdGEgPSB7XCJkYXRhXCIgOiB7IFwiYWxpZ25tZW50XCIgOiBcIioqKioqKioqKioqKioqKipcIiAsIFwic2VxdWVuY2VzXCIgOiBbIFwiLS0tLTEyMzQ1Njc4LS0tLVwiLCBcIlhYWFhYWFhYWFhYWFhYWFhcIiwgXCJBQkNEQUJDLS0tQUJDREFCXCIgXSB9fTtcbmZvby5hbGlnblRvU2VxdWVuY2UoYWxpZ25lcik7XG5jb25zb2xlLmxvZyhmb28uZ2V0U2VxdWVuY2VzKCkpO1xuY29uc29sZS5sb2coZm9vLmNhbGN1bGF0ZVBvc2l0aW9uRm9yU2VxdWVuY2UoMCwxKSk7XG5jb25zb2xlLmxvZyhmb28uY2FsY3VsYXRlUG9zaXRpb25Gb3JTZXF1ZW5jZSgwLDIpKTtcbmNvbnNvbGUubG9nKGZvby5jYWxjdWxhdGVQb3NpdGlvbkZvclNlcXVlbmNlKDAsMykpO1xuY29uc29sZS5sb2coZm9vLmNhbGN1bGF0ZVBvc2l0aW9uRm9yU2VxdWVuY2UoMCw0KSk7XG5jb25zb2xlLmxvZyhmb28uY2FsY3VsYXRlUG9zaXRpb25Gb3JTZXF1ZW5jZSgwLDUpKTtcbmNvbnNvbGUubG9nKGZvby5jYWxjdWxhdGVQb3NpdGlvbkZvclNlcXVlbmNlKDAsNikpO1xuY29uc29sZS5sb2coZm9vLmNhbGN1bGF0ZVBvc2l0aW9uRm9yU2VxdWVuY2UoMCw3KSk7XG5jb25zb2xlLmxvZyhmb28uY2FsY3VsYXRlUG9zaXRpb25Gb3JTZXF1ZW5jZSgwLDgpKTtcblxuKi9cbkNsdXN0YWxSdW5uZXIuUmVzdWx0LnByb3RvdHlwZS5jYWxjdWxhdGVQb3NpdGlvbkZvclNlcXVlbmNlID0gZnVuY3Rpb24oaWR4LHBvcykge1xuICAgIHZhciBpbnNlcnRzID0gdGhpcy5fcmF3X2RhdGEuZGF0YS5zZXF1ZW5jZXNbaWR4XS5pbnNlcnRpb25zIHx8IHt9O1xuICAgIHZhciByZXN1bHQgPSBwb3M7XG4gICAgdmFyIGFjdHVhbF9wb3NpdGlvbiA9IDA7XG4gICAgdmFyIHNlcSA9IHRoaXMuX3Jhd19kYXRhLmRhdGEuc2VxdWVuY2VzW2lkeF0udG9TdHJpbmcoKTtcbiAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBzZXEubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgIGlmIChpbnNlcnRzW2ldKSB7XG4gICAgICAgICAgICBhY3R1YWxfcG9zaXRpb24gKz0gaW5zZXJ0c1tpXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgYWN0dWFsX3Bvc2l0aW9uICs9IDE7XG4gICAgICAgIGlmIChzZXEuY2hhckF0KGkpID09ICctJykge1xuICAgICAgICAgICAgYWN0dWFsX3Bvc2l0aW9uIC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyA8PSBhY3R1YWxfcG9zaXRpb24pIHtcbiAgICAgICAgICAgIGlmIChwb3MgPT0gYWN0dWFsX3Bvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChpKzEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGkgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gLTEgKiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMSAqIHNlcS5sZW5ndGg7XG59O1xuXG5DbHVzdGFsUnVubmVyLlJlc3VsdC5wcm90b3R5cGUuY2FsY3VsYXRlU2VxdWVuY2VQb3NpdGlvbkZyb21Qb3NpdGlvbiA9IGZ1bmN0aW9uKGlkeCxwb3MpIHtcbiAgICB2YXIgaW5zZXJ0cyA9IHRoaXMuX3Jhd19kYXRhLmRhdGEuc2VxdWVuY2VzW2lkeF0uaW5zZXJ0aW9ucyB8fCB7fTtcbiAgICB2YXIgcmVzdWx0ID0gcG9zO1xuICAgIHZhciBhY3R1YWxfcG9zaXRpb24gPSAwO1xuICAgIHZhciBzZXEgPSB0aGlzLl9yYXdfZGF0YS5kYXRhLnNlcXVlbmNlc1tpZHhdLnRvU3RyaW5nKCk7XG4gICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgcG9zOyBpKysgKSB7XG4gICAgICAgIGlmIChpbnNlcnRzW2ldKSB7XG4gICAgICAgICAgICBhY3R1YWxfcG9zaXRpb24gKz0gaW5zZXJ0c1tpXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgYWN0dWFsX3Bvc2l0aW9uICs9IDE7XG4gICAgICAgIGlmIChzZXEuY2hhckF0KGkpID09ICctJykge1xuICAgICAgICAgICAgYWN0dWFsX3Bvc2l0aW9uIC09IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFjdHVhbF9wb3NpdGlvbiA9PSAwKSB7XG4gICAgICAgIGFjdHVhbF9wb3NpdGlvbiArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gYWN0dWFsX3Bvc2l0aW9uO1xufTtcblxuXG59KSgpO1xuLy8xMjY1IChQKVxuXG5DbHVzdGFsUnVubmVyLnByb3RvdHlwZS5zZXR1cFNlcXVlbmNlUmVuZGVyZXIgPSBmdW5jdGlvbihyZW5kZXJlcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHJlbmRlcmVyLnNlcXVlbmNlcyA9IHNlbGYuc2VxdWVuY2VzO1xuICAgIHJlbmRlcmVyLmFkZEF4aXNTY2FsZSgnY2x1c3RhbCcsZnVuY3Rpb24ocG9zLGxheWVyLGludmVyc2UpIHtcbiAgICAgICAgbGV0IGlkeCA9IG51bGw7XG4gICAgICAgIGxldCBzZXFfaWRlbnRpZmllcnMgPSBzZWxmLnNlcXVlbmNlcy5tYXAoZnVuY3Rpb24oc2VxKSB7IHJldHVybiBzZXEuYWdpOyB9KTtcbiAgICAgICAgd2hpbGUgKHNlcV9pZGVudGlmaWVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZHggPSBpZHggfHwgMDtcbiAgICAgICAgICAgIGxldCBhY2MgPSBzZXFfaWRlbnRpZmllcnMuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChsYXllci5zY2FsZXMuaGFzKGFjYykpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkeCsrO1xuICAgICAgICAgICAgaWYgKCBzZXFfaWRlbnRpZmllcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWR4ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGF5ZXIubmFtZSA9PT0gJ3ByaW1hcnlTZXF1ZW5jZScpIHtcbiAgICAgICAgICAgIGlkeCA9IHNlbGYucmVzdWx0LmFsaWduZWRfaWR4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpZHggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCBpbnZlcnNlICkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYucmVzdWx0LmNhbGN1bGF0ZVNlcXVlbmNlUG9zaXRpb25Gcm9tUG9zaXRpb24oaWR4LHBvcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZi5yZXN1bHQuY2FsY3VsYXRlUG9zaXRpb25Gb3JTZXF1ZW5jZShpZHgscG9zKTtcbiAgICB9KTtcblxuICAgIHZhciByZW5kZXJlZF9iaXRzID0gW107XG4gICAgdmFyIGNvbnRyb2xsZXJfbmFtZSA9ICdpc29mb3Jtcyc7XG4gICAgdmFyIGdyb3VwX25hbWUgPSAnaXNvZm9ybXMnO1xuXG4gICAgdmFyIGRyYXdfZGlzY29udGludWl0eSA9IGZ1bmN0aW9uKGNhbnZhcyxzaXplKSB7XG4gICAgICAgIHZhciB0b3AgPSAtMztcbiAgICAgICAgdmFyIGxlZnQgPSAtMjtcbiAgICAgICAgdmFyIGdyb3VwID0gY2FudmFzLmdyb3VwKCk7XG4gICAgICAgIHZhciBsaW5lO1xuICAgICAgICBsaW5lID0gY2FudmFzLmxpbmUobGVmdCsxLHRvcCs0LGxlZnQrMyx0b3ArMSk7XG4gICAgICAgIGxpbmUuc2V0QXR0cmlidXRlKCdzdHJva2UnLCcjZmNjJyk7XG4gICAgICAgIGxpbmUuc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCcxMCcpO1xuICAgICAgICBncm91cC5wdXNoKGxpbmUpO1xuICAgICAgICBsaW5lID0gY2FudmFzLmxpbmUobGVmdCsxLHRvcCs2LGxlZnQrMyx0b3ArMyk7XG4gICAgICAgIGxpbmUuc2V0QXR0cmlidXRlKCdzdHJva2UnLCcjZmNjJyk7XG4gICAgICAgIGxpbmUuc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCcxMCcpO1xuICAgICAgICBncm91cC5wdXNoKGxpbmUpO1xuICAgICAgICBsaW5lID0gY2FudmFzLmxpbmUobGVmdCsxLHRvcCs0LGxlZnQrMyx0b3ArMyk7XG4gICAgICAgIGxpbmUuc2V0QXR0cmlidXRlKCdzdHJva2UnLCcjZmNjJyk7XG4gICAgICAgIGxpbmUuc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCc1Jyk7XG4gICAgICAgIGdyb3VwLnB1c2gobGluZSk7XG4gICAgICAgIGxpbmUgPSBjYW52YXMubGluZShsZWZ0KzEsdG9wKzUuMyxsZWZ0KzEsdG9wKzUuOCk7XG4gICAgICAgIGxpbmUuc2V0QXR0cmlidXRlKCdzdHJva2UnLCcjZmNjJyk7XG4gICAgICAgIGxpbmUuc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCcxMCcpO1xuICAgICAgICBncm91cC5wdXNoKGxpbmUpO1xuICAgICAgICBsaW5lID0gY2FudmFzLmxpbmUobGVmdCsxLHRvcCs1LjksbGVmdCsxLjUsdG9wKzUuOSk7XG4gICAgICAgIGxpbmUuc2V0QXR0cmlidXRlKCdzdHJva2UnLCcjZmNjJyk7XG4gICAgICAgIGxpbmUuc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCcxMCcpO1xuICAgICAgICBncm91cC5wdXNoKGxpbmUpO1xuICAgICAgICB2YXIgY2lyY2xlID0gY2FudmFzLmNpcmNsZShsZWZ0KzIuOCx0b3ArMS43NSwxKTtcbiAgICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZSgnZmlsbCcsJyNmZmYnKTtcbiAgICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywnI2NjYycpO1xuICAgICAgICBjaXJjbGUuc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCcxMCcpO1xuICAgICAgICBncm91cC5wdXNoKGNpcmNsZSk7XG4gICAgICAgIHZhciBtaW51cyA9IGNhbnZhcy50ZXh0KGxlZnQrMi4yNSx0b3ArMi4yNSwoc2l6ZSB8fCAnw7cnKStcIlwiKTtcbiAgICAgICAgbWludXMuc2V0QXR0cmlidXRlKCdmaWxsJywnI2NjYycpO1xuICAgICAgICBtaW51cy5zZXRBdHRyaWJ1dGUoJ2ZvbnQtc2l6ZScsNzUpO1xuICAgICAgICBncm91cC5wdXNoKG1pbnVzKTtcbiAgICAgICAgY2FudmFzLmZpcnN0Q2hpbGQubmV4dFNpYmxpbmcuYXBwZW5kQ2hpbGQoZ3JvdXApO1xuICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfTtcblxuICAgIHZhciBjaGVja192YWx1ZXMgPSBmdW5jdGlvbihzZXEsaWR4LHNlcXMpIHtcbiAgICAgICAgdmFyIHBvc2l0aXZlcyA9IDA7XG4gICAgICAgIHZhciBhYSA9IHNlcS50b1N0cmluZygpLmNoYXJBdChpZHgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHNlcXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoc2Vxc1tpXS50b1N0cmluZygpLmNoYXJBdChpZHgpID09IGFhKSB7XG4gICAgICAgICAgICBwb3NpdGl2ZXMgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChwb3NpdGl2ZXMgLyAoc2Vxcy5sZW5ndGggLSAxKSk7XG4gICAgfTtcblxuXG4gICAgdmFyIHJlZHJhd19hbGlnbm1lbnRzID0gZnVuY3Rpb24oc2VxdWVuY2VfaW5kZXgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHNlbGYucmVzdWx0O1xuXG4gICAgICAgIHdoaWxlIChyZW5kZXJlZF9iaXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBiaXQgPSByZW5kZXJlZF9iaXRzLnNoaWZ0KCk7XG4gICAgICAgICAgICByZW5kZXJlci5yZW1vdmUoYml0LmxheWVyLGJpdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LmFsaWduVG9TZXF1ZW5jZShzZXF1ZW5jZV9pbmRleCB8fCAwKTtcblxuICAgICAgICB2YXIgYWxpZ25lZCA9IHJlc3VsdC5nZXRTZXF1ZW5jZXMoKTtcblxuICAgICAgICBpZiAoICEgcmVuZGVyZXIuc2VxdWVuY2UgKSB7XG4gICAgICAgICAgICByZW5kZXJlci5zZXRTZXF1ZW5jZShhbGlnbmVkW3NlcXVlbmNlX2luZGV4XSkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuc2VxdWVuY2VzID0gc2VsZi5zZXF1ZW5jZXM7XG4gICAgICAgICAgICAgICAgTUFTQ1AucmVnaXN0ZXJHcm91cChncm91cF9uYW1lLCAnQWxpZ25lZCcpO1xuICAgICAgICAgICAgICAgIE1BU0NQLnJlZ2lzdGVyTGF5ZXIoY29udHJvbGxlcl9uYW1lLCB7ICdmdWxsbmFtZScgOiAnQ29uc2VydmF0aW9uJywgJ2NvbG9yJyA6ICcjMDAwMDAwJyB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVuZGVyZXIudHJhY2tPcmRlci5pbmRleE9mKGNvbnRyb2xsZXJfbmFtZSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyLnRyYWNrT3JkZXIgPSByZW5kZXJlci50cmFja09yZGVyLmNvbmNhdChbY29udHJvbGxlcl9uYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnNob3dMYXllcihjb250cm9sbGVyX25hbWUpO1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyLmNyZWF0ZUdyb3VwQ29udHJvbGxlcihjb250cm9sbGVyX25hbWUsZ3JvdXBfbmFtZSk7XG4gICAgICAgICAgICAgICAgcmVkcmF3X2FsaWdubWVudHMoc2VxdWVuY2VfaW5kZXgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW5kZXJlci5zZXF1ZW5jZSA9IGFsaWduZWRbc2VxdWVuY2VfaW5kZXhdO1xuICAgICAgICAgICAgcmVuZGVyZXIucmVkcmF3QXhpcygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbGlnbm1lbnRzID0gcmVzdWx0LmdldEFsaWdubWVudCgpLnNwbGl0KCcnKTtcbiAgICAgICAgcmVuZGVyZWRfYml0cyA9IHJlbmRlcmVkX2JpdHMuY29uY2F0KHJlbmRlcmVyLnJlbmRlclRleHRUcmFjayhjb250cm9sbGVyX25hbWUscmVzdWx0LmdldEFsaWdubWVudCgpLnJlcGxhY2UoLyAvZywnwqAnKSkpO1xuICAgICAgICByZW5kZXJlZF9iaXRzLnNsaWNlKC0xKVswXS5zZXRBdHRyaWJ1dGUoJ2RhdGEtc3BhY2VzJywndHJ1ZScpO1xuICAgICAgICByZW5kZXJlZF9iaXRzLnNsaWNlKC0xKVswXS5sYXllciA9IGNvbnRyb2xsZXJfbmFtZTtcbiAgICAgICAgdmFyIGlkeHMgPSBbXCIqXCIsXCI6XCIsXCIuXCIsXCIgXCJdLnJldmVyc2UoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgYWxpZ25tZW50cy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgIHJlbmRlcmVkX2JpdHMucHVzaChyZW5kZXJlci5nZXRBQShpKzEsY29udHJvbGxlcl9uYW1lKS5hZGRCb3hPdmVybGF5KGNvbnRyb2xsZXJfbmFtZSwxLGlkeHMuaW5kZXhPZihhbGlnbm1lbnRzW2ldKS80LHtcIm1lcmdlXCIgOiB0cnVlfSkpO1xuICAgICAgICAgICAgcmVuZGVyZWRfYml0cy5zbGljZSgtMSlbMF0ubGF5ZXIgPSBjb250cm9sbGVyX25hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgYWxpZ25lZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxheW5hbWUgPSBzZWxmLnNlcXVlbmNlc1tpXS5hZ2kudG9VcHBlckNhc2UoKSB8fCBcIm1pc3NpbmdcIitpO1xuICAgICAgICAgICAgdmFyIGxheSA9IE1BU0NQLnJlZ2lzdGVyTGF5ZXIobGF5bmFtZSx7J2Z1bGxuYW1lJzogc2VsZi5zZXF1ZW5jZXNbaV0ubmFtZSB8fCBsYXluYW1lLnRvVXBwZXJDYXNlKCksICdncm91cCcgOiBncm91cF9uYW1lLCAnY29sb3InIDogJyNmZjAwMDAnLCAnYWNjZXNzaW9uJyA6IHNlbGYuc2VxdWVuY2VzW2ldLmFnaSB9KTtcbiAgICAgICAgICAgIGxheS5zY2FsZXMuY2xlYXIoKTtcbiAgICAgICAgICAgIGxheS5zY2FsZXMuYWRkKHNlbGYuc2VxdWVuY2VzW2ldLmFnaSk7XG5cbiAgICAgICAgICAgIGxheS5mdWxsbmFtZSA9IHNlbGYuc2VxdWVuY2VzW2ldLm5hbWUgfHwgbGF5bmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgdmFyIHRleHRfYXJyYXkgPSByZW5kZXJlci5yZW5kZXJUZXh0VHJhY2sobGF5bmFtZSxhbGlnbmVkW2ldLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgcmVuZGVyZWRfYml0cyA9IHJlbmRlcmVkX2JpdHMuY29uY2F0KHRleHRfYXJyYXkpO1xuICAgICAgICAgICAgcmVuZGVyZWRfYml0cy5zbGljZSgtMSlbMF0ubGF5ZXIgPSBsYXluYW1lO1xuICAgICAgICAgICAgaWYgKHJlbmRlcmVyLnRyYWNrT3JkZXIuaW5kZXhPZihsYXluYW1lLnRvVXBwZXJDYXNlKCkpIDwgMCkge1xuICAgICAgICAgICAgICByZW5kZXJlci50cmFja09yZGVyID0gcmVuZGVyZXIudHJhY2tPcmRlci5jb25jYXQoW2dyb3VwX25hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuYW1lID0gXCJJc29mb3JtIFwiKyhpKzEpO1xuICAgICAgICAgICAgaWYgKGFsaWduZWRbaV0uaW5zZXJ0aW9ucykge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpbnNlcnQgaW4gYWxpZ25lZFtpXS5pbnNlcnRpb25zKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluc2VydGlvbnMgPSBhbGlnbmVkW2ldLmluc2VydGlvbnM7XG4gICAgICAgICAgICAgICAgaWYgKGluc2VydCA9PSAwICYmIGluc2VydGlvbnNbaW5zZXJ0XSA9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluc2VydGlvbnNbaW5zZXJ0XS5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IGluc2VydGlvbnNbaW5zZXJ0XS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGluc2VydCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICBpbnNlcnQgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IGRyYXdfZGlzY29udGludWl0eShyZW5kZXJlci5fY2FudmFzLHNpemUpO1xuICAgICAgICAgICAgICAgIGNvbnRlbnQuc2V0QXR0cmlidXRlKCdmaWxsJywnI2ZmZmYwMCcpO1xuICAgICAgICAgICAgICAgIHZhciBhbl9hbm5vID0gcmVuZGVyZXIuZ2V0QUEoaW5zZXJ0LGNvbnRyb2xsZXJfbmFtZSkuYWRkVG9MYXllcihsYXluYW1lLFxuICAgICAgICAgICAgICAgICAgeyAnY29udGVudCcgOiBjb250ZW50LC8vJysnK2luc2VydGlvbnNbaW5zZXJ0XS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICdiYXJlX2VsZW1lbnQnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAnaGVpZ2h0JyA6IDEwLFxuICAgICAgICAgICAgICAgICAgICAnb2Zmc2V0JyA6IC01LFxuICAgICAgICAgICAgICAgICAgICAnbm9fdHJhY2VyJyA6IHRydWVcbiAgICAgICAgICAgICAgICAgIH0pWzFdO1xuICAgICAgICAgICAgICAgIGFuX2Fubm8uY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywnMzAwJyk7XG4gICAgICAgICAgICAgICAgYW5fYW5uby5jb250YWluZXIuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywnLTUwIC0xMDAgMjAwIDMwMCcpO1xuICAgICAgICAgICAgICAgIHJlbmRlcmVkX2JpdHMucHVzaChhbl9hbm5vKTtcbiAgICAgICAgICAgICAgICByZW5kZXJlZF9iaXRzLnNsaWNlKC0xKVswXS5sYXllciA9IGxheW5hbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZW5kZXJlci56b29tID0gMTtcbiAgICAgICAgcmVuZGVyZXIuc2hvd0dyb3VwKGdyb3VwX25hbWUpO1xuICAgICAgICByZW5kZXJlci5yZWZyZXNoKCk7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5iaW5kKCdyZXN1bHRSZWNlaXZlZCcsZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmVkcmF3X2FsaWdubWVudHMoMCk7XG4gICAgICAgIHNlbGYucmVzdWx0LmFsaWduZWRfaWR4ID0gMDtcbiAgICAgICAgdmFyIGFjY3MgPSBbXTtcbiAgICAgICAgc2VsZi5zZXF1ZW5jZXMuZm9yRWFjaChmdW5jdGlvbihzZXEpIHtcbiAgICAgICAgICAgIGFjY3MucHVzaChzZXEuYWdpLnRvVXBwZXJDYXNlKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGN1cnJlbnRfb3JkZXIgPSBbXTtcbiAgICAgICAgcmVuZGVyZXIuYmluZCgnb3JkZXJDaGFuZ2VkJyxmdW5jdGlvbihvcmRlcikge1xuICAgICAgICAgICAgaWYgKHNlbGYucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld19vcmRlciA9IG9yZGVyLnNsaWNlKChvcmRlci5pbmRleE9mKGNvbnRyb2xsZXJfbmFtZSkrMSksb3JkZXIubGVuZ3RoKS5maWx0ZXIoIGZ1bmN0aW9uKHRyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2NzLmluZGV4T2YodHJhY2spID49IDA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld19vcmRlci5qb2luKCcsJykgPT0gY3VycmVudF9vcmRlci5qb2luKCcsJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50X29yZGVyID0gbmV3X29yZGVyO1xuICAgICAgICAgICAgICAgIHNlbGYucmVzdWx0LmFsaWduZWRfaWR4ID0gYWNjcy5pbmRleE9mKGN1cnJlbnRfb3JkZXJbMF0pO1xuXG4gICAgICAgICAgICAgICAgcmVkcmF3X2FsaWdubWVudHMoc2VsZi5yZXN1bHQuYWxpZ25lZF9pZHgpO1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnJlZnJlc2hTY2FsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcblxufVxuXG5DbHVzdGFsUnVubmVyLlJlc3VsdC5wcm90b3R5cGUuZ2V0U2VxdWVuY2VzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3Jhd19kYXRhICYmIHRoaXMuX3Jhd19kYXRhLmRhdGEgJiYgdGhpcy5fcmF3X2RhdGEuZGF0YS5zZXF1ZW5jZXMpIHtcbiAgICAgICAgcmV0dXJuIFtdLmNvbmNhdCh0aGlzLl9yYXdfZGF0YS5kYXRhLnNlcXVlbmNlcyk7XG4gICAgfVxuICAgIHZhciBiaXRzID0gdGhpcy5fcmF3X2RhdGEubWF0Y2goL3NlcVxcZCsoLiopL2cpO1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiaXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzZXFiaXRzID0gYml0c1tpXS5tYXRjaCgvc2VxKFxcZCspXFxzKyguKikvKTtcbiAgICAgICAgaWYgKCEgcmVzdWx0c1tzZXFiaXRzWzFdXSkge1xuICAgICAgICAgICAgcmVzdWx0c1tzZXFiaXRzWzFdXSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdHNbc2VxYml0c1sxXV0gKz0gc2VxYml0c1syXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG5DbHVzdGFsUnVubmVyLlJlc3VsdC5wcm90b3R5cGUuZ2V0QWxpZ25tZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3Jhd19kYXRhICYmIHRoaXMuX3Jhd19kYXRhLmRhdGEgJiYgdGhpcy5fcmF3X2RhdGEuZGF0YS5hbGlnbm1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jhd19kYXRhLmRhdGEuYWxpZ25tZW50LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHRoaXMuX3RleHRfZGF0YSA9IHRoaXMuX3Jhd19kYXRhO1xuICAgIHZhciByZSA9IC8gezE2fSguKikvZztcbiAgICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgICB2YXIgbWF0Y2ggPSByZS5leGVjKHRoaXMuX3Jhd19kYXRhKTtcbiAgICB3aGlsZSAobWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgcmVzdWx0ICs9IG1hdGNoWzFdO1xuICAgICAgICBtYXRjaCA9IHJlLmV4ZWModGhpcy5fcmF3X2RhdGEpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5sZXQgb25seVVuaXF1ZSA9ICh2YWwsaWR4LGFycikgPT4gYXJyLmluZGV4T2YodmFsKSA9PT0gaWR4O1xuXG5sZXQgY2x1c3RhbF9lbXVsYXRvciA9IChzZXF1ZW5jZXMpID0+IHtcbiAgICBpZiAoc2VxdWVuY2VzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgc2VxdWVuY2VzOiBbXSwgYWxpZ25tZW50OiBcIlwiIH0gfTtcbiAgICB9XG4gICAgbGV0IGFsbF9hYXMgPSBzZXF1ZW5jZXMubWFwKCBzZXEgPT4gc2VxLnNwbGl0KCcnKSApO1xuICAgIGxldCBhbGlnbm1lbnQgPSBhbGxfYWFzWzBdLm1hcCggKGFhLHBvcykgPT4gIGFsbF9hYXMubWFwKCBhYXMgPT4gYWFzW3Bvc10gKS5maWx0ZXIob25seVVuaXF1ZSkubGVuZ3RoID09IDEgPyAnKicgOiAnOicgKS5qb2luKCcnKTtcbiAgICByZXR1cm4geyBkYXRhOiB7IHNlcXVlbmNlczogc2VxdWVuY2VzLCBhbGlnbm1lbnQ6IGFsaWdubWVudCB9fTtcbn07XG5cbkNsdXN0YWxSdW5uZXIuRW11bGF0ZWRDbHVzdGFsUnVubmVyID0gZnVuY3Rpb24ocmVuZGVyZXIpIHtcbiAgICBsZXQgcnVubmVyID0gbmV3IENsdXN0YWxSdW5uZXIoKTtcbiAgICBydW5uZXIucmV0cmlldmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbGV0IGRhdGFibG9jayA9IGNsdXN0YWxfZW11bGF0b3IodGhpcy5zZXF1ZW5jZXMgfHwgW10pO1xuICAgICAgICB0aGlzLl9kYXRhUmVjZWl2ZWQoZGF0YWJsb2NrKTtcbiAgICAgICAgdGhpcy5zZXF1ZW5jZXMgPSB0aGlzLnNlcXVlbmNlcy5tYXAoKHNlcSxpZHgpID0+IHsgcmV0dXJuIHsgIGFnaTogJ3NlcScraWR4LCB0b1N0cmluZzogKCkgPT4gc2VxIH0gfSk7XG4gICAgICAgIHRoaXMuZ290UmVzdWx0KCk7XG4gICAgICAgIHRoaXMucmVxdWVzdENvbXBsZXRlKCk7XG4gICAgfTtcbiAgICBpZiAocmVuZGVyZXIpIHtcbiAgICAgICAgcnVubmVyLnJlZ2lzdGVyU2VxdWVuY2VSZW5kZXJlcihyZW5kZXJlcik7XG4gICAgfVxuICAgIHJldHVybiBydW5uZXI7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBDbHVzdGFsUnVubmVyO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBR0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBSkE7QUFRQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUhBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../gator/js/lib/ClustalRunner.js\n")},"../gator/js/lib/CondensedSequenceRenderer.js":
/*!****************************************************!*\
  !*** ../gator/js/lib/CondensedSequenceRenderer.js ***!
  \****************************************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _MASCP__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MASCP */ \"../gator/js/lib/MASCP.js\");\n/* harmony import */ var _SequenceRenderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SequenceRenderer */ \"../gator/js/lib/SequenceRenderer.js\");\n/* harmony import */ var _CondensedSequenceRendererNavigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CondensedSequenceRendererNavigation */ \"../gator/js/lib/CondensedSequenceRendererNavigation.js\");\n/* harmony import */ var _bean__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../bean */ \"../gator/js/bean.js\");\n/* harmony import */ var _SVGCanvas__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SVGCanvas */ \"../gator/js/lib/SVGCanvas.js\");\n/**\n *  @fileOverview   Basic classes and definitions for an SVG-based sequence renderer\n */\n\n\n\n\n\nconst svgns = 'http://www.w3.org/2000/svg';\n/** Default class constructor\n *  @class      Renders a sequence using a condensed track-based display\n *  @param      {Element} sequenceContainer Container element that the sequence currently is found in, and also \n *              the container that data will be re-inserted into.\n *  @extends    MASCP.SequenceRenderer\n */\n\nconst CondensedSequenceRenderer = function CondensedSequenceRenderer(sequenceContainer) {\n  this._RS = 50;\n  _SequenceRenderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"].apply(this, arguments);\n  var self = this; // Create a common layer for the primary sequence\n\n  _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].registerLayer('primarySequence', {\n    'fullname': 'Primary Sequence'\n  });\n  CondensedSequenceRenderer.Zoom(self);\n  var resizeTimeout;\n\n  var resize_callback = function resize_callback() {\n    sequenceContainer.cached_width = sequenceContainer.getBoundingClientRect().width;\n  };\n\n  window.addEventListener('resize', function () {\n    clearTimeout(resizeTimeout);\n\n    if (window.requestAnimationFrame) {\n      window.requestAnimationFrame(resize_callback);\n    } else {\n      resizeTimeout = setTimeout(resize_callback, 100);\n    }\n  }, true);\n  sequenceContainer.cached_width = sequenceContainer.getBoundingClientRect().width; // We want to unbind the default handler for sequence change that we get from\n  // inheriting from CondensedSequenceRenderer\n\n  _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(this, 'sequenceChange');\n  _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(this, 'sequenceChange', function () {\n    for (var layername in _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].layers) {\n      if (_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].layers.hasOwnProperty(layername)) {\n        _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].layers[layername].disabled = true;\n      }\n    }\n\n    self.zoom = self.zoom;\n  });\n  return this;\n};\n\nCondensedSequenceRenderer.prototype = new _SequenceRenderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n\n(function (clazz) {\n  var createCanvasObject = function createCanvasObject() {\n    var renderer = this;\n\n    if (this._object) {\n      if (typeof svgweb != 'undefined') {\n        svgweb.removeChild(this._object, this._object.parentNode);\n      } else {\n        this._object.parentNode.removeChild(this._object);\n      }\n\n      this._canvas = null;\n      this._object = null;\n    }\n\n    var canvas;\n\n    if (document.implementation.hasFeature(\"http://www.w3.org/TR/SVG11/feature#BasicStructure\", \"1.1\")) {\n      var native_canvas = this.win().document.createElementNS(svgns, 'svg');\n      native_canvas.setAttribute('width', '100%');\n      native_canvas.setAttribute('height', '100%');\n\n      this._container.appendChild(native_canvas);\n\n      this._canvas = native_canvas;\n      canvas = {\n        'addEventListener': function addEventListener(name, load_func) {\n          native_canvas.contentDocument = {\n            'rootElement': native_canvas\n          };\n          load_func.call(native_canvas);\n        }\n      };\n    }\n\n    canvas.addEventListener('load', function () {\n      var container_canv = this;\n      Object(_SVGCanvas__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(container_canv);\n\n      if (renderer.font_order) {\n        container_canv.font_order = renderer.font_order;\n      }\n\n      var group = container_canv.makeEl('g');\n      var canv = container_canv.makeEl('svg');\n      canv.RS = renderer._RS;\n      Object(_SVGCanvas__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(canv);\n\n      if (renderer.font_order) {\n        canv.font_order = renderer.font_order;\n      }\n\n      group.appendChild(canv);\n      container_canv.appendChild(group);\n      var supports_events = true;\n\n      try {\n        var noop = canv.addEventListener;\n      } catch (err) {\n        supports_events = false;\n      }\n\n      var canvas_rect = canv.makeEl('rect', {\n        'x': '-10%',\n        'y': '-10%',\n        'width': '120%',\n        'height': '120%',\n        'style': 'fill: #ffffff;'\n      });\n      var left_fade = container_canv.makeEl('rect', {\n        'x': '0',\n        'y': '0',\n        'width': '50',\n        'height': '100%',\n        'style': 'fill: url(#left_fade);'\n      });\n      var right_fade = container_canv.makeEl('rect', {\n        'x': '100%',\n        'y': '0',\n        'width': '25',\n        'height': '100%',\n        'transform': 'translate(-15,0)',\n        'style': 'fill: url(#right_fade);'\n      });\n      container_canv.appendChild(left_fade);\n      container_canv.appendChild(right_fade);\n      _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(canv, 'pan', function () {\n        if (canv.currentTranslateCache.x >= 0) {\n          left_fade.setAttribute('visibility', 'hidden');\n        } else {\n          left_fade.setAttribute('visibility', 'visible');\n        }\n\n        if (renderer.rightVisibleResidue() < renderer.sequence.length) {\n          right_fade.setAttribute('visibility', 'visible');\n        } else {\n          right_fade.setAttribute('visibility', 'hidden');\n        }\n      });\n      _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(canv, '_anim_begin', function () {\n        left_fade.setAttribute('visibility', 'hidden');\n        right_fade.setAttribute('visibility', 'hidden');\n      });\n      _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(canv, '_anim_end', function () {\n        _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(canv, 'pan');\n      });\n      canv.currentTranslateCache = {\n        x: 0,\n        y: 0\n      };\n\n      if (canv.currentTranslateCache.x >= 0) {\n        left_fade.setAttribute('visibility', 'hidden');\n      }\n\n      right_fade.setAttribute('visibility', 'hidden');\n      var nav_group = container_canv.makeEl('g');\n      container_canv.appendChild(nav_group);\n      var nav_canvas = container_canv.makeEl('svg');\n      nav_group.appendChild(nav_canvas);\n      group.style.willChange = 'transform';\n\n      canv.setScale = function (scale) {\n        var curr_transform = (group._cached_transform || '').replace(/scale\\([^\\)]+\\)/, '');\n\n        if (scale !== null) {\n          curr_transform = (' scale(' + scale + ') ' + curr_transform).replace(/\\s+/g, ' ');\n        }\n\n        group._cached_transform = curr_transform;\n        group.style.transform = curr_transform;\n      };\n\n      nav_canvas.setScale = function (scale) {\n        var curr_transform = (nav_group._cached_transform || '').replace(/scale\\([^\\)]+\\)/, '');\n\n        if (scale !== null) {\n          curr_transform = (curr_transform + ' scale(' + scale + ') ').replace(/\\s+/g, ' ');\n        }\n\n        nav_group._cached_transform = curr_transform;\n        nav_group.style.transform = curr_transform;\n      };\n\n      _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(canv, 'zoomChange', () => {\n        if (!renderer.fixed_size) {\n          return;\n        }\n\n        canv.setScale(1);\n        nav_canvas.setScale(1);\n        requestAnimationFrame(() => {\n          let container_height = container_canv.getBoundingClientRect().height;\n          let canv_height = canv.getBoundingClientRect().height;\n          let current_scale = (group._cached_transform || 'scale(1)').match(/scale\\(([\\d\\.]+)\\)/) || '1';\n          canv.setScale((1 * container_height / canv_height).toFixed(2));\n          nav_canvas.setScale((1 * container_height / canv_height).toFixed(2));\n        });\n      });\n      _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(canv, 'panend', () => {\n        let evObj = new Event('panned', {\n          bubbles: true,\n          cancelable: true\n        });\n        canv.dispatchEvent(evObj);\n      });\n      var ua = window.navigator.userAgent;\n      var is_explorer = false;\n\n      if (ua.indexOf('Edge/') >= 0) {\n        is_explorer = true;\n      }\n\n      canv.setCurrentTranslateXY = function (x, y) {\n        var curr_transform = group._cached_transform || '';\n        curr_transform = (curr_transform.replace(/translate\\([^\\)]+\\)/, '') + ' translate(' + x + 'px, ' + y + 'px) ').replace(/\\s+/g, ' ');\n        group._cached_transform = curr_transform;\n\n        if (!is_explorer) {\n          group.style.transform = curr_transform;\n        } else {\n          group.setAttribute('transform', curr_transform.replace(/px/g, ''));\n        }\n\n        this.currentTranslateCache.x = x;\n        this.currentTranslateCache.y = y;\n      };\n\n      canv.setCurrentTranslateXY(0, 0);\n\n      nav_canvas.setCurrentTranslateXY = function (x, y) {\n        var curr_transform = (nav_group.getAttribute('transform') || '').replace(/translate\\([^\\)]+\\)/, '');\n        curr_transform = curr_transform + ' translate(' + x + ', ' + y + ') ';\n        nav_group.setAttribute('transform', curr_transform);\n        this.currentTranslate.x = x;\n        this.currentTranslate.y = y;\n      };\n\n      nav_canvas.setCurrentTranslateXY(0, 0);\n      addNav.call(renderer, nav_canvas);\n      var nav = renderer.navigation;\n      var old_show = nav.show,\n          old_hide = nav.hide;\n\n      nav.show = function () {\n        old_show.apply(nav, arguments);\n        canv.style.GomapScrollLeftMargin = 100 * renderer._RS / renderer.zoom;\n      };\n\n      nav.hide = function () {\n        old_hide.apply(nav, arguments);\n        canv.style.GomapScrollLeftMargin = 1000;\n      };\n\n      renderer._container_canvas = container_canv;\n      container_canv.setAttribute('preserveAspectRatio', 'xMinYMin meet');\n      container_canv.setAttribute('width', '100%');\n      container_canv.setAttribute('height', '100%');\n      canv.appendChild(canv.makeEl('rect', {\n        'x': 0,\n        'y': 0,\n        'opacity': 0,\n        'width': '100%',\n        'height': '100%',\n        'stroke-width': '0',\n        'fill': '#ffffff'\n      }));\n      renderer._object = this;\n      renderer._canvas = canv;\n      renderer._canvas._canvas_height = 0;\n      _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(renderer, 'svgready');\n    }, false);\n    return canvas;\n  };\n\n  var wheel_fn = function wheel_fn(e) {\n    e.stopPropagation();\n    return true;\n  };\n\n  var addNav = function addNav(nav_canvas) {\n    this.navigation = new CondensedSequenceRenderer.Navigation(nav_canvas, this);\n    var nav = this.navigation;\n    var self = this;\n\n    var hide_chrome = function hide_chrome() {\n      nav.demote();\n    };\n\n    var show_chrome = function show_chrome() {\n      nav.promote();\n      nav.refresh();\n    };\n\n    if (!_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].IE) {\n      _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(this._canvas, 'panstart', hide_chrome);\n      _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(this._canvas, 'panend', show_chrome);\n      _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(this._canvas, '_anim_begin', hide_chrome);\n      _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(this._canvas, '_anim_end', show_chrome);\n      nav_canvas.addEventListener('DOMMouseScroll', wheel_fn, false);\n      nav_canvas.addEventListener('wheel', wheel_fn, false);\n      nav_canvas.onmousewheel = wheel_fn;\n    }\n  };\n\n  var drawAminoAcids = function drawAminoAcids() {\n    var renderer = this;\n    var aas = renderer.addTextTrack(this.sequence, this._canvas.set());\n    aas.attr({\n      'y': 0.5 * renderer._axis_height * renderer._RS\n    });\n\n    renderer.select = function () {\n      var vals = Array.prototype.slice.call(arguments);\n      var from = vals[0];\n      var to = vals[1];\n      this.moveHighlight.apply(this, vals);\n    };\n\n    var zoomchange = function zoomchange() {\n      aas.attr({\n        'y': 0.5 * renderer._axis_height * renderer._RS\n      });\n    };\n\n    var canvas = renderer._canvas;\n    _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(canvas, 'zoomChange', zoomchange);\n    _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(aas, 'removed', function () {\n      _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(canvas, 'zoomChange', zoomchange);\n    });\n    return aas;\n  };\n\n  var mainDrawAxis;\n\n  var drawAxis = mainDrawAxis = function mainDrawAxis(canvas, lineLength) {\n    var RS = this._RS;\n    var self = this;\n    var x = 0,\n        i = 0;\n    var axis = canvas.set();\n    var axis_back = canvas.rect(0, 0, lineLength, 1.5);\n    axis_back.setAttribute('fill', \"url('#\" + self.axis_pattern_id + \"')\");\n    axis_back.removeAttribute('stroke');\n    axis_back.removeAttribute('stroke-width');\n    axis_back.setAttribute('id', 'axis_back');\n    var base_axis_height = 30;\n    var all_labels = canvas.set();\n    var major_mark_labels = canvas.set();\n    var minor_mark_labels = canvas.set();\n    var thousand_mark_labels = canvas.set();\n    var minor_mark = 10;\n    var major_mark = 20;\n\n    if (this.sequence.length > 5000) {\n      minor_mark = 100;\n      major_mark = 200;\n    }\n\n    if (this.sequence.length > 1000) {\n      minor_mark = 20;\n      major_mark = 40;\n    }\n\n    for (i = 0; i < lineLength / 5; i++) {\n      var a_text = canvas.text(x - 0.5, 0, \"\" + x);\n      all_labels.push(a_text);\n\n      if (x % major_mark === 0 && x !== 0) {\n        major_mark_labels.push(a_text);\n      } else if (x % minor_mark === 0 && x !== 0) {\n        minor_mark_labels.push(a_text);\n      }\n\n      if (x % (250 * parseInt(this.sequence.length / 500)) === 0 && x !== 0) {\n        thousand_mark_labels.push(a_text);\n      }\n\n      x += 5;\n    }\n\n    for (i = 0; i < all_labels.length; i++) {\n      all_labels[i].style.textAnchor = 'middle';\n      all_labels[i].firstChild.setAttribute('dy', '1.5ex');\n    }\n\n    all_labels.attr({\n      'pointer-events': 'none',\n      'text-anchor': 'middle',\n      'font-size': 7 * RS + 'pt'\n    });\n    all_labels.hide();\n    self._axis_height = parseInt(base_axis_height / self.zoom);\n    var zoom_status = null;\n\n    var zoomchange = function zoomchange() {\n      var renderer = self;\n      renderer._axis_height = parseInt(base_axis_height / renderer.zoom);\n\n      var pattern = renderer._canvas.ownerSVGElement.getElementById(renderer.axis_pattern_id);\n\n      thousand_mark_labels.forEach(function (label) {\n        label.setAttribute('visibility', 'hidden');\n      });\n\n      if (this.zoom > 3.6) {\n        axis_back.setAttribute('transform', 'translate(-5,' + 0.3 * renderer._axis_height * RS + ')');\n        axis_back.setAttribute('height', 0.25 * renderer._axis_height * RS);\n        pattern.setAttribute('width', 10 * RS);\n        pattern.firstChild.setAttribute('x', 9.5 * RS);\n        pattern.firstChild.setAttribute('width', RS / renderer.zoom);\n        minor_mark_labels.show();\n        major_mark_labels.show();\n        var text_scale = 0.15 * self._axis_height;\n\n        if (text_scale < 1) {\n          text_scale = 1;\n        }\n\n        minor_mark_labels.attr({\n          'font-size': text_scale * RS + 'pt',\n          'text-anchor': 'end'\n        });\n        major_mark_labels.attr({\n          'font-size': text_scale * RS + 'pt',\n          'text-anchor': 'end'\n        });\n\n        if (this._visibleTracers && this._visibleTracers()) {\n          this._visibleTracers().show();\n        }\n      } else if (this.zoom > 1.8) {\n        minor_mark_labels.hide();\n        major_mark_labels.show();\n        major_mark_labels.attr({\n          'font-size': 0.5 * RS * self._axis_height + 'pt',\n          'text-anchor': 'middle'\n        });\n        axis_back.setAttribute('transform', 'translate(-25,' + 0.5 * renderer._axis_height * RS + ')');\n        axis_back.setAttribute('height', 0.3 * renderer._axis_height * RS);\n        pattern.setAttribute('width', 20 * RS);\n        pattern.firstChild.setAttribute('width', RS / renderer.zoom);\n        pattern.firstChild.setAttribute('x', '0');\n\n        if (this.tracers) {\n          this.tracers.hide();\n        }\n      } else if (this.zoom > 0.2) {\n        if (this.tracers) {\n          this.tracers.hide();\n        }\n\n        minor_mark_labels.hide();\n        major_mark_labels.show();\n        major_mark_labels.attr({\n          'font-size': 0.5 * RS * self._axis_height + 'pt',\n          'text-anchor': 'middle'\n        });\n        axis_back.setAttribute('transform', 'translate(-25,' + 0.5 * renderer._axis_height * RS + ')');\n        axis_back.setAttribute('height', 0.3 * renderer._axis_height * RS);\n        pattern.setAttribute('width', 50 * RS);\n        pattern.firstChild.setAttribute('width', RS / renderer.zoom);\n        var last_right = -10000;\n        var changed = false;\n        major_mark_labels.forEach(function (label) {\n          if (!label.cached_bbox) {\n            label.cached_bbox = label.getBBox();\n          }\n\n          if (label.cached_bbox.x <= last_right + RS * 10 || parseInt(label.textContent) % 50 != 0) {\n            label.setAttribute('visibility', 'hidden');\n            changed = true;\n          } else {\n            label.setAttribute('visibility', 'visible');\n            last_right = label.cached_bbox.x + label.cached_bbox.width;\n          }\n        });\n\n        if (changed) {\n          major_mark_labels[0].setAttribute('visibility', 'hidden');\n        }\n      } else {\n        if (this.tracers) {\n          this.tracers.hide();\n        }\n\n        minor_mark_labels.hide();\n        major_mark_labels.hide();\n        thousand_mark_labels.show();\n        thousand_mark_labels.attr({\n          'font-size': 0.5 * RS * self._axis_height + 'pt',\n          'text-anchor': 'middle'\n        });\n        axis_back.setAttribute('transform', 'translate(-50,' + 0.85 * renderer._axis_height * RS + ')');\n        axis_back.setAttribute('height', 0.1 * renderer._axis_height * RS);\n        pattern.setAttribute('width', 250 * RS);\n        pattern.firstChild.setAttribute('width', RS / renderer.zoom);\n        var last_right = -10000;\n        var changed = false;\n        thousand_mark_labels.forEach(function (label) {\n          if (!label.cached_bbox) {\n            label.cached_bbox = label.getBBox();\n          }\n\n          if (label.cached_bbox.x <= last_right + RS * 10 || parseInt(label.textContent) % 250 != 0) {\n            label.setAttribute('visibility', 'hidden');\n          } else {\n            label.setAttribute('visibility', 'visible');\n            last_right = label.cached_bbox.x + label.cached_bbox.width;\n          }\n        });\n\n        if (changed) {\n          thousand_mark_labels[0].setAttribute('visibility', 'hidden');\n        }\n      }\n    };\n\n    _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(canvas, 'zoomChange', zoomchange);\n    _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(axis, 'removed', function () {\n      _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(canvas, 'zoomChange', zoomchange);\n\n      var remover = function remover(el) {\n        if (el.parentNode) {\n          el.parentNode.removeChild(el);\n        }\n      };\n\n      axis_back.parentNode.removeChild(axis_back);\n      all_labels.forEach(remover);\n    });\n    return axis;\n  };\n\n  clazz.prototype.panTo = function (end, callback) {\n    var renderer = this;\n    var pos = renderer.leftVisibleResidue();\n    var delta = 1;\n\n    if (pos == end) {\n      if (callback) {\n        callback.call(null);\n      }\n\n      return;\n    }\n\n    if (pos > end) {\n      delta = -1;\n    }\n\n    requestAnimationFrame(function () {\n      renderer.setLeftVisibleResidue(pos);\n      pos += delta;\n      _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(renderer._canvas, 'panend');\n\n      if (pos !== end) {\n        requestAnimationFrame(arguments.callee);\n      } else {\n        if (callback) {\n          callback.call(null);\n        }\n      }\n    });\n  };\n\n  clazz.prototype.zoomTo = function (zoom, residue, callback) {\n    var renderer = this;\n    var curr = renderer.zoom;\n    var delta = (zoom - curr) / 50;\n\n    let zoomchange = function zoomchange() {\n      _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(renderer, 'zoomChange', zoomchange);\n      delete renderer.zoomCenter;\n\n      if (callback) {\n        callback.call(null);\n      }\n    };\n\n    _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(renderer, 'zoomChange', zoomchange);\n\n    if (residue) {\n      renderer.zoomCenter = residue == 'center' ? residue : {\n        'x': renderer._RS * residue\n      };\n    } else {\n      renderer.zoom = zoom;\n      return;\n    }\n\n    let zoomer = () => {\n      renderer.zoom = curr;\n      curr += delta;\n\n      if (Math.abs(curr - zoom) > 0.01) {\n        requestAnimationFrame(zoomer);\n      }\n    };\n\n    requestAnimationFrame(zoomer);\n  };\n\n  clazz.prototype.showResidues = function (start, end) {\n    let residues_per_zoom_unit = this._container.clientWidth / this._RS;\n    let container_width = this._container.clientWidth;\n    let min_zoom_level = container_width / (2 * this.sequence.length);\n\n    if (!this.sequence) {\n      return;\n    }\n\n    let delta = end - start;\n    let target_zoom_level = min_zoom_level / (delta / this.sequence.length);\n\n    if (target_zoom_level === this.zoom) {\n      this.setLeftVisibleResidue(start);\n      return Promise.resolve();\n    }\n\n    this.zoomCenter = {\n      x: Math.floor(0.5 * (end + start))\n    };\n    let zoomed = new Promise(resolve => {\n      let zoomchange = () => {\n        _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(this, 'zoomChange', zoomchange);\n        delete this.zoomCenter;\n        this.setLeftVisibleResidue(start);\n        resolve();\n      };\n\n      _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(this, 'zoomChange', zoomchange);\n    });\n    this.zoom = target_zoom_level;\n    return zoomed;\n  };\n\n  clazz.prototype.setLeftVisibleResidue = function (val) {\n    var self = this;\n\n    self._canvas.setCurrentTranslateXY(self._canvas.width.baseVal.value * (1 - val / (self.sequence.length + self.padding + 2)) - self._canvas.width.baseVal.value, 0);\n  };\n\n  clazz.prototype.leftVisibleResidue = function () {\n    var self = this;\n    var val = Math.floor((self.sequence.length + self.padding + 2) * (1 - (self._canvas.width.baseVal.value + self._canvas.currentTranslateCache.x) / self._canvas.width.baseVal.value)) - 1;\n\n    if (val < 0) {\n      val = 0;\n    }\n\n    return val;\n  };\n\n  clazz.prototype.rightVisibleResidue = function () {\n    var self = this;\n    var container_width = self._container_canvas.parentNode.cached_width;\n\n    if (!container_width) {\n      container_width = self._container_canvas.parentNode.getBoundingClientRect().width;\n    }\n\n    var val = Math.floor(self.leftVisibleResidue() + (self.sequence.length + self.padding + 2) * (container_width / self._canvas.width.baseVal.value));\n\n    if (val > self.sequence.length) {\n      val = self.sequence.length;\n    }\n\n    return val;\n  };\n\n  clazz.prototype.addAxisScale = function (identifier, scaler) {\n    if (!this._scalers) {\n      this._scalers = [];\n    }\n\n    let scalers = this._scalers.filter(scale => scale.identifier !== identifier);\n\n    scalers.push(scaler);\n    this._scalers = scalers;\n    scaler.identifier = identifier;\n    return scaler;\n  };\n\n  clazz.prototype.refreshScale = function () {\n    var self = this;\n    var lays = Object.keys(this._layer_containers);\n    lays.forEach(function (lay) {\n      self._layer_containers[lay].forEach(function (el) {\n        if (el.move && el.aa) {\n          var aa = self.scalePosition(el.aa, lay);\n          var aa_width = self.scalePosition(el.aa + el.aa_width, lay);\n\n          if (aa < 0) {\n            aa *= -1;\n          }\n\n          if (aa_width < 0) {\n            aa_width *= -1;\n          }\n\n          el.move(aa - 1, aa_width - aa);\n        }\n      });\n    });\n  };\n\n  clazz.prototype.scalePosition = function (aa, layer, inverse) {\n    var layer_obj = _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLayer(layer);\n\n    if (!layer_obj) {\n      console.log('Missing layer object for layer identifier', layer, 'making dummy layer scaled with identifier', layer);\n      layer_obj = {\n        'name': layer,\n        'scales': new Set()\n      };\n      layer_obj.scales.add(layer);\n    }\n\n    let scaler_funcs = (this._scalers || []).concat([]);\n    var new_aa = (inverse ? scaler_funcs.reverse() : scaler_funcs).reduce((val, fn) => {\n      return fn(val, layer_obj, inverse);\n    }, aa);\n    return new_aa;\n  };\n\n  clazz.prototype.getAA = function (aa, layer, scale_name) {\n    return this.getAminoAcidsByPosition([aa], layer, scale_name).shift();\n  };\n\n  clazz.prototype.getAminoAcidsByPosition = function (aas, layer) {\n    var self = this;\n    var new_aas = aas.map(function (aa) {\n      return Math.abs(self.scalePosition(aa, layer));\n    });\n    var results = _SequenceRenderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"].prototype.getAminoAcidsByPosition.call(this, new_aas);\n\n    for (var i = 0; i < new_aas.length; i++) {\n      if (results[i]) {\n        results[i].original_index = aas[i];\n      }\n    }\n\n    return results;\n  };\n\n  clazz.prototype.getAminoAcidsByPeptide = function (peptide, layer) {\n    layer = _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLayer(layer);\n    var self = this;\n    var positions = [];\n    var self_seq;\n    var identifier = layer.accession;\n\n    if (self.sequences) {\n      self_seq = self.sequences[self.sequences.map(function (seq) {\n        return (seq.agi || seq.acc || \"\").toLowerCase();\n      }).indexOf(identifier.toLowerCase())].toString();\n    } else {\n      self_seq = self.sequence;\n    }\n\n    var start = self_seq.indexOf(peptide);\n\n    for (var i = 0; i < peptide.length; i++) {\n      positions.push(start + i);\n    }\n\n    var results = self.getAminoAcidsByPosition(positions, layer);\n\n    if (results.length) {\n      results.addToLayer = function (layername, fraction, options) {\n        return results[0].addBoxOverlay(layername, results.length, fraction, options);\n      };\n    } else {\n      results.addToLayer = function () {};\n    }\n\n    return results;\n  };\n\n  clazz.prototype.win = function () {\n    if (this._container && this._container.ownerDocument && this._container.ownerDocument.defaultView) {\n      var return_val = this._container.ownerDocument.defaultView;\n\n      if (typeof return_val === 'object' && return_val.constructor !== Window) {\n        return_val = return_val[Object.keys(return_val)[0]];\n      }\n\n      return return_val;\n    }\n\n    return null;\n  };\n\n  clazz.prototype.setSequence = function (sequence) {\n    var new_sequence = this._cleanSequence(sequence);\n\n    if (new_sequence == this.sequence && new_sequence !== null) {\n      _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(this, 'sequenceChange');\n      return;\n    }\n\n    if (!new_sequence) {\n      return;\n    }\n\n    this.sequence = new_sequence;\n    delete this.sequences;\n    var seq_chars = this.sequence.split('');\n    var line_length = seq_chars.length;\n\n    if (line_length === 0) {\n      return;\n    }\n\n    var renderer = this;\n\n    var build_sequence_els = function build_sequence_els() {\n      var seq_els = [];\n      renderer.sequence.split('').forEach(function (aa, i) {\n        var el = {};\n        el._index = i;\n        el._renderer = renderer;\n\n        renderer._extendElement(el);\n\n        el.amino_acid = aa;\n        seq_els.push(el);\n      });\n      renderer._sequence_els = seq_els;\n    };\n\n    build_sequence_els();\n    var RS = this._RS;\n    _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(this, 'svgready');\n    _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(this, 'svgready', function (cnv) {\n      var canv = renderer._canvas;\n      canv.RS = RS;\n      canv.setAttribute('background', '#000000');\n      canv.setAttribute('preserveAspectRatio', 'xMinYMin meet');\n      var defs = canv.makeEl('defs');\n\n      renderer._container_canvas.appendChild(defs);\n\n      defs.appendChild(canv.make_gradient('track_shine', '0%', '100%', ['#111111', '#aaaaaa', '#111111'], [0.5, 0.5, 0.5]));\n      defs.appendChild(canv.make_gradient('simple_gradient', '0%', '100%', ['#aaaaaa', '#888888'], [1, 1]));\n      defs.appendChild(canv.make_gradient('left_fade', '100%', '0%', ['#ffffff', '#ffffff'], [1, 0]));\n      defs.appendChild(canv.make_gradient('right_fade', '100%', '0%', ['#ffffff', '#ffffff'], [0, 1]));\n      defs.appendChild(canv.make_gradient('red_3d', '0%', '100%', ['#CF0000', '#540000'], [1, 1]));\n      renderer.gradients = [];\n\n      renderer.add3dGradient = function (color) {\n        defs.appendChild(canv.make_gradient('grad_' + color, '0%', '100%', [color, '#ffffff', color], [1, 1, 1]));\n        renderer.gradients.push(color);\n      };\n\n      var shadow = canv.makeEl('filter', {\n        'id': 'drop_shadow',\n        'filterUnits': 'objectBoundingBox',\n        'x': '-50%',\n        'y': '-50%',\n        'width': '200%',\n        'height': '200%'\n      });\n      shadow.appendChild(canv.makeEl('feGaussianBlur', {\n        'in': 'SourceGraphic',\n        'stdDeviation': '4',\n        'result': 'blur_out'\n      }));\n      shadow.appendChild(canv.makeEl('feOffset', {\n        'in': 'blur_out',\n        'result': 'the_shadow',\n        'dx': '3',\n        'dy': '1'\n      }));\n      shadow.appendChild(canv.makeEl('feBlend', {\n        'in': 'SourceGraphic',\n        'in2': 'the_shadow',\n        'mode': 'normal'\n      }));\n      defs.appendChild(shadow);\n      var link_icon = canv.makeEl('svg', {\n        'width': '100%',\n        'height': '100%',\n        'id': 'new_link_icon',\n        'viewBox': '0 0 100 100',\n        'preserveAspectRatio': 'xMinYMin meet'\n      });\n      defs.appendChild(link_icon);\n      link_icon.appendChild(canv.makeEl('rect', {\n        'x': '12.5',\n        'y': '37.5',\n        'stroke-width': '3',\n        'width': '50',\n        'height': '50',\n        'stroke': '#ffffff',\n        'fill': 'none'\n      }));\n      link_icon.appendChild(canv.makeEl('path', {\n        'd': 'M 50.0,16.7 L 83.3,16.7 L 83.3,50.0 L 79.2,56.2 L 68.8,39.6 L 43.8,66.7 L 33.3,56.2 L 60.4,31.2 L 43.8,20.8 L 50.0,16.7 z',\n        'stroke-width': '3',\n        'stroke': '#999999',\n        'fill': '#ffffff'\n      }));\n      var plus_icon = canv.makeEl('svg', {\n        'width': '100%',\n        'height': '100%',\n        'id': 'plus_icon',\n        'viewBox': '0 0 100 100',\n        'preserveAspectRatio': 'xMinYMin meet'\n      });\n      plus_icon.appendChild(canv.plus(0, 0, 100 / canv.RS));\n      defs.appendChild(plus_icon);\n      var minus_icon = canv.makeEl('svg', {\n        'width': '100%',\n        'height': '100%',\n        'id': 'minus_icon',\n        'viewBox': '0 0 100 100',\n        'preserveAspectRatio': 'xMinYMin meet'\n      });\n      minus_icon.appendChild(canv.minus(0, 0, 100 / canv.RS));\n      defs.appendChild(minus_icon);\n      var axis_pattern_id = 'axis_pattern_' + new Date().getTime();\n      var pattern = canv.makeEl('pattern', {\n        'patternUnits': 'userSpaceOnUse',\n        'x': '0',\n        'y': '0',\n        'width': 10 * canv.RS,\n        'height': 2 * canv.RS,\n        'id': axis_pattern_id\n      });\n      renderer.axis_pattern_id = axis_pattern_id;\n      var line = canv.makeEl('rect', {\n        'x': '0',\n        'y': '0',\n        'width': '10%',\n        'height': '1000%',\n        'fill': '#000',\n        'stroke': '0'\n      });\n      pattern.appendChild(line);\n      defs.appendChild(pattern);\n      var self = this;\n      renderer._axis_height = 10;\n      var aas = drawAminoAcids.call(self, canv);\n\n      renderer.hideAxis = function () {\n        drawAxis = function drawAxis(canv) {\n          _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(canv, 'zoomChange', function () {\n            self._axis_height = 10 / self.zoom;\n          });\n          return {};\n        };\n\n        self._axis_height = 10 / self.zoom;\n        this.redrawAxis();\n      };\n\n      renderer.showAxis = function () {\n        drawAxis = mainDrawAxis;\n        this.redrawAxis();\n      };\n\n      var axis = drawAxis.call(self, canv, line_length);\n\n      renderer.redrawAxis = function () {\n        _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(axis, 'removed');\n        aas.forEach(function (aa) {\n          if (aa.parentNode) {\n            aa.parentNode.removeChild(aa);\n          }\n        });\n        _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(aas, 'removed');\n        axis = drawAxis.call(self, canv, renderer.sequence.length);\n        aas = drawAminoAcids.call(self, canv);\n        build_sequence_els();\n        renderer.refresh();\n      };\n\n      if (!renderer.hide_axis) {\n        this.showAxis();\n      } else {\n        this.hideAxis();\n      }\n\n      renderer._layer_containers = {};\n      renderer.enablePrintResizing();\n      renderer.enableScaling();\n      renderer.enableSelection(); // When we have a layer registered with the global MASCP object\n      // add a track within this renderer.\n\n      _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"], 'layerRegistered', function (layer, rend) {\n        if (!rend || rend === renderer) {\n          renderer.addTrack(layer);\n        }\n      });\n      _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(renderer, 'sequenceChange');\n    });\n    var canvas = createCanvasObject.call(this);\n\n    if (!this._canvas) {\n      if (typeof svgweb != 'undefined') {\n        svgweb.appendChild(canvas, this._container);\n      } else {\n        this._container.appendChild(canvas);\n      }\n    }\n\n    var rend = this;\n    this.EnableHighlights();\n\n    var seq_change_func = function seq_change_func(other_func) {\n      if (!rend._canvas) {\n        _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(rend, 'sequenceChange', function () {\n          _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(rend, 'sequenceChange', arguments.callee);\n          other_func.apply();\n        });\n      } else {\n        other_func.apply();\n      }\n    };\n\n    seq_change_func.ready = function (other_func) {\n      this.call(this, other_func);\n    };\n\n    return seq_change_func;\n  };\n})(CondensedSequenceRenderer);\n\n(function () {\n  var svgns = 'http://www.w3.org/2000/svg';\n\n  var add_import = function add_import(ownerdoc) {\n    if (!ownerdoc.ELEMENT_NODE) {\n      ownerdoc.ELEMENT_NODE = 1;\n      ownerdoc.ATTRIBUTE_NODE = 2;\n      ownerdoc.TEXT_NODE = 3;\n      ownerdoc.CDATA_SECTION_NODE = 4;\n      ownerdoc.ENTITY_REFERENCE_NODE = 5;\n      ownerdoc.ENTITY_NODE = 6;\n      ownerdoc.PROCESSING_INSTRUCTION_NODE = 7;\n      ownerdoc.COMMENT_NODE = 8;\n      ownerdoc.DOCUMENT_NODE = 9;\n      ownerdoc.DOCUMENT_TYPE_NODE = 10;\n      ownerdoc.DOCUMENT_FRAGMENT_NODE = 11;\n      ownerdoc.NOTATION_NODE = 12;\n    }\n\n    ownerdoc._importNode = function (node, allChildren) {\n      switch (node.nodeType) {\n        case ownerdoc.ELEMENT_NODE:\n          var newNode = ownerdoc.createElementNS(svgns, node.nodeName);\n          /* does the node have any attributes to add? */\n\n          if (node.attributes && node.attributes.length > 0) for (var i = 0, il = node.attributes.length; i < il;) {\n            if (!/^on/.test(node.attributes[i].nodeName)) {\n              newNode.setAttribute(node.attributes[i].nodeName, node.getAttribute(node.attributes[i++].nodeName));\n            }\n          }\n          /* are we going after children too, and does the node have any? */\n\n          if (allChildren && node.childNodes && node.childNodes.length > 0) for (var i = 0, il = node.childNodes.length; i < il;) {\n            if (node.childNodes[i].nodeName !== 'USE' && node.childNodes[i].nodeName.toUpperCase() !== 'SCRIPT') {\n              newNode.appendChild(ownerdoc._importNode(node.childNodes[i++], allChildren));\n            }\n          }\n          return newNode;\n          break;\n\n        case ownerdoc.TEXT_NODE:\n        case ownerdoc.CDATA_SECTION_NODE:\n        case ownerdoc.COMMENT_NODE:\n          return ownerdoc.createTextNode(node.nodeValue);\n          break;\n      }\n    };\n  };\n\n  var fix_child_links = function fix_child_links(node, prefix) {\n    if (node.childNodes && node.childNodes.length > 0) {\n      for (var i = 0, il = node.childNodes.length; i < il;) {\n        if (node.childNodes[i].nodeName.toUpperCase() === 'USE') {\n          var linkval = node.childNodes[i].getAttribute('xlink:href');\n          node.childNodes[i].setAttribute('xlink:href', linkval.replace(/^#/, '#' + prefix + '_'));\n        }\n\n        i++;\n      }\n    }\n  };\n\n  CondensedSequenceRenderer.prototype.importIcons = function (namespace, doc, alt_url) {\n    var new_owner = this._container_canvas.ownerDocument;\n\n    if (this._container_canvas.getElementById('defs_' + namespace)) {\n      return;\n    }\n\n    this._container_canvas.appendChild(new_owner.createElement('defs'));\n\n    this._container_canvas.lastChild.setAttribute('id', 'defs_' + namespace);\n\n    var defs_block = this._container_canvas.lastChild;\n\n    if (!new_owner._importNode) {\n      add_import(new_owner);\n    }\n\n    var ua = window.navigator.userAgent;\n\n    if (ua.indexOf('Edge/') >= 0) {\n      this.icons_failed = this.icons_failed || {};\n      this.icons_failed[namespace] = alt_url;\n      return;\n    }\n\n    var new_nodes = new_owner._importNode(doc, true);\n\n    if (typeof XPathResult !== 'undefined') {\n      var iterator = new_owner.evaluate('//svg:defs/*', new_nodes, function (ns) {\n        return svgns;\n      }, XPathResult.ANY_TYPE, null);\n      var el = iterator.iterateNext();\n      var to_append = [];\n\n      while (el) {\n        to_append.push(el);\n        el = iterator.iterateNext();\n      }\n\n      if (to_append.length === 0) {\n        this.icons_failed = this.icons_failed || {};\n        this.icons_failed[namespace] = alt_url;\n      }\n\n      to_append.forEach(function (el) {\n        el.setAttribute('id', namespace + '_' + el.getAttribute('id'));\n        fix_child_links(el, namespace);\n        defs_block.appendChild(el);\n      });\n    } else {\n      var els = new_nodes.querySelectorAll('defs > *');\n\n      for (var i = 0; i < els.length; i++) {\n        els[i].setAttribute('id', namespace + '_' + els[i].getAttribute('id'));\n        fix_child_links(el, namespace);\n        defs_block.appendChild(els[i]);\n      }\n    }\n  };\n})();\n\nCondensedSequenceRenderer.prototype.addValuesToLayer = function (layerName, values, options) {\n  var RS = this._RS;\n  var canvas = this._canvas;\n\n  if (!canvas) {\n    var orig_func = arguments.callee;\n    var self = this;\n    _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(this._renderer, 'sequencechange', function () {\n      _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(this._renderer, 'sequencechange', arguments.callee);\n      orig_func.call(self, layerName, values);\n    });\n    log(\"Delaying rendering, waiting for sequence change\");\n    return;\n  }\n\n  var max_value;\n  var min_value;\n  var height_scale = 1;\n  options = options || {};\n\n  if (options.height) {\n    height_scale = options.height / this._layer_containers[layerName].track_height;\n  }\n\n  var offset_scale = 0;\n\n  if (options.offset) {\n    offset_scale = options.offset / this._layer_containers[layerName].track_height;\n  }\n\n  var recalculate_plot = function recalculate_plot(scale) {\n    var plot_path = ' m' + -0.5 * RS + ' 0';\n    var last_value = null;\n    values.forEach(function (value) {\n      if (typeof last_value == 'undefined') {} else {\n        plot_path += ' l' + RS + ' ' + -1 * RS * scale * height_scale * (value - last_value);\n      }\n\n      last_value = value;\n\n      if (isNaN(max_value) || value > max_value) {\n        max_value = value;\n      }\n\n      if (isNaN(min_value) || value < min_value) {\n        min_value = value;\n      }\n    });\n    return plot_path;\n  };\n\n  var plot = this._canvas.path('M0 0 M0 0 m0 ' + (max_value || 0) * RS + ' ' + recalculate_plot(1));\n\n  var abs_min_val = min_value;\n  var abs_max_val = max_value;\n  plot.setAttribute('stroke', options.color || '#ff0000');\n  plot.setAttribute('stroke-width', (options.thickness || 0.35) * RS);\n  plot.setAttribute('fill', 'none');\n  plot.setAttribute('visibility', 'hidden');\n  plot.setAttribute('pointer-events', 'none');\n\n  this._layer_containers[layerName].push(plot);\n\n  plot.setAttribute('transform', 'translate(1,10) scale(1,1)');\n\n  if (!options.hide_axis) {\n    var axis = this._canvas.path('M0 0 m0 ' + RS * ((max_value || 0) - (min_value || 0)) + ' l' + this._sequence_els.length * RS + ' 0');\n\n    axis.setAttribute('stroke-width', 0.2 * RS);\n    axis.setAttribute('visibility', 'hidden');\n    axis.setAttribute('transform', 'translate(1,0)');\n    axis.setAttribute('pointer-events', 'none');\n\n    axis.setHeight = function (height) {\n      if (abs_min_val < 0 && abs_max_val > 0) {\n        axis.setAttribute('d', 'M0 0 M0 0 m0 ' + height * offset_scale + ' m0 ' + 0.5 * height * height_scale + ' l' + renderer._sequence_els.length * RS + ' 0');\n      } else {\n        axis.setAttribute('d', 'M0 0 M0 0 m0 ' + height * offset_scale + ' m0 ' + 0.5 * (1 - abs_min_val) * height * height_scale + ' l' + renderer._sequence_els.length * RS + ' 0');\n      }\n\n      axis.setAttribute('stroke-width', 0.2 * RS / renderer.zoom);\n    };\n\n    this._layer_containers[layerName].push(axis);\n  }\n\n  var renderer = this;\n\n  if (options.label) {\n    var text = this._canvas.text(0, 0, options.label.max || options.label.min);\n\n    text.setAttribute('transform', 'translate(0,0)');\n    text.setAttribute('font-size', 4 * RS + 'pt');\n\n    text.setHeight = function (height) {\n      text.setAttribute('y', height * offset_scale);\n      text.setAttribute('font-size', 4 * RS / renderer.zoom + 'pt');\n    };\n\n    this._layer_containers[layerName].push(text);\n  }\n\n  plot.setHeight = function (height) {\n    var path_vals = recalculate_plot(0.5 * height / RS);\n    plot.setAttribute('d', 'M0 0 M0 0 m0 ' + height * offset_scale + ' m0 ' + 0.5 * height * height_scale + ' ' + path_vals);\n    plot.setAttribute('stroke-width', (options.thickness || 0.35) * RS / renderer.zoom);\n  };\n\n  return plot;\n};\n\n(function () {\n  var addElementToLayer = function addElementToLayer(layerName, opts) {\n    var canvas = this._renderer._canvas;\n\n    if (!canvas) {\n      var orig_func = arguments.callee;\n      var self = this;\n      _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(this._renderer, 'sequencechange', function () {\n        _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(this._renderer, 'sequencechange', arguments.callee);\n        orig_func.call(self, layerName);\n      });\n      log(\"Delaying rendering, waiting for sequence change\");\n      return;\n    }\n\n    var tracer = null;\n    var tracer_marker = null;\n    var renderer = this._renderer;\n\n    if (!opts) {\n      opts = {};\n    }\n\n    var scale = 1;\n\n    if (opts.height) {\n      opts.height = parseFloat(opts.height);\n\n      if (typeof opts.height !== 'undefined' && opts.bare_element) {\n        opts.height *= 2;\n      }\n\n      scale = opts.height / this._renderer._layer_containers[layerName].track_height;\n\n      if (typeof opts.offset !== 'undefined') {\n        opts.offset = -1.25 - 1.25 + opts.offset / opts.height * 5; // ( -250/4 + (x / height) * 250 ) where 250 is growing marker height\n      }\n    }\n\n    var tracer_marker = canvas.growingMarker(0, 0, opts.content || layerName.charAt(0).toUpperCase(), opts);\n    tracer_marker.setAttribute('transform', 'translate(' + (this._index + 0.5) * this._renderer._RS + ',0.01) scale(' + scale + ')');\n    tracer_marker.setAttribute('height', '250');\n    tracer_marker.firstChild.setAttribute('transform', 'translate(-100,0) rotate(0,100,0.001)');\n\n    if (opts.break_viewbox) {\n      tracer_marker.container.removeAttribute('viewBox');\n      tracer_marker.container.setAttribute('width', '100%');\n      tracer_marker.container.setAttribute('height', '100%');\n    }\n\n    if (!opts.no_tracer) {\n      var bobble = canvas.circle(this._index + 0.5, 10, 0.25);\n      bobble.setAttribute('visibility', 'hidden');\n      bobble.style.opacity = '0.4';\n      tracer = canvas.rect(this._index + 0.5, 10, 0.05, 0);\n      tracer._index = this._index;\n      tracer.style.strokeWidth = '0';\n      tracer.style.fill = _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].layers[layerName].color;\n      tracer.setAttribute('visibility', 'hidden');\n      canvas.insertBefore(tracer, canvas.firstChild.nextSibling);\n      var renderer = this._renderer;\n\n      if (!this._renderer._layer_containers[layerName].tracers) {\n        this._renderer._layer_containers[layerName].tracers = canvas.set();\n      }\n\n      if (!canvas.tracers) {\n        canvas.tracers = canvas.set();\n\n        canvas._visibleTracers = function () {\n          return renderer._visibleTracers();\n        };\n      }\n\n      tracer.setHeight = function (height) {\n        if (tracer.getAttribute('visibility') == 'hidden') {\n          return;\n        }\n\n        var transform_attr = tracer_marker.getAttribute('transform');\n        var matches = /translate\\(.*[,\\s](.*)\\) scale\\((.*)\\)/.exec(transform_attr);\n\n        if (matches[1] && matches[2]) {\n          var scale = parseFloat(matches[2]);\n          var y = parseFloat(matches[1]);\n          var new_height = y + scale * ((tracer_marker.offset || 0) * 50 + 125) - parseInt(this.getAttribute('y'));\n          this.setAttribute('height', new_height < 0 ? 0 : new_height);\n        } else {\n          this.setAttribute('height', height);\n        }\n      };\n\n      this._renderer._layer_containers[layerName].tracers.push(tracer);\n\n      this._renderer._layer_containers[layerName].tracers.push(bobble);\n\n      tracer.setAttribute('pointer-events', 'none');\n      bobble.setAttribute('pointer-events', 'none');\n      canvas.tracers.push(tracer);\n    }\n\n    if (typeof opts.offset == 'undefined' || opts.offset === null) {// tracer_marker.offset = 2.5*this._renderer._layer_containers[layerName].track_height;\n    } else {\n      tracer_marker.offset = opts.offset;\n    } // tracer_marker.setAttribute('transform','scale(0.5)');\n    // tracer_marker.zoom_level = 'text';\n\n\n    tracer_marker.setAttribute('visibility', 'hidden');\n\n    this._renderer._layer_containers[layerName].push(tracer_marker);\n\n    var result = [tracer, tracer_marker, bobble];\n    tracer_marker.setAttribute('class', layerName);\n\n    result.move = function (x, width) {\n      var transform_attr = tracer_marker.getAttribute('transform');\n      var matches = /translate\\(.*[,\\s](.*)\\) scale\\((.*)\\)/.exec(transform_attr);\n\n      if (matches[1] && matches[2]) {\n        tracer_marker.setAttribute('transform', 'translate(' + (x + 0.5) * renderer._RS + ',' + matches[1] + ') scale(' + matches[2] + ')');\n      }\n\n      if (tracer) {\n        tracer.move(x + 0.5, 0.05);\n        bobble.move(x + 0.5);\n      }\n    };\n\n    if (tracer) {\n      tracer_marker.tracer = tracer;\n      tracer_marker.bobble = bobble;\n    }\n\n    this._renderer._layer_containers[layerName].push(result);\n\n    return result;\n  };\n\n  var addBoxOverlayToElement = function addBoxOverlayToElement(layerName, width, fraction, opts) {\n    var canvas = this._renderer._canvas;\n    var renderer = this._renderer;\n\n    if (!opts) {\n      opts = {};\n    }\n\n    if (typeof fraction === 'undefined' || fraction === null) {\n      fraction = typeof opts.opacity !== 'undefined' ? opts.opacity : 1;\n    }\n\n    if (!canvas) {\n      var orig_func = arguments.callee;\n      var self = this;\n      _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(this._renderer, 'sequencechange', function () {\n        _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(this._renderer, 'sequencechange', arguments.callee);\n        orig_func.call(self, layerName, width, opts);\n      });\n      log(\"Delaying rendering, waiting for sequence change\");\n      return;\n    }\n\n    var rect = canvas.rect(-0.25 + this._index, 60, width || 1, opts.height || 4, opts);\n    var rect_x = parseFloat(rect.getAttribute('x'));\n    var rect_max_x = rect_x + parseFloat(rect.getAttribute('width'));\n    var container = this._renderer._layer_containers[layerName];\n\n    if (typeof opts.merge !== 'undefined' && opts.merge) {\n      for (var i = 0; i < container.length; i++) {\n        if (container[i].value != fraction) {\n          continue;\n        }\n\n        var el_x = parseFloat(container[i].getAttribute('x'));\n        var el_max_x = el_x + parseFloat(container[i].getAttribute('width'));\n\n        if (el_x <= rect_x && rect_x <= el_max_x || rect_x <= el_x && el_x <= rect_max_x) {\n          container[i].setAttribute('x', \"\" + Math.min(el_x, rect_x));\n          container[i].setAttribute('width', \"\" + (Math.max(el_max_x, rect_max_x) - Math.min(el_x, rect_x)));\n          rect.parentNode.removeChild(rect);\n          return container[i];\n        }\n      }\n    }\n\n    this._renderer._layer_containers[layerName].push(rect);\n\n    rect.setAttribute('class', layerName);\n    rect.setAttribute('visibility', 'hidden');\n    rect.setAttribute('stroke-width', '0px');\n\n    if (typeof fraction !== 'undefined') {\n      rect.setAttribute('opacity', fraction);\n      rect.value = fraction;\n    }\n\n    rect.setAttribute('fill', opts.fill || _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].layers[layerName].color);\n    rect.position_start = this._index;\n    rect.position_end = this._index + width;\n\n    if (typeof opts.offset !== \"undefined\" || opts.height_scale) {\n      var offset_val = opts.offset;\n\n      rect.setHeight = function (hght) {\n        var height_val = opts.height ? opts.height * renderer._RS / renderer.zoom : hght * (opts.height_scale || 1);\n\n        if (opts.align == 'bottom') {\n          this.setAttribute('y', offset_val * renderer._RS / renderer.zoom - hght * (opts.height_scale || 1));\n          this.setAttribute('height', height_val);\n        } else {\n          this.setAttribute('y', offset_val * renderer._RS / renderer.zoom);\n          this.setAttribute('height', height_val);\n        }\n      };\n    }\n\n    return rect;\n  };\n\n  var addTextToElement = function addTextToElement(layerName, width, opts) {\n    var canvas = this._renderer._canvas;\n    var renderer = this._renderer;\n\n    if (!canvas) {\n      var orig_func = arguments.callee;\n      var self = this;\n      _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(this._renderer, 'sequencechange', function () {\n        _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(this._renderer, 'sequencechange', arguments.callee);\n        orig_func.call(self, layerName, width, opts);\n      });\n      log(\"Delaying rendering, waiting for sequence change\");\n      return;\n    }\n\n    if (!opts) {\n      opts = {};\n    }\n\n    if (opts.height) {\n      opts.height = opts.height * this._renderer._RS;\n    }\n\n    var height = opts.height || this._renderer._layer_containers[layerName].trackHeight || 4;\n    var position = this._index;\n\n    if (width > 1) {\n      position = position + Math.floor(0.5 * width);\n    }\n\n    var text_scale = 4 / 3;\n    var text = canvas.text(position, 0, opts.txt || opts.content || \"Text\");\n    text.setAttribute('font-size', text_scale * height);\n    text.cached_width = text.getComputedTextLength() / height;\n    text.setAttribute('font-weight', 'bolder');\n    text.setAttribute('fill', opts.fill || '#ffffff');\n    text.setAttribute('stroke', '#000000');\n\n    if (!(\"stroke_width\" in opts)) {\n      opts.stroke_width = 5;\n    }\n\n    text.setAttribute('stroke-width', opts.stroke_width + '');\n    text.setAttribute('style', 'font-family: ' + canvas.font_order);\n    text.firstChild.setAttribute('dy', '1.3ex');\n    text.setAttribute('text-anchor', 'middle');\n\n    if (opts.align) {\n      if (opts.align == \"left\") {\n        text.setAttribute('text-anchor', 'start');\n      }\n\n      if (opts.align == 'right') {\n        text.setAttribute('text-anchor', 'end');\n      }\n    }\n\n    if (width > 1) {\n      var clip = canvas.clipPath();\n      var mask = canvas.rect(-0.5 * width, opts.offset || 0, width, height);\n      clip.push(mask);\n      mask.removeAttribute('y');\n      var mask_id = 'id' + new Date().getTime() + \"_\" + clip.parentNode.childNodes.length;\n      clip.setAttribute('id', mask_id);\n      text.setAttribute('clip-path', 'url(#' + mask_id + ')');\n    }\n\n    if (typeof opts.offset !== 'undefined') {\n      text.setAttribute('transform', 'translate(' + text.getAttribute('x') + ',' + text.getAttribute('y') + ')');\n      text.offset = opts.offset;\n\n      text.setHeight = function (height) {\n        var top_offset = this.offset;\n        this.setAttribute('x', 0);\n        this.setAttribute('y', top_offset * renderer._RS / renderer.zoom);\n        if (mask) mask.setAttribute('y', this.getAttribute('y'));\n        this.setAttribute('stroke-width', 5 / renderer.zoom);\n\n        if (opts.height) {\n          this.setAttribute('font-size', text_scale * opts.height / renderer.zoom);\n          if (mask) mask.setAttribute('height', opts.height / renderer.zoom);\n        } else {\n          this.setAttribute('font-size', text_scale * height);\n          if (mask) mask.setAttribute('height', height);\n        } // If we have a mask, we want to move the text to the left.\n\n\n        if (mask) {\n          if (this.cached_width * height > width * 50) {\n            this.setAttribute('x', -0.5 * width * 50);\n            this.setAttribute('text-anchor', 'start');\n          } else {\n            this.setAttribute('x', '0');\n            this.setAttribute('text-anchor', 'middle');\n          }\n        } else {\n          this.setAttribute('x', '0');\n          this.setAttribute('text-anchor', 'middle');\n        }\n      };\n    } else {\n      text.setHeight = function (height) {\n        text.setAttribute('stroke-width', 5 / renderer.zoom);\n\n        if (opts.height) {\n          text.setAttribute('font-size', text_scale * opts.height / renderer.zoom);\n          if (mask) mask.setAttribute('height', opts.height / renderer.zoom);\n        } else {\n          text.setAttribute('font-size', text_scale * height);\n          if (mask) mask.setAttribute('height', height);\n        }\n      };\n    }\n\n    if (width > 1) {\n      text.move = function (new_x, new_width) {\n        if (mask) mask.setAttribute('x', -1 * new_width * renderer._RS * 0.5);\n        if (mask) mask.setAttribute('width', new_width * renderer._RS);\n        text.setAttribute('x', (new_x + parseInt(0.5 * new_width)) * renderer._RS);\n      };\n    }\n\n    this._renderer._layer_containers[layerName].push(text);\n\n    return text;\n  };\n\n  var addShapeToElement = function addShapeToElement(layerName, width, opts) {\n    var canvas = this._renderer._canvas;\n    var renderer = this._renderer;\n\n    if (!canvas) {\n      var orig_func = arguments.callee;\n      var self = this;\n      _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(this._renderer, 'sequencechange', function () {\n        _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(this._renderer, 'sequencechange', arguments.callee);\n        orig_func.call(self, layerName, width, opts);\n      });\n      log(\"Delaying rendering, waiting for sequence change\");\n      return;\n    }\n\n    var methods = {\n      \"pentagon\": canvas.pentagon,\n      \"hexagon\": canvas.hexagon,\n      \"rectangle\": canvas.rect,\n      \"ellipse\": canvas.ellipticalRect,\n      \"roundrect\": function roundrect(x, y, width, height) {\n        return canvas.roundRect(x, y, width, height, 0.25 * height);\n      }\n    };\n\n    if (!opts.rotate) {\n      opts.rotate = 0;\n    }\n\n    var shape = null;\n    var shape_name = (opts.shape.split('-') || '')[0];\n\n    if (shape_name in methods) {\n      var is_rotated = opts.shape.split('-')[1];\n\n      if (is_rotated == 'left' && !opts.rotate) {\n        opts.rotate = 90;\n      }\n\n      if (is_rotated == 'right' && !opts.rotate) {\n        opts.rotate = 270;\n      }\n\n      if (is_rotated == 'flip' && !opts.rotate) {\n        opts.rotate = 180;\n      }\n\n      shape = methods[shape_name].call(canvas, this._index, 60, width || 1, opts.height || 4, opts.rotate);\n    } else {\n      return;\n    }\n\n    if (typeof opts.offset !== 'undefined') {\n      var x_pos = shape.getAttribute('x');\n      var y_pos = shape.getAttribute('y');\n      shape.setAttribute('transform', 'translate(' + x_pos + ',' + y_pos + ')');\n      shape.setAttribute('x', '0');\n      var offset_val = opts.offset || 0;\n      var orig_height = opts.height || 4;\n      shape.setAttribute('y', offset_val * this._renderer._RS);\n\n      shape.setHeight = function (height) {\n        if (!this._orig_stroke_width) {\n          this._orig_stroke_width = parseInt(this.getAttribute('stroke-width'));\n        }\n\n        shape.setAttribute('y', offset_val * renderer._RS / renderer.zoom);\n        shape.setAttribute('height', orig_height * renderer._RS / renderer.zoom);\n        shape.setAttribute('stroke-width', this._orig_stroke_width / renderer.zoom);\n\n        if (opts.shape == 'ellipse') {\n          shape.setAttribute('ry', 0.5 * (orig_height * renderer._RS) / renderer.zoom);\n        }\n\n        if (opts.shape == 'roundrect') {\n          shape.setAttribute('rx', 0.25 * (orig_height * renderer._RS) / renderer.zoom);\n          shape.setAttribute('ry', 0.25 * (orig_height * renderer._RS) / renderer.zoom);\n        }\n      };\n\n      shape.move = function (new_x, new_width) {\n        var transform_attr = this.getAttribute('transform');\n        var matches = /translate\\(.*[,\\s](.*)\\)/.exec(transform_attr);\n\n        if (matches[1]) {\n          this.setAttribute('transform', 'translate(' + new_x * renderer._RS + ',' + matches[1] + ')');\n        }\n\n        this.setAttribute('width', new_width * renderer._RS);\n      };\n    }\n\n    if (typeof opts.offset !== 'undefined' && (opts.shape == \"hexagon\" || opts.shape == \"pentagon\")) {\n      var offset_val = opts.offset || 0;\n      var orig_height = opts.height || 4;\n      var adjustment_g = canvas.group();\n      adjustment_g.setAttribute('transform', shape.getAttribute('transform'));\n      adjustment_g.push(shape);\n      shape.setAttribute('transform', 'translate(0,0)');\n\n      adjustment_g.setHeight = function (height) {\n        if (!shape._orig_stroke_width) {\n          shape._orig_stroke_width = parseInt(shape.getAttribute('stroke-width')) || 0;\n        }\n\n        shape.setHeight(orig_height * renderer._RS / renderer.zoom);\n        shape.setAttribute('stroke-width', this._orig_stroke_width / renderer.zoom);\n        shape.setAttribute('transform', 'translate(0,0)');\n      };\n\n      this._renderer._layer_containers[layerName].push(adjustment_g);\n\n      adjustment_g.setAttribute('visibility', 'hidden');\n      adjustment_g.setAttribute('class', layerName);\n      adjustment_g.position_start = this._index;\n      adjustment_g.position_end = this._index + width;\n    } else {\n      this._renderer._layer_containers[layerName].push(shape);\n\n      shape.setAttribute('visibility', 'hidden');\n      shape.setAttribute('class', layerName);\n      shape.position_start = this._index;\n      shape.position_end = this._index + width;\n    }\n\n    shape.setAttribute('fill', opts.fill || _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].layers[layerName].color);\n\n    if (opts.stroke) {\n      shape.setAttribute('stroke', opts.stroke);\n    }\n\n    if (opts.stroke_width) {\n      shape.setAttribute('stroke-width', renderer._RS * opts.stroke_width);\n    } else {\n      shape.style.strokeWidth = '0';\n    }\n\n    return shape;\n  };\n\n  var addElementToLayerWithLink = function addElementToLayerWithLink(layerName, url, width) {\n    var canvas = this._renderer._canvas;\n\n    if (!canvas) {\n      var orig_func = arguments.callee;\n      var self = this;\n      _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(this._renderer, 'sequencechange', function () {\n        _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(this._renderer, 'sequencechange', arguments.callee);\n        orig_func.call(self, layerName, url, width);\n      });\n      log(\"Delaying rendering, waiting for sequence change\");\n      return;\n    }\n\n    var rect = canvas.rect(-0.25 + this._index, 60, width || 1, 4);\n\n    this._renderer._layer_containers[layerName].push(rect);\n\n    rect.style.strokeWidth = '0px';\n    rect.setAttribute('fill', _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].layers[layerName].color);\n    rect.setAttribute('visibility', 'hidden');\n    rect.setAttribute('class', layerName);\n    return rect;\n  };\n\n  var addCalloutToLayer = function addCalloutToLayer(layerName, element, opts) {\n    var canvas = this._renderer._canvas;\n    var renderer = this._renderer;\n\n    if (typeof element == 'string') {\n      var a_el = document.createElement('div');\n      renderer.fillTemplate(element, opts, function (err, el) {\n        a_el.innerHTML = el;\n      });\n      element = a_el;\n    }\n\n    if (!canvas) {\n      var orig_func = arguments.callee;\n      var self = this;\n      _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(this._renderer, 'sequencechange', function () {\n        _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(this._renderer, 'sequencechange', arguments.callee);\n        orig_func.call(self, layerName, width, opts);\n      });\n      log(\"Delaying rendering, waiting for sequence change\");\n      return;\n    }\n\n    var callout = canvas.callout(this._index + 0.5, 0.01, element, {\n      'width': 10 * opts.width || 100,\n      'height': opts.height * 10 || 100,\n      'align': opts.align,\n      'font-size': opts['font-size']\n    });\n    callout.setHeight(opts.height * this._renderer._RS);\n    this._renderer._canvas_callout_padding = Math.max(10 * opts.height || 100, this._renderer._canvas_callout_padding || 0);\n\n    this._renderer._layer_containers[layerName].push(callout);\n\n    callout.clear = function () {\n      var cont = renderer._layer_containers[layerName];\n\n      if (cont.indexOf(callout) > 0) {\n        cont.splice(cont.indexOf(callout), 1);\n      }\n\n      callout.parentNode.removeChild(callout);\n    };\n\n    return callout;\n  };\n\n  var scaledAddShapeOverlay = function scaledAddShapeOverlay(layername, width, opts) {\n    var start = this._index;\n    var end = Math.abs(this._renderer.scalePosition(this.original_index + width, layername)) - 1;\n    var res = addShapeToElement.call(start < end ? this : this._renderer._sequence_els[end], layername, Math.abs(end - start), opts);\n    res.aa = this.original_index;\n    res.aa_width = width;\n    return res;\n  };\n\n  var scaledAddBoxOverlay = function scaledAddBoxOverlay(layername, width, fraction, opts) {\n    var start = this._index;\n    var end = Math.abs(this._renderer.scalePosition(this.original_index + width, layername)) - 1;\n    var res = addBoxOverlayToElement.call(start < end ? this : this._renderer._sequence_els[end], layername, Math.abs(end - start), fraction, opts);\n\n    if (!(opts || {}).merge) {\n      res.aa_width = width;\n      res.aa = this.original_index;\n    } else {\n      res.aa_width = parseInt(res.getAttribute('width')) / this._renderer._RS;\n\n      if (res.aa_width == width) {\n        res.aa = this.original_index;\n      }\n    }\n\n    return res;\n  };\n\n  var scaledAddTextOverlay = function scaledAddTextOverlay(layername, width, opts) {\n    var start = this._index;\n    var end = Math.abs(this._renderer.scalePosition(this.original_index + width, layername)) - 1;\n    var res = addTextToElement.call(start < end ? this : this._renderer._sequence_els[end], layername, Math.abs(end - start), opts);\n    res.aa = this.original_index;\n    res.aa_width = width;\n    return res;\n  };\n\n  var scaledAddToLayerWithLink = function scaledAddToLayerWithLink(layername, url, width) {\n    var start = this._index;\n    var end = Math.abs(this._renderer.scalePosition(this.original_index + width, layername)) - 1;\n    var res = addElementToLayerWithLink.call(start < end ? this : this._renderer._sequence_els[end], layername, url, Math.abs(end - start));\n    res.aa = this.original_index;\n    return res;\n  };\n\n  var scaledAddToLayer = function scaledAddToLayer(layername, opts) {\n    var res = addElementToLayer.call(this, layername, opts);\n    res.aa = this.original_index;\n    res.aa_width = 1;\n    return res;\n  };\n\n  CondensedSequenceRenderer.prototype.enableScaling = function () {\n    _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(this, 'readerRegistered', function (reader) {\n      console.log('Enabling scaling for legacy readers');\n      var old_result = reader.gotResult;\n      var renderer = this;\n\n      reader.gotResult = function () {\n        var wanted_id = reader.acc || reader.agi || \"\";\n        var old_get_aas = CondensedSequenceRenderer.prototype.getAminoAcidsByPosition;\n        var old_get_pep = CondensedSequenceRenderer.prototype.getAminoAcidsByPeptide;\n        var old_sequence = renderer.sequence;\n\n        if (renderer.sequences) {\n          renderer.sequence = (renderer.sequences[renderer.sequences.map(function (seq) {\n            return (seq.agi || seq.acc || \"\").toLowerCase();\n          }).indexOf(wanted_id.toLowerCase())] || \"\").toString();\n        } else {\n          old_sequence = null;\n        }\n\n        renderer.getAminoAcidsByPosition = function (aas, lay, accession) {\n          if (!lay && !accession) {\n            console.log('Guessing scaling identifier as', wanted_id);\n          }\n\n          return old_get_aas.call(this, aas, lay || wanted_id, accession || wanted_id);\n        };\n\n        renderer.getAminoAcidsByPeptide = function (peptide, lay, accession) {\n          if (!lay && !accession) {\n            console.log('Guessing scaling identifier as', wanted_id);\n          }\n\n          return old_get_pep.call(this, peptide, lay || wanted_id, accession || wanted_id);\n        };\n\n        old_result.call(reader);\n\n        if (old_sequence) {\n          renderer.sequence = old_sequence;\n        }\n\n        renderer.getAminoAcidsByPosition = old_get_aas;\n        renderer.getAminoAcidsByPeptide = old_get_pep;\n      };\n    });\n  };\n\n  CondensedSequenceRenderer.prototype._extendElement = function (el) {\n    el.addToLayer = scaledAddToLayer;\n    el.addBoxOverlay = scaledAddBoxOverlay;\n    el.addShapeOverlay = scaledAddShapeOverlay;\n    el.addTextOverlay = scaledAddTextOverlay;\n    el.addToLayerWithLink = scaledAddToLayerWithLink;\n    el.callout = addCalloutToLayer;\n    el['_renderer'] = this;\n  };\n\n  CondensedSequenceRenderer.prototype.remove = function (lay, el) {\n    if (!el) {\n      return false;\n    }\n\n    if (this._layer_containers[lay] && this._layer_containers[lay].indexOf(el) >= 0) {\n      this._layer_containers[lay].splice(this._layer_containers[lay].indexOf(el), 1);\n\n      _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(el, 'removed');\n\n      if (el.parentNode) {\n        el.parentNode.removeChild(el);\n      }\n\n      if (el.tracer && el.tracer.parentNode) {\n        el.tracer.parentNode.removeChild(el.tracer);\n      }\n\n      if (el.bobble && el.bobble.parentNode) {\n        el.bobble.parentNode.removeChild(el.bobble);\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n\n  var mark_groups = function mark_groups(renderer, objects) {\n    var group = [];\n    var new_objects = [];\n\n    for (i = 0; i < objects.length; i++) {\n      var current = objects[i],\n          next = null;\n\n      if (!current) {\n        continue;\n      }\n\n      if (objects[i + 1]) {\n        next = objects[i + 1];\n      }\n\n      if (!next || parseInt(next.aa) - parseInt(current.aa) > 10 || renderer.sequence.substring(current, next - 1).match(/[ST]/)) {\n        if (group.length < 3) {\n          group.push(current);\n        } else {\n          group.push(current);\n          group.forEach(function (site) {\n            site.options.zoom_level = 'text';\n          });\n          var coalesce_options = group[0].coalesce || objects[0].coalesce;\n          new_objects.push({\n            'aa': group[0].aa,\n            'type': 'shape',\n            'width': parseInt(current.aa) - parseInt(group[0].aa) + 1,\n            'options': {\n              'zoom_level': 'summary',\n              'shape': 'roundrect',\n              'fill': coalesce_options.fill,\n              'stroke': coalesce_options.stroke,\n              'stroke_width': coalesce_options.stroke_width,\n              'height': group[0].options.height,\n              'offset': group[0].options.offset\n            }\n          });\n        }\n\n        group = [];\n      } else {\n        group.push(current);\n      }\n    }\n\n    new_objects.forEach(function (obj) {\n      objects.push(obj);\n    });\n  };\n\n  CondensedSequenceRenderer.prototype.fix_icons = function (icon_ref) {\n    if (!this.icons_failed) {\n      return icon_ref;\n    }\n\n    if (typeof icon_ref === 'string') {\n      var vals = icon_ref.split('_');\n\n      if (vals[0] && this.icons_failed[vals[0].replace('#', '')]) {\n        vals[0] = this.icons_failed[vals[0].replace('#', '')] + '#';\n        var start = vals.shift();\n        console.log(icon_ref, start + vals.join('_'));\n        return start + vals.join('_');\n      }\n    }\n\n    return icon_ref;\n  };\n\n  CondensedSequenceRenderer.prototype.renderObjects = function (track, objects) {\n    var renderer = this;\n\n    if (objects.length > 0 && objects[0].coalesce) {\n      mark_groups(renderer, objects);\n    }\n\n    var results = [];\n    objects.forEach(function (object) {\n      var potential_height = object.options ? (object.options.height || renderer._layer_containers[track].track_height) + (object.options.offset + object.options.height || 0) : 0;\n\n      if (object.options && potential_height > renderer._layer_containers[track].track_height) {\n        var new_height = renderer._layer_containers[track].track_height + object.options.offset + (object.options.height || renderer._layer_containers[track].track_height);\n\n        if ((renderer._layer_containers[track].fixed_track_height || 0) < new_height) {\n          renderer._layer_containers[track].fixed_track_height = new_height;\n        }\n      }\n\n      var click_reveal;\n      var rendered;\n\n      if (object.aa && !renderer.getAA(parseInt(object.aa), track)) {\n        return;\n      }\n\n      if (typeof object.aa !== 'undefined' && isNaN(object.aa)) {\n        return;\n      }\n\n      if (object.type == \"text\") {\n        if (object.aa) {\n          if (object.width) {\n            rendered = renderer.getAA(parseInt(object.aa), track).addTextOverlay(track, object.width, object.options);\n          } else {\n            rendered = renderer.getAA(parseInt(object.aa), track).addTextOverlay(track, 1, object.options);\n          }\n        } else if (object.peptide) {\n          rendered = renderer.getAminoAcidsByPeptide(object.peptide, track).addTextOverlay(track, 1, object.options);\n        }\n      }\n\n      if (object.type === \"box\") {\n        if (object.aa) {\n          rendered = renderer.getAA(parseInt(object.aa), track).addBoxOverlay(track, parseInt(object.width), null, object.options);\n        } else if (object.peptide) {\n          rendered = renderer.getAminoAcidsByPeptide(object.peptide, track).addToLayer(track, null, object.options);\n        }\n      }\n\n      if (object.type == \"shape\") {\n        if (object.aa) {\n          rendered = renderer.getAA(parseInt(object.aa), track).addShapeOverlay(track, parseInt(object.width), object.options);\n        } else if (object.peptide) {\n          rendered = renderer.getAminoAcidsByPeptide(object.peptide, track)[0].addShapeOverlay(track, object.peptide.length, object.options);\n        }\n      }\n\n      if (object.type == 'line') {\n        rendered = renderer.addValuesToLayer(track, object.values, object.options);\n      }\n\n      if (object.type == \"marker\") {\n        var content = (object.options || {}).content;\n        var wanted_height = object.options.height;\n\n        if (Array.isArray && Array.isArray(content)) {\n          var cloned_options_array = {};\n\n          for (var key in object.options) {\n            if (object.options.hasOwnProperty(key)) {\n              cloned_options_array[key] = object.options[key];\n            }\n          }\n\n          if (object.options.content && Array.isArray(content_data)) {\n            cloned_options_array.content = object.options.content.map(renderer.fix_icons.bind(renderer));\n          }\n\n          click_reveal = renderer.getAA(parseInt(object.aa), track).addToLayer(track, cloned_options_array);\n          click_reveal = click_reveal[1];\n          click_reveal.style.display = 'none';\n          object.options.content = object.options.alt_content;\n          content = object.options.content;\n        }\n\n        if (typeof content == 'object') {\n          var content_el;\n\n          if (content.type == \"circle\") {\n            content_el = renderer._canvas.circle(-0.5, -0.5, 1, 1);\n          }\n\n          if (content.type == 'text_circle') {\n            content_el = renderer._canvas.text_circle(0.5, 0.5, 1, content.text, content.options || {});\n            object.options.break_viewbox = true;\n          }\n\n          if (content.type == \"left_triangle\") {\n            content_el = renderer._canvas.poly('-100,0 0,-100 0,100');\n          }\n\n          if (content.type == \"right_triangle\") {\n            content_el = renderer._canvas.poly('0,100 100,0 0,-100');\n          }\n\n          [\"fill\", \"stroke\", \"stroke-width\", \"fill-opacity\", \"stroke-opacity\", \"opacity\"].forEach(function (prop) {\n            if (content[prop]) {\n              content_el.setAttribute(prop, content[prop]);\n            }\n          });\n          object.options.content = content_el;\n        }\n\n        var cloned_options = {};\n\n        for (var key in object.options) {\n          if (object.options.hasOwnProperty(key)) {\n            cloned_options[key] = object.options[key];\n          }\n        }\n\n        var content_data = (object.options || {}).content;\n\n        if (content_data && typeof content_data === 'string') {\n          cloned_options.content = renderer.fix_icons(content_data);\n        }\n\n        if (content_data && Array.isArray(content_data)) {\n          cloned_options.content = content_data.map(renderer.fix_icons.bind(renderer));\n        }\n\n        var added = renderer.getAA(parseInt(object.aa), track).addToLayer(track, cloned_options);\n\n        if (click_reveal) {\n          click_reveal.toggleReveal = function (ev) {\n            ev.stopPropagation();\n\n            if (this.style.display === 'none') {\n              this.parentNode.appendChild(this);\n              this.style.display = 'block';\n            } else {\n              this.style.display = 'none';\n            }\n\n            renderer.refresh();\n          };\n\n          added[1].addEventListener('touchstart', click_reveal.toggleReveal.bind(click_reveal), true);\n          added[1].addEventListener('click', click_reveal.toggleReveal.bind(click_reveal), false);\n        }\n\n        rendered = added[1];\n      }\n\n      if ((object.options || {}).zoom_level) {\n        rendered.zoom_level = object.options.zoom_level;\n      }\n\n      if (object.identifier) {\n        rendered.setAttribute('identifier', object.identifier);\n      }\n\n      if ((object.options || {}).events && rendered) {\n        object.options.events.forEach(function (ev) {\n          (ev.type || \"\").split(\",\").forEach(function (evtype) {\n            if (evtype == 'click' && rendered.style) {\n              rendered.style.cursor = 'pointer';\n            }\n\n            rendered.addEventListener(evtype, function (e) {\n              e.event_data = ev.data;\n              e.layer = track;\n              e.aa = object.aa;\n            });\n          });\n        });\n      }\n\n      results.push(rendered);\n    });\n    return results;\n  };\n\n  CondensedSequenceRenderer.prototype.addTextTrack = function (seq, container) {\n    var RS = this._RS;\n    var renderer = this;\n    var max_length = 300;\n    var canvas = renderer._canvas;\n    var seq_chars = seq.split('');\n    var amino_acids = canvas.set();\n    var amino_acids_shown = false;\n    var x = 0;\n    var has_textLength = true;\n\n    var no_op = function no_op() {};\n\n    try {\n      var test_el = document.createElementNS(svgns, 'text');\n      test_el.setAttribute('textLength', 10);\n      no_op(test_el.textLength);\n    } catch (e) {\n      has_textLength = false;\n    }\n    /* We used to test to see if there was a touch event\n       when doing the textLength method of amino acid\n       layout, but iOS seems to support this now.\n       \n       Test case for textLength can be found here\n       \n       http://jsfiddle.net/nkmLu/11/embedded/result/\n    */\n\n    /* We also need to test for support for adjusting textLength\n       while also adjusting the dx value. Internet Explorer 10\n       squeezes text when setting a dx value as well as a textLength.\n       I.e. the right-most position of the character is calculated to\n       be x + textLength, rather than x + dx + textLength.\n     */\n\n\n    var supports_dx = false;\n\n    if (typeof _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].supports_dx !== 'undefined') {\n      supports_dx = _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].supports_dx;\n    } else {\n      (function (supports_textLength) {\n        if (!supports_textLength) {\n          supports_dx = false;\n          return;\n        }\n\n        var test_el = document.createElementNS(svgns, 'text');\n        test_el.setAttribute('textLength', 30);\n\n        if (!test_el.getExtentOfChar) {\n          return;\n        }\n\n        test_el.setAttribute('x', '0');\n        test_el.setAttribute('y', '0');\n        test_el.textContent = 'ABC';\n        canvas.appendChild(test_el);\n        var extent = test_el.getExtentOfChar(2).x;\n        test_el.setAttribute('dx', '10');\n\n        if (Math.abs(test_el.getExtentOfChar(2).x - extent) < 9.5) {\n          supports_dx = false;\n        } else {\n          supports_dx = true;\n        }\n\n        _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].supports_dx = supports_dx;\n        test_el.parentNode.removeChild(test_el);\n      })(has_textLength);\n    }\n\n    var a_text;\n\n    if (has_textLength && 'lengthAdjust' in document.createElementNS(svgns, 'text') && 'textLength' in document.createElementNS(svgns, 'text')) {\n      if (seq.length <= max_length) {\n        a_text = canvas.text(0, 12, document.createTextNode(seq));\n        a_text.setAttribute('textLength', RS * seq.length);\n      } else {\n        a_text = canvas.text(0, 12, document.createTextNode(seq.substr(0, max_length)));\n        a_text.setAttribute('textLength', RS * max_length);\n      }\n\n      canvas.insertBefore(a_text, canvas.firstChild.nextSibling);\n      a_text.style.fontFamily = \"'Lucida Console', 'Courier New', Monaco, monospace\";\n      a_text.setAttribute('lengthAdjust', 'spacing');\n      a_text.setAttribute('text-anchor', 'start');\n      a_text.setAttribute('dx', 5);\n      a_text.setAttribute('dy', '1.5ex');\n      a_text.setAttribute('font-size', RS);\n      a_text.setAttribute('fill', '#000000');\n      amino_acids.push(a_text);\n      container.push(a_text);\n    } else {\n      for (var i = 0; i < seq_chars.length; i++) {\n        a_text = canvas.text(x, 12, seq_chars[i]);\n        a_text.firstChild.setAttribute('dy', '1.5ex');\n        amino_acids.push(a_text);\n        container.push(a_text);\n        a_text.style.fontFamily = \"'Lucida Console', Monaco, monospace\";\n        x += 1;\n      }\n\n      amino_acids.attr({\n        'width': RS,\n        'text-anchor': 'start',\n        'height': RS,\n        'font-size': RS,\n        'fill': '#000000'\n      });\n    }\n\n    var update_sequence = function update_sequence() {\n      if (seq.length <= max_length) {\n        return;\n      }\n\n      var container_width = renderer._container_canvas.parentNode.cached_width;\n\n      if (!container_width) {\n        container_width = renderer._container_canvas.parentNode.getBoundingClientRect().width;\n        var docwidth = document.documentElement.clientWidth;\n\n        if (docwidth > container_width) {\n          container_width = docwidth;\n        }\n      }\n\n      let max_size = Math.ceil(10 * container_width * renderer.zoom / RS);\n\n      if (max_size > seq.length) {\n        max_size = seq.length;\n      }\n\n      a_text.setAttribute('textLength', RS * max_size);\n      var start = parseInt(renderer.leftVisibleResidue());\n      start -= 50;\n\n      if (start < 0) {\n        start = 0;\n      }\n\n      if (start + max_size >= seq.length) {\n        start = seq.length - max_size;\n\n        if (start < 0) {\n          start = 0;\n        }\n      }\n\n      a_text.replaceChild(document.createTextNode(seq.substr(start, max_size)), a_text.firstChild);\n      a_text.setAttribute(supports_dx ? 'dx' : 'x', 5 + start * RS);\n    };\n\n    var panstart = function panstart() {\n      if (amino_acids_shown) {\n        amino_acids.attr({\n          'display': 'none'\n        });\n      }\n    };\n\n    var panend = function panend() {\n      if (amino_acids_shown) {\n        amino_acids.attr({\n          'display': 'block'\n        });\n        update_sequence();\n      }\n    };\n\n    var zoomchange = function zoomchange() {\n      if (canvas.zoom > 3.6) {\n        amino_acids.attr({\n          'display': 'block'\n        });\n        amino_acids_shown = true;\n        update_sequence();\n      } else if (canvas.zoom > 0.2) {\n        amino_acids.attr({\n          'display': 'none'\n        });\n        amino_acids_shown = false;\n      } else {\n        amino_acids.attr({\n          'display': 'none'\n        });\n        amino_acids_shown = false;\n      }\n    };\n\n    if (!container.panevents) {\n      canvas.addEventListener('panstart', panstart, false);\n      _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(canvas, 'panend', panend);\n      container.panevents = true;\n    }\n\n    _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(canvas, 'zoomChange', zoomchange, false);\n    _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(amino_acids[0], 'removed', function () {\n      canvas.removeEventListener('panstart', panstart);\n      _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(canvas, 'panend', panend);\n      _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(canvas, 'zoomChange', zoomchange);\n      delete container.panevents;\n    });\n    return amino_acids;\n  };\n\n  CondensedSequenceRenderer.prototype.renderTextTrack = function (lay, in_text) {\n    var layerName = lay;\n\n    if (typeof layerName !== 'string') {\n      layerName = lay.name;\n    }\n\n    var canvas = this._canvas;\n\n    if (!canvas || typeof layerName == 'undefined') {\n      return;\n    }\n\n    var renderer = this;\n    var container = this._layer_containers[layerName];\n    var result = this.addTextTrack(in_text, container);\n    return result;\n  };\n})();\n\nCondensedSequenceRenderer.prototype.EnableHighlights = function () {\n  var renderer = this;\n  var highlights = [];\n\n  var createNewHighlight = function createNewHighlight() {\n    var highlight = renderer._canvas.rect(0, 0, 0, '100%');\n\n    highlight.addEventListener('click', ev => {\n      ev.stopPropagation();\n      return false;\n    });\n    highlight.addEventListener('mousedown', ev => {\n      ev.stopPropagation();\n      return false;\n    });\n    highlight.addEventListener('touchstart', ev => {\n      ev.stopPropagation();\n      return false;\n    });\n    highlight.setAttribute('fill', '#ffdddd');\n    highlight.removeAttribute('stroke');\n    var pnode = highlight.parentNode;\n    pnode.insertBefore(highlight, pnode.firstChild.nextSibling);\n    highlights.push(highlight);\n  };\n\n  createNewHighlight();\n\n  renderer.moveHighlight = function () {\n    var vals = Array.prototype.slice.call(arguments);\n    var RS = this._RS;\n    var i = 0,\n        idx = 0;\n\n    for (i = 0; i < vals.length; i += 2) {\n      var from = vals[i];\n      var to = vals[i + 1];\n      var highlight = highlights[idx];\n\n      if (!highlight) {\n        createNewHighlight();\n        highlight = highlights[idx];\n      }\n\n      if (highlight.previousSibling.previousSibling && highlights.indexOf(highlight.previousSibling.previousSibling) < 0) {\n        highlight.parentNode.insertBefore(highlight, highlight.parentNode.firstChild.nextSibling);\n      }\n\n      highlight.setAttribute('x', (from - 1) * RS);\n      highlight.setAttribute('width', (to - (from - 1)) * RS);\n      highlight.setAttribute('visibility', 'visible');\n      idx += 1;\n    }\n\n    for (i = idx; i < highlights.length; i++) {\n      highlights[i].setAttribute('visibility', 'hidden');\n    }\n  };\n};\n\n(function () {\n  var bindClick = function bindClick(element, handler) {\n    if (\"ontouchstart\" in window) {\n      element.addEventListener('touchstart', function (ev) {\n        var startX = ev.touches[0].clientX;\n        var startY = ev.touches[0].clientY;\n\n        var reset = function reset() {\n          document.body.removeEventListener('touchmove', move);\n          element.removeEventListener('touchend', end);\n        };\n\n        var end = function end(ev) {\n          reset();\n          ev.stopPropagation();\n          ev.preventDefault();\n\n          if (handler) {\n            handler.call(null, ev);\n          }\n        };\n\n        var move = function move(ev) {\n          if (Math.abs(ev.touches[0].clientX - startX) > 10 || Math.abs(ev.touches[0].clientY - startY) > 10) {\n            reset();\n          }\n        }; //FIXME - PASSIVE\n\n\n        document.body.addEventListener('touchmove', move, {\n          passive: true\n        });\n        element.addEventListener('touchend', end, false);\n      }, {\n        passive: true\n      }); //FIXME - PASSIVE\n    } else {\n      element.addEventListener('click', handler, false);\n    }\n  };\n\n  var mousePosition = function mousePosition(evt) {\n    var posx = 0;\n    var posy = 0;\n\n    if (!evt) {\n      evt = window.event;\n    }\n\n    if (evt.pageX || evt.pageY) {\n      posx = evt.pageX - (document.body.scrollLeft + document.documentElement.scrollLeft);\n      posy = evt.pageY - (document.body.scrollTop + document.documentElement.scrollTop);\n    } else if (evt.clientX || evt.clientY) {\n      posx = evt.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;\n      posy = evt.clientY + document.body.scrollTop + document.documentElement.scrollTop;\n    }\n\n    if (self.targetElement) {\n      posx = evt.screenX;\n      posy = evt.screenY;\n    }\n\n    return [posx, posy];\n  };\n\n  var svgPosition = function svgPosition(ev, svgel) {\n    var positions = mousePosition(ev.changedTouches ? ev.changedTouches[0] : ev);\n    var p = {};\n\n    if (svgel.nodeName == 'svg') {\n      p = svgel.createSVGPoint();\n      var rootCTM = svgel.getScreenCTM();\n      p.x = positions[0];\n      p.y = positions[1];\n      self.matrix = rootCTM.inverse();\n      p = p.matrixTransform(self.matrix);\n    } else {\n      p.x = positions[0];\n      p.y = positions[1];\n    }\n\n    return p;\n  };\n\n  var notifySelectionToLayers = function notifySelectionToLayers(start, end, renderer) {\n    let selections = new WeakMap();\n    selections.set(renderer, [start, end]);\n\n    for (let layname of Object.keys(renderer._layer_containers || {})) {\n      var lay = _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLayer(layname);\n      let values = [null, null];\n\n      if (start && end) {\n        values = [renderer.scalePosition(start, layname, true), renderer.scalePosition(end, layname, true)];\n      }\n\n      _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(lay, 'selection', values);\n      selections.set(lay, values);\n    }\n\n    _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(renderer, 'selection', selections);\n  };\n\n  CondensedSequenceRenderer.prototype.enableSelection = function (callback) {\n    var self = this;\n\n    if (!self._canvas) {\n      _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(self, 'sequenceChange', function () {\n        self.enableSelection();\n      });\n      return;\n    }\n\n    var canvas = self._canvas;\n    var start;\n    var end;\n    var end_func;\n    var local_start;\n    var local_end;\n    let in_drag = false;\n\n    var moving_func = function moving_func(evt) {\n      evt.preventDefault();\n      var p = svgPosition(evt, canvas);\n      end = p.x;\n\n      if (start > end) {\n        local_end = parseInt(start / 50);\n        local_start = parseInt(end / 50);\n      } else {\n        local_end = parseInt(end / 50);\n        local_start = parseInt(start / 50);\n      }\n\n      self.select(local_start + 1, local_end);\n    }; // Do not send the click event to the canvas\n    // this screws up with doing things on the selection\n    // Need alternative method to clear selection\n    //\n\n\n    bindClick(canvas, function (evt) {\n      if (!self.selecting) {\n        return;\n      }\n    });\n    canvas.addEventListener('mousedown', function (evt) {\n      if (!self.selecting) {\n        return;\n      }\n\n      in_drag = true;\n      self.select();\n      var positions = mousePosition(evt);\n      var p = {};\n\n      if (canvas.nodeName == 'svg') {\n        p = canvas.createSVGPoint();\n        var rootCTM = this.getScreenCTM();\n        p.x = positions[0];\n        p.y = positions[1];\n        self.matrix = rootCTM.inverse();\n        p = p.matrixTransform(self.matrix);\n      } else {\n        p.x = positions[0];\n        p.y = positions[1];\n      }\n\n      start = p.x;\n      end = p.x;\n      canvas.addEventListener('mousemove', moving_func, false);\n      evt.preventDefault();\n    }, false);\n    canvas.addEventListener('mouseup', function (evt) {\n      if (in_drag) {\n        notifySelectionToLayers(local_start === null ? null : local_start + 1, local_end, self);\n        local_start = null;\n        local_end = null;\n        in_drag = false;\n      }\n\n      canvas.removeEventListener('mousemove', moving_func);\n      evt.preventDefault();\n    });\n    canvas.addEventListener('touchend', function () {\n      if (in_drag) {\n        setTimeout(function () {\n          notifySelectionToLayers(local_start === null ? null : local_start + 1, local_end, self);\n          local_start = null;\n          local_end = null;\n          in_drag = false;\n        }, 500);\n      }\n\n      canvas.removeEventListener('touchmove', moving_func);\n    });\n    canvas.addEventListener('touchstart', function (evt) {\n      if (!self.selecting) {\n        return;\n      }\n\n      if (evt.changedTouches.length == 1) {\n        in_drag = true;\n        evt.preventDefault();\n        var positions = mousePosition(evt.changedTouches[0]);\n        var p = {};\n\n        if (canvas.nodeName == 'svg') {\n          p = canvas.createSVGPoint();\n          var rootCTM = this.getScreenCTM();\n          p.x = positions[0];\n          p.y = positions[1];\n          self.matrix = rootCTM.inverse();\n          p = p.matrixTransform(self.matrix);\n        } else {\n          p.x = positions[0];\n          p.y = positions[1];\n        }\n\n        start = p.x;\n        end = p.x;\n        canvas.addEventListener('touchmove', moving_func, {\n          passive: false\n        });\n      }\n    }, {\n      passive: false\n    }); //FIXME - PASSIVE\n  };\n})();\n/*\n * Get a canvas set of the visible tracers on this renderer\n */\n\n\nCondensedSequenceRenderer.prototype._visibleTracers = function () {\n  var tracers = null;\n\n  for (var i in _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].layers) {\n    if (this.isLayerActive(i) && this._layer_containers[i] && this._layer_containers[i].tracers) {\n      if (!tracers) {\n        tracers = this._layer_containers[i].tracers;\n      } else {\n        tracers.concat(this._layer_containers[i].tracers);\n      }\n    }\n  }\n\n  return tracers;\n};\n\nCondensedSequenceRenderer.prototype._resizeContainer = function () {\n  var RS = this._RS;\n\n  if (this._container && this._canvas) {\n    var width = (this.zoom || 1) * 2 * this.sequence.length;\n    var height = (this.zoom || 1) * 2 * (this._canvas._canvas_height / this._RS);\n\n    if (this._canvas_callout_padding) {\n      height += this._canvas_callout_padding;\n    }\n\n    this._canvas.setAttribute('width', width);\n\n    this._canvas.setAttribute('height', height);\n\n    this.navigation.setDimensions(width, height);\n\n    if (this.grow_container) {\n      this._container_canvas.setAttribute('height', height); // this._container.style.height = height+'px';        \n\n    } else {\n      this._container_canvas.setAttribute('height', '100%');\n\n      this._container_canvas.setAttribute('width', '100%'); // this._container.style.height = 'auto';\n\n\n      this.navigation.setZoom(this.zoom);\n    }\n  }\n};\n\n(function (clazz) {\n  var vis_change_event = function vis_change_event(renderer, visibility) {\n    var self = this;\n\n    if (!renderer._layer_containers[self.name] || renderer._layer_containers[self.name].length <= 0) {\n      return;\n    }\n\n    if (!visibility) {\n      if (renderer._layer_containers[self.name].tracers) {\n        renderer._layer_containers[self.name].tracers.hide();\n      }\n    }\n  };\n  /**\n   * Add a layer to this renderer.\n   * @param {Object} layer    Layer object to add. The layer data is used to create a track that can be independently shown/hidden.\n   *                          The track itself is by default hidden.\n   */\n\n\n  clazz.prototype.addTrack = function (layer) {\n    var RS = this._RS;\n    var renderer = this;\n\n    if (!this._canvas) {\n      _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(this, 'sequencechange', function () {\n        this.addTrack(layer);\n        _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(this, 'sequencechange', arguments.callee);\n      });\n      console.log(\"No canvas, cannot add track, waiting for sequencechange event\");\n      return;\n    }\n\n    var layer_containers = this._layer_containers || [];\n\n    if (!layer_containers[layer.name] || layer_containers[layer.name] === null) {\n      layer_containers[layer.name] = this._canvas.set();\n\n      if (!layer_containers[layer.name].track_height) {\n        layer_containers[layer.name].track_height = renderer.trackHeight || 4;\n      }\n\n      _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(layer, 'visibilityChange', vis_change_event);\n      _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(layer, 'visibilityChange', vis_change_event);\n      var event_names = ['click', 'mouseover', 'mousedown', 'mousemove', 'mouseout', 'mouseup', 'mouseenter', 'mouseleave'];\n\n      var ev_function = function ev_function(ev, original_event, element) {\n        _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(layer, ev.type, [original_event, element.position_start, element.position_end]);\n      }; // for (var i = 0 ; i < event_names.length; i++) {\n      //     bean.add(layer_containers[layer.name]._event_proxy,event_names[i],ev_function);\n      // }\n\n\n      _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(layer, 'removed');\n      _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(layer, 'removed', function (rend) {\n        if (rend) {\n          rend.removeTrack(this);\n        } else {\n          renderer.removeTrack(this);\n        }\n      });\n    }\n\n    this._layer_containers = layer_containers;\n  };\n\n  clazz.prototype.removeTrack = function (layer) {\n    if (!this._layer_containers) {\n      return;\n    }\n\n    var layer_containers = this._layer_containers || [];\n\n    if (layer_containers[layer.name]) {\n      let elements = [].concat(layer_containers[layer.name]);\n\n      for (let el of elements) {\n        this.remove(layer.name, el);\n      }\n\n      delete this._layer_containers[layer.name];\n      layer.disabled = true;\n    }\n  };\n\n  var refresh_id = 0;\n\n  clazz.prototype.disablePrintResizing = function () {\n    delete this._media_func;\n  };\n\n  clazz.prototype.enablePrintResizing = function () {\n    if (!(this.win() || window).matchMedia) {\n      return;\n    }\n\n    if (this._media_func) {\n      return this._media_func;\n    }\n\n    this._media_func = function (matcher) {\n      var self = this;\n\n      if (!self._canvas) {\n        return;\n      }\n\n      if (self.grow_container) {\n        if (matcher.matches) {\n          delete self._container_canvas.parentNode.cached_width;\n          _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(self._canvas, 'panend');\n        }\n\n        return;\n      }\n\n      var match = matcher;\n\n      if (!match.matches) {\n        if (self.old_zoom) {\n          var a_zoom = self.old_zoom;\n          self.old_zoom = null;\n          self.zoomCenter = null;\n          self.withoutRefresh(function () {\n            self.zoom = a_zoom;\n          });\n\n          self._canvas.setCurrentTranslateXY(self.old_translate, 0);\n\n          self._container_canvas.setAttribute('viewBox', self.old_viewbox); // self._container.style.height = 'auto';\n\n\n          self.old_zoom = null;\n          self.old_translate = null;\n          self.refresh();\n          _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(self._canvas, 'zoomChange');\n        }\n\n        return;\n      }\n\n      try {\n        var container = self._container;\n        self.old_translate = self._canvas.currentTranslateCache.x;\n\n        self._canvas.setCurrentTranslateXY(0, 0);\n\n        var zoomFactor = 0.95 * container.clientWidth / self.sequence.length;\n\n        if (!self.old_zoom) {\n          self.old_zoom = self.zoom;\n          self.old_viewbox = self._container_canvas.getAttribute('viewBox');\n        }\n\n        self.zoomCenter = null;\n\n        self._container_canvas.removeAttribute('viewBox');\n\n        self.withoutRefresh(function () {\n          self.zoom = zoomFactor;\n        });\n        self.refresh();\n      } catch (err) {\n        console.log(err);\n        console.log(err.stack);\n      }\n    };\n\n    var rend = this;\n\n    if (!rend._bound_media) {\n      (this.win() || window).matchMedia('print').addListener(function (matcher) {\n        if (rend._media_func) {\n          rend._media_func(matcher);\n        }\n      });\n    }\n\n    rend._bound_media = true;\n  };\n  /**\n   * Cause a refresh of the renderer, re-arranging the tracks on the canvas, and resizing the canvas if necessary.\n   * @param {Boolean} animateds Cause this refresh to be an animated refresh\n   */\n\n\n  clazz.prototype.refresh = function (animated) {\n    if (!this._canvas) {\n      return;\n    }\n\n    var layer_containers = this._layer_containers || [];\n    var RS = this._RS;\n    var track_heights = 0;\n    var order = this.trackOrder || [];\n    var fixed_font_scale = this.fixedFontScale;\n\n    if (this.navigation) {\n      this.navigation.reset();\n    }\n\n    for (var i = 0; i < order.length; i++) {\n      var name = order[i];\n      var container = layer_containers[name];\n\n      if (!container) {\n        continue;\n      }\n\n      var y_val;\n\n      if (!this.isLayerActive(name)) {\n        var attrs = {\n          'y': -1 * this._axis_height * RS,\n          'height': RS * container.track_height / this.zoom,\n          'visibility': 'hidden'\n        }; //            var attrs = { 'y' : (this._axis_height  + (track_heights - container.track_height )/ this.zoom)*RS, 'height' :  RS * container.track_height / this.zoom ,'visibility' : 'hidden' };\n\n        if (_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLayer(name).group) {\n          var controller_track = this.navigation.getController(_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLayer(name).group);\n\n          if (controller_track && this.isLayerActive(controller_track)) {\n            attrs.y = layer_containers[controller_track.name].currenty();\n          }\n        }\n\n        if (container.fixed_track_height) {\n          delete attrs.height;\n        }\n\n        if (animated) {\n          container.animate(attrs);\n        } else {\n          container.attr(attrs);\n        }\n\n        if (container.tracers) {}\n\n        continue;\n      } else {// container.attr({ 'opacity' : '1' });\n      }\n\n      var tracer_top = track_heights;\n\n      if (container.fixed_track_height) {\n        var track_height = container.fixed_track_height;\n        y_val = this._axis_height + track_heights / this.zoom;\n\n        if (animated) {\n          container.animate({\n            'visibility': 'visible',\n            'y': y_val * RS,\n            'height': RS * container.track_height / this.zoom\n          });\n        } else {\n          container.attr({\n            'visibility': 'visible',\n            'y': y_val * RS,\n            'height': RS * container.track_height / this.zoom\n          });\n        }\n\n        if (this.navigation) {\n          y_val -= 1 * container.track_height / this.zoom;\n          this.navigation.renderTrack(_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLayer(name), y_val * RS, RS * container.fixed_track_height / this.zoom, {\n            'font-scale': (fixed_font_scale || 1) * 3 * container.track_height / container.fixed_track_height\n          });\n        }\n\n        track_heights += container.fixed_track_height + this.trackGap - container.track_height;\n      } else {\n        y_val = this._axis_height + track_heights / this.zoom;\n\n        if (animated) {\n          container.animate({\n            'visibility': 'visible',\n            'y': y_val * RS,\n            'height': RS * container.track_height / this.zoom\n          });\n        } else {\n          container.attr({\n            'visibility': 'visible',\n            'y': y_val * RS,\n            'height': RS * container.track_height / this.zoom\n          });\n        }\n\n        if (this.navigation) {\n          y_val -= 1 * container.track_height / this.zoom;\n          this.navigation.renderTrack(_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLayer(name), y_val * RS, RS * 3 * container.track_height / this.zoom, fixed_font_scale ? {\n            'font-scale': fixed_font_scale\n          } : null);\n          track_heights += container.track_height;\n        }\n\n        track_heights += container.track_height + this.trackGap;\n      }\n\n      container.refresh_zoom();\n\n      if (container.tracers) {\n        var disp_style = this.isLayerActive(name) && this.zoom > 3.6 ? 'visible' : 'hidden';\n        var height = (1.5 + tracer_top / this.zoom) * RS;\n\n        if (animated) {\n          container.tracers.animate({\n            'visibility': disp_style,\n            'y': 0.65 * this._axis_height * RS,\n            'height': height\n          });\n        } else {\n          container.tracers.attr({\n            'visibility': disp_style,\n            'y': 0.65 * this._axis_height * RS,\n            'height': height\n          });\n        }\n      }\n    }\n\n    var viewBox = [-1, 0, 0, 0];\n    viewBox[0] = -2 * RS;\n    viewBox[2] = (this.sequence.split('').length + this.padding + 2) * RS;\n    viewBox[3] = (this._axis_height + track_heights / this.zoom + this.padding / this.zoom) * RS;\n\n    this._canvas.setAttribute('viewBox', viewBox.join(' '));\n\n    this._canvas._canvas_height = viewBox[3];\n    var outer_viewbox = [].concat(viewBox);\n    outer_viewbox[0] = 0;\n    outer_viewbox[2] = this.zoom * (2 * this.sequence.length) + this.padding;\n    outer_viewbox[3] = this.zoom * 2 * (this._axis_height + track_heights / this.zoom + this.padding / this.zoom);\n\n    if (!this.grow_container) {\n      this._container_canvas.setAttribute('viewBox', outer_viewbox.join(' '));\n    } else {\n      this._container_canvas.removeAttribute('viewBox');\n    }\n\n    this._resizeContainer();\n\n    viewBox[0] = 0;\n\n    if (this.navigation) {\n      if (this.grow_container) {\n        this.navigation.nav_width_base = outer_viewbox[3] < 200 ? outer_viewbox[3] : 200;\n      }\n\n      this.navigation.move_closer();\n\n      if (this.navigation.visible()) {\n        this._canvas.style.GomapScrollLeftMargin = 100 * RS / this.zoom;\n      } else {\n        this._canvas.style.GomapScrollLeftMargin = 1000;\n      }\n\n      this.navigation.setViewBox(viewBox.join(' '));\n    }\n\n    if (this.navigation) {\n      this.navigation.refresh();\n    }\n  };\n  /*\n  \n  Modified from:\n  \n  http://stackoverflow.com/questions/5433806/convert-embedded-svg-to-png-in-place\n  \n  None of the Safari browsers work with this, giving DOM Exception 18\n  \n  http://stackoverflow.com/questions/8158312/rasterizing-an-in-document-svg-to-canvas\n  \n  I think this is the relevant bug.\n  \n  https://bugs.webkit.org/show_bug.cgi?id=119492\n  \n  */\n\n\n  var svgDataURL = function svgDataURL(svg) {\n    svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n    svg.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');\n    var svgAsXML = new XMLSerializer().serializeToString(svg);\n    return \"data:image/svg+xml,\" + encodeURIComponent(svgAsXML);\n  };\n\n  clazz.prototype.pngURL = function (pngReady, out_width) {\n    //var svg = document.getElementById('foobar');//this._canvas;\n    var svg_data = this._canvas.cloneNode(true);\n\n    var sequences = svg_data.querySelectorAll('text[data-spaces]');\n\n    for (var i = 0; i < sequences.length; i++) {\n      sequences[i].parentNode.removeChild(sequences[i]);\n    } // Set up the aspect ratio of the output element\n\n\n    var svg = document.createElementNS(svgns, 'svg');\n    svg.setAttribute('width', this._container_canvas.getBoundingClientRect().width);\n    svg.setAttribute('height', this._container_canvas.getBoundingClientRect().height);\n    svg.setAttribute('preserveAspectRatio', 'xMinYMin meet');\n    var transform_group = document.createElementNS(svgns, 'g');\n    transform_group.setAttribute('transform', this._canvas.parentNode.getAttribute('transform'));\n    svg.appendChild(transform_group);\n    transform_group.appendChild(svg_data); // We are missing the defs elements from the containing node\n\n    var all_defs = this._container_canvas.querySelectorAll('defs');\n\n    for (var i = 0; i < all_defs.length; i++) {\n      svg.appendChild(all_defs[i].cloneNode(true));\n    }\n\n    var can = document.createElement('canvas');\n    var total_width = 2 * parseInt(svg.getAttribute('width'));\n    var total_height = 2 * parseInt(svg.getAttribute('height'));\n\n    if (out_width) {\n      if (total_width > out_width) {\n        var ratio = total_width / out_width;\n        total_width = out_width;\n        total_height = parseInt(total_height / ratio);\n      }\n    }\n\n    can.width = total_width;\n    can.height = total_height;\n    var svgImg = new Image();\n    svgImg.width = 1;\n    svgImg.height = 1;\n    var ctx = can.getContext('2d');\n\n    svgImg.onload = function () {\n      ctx.drawImage(svgImg, 0, 0, can.width, can.height);\n      pngReady(can.toDataURL());\n    };\n\n    svgImg.onerror = function () {\n      console.log(\"Got an error\");\n    };\n\n    var dataurl = svgDataURL(svg);\n    svgImg.src = dataurl;\n  };\n})(CondensedSequenceRenderer);\n/**\n * Zoom level has changed for this renderer\n * @name    CondensedSequenceRenderer#zoomChange\n * @event\n * @param   {Object}    e\n */\n\n\nCondensedSequenceRenderer.Zoom = function (renderer) {\n  /**\n   *  @lends CondensedSequenceRenderer.prototype\n   *  @property   {Number}    zoom        The zoom level for a renderer. Minimum zoom level is zero, and defaults to the default zoom value\n   *  @property   {Array}     trackOrder  The order of tracks on the renderer, an array of layer/group names.\n   *  @property   {Number}    padding     Padding to apply to the right and top of plots (default 10).\n   *  @property   {Number}    trackGap    Vertical gap between tracks (default 10)\n   */\n  var timeout = null;\n  var start_zoom = null;\n  var zoom_level = null;\n  var center_residue = null;\n  var start_x = null;\n  var transformer;\n  var shifter;\n  var accessors = {\n    setZoom: function setZoom(zoomLevel) {\n      var container_width = renderer._container.cached_width;\n\n      if (!container_width) {\n        container_width = renderer._container.clientWidth;\n      }\n\n      if (!renderer.sequence) {\n        zoom_level = zoomLevel;\n        return;\n      }\n\n      var min_zoom_level = container_width / (2 * renderer.sequence.length); // if  (! renderer.grow_container ) {\n      //     min_zoom_level = 0.3 / 2 * min_zoom_level;\n      // }\n      // var min_zoom_level = renderer.sequence ? (0.3 / 2) * container_width / renderer.sequence.length : 0.5;\n\n      if (zoomLevel < min_zoom_level) {\n        zoomLevel = min_zoom_level;\n      }\n\n      if (zoomLevel > 10) {\n        zoomLevel = 10;\n      }\n\n      var self = this;\n\n      if (zoomLevel == zoom_level) {\n        if (this.refresh.suspended && self._canvas && self._canvas.zoom !== parseFloat(zoom_level)) {\n          self._canvas.zoom = parseFloat(zoom_level);\n\n          self._canvas.setScale(1);\n\n          _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(self._canvas, 'zoomChange');\n        }\n\n        return;\n      }\n\n      if (!self._canvas) {\n        zoom_level = zoomLevel;\n        return;\n      }\n\n      var no_touch_center = false;\n\n      if (self.zoomCenter == 'center') {\n        no_touch_center = true;\n        self.zoomCenter = {\n          'x': self._RS * 0.5 * (self.leftVisibleResidue() + self.rightVisibleResidue())\n        };\n      }\n\n      if (self.zoomCenter && !center_residue) {\n        start_x = self._canvas.currentTranslateCache.x || 0;\n        center_residue = self.zoomCenter ? self.zoomCenter.x : 0;\n      } else if (center_residue && !self.zoomCenter) {\n        // We should not be zooming if there is a center residue and no zoomCenter;\n        return;\n      }\n\n      if (timeout) {\n        clearTimeout(timeout);\n      } else {\n        start_zoom = parseFloat(zoom_level || 1);\n      }\n\n      zoom_level = parseFloat(zoomLevel);\n      var scale_value = Math.abs(parseFloat(zoomLevel) / start_zoom);\n      window.cancelAnimationFrame(transformer);\n      transformer = window.requestAnimationFrame(function () {\n        // Rendering bottleneck\n        self._canvas.setScale(scale_value);\n      });\n      _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(self._canvas, '_anim_begin');\n\n      if (document.createEvent) {\n        var evObj = document.createEvent('Events');\n        evObj.initEvent('panstart', false, true);\n\n        self._canvas.dispatchEvent(evObj);\n      }\n\n      var old_x = self._canvas.currentTranslateCache.x;\n\n      if (center_residue) {\n        var delta = (start_zoom - zoom_level) / (scale_value * 25) * center_residue;\n        delta += start_x / scale_value;\n        cancelAnimationFrame(shifter);\n        shifter = window.requestAnimationFrame(function () {\n          // Rendering bottleneck\n          self._canvas.setCurrentTranslateXY(delta, (start_zoom - zoom_level) / scale_value * self._axis_height * 2);\n        });\n      }\n\n      var end_function = function end_function() {\n        timeout = null;\n        var scale_value = Math.abs(parseFloat(zoom_level) / start_zoom);\n\n        self._canvas.setScale(null);\n\n        _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(self._canvas, 'panend');\n        _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(self._canvas, '_anim_end');\n\n        let zoomchange = function zoomchange() {\n          _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(self._canvas, 'zoomChange', zoomchange);\n          self.refresh();\n\n          if (typeof center_residue != 'undefined') {\n            var delta = (start_zoom - zoom_level) / 25 * center_residue;\n            delta += start_x;\n\n            self._resizeContainer();\n\n            if (self._canvas.shiftPosition) {\n              self._canvas.shiftPosition(delta, 0);\n            } else {\n              self._canvas.setCurrentTranslateXY(delta, 0);\n            }\n          }\n\n          center_residue = null;\n          start_x = null;\n        };\n\n        _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(self._canvas, 'zoomChange', zoomchange);\n\n        if (self._canvas) {\n          self._canvas.zoom = parseFloat(zoom_level);\n          _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(self._canvas, 'zoomChange');\n        }\n\n        _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(self, 'zoomChange');\n      };\n\n      if (!this.refresh.suspended) {\n        timeout = setTimeout(end_function, 100);\n      } else {\n        end_function();\n      }\n    },\n    fitZoom: function fitZoom() {\n      var container_width = renderer._container.cached_width;\n\n      if (!container_width) {\n        container_width = renderer._container.clientWidth;\n      }\n\n      var min_zoom_level = 0.5;\n\n      if (renderer.sequence) {\n        min_zoom_level = container_width / (2 * renderer.sequence.length);\n      }\n\n      renderer.zoom = min_zoom_level;\n    },\n    getZoom: function getZoom() {\n      return zoom_level || 1;\n    }\n  };\n\n  if (Object.defineProperty && !_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].IE8) {\n    Object.defineProperty(renderer, \"zoom\", {\n      get: accessors.getZoom,\n      set: accessors.setZoom\n    });\n  }\n\n  renderer.fitZoom = accessors.fitZoom;\n};\n/* Add some properties that will trigger a refresh on the renderer when they are changed.\n   These are all stateless\n */\n\n\n(function (clazz) {\n  var accessors = {\n    getPadding: function getPadding() {\n      return this._padding || 10;\n    },\n    setPadding: function setPadding(padding) {\n      this._padding = padding;\n      this.refresh();\n    },\n    getTrackGap: function getTrackGap() {\n      if (!this._track_gap) {\n        var default_value = \"ontouchend\" in document ? 20 : 10;\n        this._track_gap = this._track_gap || default_value;\n      }\n\n      return this._track_gap;\n    },\n    setTrackGap: function setTrackGap(trackGap) {\n      this._track_gap = trackGap;\n      this.refresh();\n    }\n  };\n\n  if (Object.defineProperty && !_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].IE8) {\n    Object.defineProperty(clazz.prototype, \"padding\", {\n      get: accessors.getPadding,\n      set: accessors.setPadding\n    });\n    Object.defineProperty(clazz.prototype, \"trackGap\", {\n      get: accessors.getTrackGap,\n      set: accessors.setTrackGap\n    });\n  }\n})(CondensedSequenceRenderer);\n\nCondensedSequenceRenderer.Navigation = _CondensedSequenceRendererNavigation__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n/* harmony default export */ __webpack_exports__[\"default\"] = (CondensedSequenceRenderer);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vZ2F0b3IvanMvbGliL0NvbmRlbnNlZFNlcXVlbmNlUmVuZGVyZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vZ2F0b3IvanMvbGliL0NvbmRlbnNlZFNlcXVlbmNlUmVuZGVyZXIuanM/MDBiMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBAZmlsZU92ZXJ2aWV3ICAgQmFzaWMgY2xhc3NlcyBhbmQgZGVmaW5pdGlvbnMgZm9yIGFuIFNWRy1iYXNlZCBzZXF1ZW5jZSByZW5kZXJlclxuICovXG5cbmltcG9ydCBNQVNDUCBmcm9tICcuL01BU0NQJztcbmltcG9ydCBTZXF1ZW5jZVJlbmRlcmVyIGZyb20gJy4vU2VxdWVuY2VSZW5kZXJlcic7XG5pbXBvcnQgTmF2aWdhdGlvbiBmcm9tICcuL0NvbmRlbnNlZFNlcXVlbmNlUmVuZGVyZXJOYXZpZ2F0aW9uJztcbmltcG9ydCBiZWFuIGZyb20gJy4uL2JlYW4nO1xuaW1wb3J0IFNWR0NhbnZhcyBmcm9tICcuL1NWR0NhbnZhcyc7XG5cbmNvbnN0IHN2Z25zID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcblxuLyoqIERlZmF1bHQgY2xhc3MgY29uc3RydWN0b3JcbiAqICBAY2xhc3MgICAgICBSZW5kZXJzIGEgc2VxdWVuY2UgdXNpbmcgYSBjb25kZW5zZWQgdHJhY2stYmFzZWQgZGlzcGxheVxuICogIEBwYXJhbSAgICAgIHtFbGVtZW50fSBzZXF1ZW5jZUNvbnRhaW5lciBDb250YWluZXIgZWxlbWVudCB0aGF0IHRoZSBzZXF1ZW5jZSBjdXJyZW50bHkgaXMgZm91bmQgaW4sIGFuZCBhbHNvIFxuICogICAgICAgICAgICAgIHRoZSBjb250YWluZXIgdGhhdCBkYXRhIHdpbGwgYmUgcmUtaW5zZXJ0ZWQgaW50by5cbiAqICBAZXh0ZW5kcyAgICBNQVNDUC5TZXF1ZW5jZVJlbmRlcmVyXG4gKi9cbmNvbnN0IENvbmRlbnNlZFNlcXVlbmNlUmVuZGVyZXIgPSBmdW5jdGlvbihzZXF1ZW5jZUNvbnRhaW5lcikge1xuICAgIHRoaXMuX1JTID0gNTA7XG4gICAgU2VxdWVuY2VSZW5kZXJlci5hcHBseSh0aGlzLGFyZ3VtZW50cyk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gQ3JlYXRlIGEgY29tbW9uIGxheWVyIGZvciB0aGUgcHJpbWFyeSBzZXF1ZW5jZVxuICAgIE1BU0NQLnJlZ2lzdGVyTGF5ZXIoJ3ByaW1hcnlTZXF1ZW5jZScsIHsgJ2Z1bGxuYW1lJyA6ICdQcmltYXJ5IFNlcXVlbmNlJyB9KTtcblxuXG4gICAgQ29uZGVuc2VkU2VxdWVuY2VSZW5kZXJlci5ab29tKHNlbGYpO1xuICAgIHZhciByZXNpemVUaW1lb3V0O1xuICAgIHZhciByZXNpemVfY2FsbGJhY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VxdWVuY2VDb250YWluZXIuY2FjaGVkX3dpZHRoID0gc2VxdWVuY2VDb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJyxmdW5jdGlvbigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHJlc2l6ZVRpbWVvdXQpO1xuICAgICAgICBpZiAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShyZXNpemVfY2FsbGJhY2spXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNpemVUaW1lb3V0ID0gc2V0VGltZW91dChyZXNpemVfY2FsbGJhY2ssMTAwKTtcbiAgICAgICAgfVxuICAgIH0sdHJ1ZSk7XG4gICAgc2VxdWVuY2VDb250YWluZXIuY2FjaGVkX3dpZHRoID0gc2VxdWVuY2VDb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG5cbiAgICAvLyBXZSB3YW50IHRvIHVuYmluZCB0aGUgZGVmYXVsdCBoYW5kbGVyIGZvciBzZXF1ZW5jZSBjaGFuZ2UgdGhhdCB3ZSBnZXQgZnJvbVxuICAgIC8vIGluaGVyaXRpbmcgZnJvbSBDb25kZW5zZWRTZXF1ZW5jZVJlbmRlcmVyXG4gICAgYmVhbi5yZW1vdmUodGhpcywnc2VxdWVuY2VDaGFuZ2UnKTtcblxuICAgIGJlYW4uYWRkKHRoaXMsJ3NlcXVlbmNlQ2hhbmdlJyxmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgbGF5ZXJuYW1lIGluIE1BU0NQLmxheWVycykge1xuICAgICAgICAgICAgaWYgKE1BU0NQLmxheWVycy5oYXNPd25Qcm9wZXJ0eShsYXllcm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgTUFTQ1AubGF5ZXJzW2xheWVybmFtZV0uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNlbGYuem9vbSA9IHNlbGYuem9vbTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuQ29uZGVuc2VkU2VxdWVuY2VSZW5kZXJlci5wcm90b3R5cGUgPSBuZXcgU2VxdWVuY2VSZW5kZXJlcigpO1xuXG4oZnVuY3Rpb24oY2xhenopIHtcbiAgICB2YXIgY3JlYXRlQ2FudmFzT2JqZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHRoaXMuX29iamVjdCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdmd3ZWIgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBzdmd3ZWIucmVtb3ZlQ2hpbGQodGhpcy5fb2JqZWN0LCB0aGlzLl9vYmplY3QucGFyZW50Tm9kZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX29iamVjdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX29iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jYW52YXMgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fb2JqZWN0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FudmFzO1xuICAgICAgICBpZiAoIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoXCJodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0Jhc2ljU3RydWN0dXJlXCIsIFwiMS4xXCIpICkge1xuICAgICAgICAgICAgdmFyIG5hdGl2ZV9jYW52YXMgPSB0aGlzLndpbigpLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzdmducywnc3ZnJyk7XG4gICAgICAgICAgICBuYXRpdmVfY2FudmFzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCcxMDAlJyk7XG4gICAgICAgICAgICBuYXRpdmVfY2FudmFzLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywnMTAwJScpO1xuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKG5hdGl2ZV9jYW52YXMpO1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzID0gbmF0aXZlX2NhbnZhcztcbiAgICAgICAgICAgIGNhbnZhcyA9IHtcbiAgICAgICAgICAgICAgICAnYWRkRXZlbnRMaXN0ZW5lcicgOiBmdW5jdGlvbihuYW1lLGxvYWRfZnVuYykge1xuICAgICAgICAgICAgICAgICAgICBuYXRpdmVfY2FudmFzLmNvbnRlbnREb2N1bWVudCA9IHsgJ3Jvb3RFbGVtZW50JyA6IG5hdGl2ZV9jYW52YXMgfTtcbiAgICAgICAgICAgICAgICAgICAgbG9hZF9mdW5jLmNhbGwobmF0aXZlX2NhbnZhcyk7XG4gICAgICAgICAgICAgICAgfSAgICAgICAgICAgIFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJyxmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXJfY2FudiA9IHRoaXM7XG4gICAgICAgICAgICBTVkdDYW52YXMoY29udGFpbmVyX2NhbnYpO1xuICAgICAgICAgICAgaWYgKHJlbmRlcmVyLmZvbnRfb3JkZXIpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXJfY2Fudi5mb250X29yZGVyID0gcmVuZGVyZXIuZm9udF9vcmRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBncm91cCA9IGNvbnRhaW5lcl9jYW52Lm1ha2VFbCgnZycpO1xuICAgICAgICBcbiAgICAgICAgICAgIHZhciBjYW52ID0gY29udGFpbmVyX2NhbnYubWFrZUVsKCdzdmcnKTtcbiAgICAgICAgICAgIGNhbnYuUlMgPSByZW5kZXJlci5fUlM7XG4gICAgICAgICAgICBTVkdDYW52YXMoY2Fudik7XG4gICAgICAgICAgICBpZiAocmVuZGVyZXIuZm9udF9vcmRlcikge1xuICAgICAgICAgICAgICAgIGNhbnYuZm9udF9vcmRlciA9IHJlbmRlcmVyLmZvbnRfb3JkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBncm91cC5hcHBlbmRDaGlsZChjYW52KTtcbiAgICAgICAgICAgIGNvbnRhaW5lcl9jYW52LmFwcGVuZENoaWxkKGdyb3VwKTtcblxuICAgICAgICAgICAgdmFyIHN1cHBvcnRzX2V2ZW50cyA9IHRydWU7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vb3AgPSBjYW52LmFkZEV2ZW50TGlzdGVuZXI7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBzdXBwb3J0c19ldmVudHMgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNhbnZhc19yZWN0ID0gY2Fudi5tYWtlRWwoJ3JlY3QnLCB7ICAneCc6Jy0xMCUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd5JzonLTEwJScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3dpZHRoJzonMTIwJScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2hlaWdodCc6JzEyMCUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzdHlsZSc6J2ZpbGw6ICNmZmZmZmY7J30pO1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICAgICAgdmFyIGxlZnRfZmFkZSA9IGNvbnRhaW5lcl9jYW52Lm1ha2VFbCgncmVjdCcseyAgICAgICd4JzonMCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3knOicwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnd2lkdGgnOic1MCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2hlaWdodCc6JzEwMCUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzdHlsZSc6J2ZpbGw6IHVybCgjbGVmdF9mYWRlKTsnfSk7XG5cbiAgICAgICAgICAgIHZhciByaWdodF9mYWRlID0gY29udGFpbmVyX2NhbnYubWFrZUVsKCdyZWN0Jyx7ICAgICAneCc6JzEwMCUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd5JzonMCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3dpZHRoJzonMjUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdoZWlnaHQnOicxMDAlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndHJhbnNmb3JtJzondHJhbnNsYXRlKC0xNSwwKScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3N0eWxlJzonZmlsbDogdXJsKCNyaWdodF9mYWRlKTsnfSk7XG5cbiAgICAgICAgICAgIGNvbnRhaW5lcl9jYW52LmFwcGVuZENoaWxkKGxlZnRfZmFkZSk7XG4gICAgICAgICAgICBjb250YWluZXJfY2Fudi5hcHBlbmRDaGlsZChyaWdodF9mYWRlKTtcblxuICAgICAgICAgICAgYmVhbi5hZGQoY2FudiwncGFuJyxmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2Fudi5jdXJyZW50VHJhbnNsYXRlQ2FjaGUueCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRfZmFkZS5zZXRBdHRyaWJ1dGUoJ3Zpc2liaWxpdHknLCdoaWRkZW4nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0X2ZhZGUuc2V0QXR0cmlidXRlKCd2aXNpYmlsaXR5JywndmlzaWJsZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVuZGVyZXIucmlnaHRWaXNpYmxlUmVzaWR1ZSgpIDwgcmVuZGVyZXIuc2VxdWVuY2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0X2ZhZGUuc2V0QXR0cmlidXRlKCd2aXNpYmlsaXR5JywndmlzaWJsZScpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0X2ZhZGUuc2V0QXR0cmlidXRlKCd2aXNpYmlsaXR5JywnaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAgICAgYmVhbi5hZGQoY2FudiwnX2FuaW1fYmVnaW4nLGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGxlZnRfZmFkZS5zZXRBdHRyaWJ1dGUoJ3Zpc2liaWxpdHknLCdoaWRkZW4nKTtcbiAgICAgICAgICAgICAgICByaWdodF9mYWRlLnNldEF0dHJpYnV0ZSgndmlzaWJpbGl0eScsJ2hpZGRlbicpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAgICAgYmVhbi5hZGQoY2FudiwnX2FuaW1fZW5kJyxmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBiZWFuLmZpcmUoY2FudiwncGFuJyk7XG4gICAgICAgICAgICB9KTtcblxuXG4gICAgICAgICAgICBjYW52LmN1cnJlbnRUcmFuc2xhdGVDYWNoZSA9IHsgeDogMCwgeTogMCB9O1xuXG4gICAgICAgICAgICBpZiAoY2Fudi5jdXJyZW50VHJhbnNsYXRlQ2FjaGUueCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgbGVmdF9mYWRlLnNldEF0dHJpYnV0ZSgndmlzaWJpbGl0eScsJ2hpZGRlbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmlnaHRfZmFkZS5zZXRBdHRyaWJ1dGUoJ3Zpc2liaWxpdHknLCdoaWRkZW4nKTtcblxuICAgICAgICAgICAgdmFyIG5hdl9ncm91cCA9IGNvbnRhaW5lcl9jYW52Lm1ha2VFbCgnZycpO1xuICAgICAgICAgICAgY29udGFpbmVyX2NhbnYuYXBwZW5kQ2hpbGQobmF2X2dyb3VwKTtcbiAgICAgICAgICAgIHZhciBuYXZfY2FudmFzID0gY29udGFpbmVyX2NhbnYubWFrZUVsKCdzdmcnKTtcbiAgICAgICAgICAgIG5hdl9ncm91cC5hcHBlbmRDaGlsZChuYXZfY2FudmFzKTtcblxuICAgICAgICAgICAgZ3JvdXAuc3R5bGUud2lsbENoYW5nZSA9ICd0cmFuc2Zvcm0nO1xuXG4gICAgICAgICAgIGNhbnYuc2V0U2NhbGUgPSBmdW5jdGlvbihzY2FsZSkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyX3RyYW5zZm9ybSA9IChncm91cC5fY2FjaGVkX3RyYW5zZm9ybSB8fCAnJyApLnJlcGxhY2UoL3NjYWxlXFwoW15cXCldK1xcKS8sJycpO1xuICAgICAgICAgICAgICAgIGlmIChzY2FsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyX3RyYW5zZm9ybSA9ICgnIHNjYWxlKCcrc2NhbGUrJykgJyArIGN1cnJfdHJhbnNmb3JtICkucmVwbGFjZSgvXFxzKy9nLCcgJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdyb3VwLl9jYWNoZWRfdHJhbnNmb3JtID0gY3Vycl90cmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgZ3JvdXAuc3R5bGUudHJhbnNmb3JtID0gY3Vycl90cmFuc2Zvcm07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgIG5hdl9jYW52YXMuc2V0U2NhbGUgPSBmdW5jdGlvbihzY2FsZSkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyX3RyYW5zZm9ybSA9IChuYXZfZ3JvdXAuX2NhY2hlZF90cmFuc2Zvcm0gfHwgJycgKS5yZXBsYWNlKC9zY2FsZVxcKFteXFwpXStcXCkvLCcnKTtcbiAgICAgICAgICAgICAgICBpZiAoc2NhbGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3Vycl90cmFuc2Zvcm0gPSAoY3Vycl90cmFuc2Zvcm0gKyAnIHNjYWxlKCcrc2NhbGUrJykgJykucmVwbGFjZSgvXFxzKy9nLCcgJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5hdl9ncm91cC5fY2FjaGVkX3RyYW5zZm9ybSA9IGN1cnJfdHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgIG5hdl9ncm91cC5zdHlsZS50cmFuc2Zvcm0gPSBjdXJyX3RyYW5zZm9ybTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBiZWFuLmFkZChjYW52LCd6b29tQ2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICggISByZW5kZXJlci5maXhlZF9zaXplICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbnYuc2V0U2NhbGUoMSk7XG4gICAgICAgICAgICAgICAgbmF2X2NhbnZhcy5zZXRTY2FsZSgxKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29udGFpbmVyX2hlaWdodCA9IGNvbnRhaW5lcl9jYW52LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNhbnZfaGVpZ2h0ID0gY2Fudi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW50X3NjYWxlID0gKGdyb3VwLl9jYWNoZWRfdHJhbnNmb3JtIHx8ICdzY2FsZSgxKScpLm1hdGNoKC9zY2FsZVxcKChbXFxkXFwuXSspXFwpLykgfHwgJzEnO1xuICAgICAgICAgICAgICAgICAgICBjYW52LnNldFNjYWxlKCgxKmNvbnRhaW5lcl9oZWlnaHQgLyBjYW52X2hlaWdodCkudG9GaXhlZCgyKSk7XG4gICAgICAgICAgICAgICAgICAgIG5hdl9jYW52YXMuc2V0U2NhbGUoKDEqY29udGFpbmVyX2hlaWdodCAvIGNhbnZfaGVpZ2h0KS50b0ZpeGVkKDIpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYmVhbi5hZGQoY2FudiwncGFuZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBldk9iaiA9IG5ldyBFdmVudCgncGFubmVkJywge2J1YmJsZXM6IHRydWUsIGNhbmNlbGFibGU6IHRydWV9KTtcbiAgICAgICAgICAgICAgICBjYW52LmRpc3BhdGNoRXZlbnQoZXZPYmopO1xuICAgICAgICAgICAgfSk7XG5cblxuXG4gICAgICAgICAgICB2YXIgdWEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICAgICAgICAgIHZhciBpc19leHBsb3JlciA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHVhLmluZGV4T2YoJ0VkZ2UvJykgPj0gMCkge1xuICAgICAgICAgICAgICAgIGlzX2V4cGxvcmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgIGNhbnYuc2V0Q3VycmVudFRyYW5zbGF0ZVhZID0gZnVuY3Rpb24oeCx5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJfdHJhbnNmb3JtID0gZ3JvdXAuX2NhY2hlZF90cmFuc2Zvcm0gfHwgJyc7XG4gICAgICAgICAgICAgICAgY3Vycl90cmFuc2Zvcm0gPSAoY3Vycl90cmFuc2Zvcm0ucmVwbGFjZSgvdHJhbnNsYXRlXFwoW15cXCldK1xcKS8sJycpICsgJyB0cmFuc2xhdGUoJyt4KydweCwgJyt5KydweCkgJykucmVwbGFjZSgvXFxzKy9nLCcgJyk7XG4gICAgICAgICAgICAgICAgZ3JvdXAuX2NhY2hlZF90cmFuc2Zvcm0gPSBjdXJyX3RyYW5zZm9ybTtcbiAgICAgICAgICAgICAgICBpZiAoICEgaXNfZXhwbG9yZXIgKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLnN0eWxlLnRyYW5zZm9ybSA9IGN1cnJfdHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJyxjdXJyX3RyYW5zZm9ybS5yZXBsYWNlKC9weC9nLCcnKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50VHJhbnNsYXRlQ2FjaGUueCA9IHg7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50VHJhbnNsYXRlQ2FjaGUueSA9IHk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2Fudi5zZXRDdXJyZW50VHJhbnNsYXRlWFkoMCwwKTtcbiAgICAgICAgXG4gICAgICAgICAgICBuYXZfY2FudmFzLnNldEN1cnJlbnRUcmFuc2xhdGVYWSA9IGZ1bmN0aW9uKHgseSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3Vycl90cmFuc2Zvcm0gPSAobmF2X2dyb3VwLmdldEF0dHJpYnV0ZSgndHJhbnNmb3JtJykgfHwgJycpLnJlcGxhY2UoL3RyYW5zbGF0ZVxcKFteXFwpXStcXCkvLCcnKTtcbiAgICAgICAgICAgICAgICAgICAgY3Vycl90cmFuc2Zvcm0gPSBjdXJyX3RyYW5zZm9ybSArICcgdHJhbnNsYXRlKCcreCsnLCAnK3krJykgJztcbiAgICAgICAgICAgICAgICAgICAgbmF2X2dyb3VwLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJyxjdXJyX3RyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFRyYW5zbGF0ZS54ID0geDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50VHJhbnNsYXRlLnkgPSB5O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG5hdl9jYW52YXMuc2V0Q3VycmVudFRyYW5zbGF0ZVhZKDAsMCk7XG4gICAgICAgIFxuXG4gICAgICAgIFxuICAgICAgICAgICAgYWRkTmF2LmNhbGwocmVuZGVyZXIsbmF2X2NhbnZhcyk7XG5cbiAgICAgICAgICAgIHZhciBuYXYgPSByZW5kZXJlci5uYXZpZ2F0aW9uO1xuICAgICAgICAgICAgdmFyIG9sZF9zaG93ID0gbmF2LnNob3csIG9sZF9oaWRlID0gbmF2LmhpZGU7XG4gICAgICAgICAgICBuYXYuc2hvdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIG9sZF9zaG93LmFwcGx5KG5hdixhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGNhbnYuc3R5bGUuR29tYXBTY3JvbGxMZWZ0TWFyZ2luID0gMTAwICogcmVuZGVyZXIuX1JTIC8gcmVuZGVyZXIuem9vbTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICAgICAgbmF2LmhpZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBvbGRfaGlkZS5hcHBseShuYXYsYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBjYW52LnN0eWxlLkdvbWFwU2Nyb2xsTGVmdE1hcmdpbiA9IDEwMDA7XG4gICAgICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgICAgIHJlbmRlcmVyLl9jb250YWluZXJfY2FudmFzID0gY29udGFpbmVyX2NhbnY7XG4gICAgICAgICAgICBjb250YWluZXJfY2Fudi5zZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLCd4TWluWU1pbiBtZWV0Jyk7XG4gICAgICAgICAgICBjb250YWluZXJfY2Fudi5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywnMTAwJScpO1xuICAgICAgICAgICAgY29udGFpbmVyX2NhbnYuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCcxMDAlJyk7XG4gICAgICAgICAgICBjYW52LmFwcGVuZENoaWxkKGNhbnYubWFrZUVsKCdyZWN0Jywgeyd4JzowLCd5JzowLCdvcGFjaXR5JzogMCwnd2lkdGgnOicxMDAlJywnaGVpZ2h0JzonMTAwJScsJ3N0cm9rZS13aWR0aCc6JzAnLCdmaWxsJzonI2ZmZmZmZid9KSk7XG4gICAgICAgICAgICByZW5kZXJlci5fb2JqZWN0ID0gdGhpcztcbiAgICAgICAgICAgIHJlbmRlcmVyLl9jYW52YXMgPSBjYW52O1xuICAgICAgICAgICAgcmVuZGVyZXIuX2NhbnZhcy5fY2FudmFzX2hlaWdodCA9IDA7XG4gICAgICAgICAgICBiZWFuLmZpcmUocmVuZGVyZXIsJ3N2Z3JlYWR5Jyk7XG4gICAgICAgIH0sZmFsc2UpO1xuICAgIFxuICAgICAgICByZXR1cm4gY2FudmFzO1xuICAgIH07XG5cbiAgICB2YXIgd2hlZWxfZm4gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICB2YXIgYWRkTmF2ID0gZnVuY3Rpb24obmF2X2NhbnZhcykge1xuICAgICAgICB0aGlzLm5hdmlnYXRpb24gPSBuZXcgQ29uZGVuc2VkU2VxdWVuY2VSZW5kZXJlci5OYXZpZ2F0aW9uKG5hdl9jYW52YXMsdGhpcyk7XG4gICAgICAgIHZhciBuYXYgPSB0aGlzLm5hdmlnYXRpb247XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBcbiAgICAgICAgdmFyIGhpZGVfY2hyb21lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBuYXYuZGVtb3RlKCk7IFxuICAgICAgICB9O1xuICAgIFxuICAgICAgICB2YXIgc2hvd19jaHJvbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIG5hdi5wcm9tb3RlKCk7XG4gICAgICAgICAgICBuYXYucmVmcmVzaCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICggISBNQVNDUC5JRSApIHtcbiAgICAgICAgYmVhbi5hZGQodGhpcy5fY2FudmFzLCdwYW5zdGFydCcsaGlkZV9jaHJvbWUpO1xuICAgICAgICBiZWFuLmFkZCh0aGlzLl9jYW52YXMsJ3BhbmVuZCcsc2hvd19jaHJvbWUpO1xuICAgICAgICBiZWFuLmFkZCh0aGlzLl9jYW52YXMsJ19hbmltX2JlZ2luJyxoaWRlX2Nocm9tZSk7XG4gICAgICAgIGJlYW4uYWRkKHRoaXMuX2NhbnZhcywnX2FuaW1fZW5kJyxzaG93X2Nocm9tZSk7XG4gICAgICAgIG5hdl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLHdoZWVsX2ZuLGZhbHNlKTtcbiAgICAgICAgbmF2X2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsd2hlZWxfZm4sZmFsc2UpO1xuICAgICAgICBuYXZfY2FudmFzLm9ubW91c2V3aGVlbCA9IHdoZWVsX2ZuO1xuXG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBkcmF3QW1pbm9BY2lkcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzO1xuICAgICAgICB2YXIgYWFzID0gcmVuZGVyZXIuYWRkVGV4dFRyYWNrKHRoaXMuc2VxdWVuY2UsdGhpcy5fY2FudmFzLnNldCgpKTtcbiAgICAgICAgYWFzLmF0dHIoeyd5JyA6IDAuNSpyZW5kZXJlci5fYXhpc19oZWlnaHQqcmVuZGVyZXIuX1JTfSk7XG4gICAgICAgIHJlbmRlcmVyLnNlbGVjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHZhbHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgdmFyIGZyb20gPSB2YWxzWzBdO1xuICAgICAgICAgICAgdmFyIHRvID0gdmFsc1sxXTtcbiAgICAgICAgICAgIHRoaXMubW92ZUhpZ2hsaWdodC5hcHBseSh0aGlzLHZhbHMpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgem9vbWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYWFzLmF0dHIoeyd5JyA6IDAuNSpyZW5kZXJlci5fYXhpc19oZWlnaHQqcmVuZGVyZXIuX1JTfSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBjYW52YXMgPSByZW5kZXJlci5fY2FudmFzO1xuICAgICAgICBiZWFuLmFkZChjYW52YXMsJ3pvb21DaGFuZ2UnLCB6b29tY2hhbmdlKTtcbiAgICAgICAgYmVhbi5hZGQoYWFzLCdyZW1vdmVkJyxmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGJlYW4ucmVtb3ZlKGNhbnZhcywnem9vbUNoYW5nZScsem9vbWNoYW5nZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYWFzO1xuICAgIH07XG4gICAgdmFyIG1haW5EcmF3QXhpcztcbiAgICB2YXIgZHJhd0F4aXMgPSBtYWluRHJhd0F4aXMgPSBmdW5jdGlvbihjYW52YXMsbGluZUxlbmd0aCkge1xuICAgICAgICB2YXIgUlMgPSB0aGlzLl9SUztcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgeCA9IDAsIGkgPSAwO1xuICAgIFxuICAgIFxuICAgICAgICB2YXIgYXhpcyA9IGNhbnZhcy5zZXQoKTtcblxuICAgICAgICB2YXIgYXhpc19iYWNrID0gY2FudmFzLnJlY3QoMCwwLGxpbmVMZW5ndGgsMS41KTtcbiAgICAgICAgYXhpc19iYWNrLnNldEF0dHJpYnV0ZSgnZmlsbCcsXCJ1cmwoJyNcIitzZWxmLmF4aXNfcGF0dGVybl9pZCtcIicpXCIpO1xuICAgICAgICBheGlzX2JhY2sucmVtb3ZlQXR0cmlidXRlKCdzdHJva2UnKTtcbiAgICAgICAgYXhpc19iYWNrLnJlbW92ZUF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJyk7XG4gICAgICAgIGF4aXNfYmFjay5zZXRBdHRyaWJ1dGUoJ2lkJywnYXhpc19iYWNrJyk7XG5cbiAgICAgICAgdmFyIGJhc2VfYXhpc19oZWlnaHQgPSAzMDtcblxuICAgICAgICB2YXIgYWxsX2xhYmVscyA9IGNhbnZhcy5zZXQoKTtcbiAgICAgICAgdmFyIG1ham9yX21hcmtfbGFiZWxzID0gY2FudmFzLnNldCgpO1xuICAgICAgICB2YXIgbWlub3JfbWFya19sYWJlbHMgPSBjYW52YXMuc2V0KCk7XG4gICAgICAgIHZhciB0aG91c2FuZF9tYXJrX2xhYmVscyA9IGNhbnZhcy5zZXQoKTtcbiAgICAgICAgdmFyIG1pbm9yX21hcmsgPSAxMDtcbiAgICAgICAgdmFyIG1ham9yX21hcmsgPSAyMDtcbiAgICAgICAgXG4gICAgICAgIGlmICh0aGlzLnNlcXVlbmNlLmxlbmd0aCA+IDUwMDApIHtcbiAgICAgICAgICAgIG1pbm9yX21hcmsgPSAxMDA7XG4gICAgICAgICAgICBtYWpvcl9tYXJrID0gMjAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNlcXVlbmNlLmxlbmd0aCA+IDEwMDApIHtcbiAgICAgICAgICAgIG1pbm9yX21hcmsgPSAyMDtcbiAgICAgICAgICAgIG1ham9yX21hcmsgPSA0MDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IChsaW5lTGVuZ3RoLzUpOyBpKysgKSB7XG5cbiAgICAgICAgICAgIHZhciBhX3RleHQgPSBjYW52YXMudGV4dCh4LTAuNSwwLFwiXCIrKHgpKTtcbiAgICAgICAgICAgIGFsbF9sYWJlbHMucHVzaChhX3RleHQpO1xuXG4gICAgICAgICAgICBpZiAoICh4ICUgbWFqb3JfbWFyaykgPT09IDAgJiYgeCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIG1ham9yX21hcmtfbGFiZWxzLnB1c2goYV90ZXh0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKCB4ICUgbWlub3JfbWFyayApID09PSAwICYmIHggIT09IDApIHtcbiAgICAgICAgICAgICAgICBtaW5vcl9tYXJrX2xhYmVscy5wdXNoKGFfdGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoICh4ICUgKDI1MCpwYXJzZUludCh0aGlzLnNlcXVlbmNlLmxlbmd0aCAvIDUwMCkpKSA9PT0gMCAmJiB4ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhvdXNhbmRfbWFya19sYWJlbHMucHVzaChhX3RleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeCArPSA1O1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIGZvciAoIGkgPSAwOyBpIDwgYWxsX2xhYmVscy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgIGFsbF9sYWJlbHNbaV0uc3R5bGUudGV4dEFuY2hvciA9ICdtaWRkbGUnO1xuICAgICAgICAgICAgYWxsX2xhYmVsc1tpXS5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSgnZHknLCcxLjVleCcpO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIGFsbF9sYWJlbHMuYXR0cih7J3BvaW50ZXItZXZlbnRzJyA6ICdub25lJywgJ3RleHQtYW5jaG9yJyA6ICdtaWRkbGUnLCAnZm9udC1zaXplJyA6IDcqUlMrJ3B0J30pO1xuICAgICAgICBhbGxfbGFiZWxzLmhpZGUoKTtcblxuICAgICAgIHNlbGYuX2F4aXNfaGVpZ2h0ID0gcGFyc2VJbnQoIGJhc2VfYXhpc19oZWlnaHQgLyBzZWxmLnpvb20pO1xuXG4gICAgXG4gICAgICAgIHZhciB6b29tX3N0YXR1cyA9IG51bGw7XG4gICAgICAgIHZhciB6b29tY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcmVuZGVyZXIgPSBzZWxmO1xuICAgICAgICAgICAgICAgcmVuZGVyZXIuX2F4aXNfaGVpZ2h0ID0gcGFyc2VJbnQoIGJhc2VfYXhpc19oZWlnaHQgLyByZW5kZXJlci56b29tKTtcbiAgICAgICAgICAgICAgIHZhciBwYXR0ZXJuID0gcmVuZGVyZXIuX2NhbnZhcy5vd25lclNWR0VsZW1lbnQuZ2V0RWxlbWVudEJ5SWQocmVuZGVyZXIuYXhpc19wYXR0ZXJuX2lkKTtcblxuICAgICAgICAgICAgICAgdGhvdXNhbmRfbWFya19sYWJlbHMuZm9yRWFjaChmdW5jdGlvbihsYWJlbCkge1xuICAgICAgICAgICAgICAgIGxhYmVsLnNldEF0dHJpYnV0ZSgndmlzaWJpbGl0eScsJ2hpZGRlbicpO1xuICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgIGlmICh0aGlzLnpvb20gPiAzLjYpIHtcbiAgICAgICAgICAgICAgICAgICBheGlzX2JhY2suc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCd0cmFuc2xhdGUoLTUsJysoMC4zKnJlbmRlcmVyLl9heGlzX2hlaWdodCpSUykrJyknKTtcbiAgICAgICAgICAgICAgICAgICBheGlzX2JhY2suc2V0QXR0cmlidXRlKCdoZWlnaHQnLDAuMjUqcmVuZGVyZXIuX2F4aXNfaGVpZ2h0KlJTKTtcbiAgICAgICAgICAgICAgICAgICBwYXR0ZXJuLnNldEF0dHJpYnV0ZSgnd2lkdGgnLDEwKlJTKTtcbiAgICAgICAgICAgICAgICAgICBwYXR0ZXJuLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCd4Jyw5LjUqUlMpO1xuICAgICAgICAgICAgICAgICAgIHBhdHRlcm4uZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJyxSUyAvIHJlbmRlcmVyLnpvb20pO1xuXG4gICAgICAgICAgICAgICAgICAgbWlub3JfbWFya19sYWJlbHMuc2hvdygpO1xuICAgICAgICAgICAgICAgICAgIG1ham9yX21hcmtfbGFiZWxzLnNob3coKTtcbiAgICAgICAgICAgICAgICAgICB2YXIgdGV4dF9zY2FsZSA9IDAuMTUqc2VsZi5fYXhpc19oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgaWYgKHRleHRfc2NhbGUgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRfc2NhbGUgPSAxO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICBtaW5vcl9tYXJrX2xhYmVscy5hdHRyKHsgJ2ZvbnQtc2l6ZScgOiAodGV4dF9zY2FsZSpSUykrJ3B0JywgJ3RleHQtYW5jaG9yJyA6ICdlbmQnIH0pO1xuICAgICAgICAgICAgICAgICAgIG1ham9yX21hcmtfbGFiZWxzLmF0dHIoeyAnZm9udC1zaXplJyA6ICh0ZXh0X3NjYWxlKlJTKSsncHQnLCAndGV4dC1hbmNob3InIDogJ2VuZCcgfSk7XG4gICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Zpc2libGVUcmFjZXJzICYmIHRoaXMuX3Zpc2libGVUcmFjZXJzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmlzaWJsZVRyYWNlcnMoKS5zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnpvb20gPiAxLjgpIHtcblxuICAgICAgICAgICAgICAgICAgIG1pbm9yX21hcmtfbGFiZWxzLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICBtYWpvcl9tYXJrX2xhYmVscy5zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgbWFqb3JfbWFya19sYWJlbHMuYXR0cih7ICdmb250LXNpemUnIDogKDAuNSpSUypzZWxmLl9heGlzX2hlaWdodCkrJ3B0JywgJ3RleHQtYW5jaG9yJyA6ICdtaWRkbGUnIH0pO1xuICAgICAgICAgICAgICAgICAgIGF4aXNfYmFjay5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsJ3RyYW5zbGF0ZSgtMjUsJysoMC41KnJlbmRlcmVyLl9heGlzX2hlaWdodCpSUykrJyknKTtcbiAgICAgICAgICAgICAgICAgICBheGlzX2JhY2suc2V0QXR0cmlidXRlKCdoZWlnaHQnLDAuMypyZW5kZXJlci5fYXhpc19oZWlnaHQqUlMpO1xuICAgICAgICAgICAgICAgICAgIHBhdHRlcm4uc2V0QXR0cmlidXRlKCd3aWR0aCcsMjAqUlMpO1xuICAgICAgICAgICAgICAgICAgIHBhdHRlcm4uZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJyxSUyAvIHJlbmRlcmVyLnpvb20gKTtcbiAgICAgICAgICAgICAgICAgICBwYXR0ZXJuLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCd4JywnMCcpO1xuICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZXJzLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuem9vbSA+IDAuMikge1xuXG4gICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2Vycykge1xuICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlcnMuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICBtaW5vcl9tYXJrX2xhYmVscy5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgbWFqb3JfbWFya19sYWJlbHMuc2hvdygpO1xuICAgICAgICAgICAgICAgICAgIG1ham9yX21hcmtfbGFiZWxzLmF0dHIoeyAnZm9udC1zaXplJyA6ICgwLjUqUlMqc2VsZi5fYXhpc19oZWlnaHQpKydwdCcsICd0ZXh0LWFuY2hvcicgOiAnbWlkZGxlJyB9KTtcbiAgICAgICAgICAgICAgICAgICBheGlzX2JhY2suc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCd0cmFuc2xhdGUoLTI1LCcrKDAuNSpyZW5kZXJlci5fYXhpc19oZWlnaHQqUlMpKycpJyk7XG4gICAgICAgICAgICAgICAgICAgYXhpc19iYWNrLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywwLjMqcmVuZGVyZXIuX2F4aXNfaGVpZ2h0KlJTKTtcbiAgICAgICAgICAgICAgICAgICBwYXR0ZXJuLnNldEF0dHJpYnV0ZSgnd2lkdGgnLDUwKlJTKTtcbiAgICAgICAgICAgICAgICAgICBwYXR0ZXJuLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCd3aWR0aCcsUlMgLyByZW5kZXJlci56b29tKTtcblxuXG5cbiAgICAgICAgICAgICAgICAgICB2YXIgbGFzdF9yaWdodCA9IC0xMDAwMDtcbiAgICAgICAgICAgICAgICAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgIG1ham9yX21hcmtfbGFiZWxzLmZvckVhY2goZnVuY3Rpb24obGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhIGxhYmVsLmNhY2hlZF9iYm94KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbC5jYWNoZWRfYmJveCA9IGxhYmVsLmdldEJCb3goKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWwuY2FjaGVkX2Jib3gueCA8PSAobGFzdF9yaWdodCsoUlMqMTApKSB8fCAocGFyc2VJbnQobGFiZWwudGV4dENvbnRlbnQpICUgNTApICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsLnNldEF0dHJpYnV0ZSgndmlzaWJpbGl0eScsJ2hpZGRlbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbC5zZXRBdHRyaWJ1dGUoJ3Zpc2liaWxpdHknLCd2aXNpYmxlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0X3JpZ2h0ID0gbGFiZWwuY2FjaGVkX2Jib3gueCArIGxhYmVsLmNhY2hlZF9iYm94LndpZHRoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFqb3JfbWFya19sYWJlbHNbMF0uc2V0QXR0cmlidXRlKCd2aXNpYmlsaXR5JywnaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFjZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2Vycy5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgIG1pbm9yX21hcmtfbGFiZWxzLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICBtYWpvcl9tYXJrX2xhYmVscy5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgdGhvdXNhbmRfbWFya19sYWJlbHMuc2hvdygpO1xuICAgICAgICAgICAgICAgICAgIHRob3VzYW5kX21hcmtfbGFiZWxzLmF0dHIoeyAnZm9udC1zaXplJyA6ICgwLjUqUlMqc2VsZi5fYXhpc19oZWlnaHQpKydwdCcsICd0ZXh0LWFuY2hvcicgOiAnbWlkZGxlJyB9KTtcblxuICAgICAgICAgICAgICAgICAgIGF4aXNfYmFjay5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsJ3RyYW5zbGF0ZSgtNTAsJysoMC44NSpyZW5kZXJlci5fYXhpc19oZWlnaHQqUlMpKycpJyk7XG4gICAgICAgICAgICAgICAgICAgYXhpc19iYWNrLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywwLjEqcmVuZGVyZXIuX2F4aXNfaGVpZ2h0KlJTKTtcbiAgICAgICAgICAgICAgICAgICBwYXR0ZXJuLnNldEF0dHJpYnV0ZSgnd2lkdGgnLDI1MCpSUyk7XG4gICAgICAgICAgICAgICAgICAgcGF0dGVybi5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSgnd2lkdGgnLFJTIC8gcmVuZGVyZXIuem9vbSk7XG5cblxuICAgICAgICAgICAgICAgICAgIHZhciBsYXN0X3JpZ2h0ID0gLTEwMDAwO1xuICAgICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgdGhvdXNhbmRfbWFya19sYWJlbHMuZm9yRWFjaChmdW5jdGlvbihsYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoICEgbGFiZWwuY2FjaGVkX2Jib3gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsLmNhY2hlZF9iYm94ID0gbGFiZWwuZ2V0QkJveCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbC5jYWNoZWRfYmJveC54IDw9IChsYXN0X3JpZ2h0KyhSUyoxMCkpIHx8IChwYXJzZUludChsYWJlbC50ZXh0Q29udGVudCkgJSAyNTApICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsLnNldEF0dHJpYnV0ZSgndmlzaWJpbGl0eScsJ2hpZGRlbicpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWwuc2V0QXR0cmlidXRlKCd2aXNpYmlsaXR5JywndmlzaWJsZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdF9yaWdodCA9IGxhYmVsLmNhY2hlZF9iYm94LnggKyBsYWJlbC5jYWNoZWRfYmJveC53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRob3VzYW5kX21hcmtfbGFiZWxzWzBdLnNldEF0dHJpYnV0ZSgndmlzaWJpbGl0eScsJ2hpZGRlbicpO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgYmVhbi5hZGQoY2FudmFzLCd6b29tQ2hhbmdlJywgem9vbWNoYW5nZSk7XG4gICAgICAgIGJlYW4uYWRkKGF4aXMsJ3JlbW92ZWQnLGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYmVhbi5yZW1vdmUoY2FudmFzLCd6b29tQ2hhbmdlJyx6b29tY2hhbmdlKTtcbiAgICAgICAgICAgIHZhciByZW1vdmVyID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWwucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYXhpc19iYWNrLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYXhpc19iYWNrKTtcbiAgICAgICAgICAgIGFsbF9sYWJlbHMuZm9yRWFjaChyZW1vdmVyKTtcblxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGF4aXM7XG4gICAgfTtcblxuICAgIGNsYXp6LnByb3RvdHlwZS5wYW5UbyA9IGZ1bmN0aW9uKGVuZCxjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzO1xuICAgICAgICB2YXIgcG9zID0gcmVuZGVyZXIubGVmdFZpc2libGVSZXNpZHVlKCk7XG4gICAgICAgIHZhciBkZWx0YSA9IDE7XG4gICAgICAgIGlmIChwb3MgPT0gZW5kKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPiBlbmQpIHtcbiAgICAgICAgICAgIGRlbHRhID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVuZGVyZXIuc2V0TGVmdFZpc2libGVSZXNpZHVlKHBvcyk7XG4gICAgICAgICAgICBwb3MgKz0gZGVsdGE7XG4gICAgICAgICAgICBiZWFuLmZpcmUocmVuZGVyZXIuX2NhbnZhcywncGFuZW5kJyk7XG4gICAgICAgICAgICBpZiAocG9zICE9PSBlbmQpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYXJndW1lbnRzLmNhbGxlZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNsYXp6LnByb3RvdHlwZS56b29tVG8gPSBmdW5jdGlvbih6b29tLHJlc2lkdWUsY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcztcbiAgICAgICAgdmFyIGN1cnIgPSByZW5kZXJlci56b29tO1xuICAgICAgICB2YXIgZGVsdGEgPSAoem9vbSAtIGN1cnIpLzUwO1xuICAgICAgICBsZXQgem9vbWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYmVhbi5yZW1vdmUocmVuZGVyZXIsJ3pvb21DaGFuZ2UnLHpvb21jaGFuZ2UpO1xuICAgICAgICAgICAgZGVsZXRlIHJlbmRlcmVyLnpvb21DZW50ZXI7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBiZWFuLmFkZChyZW5kZXJlciwnem9vbUNoYW5nZScsem9vbWNoYW5nZSk7XG4gICAgICAgIGlmIChyZXNpZHVlKSB7XG4gICAgICAgICAgICByZW5kZXJlci56b29tQ2VudGVyID0gKHJlc2lkdWUgPT0gJ2NlbnRlcicpID8gcmVzaWR1ZSA6IHsgJ3gnIDogcmVuZGVyZXIuX1JTKnJlc2lkdWUgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLnpvb20gPSB6b29tO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB6b29tZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICByZW5kZXJlci56b29tID0gY3VycjtcbiAgICAgICAgICAgIGN1cnIgKz0gZGVsdGE7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoY3VyciAtIHpvb20pID4gMC4wMSkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh6b29tZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoem9vbWVyKTtcbiAgICB9O1xuXG4gICAgY2xhenoucHJvdG90eXBlLnNob3dSZXNpZHVlcyA9IGZ1bmN0aW9uKHN0YXJ0LGVuZCkge1xuICAgICAgICBsZXQgcmVzaWR1ZXNfcGVyX3pvb21fdW5pdCA9IHRoaXMuX2NvbnRhaW5lci5jbGllbnRXaWR0aCAvIHRoaXMuX1JTO1xuICAgICAgICBsZXQgY29udGFpbmVyX3dpZHRoID0gdGhpcy5fY29udGFpbmVyLmNsaWVudFdpZHRoO1xuICAgICAgICBsZXQgbWluX3pvb21fbGV2ZWwgPSBjb250YWluZXJfd2lkdGggLyAoMiAqIHRoaXMuc2VxdWVuY2UubGVuZ3RoKTtcblxuICAgICAgICBpZiAoICEgdGhpcy5zZXF1ZW5jZSApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBkZWx0YSA9IGVuZCAtIHN0YXJ0O1xuICAgICAgICBsZXQgdGFyZ2V0X3pvb21fbGV2ZWwgPSBtaW5fem9vbV9sZXZlbCAvICggZGVsdGEgLyB0aGlzLnNlcXVlbmNlLmxlbmd0aCApIDtcbiAgICAgICAgaWYgKHRhcmdldF96b29tX2xldmVsID09PSB0aGlzLnpvb20pIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TGVmdFZpc2libGVSZXNpZHVlKHN0YXJ0KTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnpvb21DZW50ZXIgPSB7IHg6IE1hdGguZmxvb3IoMC41KihlbmQgKyBzdGFydCkpIH07XG4gICAgICAgIGxldCB6b29tZWQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgbGV0IHpvb21jaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgYmVhbi5yZW1vdmUodGhpcywnem9vbUNoYW5nZScsem9vbWNoYW5nZSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuem9vbUNlbnRlcjtcbiAgICAgICAgICAgICAgICB0aGlzLnNldExlZnRWaXNpYmxlUmVzaWR1ZShzdGFydCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJlYW4uYWRkKHRoaXMsJ3pvb21DaGFuZ2UnLHpvb21jaGFuZ2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy56b29tID0gdGFyZ2V0X3pvb21fbGV2ZWw7XG5cbiAgICAgICAgcmV0dXJuIHpvb21lZDtcbiAgICB9O1xuXG4gICAgY2xhenoucHJvdG90eXBlLnNldExlZnRWaXNpYmxlUmVzaWR1ZSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHNlbGYuX2NhbnZhcy5zZXRDdXJyZW50VHJhbnNsYXRlWFkoKHNlbGYuX2NhbnZhcy53aWR0aC5iYXNlVmFsLnZhbHVlICogKDEgLSAodmFsIC8gKHNlbGYuc2VxdWVuY2UubGVuZ3RoK3NlbGYucGFkZGluZysyKSkpKSAtIHNlbGYuX2NhbnZhcy53aWR0aC5iYXNlVmFsLnZhbHVlLDApO1xuICAgIH07XG5cbiAgICBjbGF6ei5wcm90b3R5cGUubGVmdFZpc2libGVSZXNpZHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHZhbCA9IE1hdGguZmxvb3IoKHNlbGYuc2VxdWVuY2UubGVuZ3RoK3NlbGYucGFkZGluZysyKSooMS0oKHNlbGYuX2NhbnZhcy53aWR0aC5iYXNlVmFsLnZhbHVlICsgc2VsZi5fY2FudmFzLmN1cnJlbnRUcmFuc2xhdGVDYWNoZS54KSAvIHNlbGYuX2NhbnZhcy53aWR0aC5iYXNlVmFsLnZhbHVlKSkpLTE7XG4gICAgICAgIGlmICh2YWwgPCAwKSB7XG4gICAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcblxuICAgIGNsYXp6LnByb3RvdHlwZS5yaWdodFZpc2libGVSZXNpZHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGNvbnRhaW5lcl93aWR0aCA9IHNlbGYuX2NvbnRhaW5lcl9jYW52YXMucGFyZW50Tm9kZS5jYWNoZWRfd2lkdGg7XG4gICAgICAgIGlmICggISBjb250YWluZXJfd2lkdGggKSB7XG4gICAgICAgICAgICBjb250YWluZXJfd2lkdGggPSBzZWxmLl9jb250YWluZXJfY2FudmFzLnBhcmVudE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbCA9IE1hdGguZmxvb3Ioc2VsZi5sZWZ0VmlzaWJsZVJlc2lkdWUoKSArIChzZWxmLnNlcXVlbmNlLmxlbmd0aCtzZWxmLnBhZGRpbmcrMikqKGNvbnRhaW5lcl93aWR0aC8gc2VsZi5fY2FudmFzLndpZHRoLmJhc2VWYWwudmFsdWUpKTtcbiAgICAgICAgaWYgKHZhbCA+IHNlbGYuc2VxdWVuY2UubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YWwgPSBzZWxmLnNlcXVlbmNlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH07XG5cbiAgICBjbGF6ei5wcm90b3R5cGUuYWRkQXhpc1NjYWxlID0gZnVuY3Rpb24oaWRlbnRpZmllcixzY2FsZXIpIHtcbiAgICAgICAgaWYgKCAhIHRoaXMuX3NjYWxlcnMgKSB7XG4gICAgICAgICAgICB0aGlzLl9zY2FsZXJzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNjYWxlcnMgPSB0aGlzLl9zY2FsZXJzLmZpbHRlciggc2NhbGUgPT4gc2NhbGUuaWRlbnRpZmllciAhPT0gaWRlbnRpZmllciApO1xuICAgICAgICBzY2FsZXJzLnB1c2goc2NhbGVyKTtcbiAgICAgICAgdGhpcy5fc2NhbGVycyA9IHNjYWxlcnM7XG4gICAgICAgIHNjYWxlci5pZGVudGlmaWVyID0gaWRlbnRpZmllcjtcbiAgICAgICAgcmV0dXJuIHNjYWxlcjtcbiAgICB9O1xuXG4gICAgY2xhenoucHJvdG90eXBlLnJlZnJlc2hTY2FsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBsYXlzID0gT2JqZWN0LmtleXModGhpcy5fbGF5ZXJfY29udGFpbmVycyk7XG4gICAgICAgIGxheXMuZm9yRWFjaChmdW5jdGlvbihsYXkpIHtcbiAgICAgICAgICAgIHNlbGYuX2xheWVyX2NvbnRhaW5lcnNbbGF5XS5mb3JFYWNoKGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsLm1vdmUgJiYgZWwuYWEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFhID0gc2VsZi5zY2FsZVBvc2l0aW9uKGVsLmFhLGxheSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhYV93aWR0aCA9IHNlbGYuc2NhbGVQb3NpdGlvbihlbC5hYStlbC5hYV93aWR0aCxsYXkpIDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFhIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWEgKj0gLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFhX3dpZHRoIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWFfd2lkdGggKj0gLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWwubW92ZShhYS0xLGFhX3dpZHRoLWFhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNsYXp6LnByb3RvdHlwZS5zY2FsZVBvc2l0aW9uID0gZnVuY3Rpb24oYWEsbGF5ZXIsaW52ZXJzZSkge1xuICAgICAgICB2YXIgbGF5ZXJfb2JqID0gTUFTQ1AuZ2V0TGF5ZXIobGF5ZXIpO1xuICAgICAgICBpZiAoICEgbGF5ZXJfb2JqICkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ01pc3NpbmcgbGF5ZXIgb2JqZWN0IGZvciBsYXllciBpZGVudGlmaWVyJyxsYXllciwnbWFraW5nIGR1bW15IGxheWVyIHNjYWxlZCB3aXRoIGlkZW50aWZpZXInLGxheWVyKTtcbiAgICAgICAgICAgIGxheWVyX29iaiA9IHsgJ25hbWUnIDogbGF5ZXIsICdzY2FsZXMnIDogbmV3IFNldCgpIH07XG4gICAgICAgICAgICBsYXllcl9vYmouc2NhbGVzLmFkZChsYXllcik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNjYWxlcl9mdW5jcyA9ICh0aGlzLl9zY2FsZXJzIHx8IFtdKS5jb25jYXQoW10pO1xuICAgICAgICB2YXIgbmV3X2FhID0gKGludmVyc2UgPyBzY2FsZXJfZnVuY3MucmV2ZXJzZSgpIDogc2NhbGVyX2Z1bmNzKS5yZWR1Y2UoKHZhbCxmbikgPT4geyAgcmV0dXJuIGZuKHZhbCxsYXllcl9vYmosaW52ZXJzZSk7IH0sYWEpO1xuICAgICAgICByZXR1cm4gbmV3X2FhO1xuICAgIH07XG5cbiAgICBjbGF6ei5wcm90b3R5cGUuZ2V0QUEgPSBmdW5jdGlvbihhYSxsYXllcixzY2FsZV9uYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEFtaW5vQWNpZHNCeVBvc2l0aW9uKFthYV0sbGF5ZXIsc2NhbGVfbmFtZSkuc2hpZnQoKTtcbiAgICB9O1xuXG4gICAgY2xhenoucHJvdG90eXBlLmdldEFtaW5vQWNpZHNCeVBvc2l0aW9uID0gZnVuY3Rpb24oYWFzLGxheWVyKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIG5ld19hYXMgPSBhYXMubWFwKGZ1bmN0aW9uKGFhKSB7IHJldHVybiBNYXRoLmFicyhzZWxmLnNjYWxlUG9zaXRpb24oYWEsbGF5ZXIpKTsgfSk7XG4gICAgICAgIHZhciByZXN1bHRzID0gU2VxdWVuY2VSZW5kZXJlci5wcm90b3R5cGUuZ2V0QW1pbm9BY2lkc0J5UG9zaXRpb24uY2FsbCh0aGlzLG5ld19hYXMpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3X2Fhcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHJlc3VsdHNbaV0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzW2ldLm9yaWdpbmFsX2luZGV4ID0gYWFzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG5cbiAgICBjbGF6ei5wcm90b3R5cGUuZ2V0QW1pbm9BY2lkc0J5UGVwdGlkZSA9IGZ1bmN0aW9uKHBlcHRpZGUsbGF5ZXIpIHtcbiAgICAgICAgbGF5ZXIgPSBNQVNDUC5nZXRMYXllcihsYXllcik7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHBvc2l0aW9ucyA9IFtdO1xuICAgICAgICB2YXIgc2VsZl9zZXE7XG4gICAgICAgIHZhciBpZGVudGlmaWVyID0gbGF5ZXIuYWNjZXNzaW9uO1xuICAgICAgICBpZiAoc2VsZi5zZXF1ZW5jZXMpIHtcbiAgICAgICAgICAgIHNlbGZfc2VxID0gc2VsZi5zZXF1ZW5jZXMgWyAoIHNlbGYuc2VxdWVuY2VzLm1hcChmdW5jdGlvbihzZXEpIHsgIHJldHVybiAoc2VxLmFnaSB8fCBzZXEuYWNjIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7ICB9KSApLmluZGV4T2YoaWRlbnRpZmllci50b0xvd2VyQ2FzZSgpKSBdLnRvU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmX3NlcSA9IHNlbGYuc2VxdWVuY2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXJ0ID0gc2VsZl9zZXEuaW5kZXhPZihwZXB0aWRlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwZXB0aWRlLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goc3RhcnQraSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdHMgPSBzZWxmLmdldEFtaW5vQWNpZHNCeVBvc2l0aW9uKHBvc2l0aW9ucyxsYXllcik7XG4gICAgICAgIGlmIChyZXN1bHRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0cy5hZGRUb0xheWVyID0gZnVuY3Rpb24obGF5ZXJuYW1lLCBmcmFjdGlvbiwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzWzBdLmFkZEJveE92ZXJsYXkobGF5ZXJuYW1lLHJlc3VsdHMubGVuZ3RoLGZyYWN0aW9uLG9wdGlvbnMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdHMuYWRkVG9MYXllciA9IGZ1bmN0aW9uKCkge307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcblxuICAgIGNsYXp6LnByb3RvdHlwZS53aW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbnRhaW5lciAmJiB0aGlzLl9jb250YWluZXIub3duZXJEb2N1bWVudCAmJiB0aGlzLl9jb250YWluZXIub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldykge1xuICAgICAgICAgICAgdmFyIHJldHVybl92YWwgPSB0aGlzLl9jb250YWluZXIub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmV0dXJuX3ZhbCA9PT0gJ29iamVjdCcgJiYgcmV0dXJuX3ZhbC5jb25zdHJ1Y3RvciAhPT0gV2luZG93ICkge1xuICAgICAgICAgICAgICAgIHJldHVybl92YWwgPSByZXR1cm5fdmFsW09iamVjdC5rZXlzKHJldHVybl92YWwpWzBdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXR1cm5fdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cblxuICAgIGNsYXp6LnByb3RvdHlwZS5zZXRTZXF1ZW5jZSA9IGZ1bmN0aW9uKHNlcXVlbmNlKSB7XG4gICAgICAgIHZhciBuZXdfc2VxdWVuY2UgPSB0aGlzLl9jbGVhblNlcXVlbmNlKHNlcXVlbmNlKTtcbiAgICAgICAgaWYgKG5ld19zZXF1ZW5jZSA9PSB0aGlzLnNlcXVlbmNlICYmIG5ld19zZXF1ZW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgYmVhbi5maXJlKHRoaXMsJ3NlcXVlbmNlQ2hhbmdlJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgaWYgKCEgbmV3X3NlcXVlbmNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgdGhpcy5zZXF1ZW5jZSA9IG5ld19zZXF1ZW5jZTtcblxuICAgICAgICBkZWxldGUgdGhpcy5zZXF1ZW5jZXM7XG5cbiAgICAgICAgdmFyIHNlcV9jaGFycyA9IHRoaXMuc2VxdWVuY2Uuc3BsaXQoJycpO1xuICAgICAgICB2YXIgbGluZV9sZW5ndGggPSBzZXFfY2hhcnMubGVuZ3RoO1xuXG4gICAgICAgIGlmIChsaW5lX2xlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcztcblxuXG4gICAgICAgIHZhciBidWlsZF9zZXF1ZW5jZV9lbHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZXFfZWxzID0gW107XG4gICAgICAgICAgICByZW5kZXJlci5zZXF1ZW5jZS5zcGxpdCgnJykuZm9yRWFjaCggZnVuY3Rpb24oYWEsaSkge1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IHt9O1xuICAgICAgICAgICAgICAgIGVsLl9pbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgZWwuX3JlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuX2V4dGVuZEVsZW1lbnQoZWwpO1xuICAgICAgICAgICAgICAgIGVsLmFtaW5vX2FjaWQgPSBhYTtcbiAgICAgICAgICAgICAgICBzZXFfZWxzLnB1c2goZWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZW5kZXJlci5fc2VxdWVuY2VfZWxzID0gc2VxX2VscztcbiAgICAgICAgfTtcblxuICAgICAgICBidWlsZF9zZXF1ZW5jZV9lbHMoKTtcblxuICAgICAgICB2YXIgUlMgPSB0aGlzLl9SUztcblxuICAgICAgICBiZWFuLnJlbW92ZSh0aGlzLCdzdmdyZWFkeScpO1xuICAgICAgICBiZWFuLmFkZCh0aGlzLCdzdmdyZWFkeScsZnVuY3Rpb24oY252KSB7XG4gICAgICAgICAgICB2YXIgY2FudiA9IHJlbmRlcmVyLl9jYW52YXM7XG4gICAgICAgICAgICBjYW52LlJTID0gUlM7XG4gICAgICAgICAgICBjYW52LnNldEF0dHJpYnV0ZSgnYmFja2dyb3VuZCcsICcjMDAwMDAwJyk7XG4gICAgICAgICAgICBjYW52LnNldEF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycsJ3hNaW5ZTWluIG1lZXQnKTtcbiAgICAgICAgXG4gICAgICAgICAgICB2YXIgZGVmcyA9IGNhbnYubWFrZUVsKCdkZWZzJyk7XG4gICAgICAgICAgICByZW5kZXJlci5fY29udGFpbmVyX2NhbnZhcy5hcHBlbmRDaGlsZChkZWZzKTtcblxuXG4gICAgICAgICAgICBkZWZzLmFwcGVuZENoaWxkKGNhbnYubWFrZV9ncmFkaWVudCgndHJhY2tfc2hpbmUnLCcwJScsJzEwMCUnLFsnIzExMTExMScsJyNhYWFhYWEnLCcjMTExMTExJ10sIFswLjUsMC41LDAuNV0pKTtcbiAgICAgICAgICAgIGRlZnMuYXBwZW5kQ2hpbGQoY2Fudi5tYWtlX2dyYWRpZW50KCdzaW1wbGVfZ3JhZGllbnQnLCcwJScsJzEwMCUnLFsnI2FhYWFhYScsJyM4ODg4ODgnXSwgWzEsMV0pKTtcbiAgICAgICAgICAgIGRlZnMuYXBwZW5kQ2hpbGQoY2Fudi5tYWtlX2dyYWRpZW50KCdsZWZ0X2ZhZGUnLCcxMDAlJywnMCUnLFsnI2ZmZmZmZicsJyNmZmZmZmYnXSwgWzEsMF0pKTtcbiAgICAgICAgICAgIGRlZnMuYXBwZW5kQ2hpbGQoY2Fudi5tYWtlX2dyYWRpZW50KCdyaWdodF9mYWRlJywnMTAwJScsJzAlJyxbJyNmZmZmZmYnLCcjZmZmZmZmJ10sIFswLDFdKSk7XG4gICAgICAgICAgICBkZWZzLmFwcGVuZENoaWxkKGNhbnYubWFrZV9ncmFkaWVudCgncmVkXzNkJywnMCUnLCcxMDAlJyxbJyNDRjAwMDAnLCcjNTQwMDAwJ10sIFsxLDFdKSk7XG4gICAgICAgIFxuICAgICAgICAgICAgcmVuZGVyZXIuZ3JhZGllbnRzID0gW107XG4gICAgICAgICAgICByZW5kZXJlci5hZGQzZEdyYWRpZW50ID0gZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgICAgICBkZWZzLmFwcGVuZENoaWxkKGNhbnYubWFrZV9ncmFkaWVudCgnZ3JhZF8nK2NvbG9yLCcwJScsJzEwMCUnLFtjb2xvciwnI2ZmZmZmZicsY29sb3JdLFsxLDEsMV0gKSk7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuZ3JhZGllbnRzLnB1c2goY29sb3IpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHNoYWRvdyA9IGNhbnYubWFrZUVsKCdmaWx0ZXInLHtcbiAgICAgICAgICAgICAgICAnaWQnOidkcm9wX3NoYWRvdycsXG4gICAgICAgICAgICAgICAgJ2ZpbHRlclVuaXRzJzonb2JqZWN0Qm91bmRpbmdCb3gnLFxuICAgICAgICAgICAgICAgICd4JzogJy01MCUnLFxuICAgICAgICAgICAgICAgICd5JzogJy01MCUnLFxuICAgICAgICAgICAgICAgICd3aWR0aCc6JzIwMCUnLFxuICAgICAgICAgICAgICAgICdoZWlnaHQnOicyMDAlJ1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHNoYWRvdy5hcHBlbmRDaGlsZChjYW52Lm1ha2VFbCgnZmVHYXVzc2lhbkJsdXInLHsnaW4nOidTb3VyY2VHcmFwaGljJywgJ3N0ZERldmlhdGlvbic6JzQnLCAncmVzdWx0JyA6ICdibHVyX291dCd9KSk7XG4gICAgICAgICAgICBzaGFkb3cuYXBwZW5kQ2hpbGQoY2Fudi5tYWtlRWwoJ2ZlT2Zmc2V0Jyx7J2luJzonYmx1cl9vdXQnLCAncmVzdWx0JzondGhlX3NoYWRvdycsICdkeCc6JzMnLCdkeSc6JzEnfSkpO1xuICAgICAgICAgICAgc2hhZG93LmFwcGVuZENoaWxkKGNhbnYubWFrZUVsKCdmZUJsZW5kJyx7J2luJzonU291cmNlR3JhcGhpYycsICdpbjInOid0aGVfc2hhZG93JywgJ21vZGUnOidub3JtYWwnfSkpO1xuICAgICAgICBcbiAgICAgICAgICAgIGRlZnMuYXBwZW5kQ2hpbGQoc2hhZG93KTtcbiAgICAgICAgICAgIHZhciBsaW5rX2ljb24gPSBjYW52Lm1ha2VFbCgnc3ZnJyx7XG4gICAgICAgICAgICAgICAgJ3dpZHRoJyA6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICAnaGVpZ2h0JzogJzEwMCUnLFxuICAgICAgICAgICAgICAgICdpZCcgICAgOiAnbmV3X2xpbmtfaWNvbicsXG4gICAgICAgICAgICAgICAgJ3ZpZXdCb3gnOiAnMCAwIDEwMCAxMDAnLFxuICAgICAgICAgICAgICAgICdwcmVzZXJ2ZUFzcGVjdFJhdGlvJyA6ICd4TWluWU1pbiBtZWV0J1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRlZnMuYXBwZW5kQ2hpbGQobGlua19pY29uKTtcblxuICAgICAgICAgICAgbGlua19pY29uLmFwcGVuZENoaWxkKGNhbnYubWFrZUVsKCdyZWN0Jywge1xuICAgICAgICAgICAgICAgICd4JyA6ICcxMi41JyxcbiAgICAgICAgICAgICAgICAneScgOiAnMzcuNScsXG4gICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCcgOiAnMycsXG4gICAgICAgICAgICAgICAgJ3dpZHRoJyA6ICc1MCcsXG4gICAgICAgICAgICAgICAgJ2hlaWdodCc6ICc1MCcsXG4gICAgICAgICAgICAgICAgJ3N0cm9rZSc6ICcjZmZmZmZmJyxcbiAgICAgICAgICAgICAgICAnZmlsbCcgIDogJ25vbmUnICAgICAgICAgICAgXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBsaW5rX2ljb24uYXBwZW5kQ2hpbGQoY2Fudi5tYWtlRWwoJ3BhdGgnLCB7XG4gICAgICAgICAgICAgICAgJ2QnIDogJ00gNTAuMCwxNi43IEwgODMuMywxNi43IEwgODMuMyw1MC4wIEwgNzkuMiw1Ni4yIEwgNjguOCwzOS42IEwgNDMuOCw2Ni43IEwgMzMuMyw1Ni4yIEwgNjAuNCwzMS4yIEwgNDMuOCwyMC44IEwgNTAuMCwxNi43IHonLFxuICAgICAgICAgICAgICAgICdzdHJva2Utd2lkdGgnIDogJzMnLFxuICAgICAgICAgICAgICAgICdzdHJva2UnOiAnIzk5OTk5OScsXG4gICAgICAgICAgICAgICAgJ2ZpbGwnICA6ICcjZmZmZmZmJyAgICAgICAgICAgIFxuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICB2YXIgcGx1c19pY29uID0gY2Fudi5tYWtlRWwoJ3N2Zycse1xuICAgICAgICAgICAgICAgICd3aWR0aCcgOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgJ2hlaWdodCc6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICAnaWQnICAgIDogJ3BsdXNfaWNvbicsXG4gICAgICAgICAgICAgICAgJ3ZpZXdCb3gnOiAnMCAwIDEwMCAxMDAnLFxuICAgICAgICAgICAgICAgICdwcmVzZXJ2ZUFzcGVjdFJhdGlvJyA6ICd4TWluWU1pbiBtZWV0J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwbHVzX2ljb24uYXBwZW5kQ2hpbGQoY2Fudi5wbHVzKDAsMCwxMDAvY2Fudi5SUykpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBkZWZzLmFwcGVuZENoaWxkKHBsdXNfaWNvbik7XG5cbiAgICAgICAgICAgIHZhciBtaW51c19pY29uID0gY2Fudi5tYWtlRWwoJ3N2Zycse1xuICAgICAgICAgICAgICAgICd3aWR0aCcgOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgJ2hlaWdodCc6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICAnaWQnICAgIDogJ21pbnVzX2ljb24nLFxuICAgICAgICAgICAgICAgICd2aWV3Qm94JzogJzAgMCAxMDAgMTAwJyxcbiAgICAgICAgICAgICAgICAncHJlc2VydmVBc3BlY3RSYXRpbycgOiAneE1pbllNaW4gbWVldCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbWludXNfaWNvbi5hcHBlbmRDaGlsZChjYW52Lm1pbnVzKDAsMCwxMDAvY2Fudi5SUykpO1xuXG4gICAgICAgICAgICBkZWZzLmFwcGVuZENoaWxkKG1pbnVzX2ljb24pO1xuICAgICAgICAgICAgdmFyIGF4aXNfcGF0dGVybl9pZCA9ICdheGlzX3BhdHRlcm5fJysobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSBjYW52Lm1ha2VFbCgncGF0dGVybicsIHtcbiAgICAgICAgICAgICAgICAncGF0dGVyblVuaXRzJyA6ICd1c2VyU3BhY2VPblVzZScsXG4gICAgICAgICAgICAgICAgJ3gnICAgICAgICAgICAgOiAnMCcsXG4gICAgICAgICAgICAgICAgJ3knICAgICAgICAgICAgOiAnMCcsXG4gICAgICAgICAgICAgICAgJ3dpZHRoJyAgICAgICAgOiAxMCpjYW52LlJTLFxuICAgICAgICAgICAgICAgICdoZWlnaHQnICAgICAgIDogMipjYW52LlJTLFxuICAgICAgICAgICAgICAgICdpZCcgICAgICAgICAgIDogYXhpc19wYXR0ZXJuX2lkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlbmRlcmVyLmF4aXNfcGF0dGVybl9pZCA9IGF4aXNfcGF0dGVybl9pZDtcblxuICAgICAgICAgICAgdmFyIGxpbmUgPSBjYW52Lm1ha2VFbCgncmVjdCcse1xuICAgICAgICAgICAgICAgICd4JyAgICAgOiAnMCcsXG4gICAgICAgICAgICAgICAgJ3knICAgICA6ICcwJyxcbiAgICAgICAgICAgICAgICAnd2lkdGgnIDogJzEwJScsXG4gICAgICAgICAgICAgICAgJ2hlaWdodCc6ICcxMDAwJScsXG4gICAgICAgICAgICAgICAgJ2ZpbGwnICA6ICcjMDAwJyxcbiAgICAgICAgICAgICAgICAnc3Ryb2tlJzogJzAnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwYXR0ZXJuLmFwcGVuZENoaWxkKGxpbmUpO1xuXG4gICAgICAgICAgICBkZWZzLmFwcGVuZENoaWxkKHBhdHRlcm4pO1xuXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICByZW5kZXJlci5fYXhpc19oZWlnaHQgPSAxMDtcbiAgICAgICAgICAgIHZhciBhYXMgPSBkcmF3QW1pbm9BY2lkcy5jYWxsKHNlbGYsY2Fudik7XG4gICAgICAgICAgICByZW5kZXJlci5oaWRlQXhpcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGRyYXdBeGlzID0gZnVuY3Rpb24oY2Fudikge1xuICAgICAgICAgICAgICAgICAgICBiZWFuLmFkZChjYW52LCAnem9vbUNoYW5nZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fYXhpc19oZWlnaHQgPSAxMCAvIHNlbGYuem9vbTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHNlbGYuX2F4aXNfaGVpZ2h0ID0gMTAgLyBzZWxmLnpvb207XG4gICAgICAgICAgICAgICAgdGhpcy5yZWRyYXdBeGlzKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVuZGVyZXIuc2hvd0F4aXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBkcmF3QXhpcyA9IG1haW5EcmF3QXhpcztcbiAgICAgICAgICAgICAgICB0aGlzLnJlZHJhd0F4aXMoKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBheGlzID0gZHJhd0F4aXMuY2FsbChzZWxmLGNhbnYsbGluZV9sZW5ndGgpO1xuICAgICAgICAgICAgcmVuZGVyZXIucmVkcmF3QXhpcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGJlYW4uZmlyZShheGlzLCdyZW1vdmVkJyk7XG4gICAgICAgICAgICAgICAgYWFzLmZvckVhY2goZnVuY3Rpb24oYWEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFhLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYWEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYmVhbi5maXJlKGFhcywncmVtb3ZlZCcpO1xuICAgICAgICAgICAgICAgIGF4aXMgPSBkcmF3QXhpcy5jYWxsKHNlbGYsY2FudixyZW5kZXJlci5zZXF1ZW5jZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGFhcyA9IGRyYXdBbWlub0FjaWRzLmNhbGwoc2VsZixjYW52KTtcblxuICAgICAgICAgICAgICAgIGJ1aWxkX3NlcXVlbmNlX2VscygpO1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnJlZnJlc2goKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoICEgcmVuZGVyZXIuaGlkZV9heGlzICkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvd0F4aXMoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlQXhpcygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZW5kZXJlci5fbGF5ZXJfY29udGFpbmVycyA9IHt9O1xuICAgICAgICAgICAgcmVuZGVyZXIuZW5hYmxlUHJpbnRSZXNpemluZygpO1xuICAgICAgICAgICAgcmVuZGVyZXIuZW5hYmxlU2NhbGluZygpO1xuICAgICAgICAgICAgcmVuZGVyZXIuZW5hYmxlU2VsZWN0aW9uKCk7XG5cbiAgICAgICAgICAgIC8vIFdoZW4gd2UgaGF2ZSBhIGxheWVyIHJlZ2lzdGVyZWQgd2l0aCB0aGUgZ2xvYmFsIE1BU0NQIG9iamVjdFxuICAgICAgICAgICAgLy8gYWRkIGEgdHJhY2sgd2l0aGluIHRoaXMgcmVuZGVyZXIuXG4gICAgICAgICAgICBiZWFuLmFkZChNQVNDUCwnbGF5ZXJSZWdpc3RlcmVkJywgZnVuY3Rpb24obGF5ZXIscmVuZCkge1xuICAgICAgICAgICAgICAgIGlmICghIHJlbmQgfHwgcmVuZCA9PT0gcmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXIuYWRkVHJhY2sobGF5ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBiZWFuLmZpcmUocmVuZGVyZXIsJ3NlcXVlbmNlQ2hhbmdlJyk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY2FudmFzID0gY3JlYXRlQ2FudmFzT2JqZWN0LmNhbGwodGhpcyk7XG4gICAgICAgIGlmICghIHRoaXMuX2NhbnZhcykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdmd3ZWIgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBzdmd3ZWIuYXBwZW5kQ2hpbGQoY2FudmFzLHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXG4gICAgICAgIHZhciByZW5kID0gdGhpcztcbiAgICAgICAgdGhpcy5FbmFibGVIaWdobGlnaHRzKCk7XG4gICAgXG4gICAgICAgIHZhciBzZXFfY2hhbmdlX2Z1bmMgPSBmdW5jdGlvbihvdGhlcl9mdW5jKSB7XG4gICAgICAgICAgICBpZiAoICEgcmVuZC5fY2FudmFzICkge1xuICAgICAgICAgICAgICAgIGJlYW4uYWRkKHJlbmQsJ3NlcXVlbmNlQ2hhbmdlJyxmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVhbi5yZW1vdmUocmVuZCwnc2VxdWVuY2VDaGFuZ2UnLGFyZ3VtZW50cy5jYWxsZWUpO1xuICAgICAgICAgICAgICAgICAgICBvdGhlcl9mdW5jLmFwcGx5KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG90aGVyX2Z1bmMuYXBwbHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICBcbiAgICAgICAgc2VxX2NoYW5nZV9mdW5jLnJlYWR5ID0gZnVuY3Rpb24ob3RoZXJfZnVuYykge1xuICAgICAgICAgICAgdGhpcy5jYWxsKHRoaXMsb3RoZXJfZnVuYyk7XG4gICAgICAgIH07XG4gICAgXG4gICAgICAgIHJldHVybiBzZXFfY2hhbmdlX2Z1bmM7XG4gICAgXG4gICAgfTtcblxufSkoQ29uZGVuc2VkU2VxdWVuY2VSZW5kZXJlcik7XG5cblxuKGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdmducyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG4gICAgdmFyIGFkZF9pbXBvcnQgPSBmdW5jdGlvbihvd25lcmRvYykge1xuICAgICAgICBpZiAoIW93bmVyZG9jLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgIG93bmVyZG9jLkVMRU1FTlRfTk9ERSA9IDE7XG4gICAgICAgICAgb3duZXJkb2MuQVRUUklCVVRFX05PREUgPSAyO1xuICAgICAgICAgIG93bmVyZG9jLlRFWFRfTk9ERSA9IDM7XG4gICAgICAgICAgb3duZXJkb2MuQ0RBVEFfU0VDVElPTl9OT0RFID0gNDtcbiAgICAgICAgICBvd25lcmRvYy5FTlRJVFlfUkVGRVJFTkNFX05PREUgPSA1O1xuICAgICAgICAgIG93bmVyZG9jLkVOVElUWV9OT0RFID0gNjtcbiAgICAgICAgICBvd25lcmRvYy5QUk9DRVNTSU5HX0lOU1RSVUNUSU9OX05PREUgPSA3O1xuICAgICAgICAgIG93bmVyZG9jLkNPTU1FTlRfTk9ERSA9IDg7XG4gICAgICAgICAgb3duZXJkb2MuRE9DVU1FTlRfTk9ERSA9IDk7XG4gICAgICAgICAgb3duZXJkb2MuRE9DVU1FTlRfVFlQRV9OT0RFID0gMTA7XG4gICAgICAgICAgb3duZXJkb2MuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSA9IDExO1xuICAgICAgICAgIG93bmVyZG9jLk5PVEFUSU9OX05PREUgPSAxMjtcbiAgICAgICAgfVxuXG4gICAgICAgIG93bmVyZG9jLl9pbXBvcnROb2RlID0gZnVuY3Rpb24obm9kZSwgYWxsQ2hpbGRyZW4pIHtcbiAgICAgICAgICBzd2l0Y2ggKG5vZGUubm9kZVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2Ugb3duZXJkb2MuRUxFTUVOVF9OT0RFOlxuICAgICAgICAgICAgICB2YXIgbmV3Tm9kZSA9IG93bmVyZG9jLmNyZWF0ZUVsZW1lbnROUyhzdmducyxub2RlLm5vZGVOYW1lKTtcbiAgICAgICAgICAgICAgLyogZG9lcyB0aGUgbm9kZSBoYXZlIGFueSBhdHRyaWJ1dGVzIHRvIGFkZD8gKi9cbiAgICAgICAgICAgICAgaWYgKG5vZGUuYXR0cmlidXRlcyAmJiBub2RlLmF0dHJpYnV0ZXMubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBub2RlLmF0dHJpYnV0ZXMubGVuZ3RoOyBpIDwgaWw7KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoISAvXm9uLy50ZXN0KG5vZGUuYXR0cmlidXRlc1tpXS5ub2RlTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlLnNldEF0dHJpYnV0ZShub2RlLmF0dHJpYnV0ZXNbaV0ubm9kZU5hbWUsIG5vZGUuZ2V0QXR0cmlidXRlKG5vZGUuYXR0cmlidXRlc1tpKytdLm5vZGVOYW1lKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKiBhcmUgd2UgZ29pbmcgYWZ0ZXIgY2hpbGRyZW4gdG9vLCBhbmQgZG9lcyB0aGUgbm9kZSBoYXZlIGFueT8gKi9cbiAgICAgICAgICAgICAgaWYgKGFsbENoaWxkcmVuICYmIG5vZGUuY2hpbGROb2RlcyAmJiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgaWw7KSB7XG4gICAgICAgICAgICAgICAgICBpZiAobm9kZS5jaGlsZE5vZGVzW2ldLm5vZGVOYW1lICE9PSAnVVNFJyAmJiBub2RlLmNoaWxkTm9kZXNbaV0ubm9kZU5hbWUudG9VcHBlckNhc2UoKSAhPT0gJ1NDUklQVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlLmFwcGVuZENoaWxkKG93bmVyZG9jLl9pbXBvcnROb2RlKG5vZGUuY2hpbGROb2Rlc1tpKytdLCBhbGxDaGlsZHJlbikpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG5ld05vZGU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBvd25lcmRvYy5URVhUX05PREU6XG4gICAgICAgICAgICBjYXNlIG93bmVyZG9jLkNEQVRBX1NFQ1RJT05fTk9ERTpcbiAgICAgICAgICAgIGNhc2Ugb3duZXJkb2MuQ09NTUVOVF9OT0RFOlxuICAgICAgICAgICAgICByZXR1cm4gb3duZXJkb2MuY3JlYXRlVGV4dE5vZGUobm9kZS5ub2RlVmFsdWUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBmaXhfY2hpbGRfbGlua3MgPSBmdW5jdGlvbihub2RlLHByZWZpeCkge1xuICAgICAgaWYgKG5vZGUuY2hpbGROb2RlcyAmJiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgaWw7KSB7XG4gICAgICAgICAgaWYgKG5vZGUuY2hpbGROb2Rlc1tpXS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnVVNFJykge1xuICAgICAgICAgICAgdmFyIGxpbmt2YWwgPSBub2RlLmNoaWxkTm9kZXNbaV0uZ2V0QXR0cmlidXRlKCd4bGluazpocmVmJyk7XG4gICAgICAgICAgICBub2RlLmNoaWxkTm9kZXNbaV0uc2V0QXR0cmlidXRlKCd4bGluazpocmVmJyxsaW5rdmFsLnJlcGxhY2UoL14jLywnIycrcHJlZml4KydfJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ29uZGVuc2VkU2VxdWVuY2VSZW5kZXJlci5wcm90b3R5cGUuaW1wb3J0SWNvbnMgPSBmdW5jdGlvbihuYW1lc3BhY2UsZG9jLGFsdF91cmwpIHtcbiAgICAgICAgdmFyIG5ld19vd25lciA9IHRoaXMuX2NvbnRhaW5lcl9jYW52YXMub3duZXJEb2N1bWVudDtcbiAgICAgICAgaWYgKHRoaXMuX2NvbnRhaW5lcl9jYW52YXMuZ2V0RWxlbWVudEJ5SWQoJ2RlZnNfJytuYW1lc3BhY2UpKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb250YWluZXJfY2FudmFzLmFwcGVuZENoaWxkKG5ld19vd25lci5jcmVhdGVFbGVtZW50KCdkZWZzJykpO1xuICAgICAgICB0aGlzLl9jb250YWluZXJfY2FudmFzLmxhc3RDaGlsZC5zZXRBdHRyaWJ1dGUoJ2lkJywnZGVmc18nK25hbWVzcGFjZSk7XG4gICAgICAgIHZhciBkZWZzX2Jsb2NrID0gdGhpcy5fY29udGFpbmVyX2NhbnZhcy5sYXN0Q2hpbGQ7XG5cbiAgICAgICAgaWYgKCAhIG5ld19vd25lci5faW1wb3J0Tm9kZSApIHtcbiAgICAgICAgICAgIGFkZF9pbXBvcnQobmV3X293bmVyKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdWEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICAgICAgaWYgKHVhLmluZGV4T2YoJ0VkZ2UvJykgPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5pY29uc19mYWlsZWQgPSB0aGlzLmljb25zX2ZhaWxlZCB8fCB7fTtcbiAgICAgICAgICAgIHRoaXMuaWNvbnNfZmFpbGVkW25hbWVzcGFjZV0gPSBhbHRfdXJsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdfbm9kZXMgPSBuZXdfb3duZXIuX2ltcG9ydE5vZGUoZG9jLHRydWUpO1xuICAgICAgICBpZiAodHlwZW9mIFhQYXRoUmVzdWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gbmV3X293bmVyLmV2YWx1YXRlKCcvL3N2ZzpkZWZzLyonLG5ld19ub2RlcyxmdW5jdGlvbihucykgeyByZXR1cm4gc3ZnbnM7IH0gLFhQYXRoUmVzdWx0LkFOWV9UWVBFLG51bGwpO1xuICAgICAgICAgICAgdmFyIGVsID0gaXRlcmF0b3IuaXRlcmF0ZU5leHQoKTtcbiAgICAgICAgICAgIHZhciB0b19hcHBlbmQgPSBbXTtcbiAgICAgICAgICAgIHdoaWxlIChlbCkge1xuICAgICAgICAgICAgICAgIHRvX2FwcGVuZC5wdXNoKGVsKTtcbiAgICAgICAgICAgICAgICBlbCA9IGl0ZXJhdG9yLml0ZXJhdGVOZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9fYXBwZW5kLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaWNvbnNfZmFpbGVkID0gdGhpcy5pY29uc19mYWlsZWQgfHwge307XG4gICAgICAgICAgICAgICAgdGhpcy5pY29uc19mYWlsZWRbbmFtZXNwYWNlXSA9IGFsdF91cmw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b19hcHBlbmQuZm9yRWFjaChmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnaWQnLG5hbWVzcGFjZSsnXycrZWwuZ2V0QXR0cmlidXRlKCdpZCcpKTtcbiAgICAgICAgICAgICAgICBmaXhfY2hpbGRfbGlua3MoZWwsbmFtZXNwYWNlKTtcbiAgICAgICAgICAgICAgICBkZWZzX2Jsb2NrLmFwcGVuZENoaWxkKGVsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGVscyA9IG5ld19ub2Rlcy5xdWVyeVNlbGVjdG9yQWxsKCdkZWZzID4gKicpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgZWxzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgICAgIGVsc1tpXS5zZXRBdHRyaWJ1dGUoJ2lkJyxuYW1lc3BhY2UrJ18nK2Vsc1tpXS5nZXRBdHRyaWJ1dGUoJ2lkJykpO1xuICAgICAgICAgICAgICAgIGZpeF9jaGlsZF9saW5rcyhlbCxuYW1lc3BhY2UpO1xuICAgICAgICAgICAgICAgIGRlZnNfYmxvY2suYXBwZW5kQ2hpbGQoZWxzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbn0pKCk7XG5cblxuQ29uZGVuc2VkU2VxdWVuY2VSZW5kZXJlci5wcm90b3R5cGUuYWRkVmFsdWVzVG9MYXllciA9IGZ1bmN0aW9uKGxheWVyTmFtZSx2YWx1ZXMsb3B0aW9ucykge1xuICAgIHZhciBSUyA9IHRoaXMuX1JTO1xuICAgIFxuICAgIHZhciBjYW52YXMgPSB0aGlzLl9jYW52YXM7XG4gICAgXG4gICAgaWYgKCAhIGNhbnZhcyApIHsgICAgICAgIFxuICAgICAgICB2YXIgb3JpZ19mdW5jID0gYXJndW1lbnRzLmNhbGxlZTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBiZWFuLmFkZCh0aGlzLl9yZW5kZXJlciwnc2VxdWVuY2VjaGFuZ2UnLGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYmVhbi5yZW1vdmUodGhpcy5fcmVuZGVyZXIsJ3NlcXVlbmNlY2hhbmdlJyxhcmd1bWVudHMuY2FsbGVlKTtcbiAgICAgICAgICAgIG9yaWdfZnVuYy5jYWxsKHNlbGYsbGF5ZXJOYW1lLHZhbHVlcyk7XG4gICAgICAgIH0pO1xuICAgICAgICBsb2coXCJEZWxheWluZyByZW5kZXJpbmcsIHdhaXRpbmcgZm9yIHNlcXVlbmNlIGNoYW5nZVwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBtYXhfdmFsdWU7XG4gICAgdmFyIG1pbl92YWx1ZTtcbiAgICB2YXIgaGVpZ2h0X3NjYWxlID0gMTtcbiAgICBcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGlmIChvcHRpb25zLmhlaWdodCkge1xuICAgICAgICBoZWlnaHRfc2NhbGUgPSBvcHRpb25zLmhlaWdodCAvIHRoaXMuX2xheWVyX2NvbnRhaW5lcnNbbGF5ZXJOYW1lXS50cmFja19oZWlnaHQ7XG4gICAgfVxuXG4gICAgdmFyIG9mZnNldF9zY2FsZSA9IDA7XG4gICAgaWYgKG9wdGlvbnMub2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldF9zY2FsZSA9IG9wdGlvbnMub2Zmc2V0IC8gdGhpcy5fbGF5ZXJfY29udGFpbmVyc1tsYXllck5hbWVdLnRyYWNrX2hlaWdodDtcbiAgICB9XG4gICAgdmFyIHJlY2FsY3VsYXRlX3Bsb3QgID0gZnVuY3Rpb24oc2NhbGUpIHtcbiAgICAgICAgdmFyIHBsb3RfcGF0aCA9ICcgbScrKC0wLjUqUlMpKycgMCc7XG4gICAgICAgIHZhciBsYXN0X3ZhbHVlID0gbnVsbDtcbiAgICAgICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGlmICggdHlwZW9mKGxhc3RfdmFsdWUpID09ICd1bmRlZmluZWQnICkge1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwbG90X3BhdGggKz0gJyBsJytSUysnICcrKC0xICpSUypzY2FsZSpoZWlnaHRfc2NhbGUqKHZhbHVlIC0gbGFzdF92YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdF92YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKGlzTmFOKG1heF92YWx1ZSkgfHwgKHZhbHVlID4gbWF4X3ZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG1heF92YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTmFOKG1pbl92YWx1ZSkgfHwgKHZhbHVlIDwgbWluX3ZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG1pbl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBsb3RfcGF0aDtcbiAgICB9O1xuICAgIHZhciBwbG90ID0gdGhpcy5fY2FudmFzLnBhdGgoJ00wIDAgTTAgMCBtMCAnKygobWF4X3ZhbHVlIHx8IDApKSpSUysnICcrcmVjYWxjdWxhdGVfcGxvdCgxKSk7XG4gICAgdmFyIGFic19taW5fdmFsID0gbWluX3ZhbHVlO1xuICAgIHZhciBhYnNfbWF4X3ZhbCA9IG1heF92YWx1ZTtcbiAgICBwbG90LnNldEF0dHJpYnV0ZSgnc3Ryb2tlJyxvcHRpb25zLmNvbG9yIHx8ICcjZmYwMDAwJyk7XG4gICAgcGxvdC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIChvcHRpb25zLnRoaWNrbmVzcyB8fCAwLjM1KSpSUyk7XG4gICAgcGxvdC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCAnbm9uZScpO1xuICAgIHBsb3Quc2V0QXR0cmlidXRlKCd2aXNpYmlsaXR5JywnaGlkZGVuJyk7XG4gICAgcGxvdC5zZXRBdHRyaWJ1dGUoJ3BvaW50ZXItZXZlbnRzJywnbm9uZScpO1xuICAgIHRoaXMuX2xheWVyX2NvbnRhaW5lcnNbbGF5ZXJOYW1lXS5wdXNoKHBsb3QpO1xuICAgIHBsb3Quc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCd0cmFuc2xhdGUoMSwxMCkgc2NhbGUoMSwxKScpO1xuICAgIGlmICghIG9wdGlvbnMuaGlkZV9heGlzKSB7XG4gICAgICAgIHZhciBheGlzID0gdGhpcy5fY2FudmFzLnBhdGgoJ00wIDAgbTAgJysoUlMqKChtYXhfdmFsdWUgfHwgMCkgLSAobWluX3ZhbHVlIHx8IDApKSkrJyBsJyt0aGlzLl9zZXF1ZW5jZV9lbHMubGVuZ3RoKlJTKycgMCcpO1xuICAgICAgICBheGlzLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywwLjIqUlMpO1xuICAgICAgICBheGlzLnNldEF0dHJpYnV0ZSgndmlzaWJpbGl0eScsJ2hpZGRlbicpO1xuICAgICAgICBheGlzLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywndHJhbnNsYXRlKDEsMCknKTtcbiAgICAgICAgYXhpcy5zZXRBdHRyaWJ1dGUoJ3BvaW50ZXItZXZlbnRzJywnbm9uZScpO1xuICAgICAgICBheGlzLnNldEhlaWdodCA9IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgICAgICAgICAgaWYgKGFic19taW5fdmFsIDwgMCAmJiBhYnNfbWF4X3ZhbCA+IDApIHtcbiAgICAgICAgICAgICAgICBheGlzLnNldEF0dHJpYnV0ZSgnZCcsJ00wIDAgTTAgMCBtMCAnKyhoZWlnaHQqb2Zmc2V0X3NjYWxlKSsnIG0wICcrKDAuNSpoZWlnaHQqaGVpZ2h0X3NjYWxlKSsnIGwnK3JlbmRlcmVyLl9zZXF1ZW5jZV9lbHMubGVuZ3RoKlJTKycgMCcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBheGlzLnNldEF0dHJpYnV0ZSgnZCcsJ00wIDAgTTAgMCBtMCAnKyhoZWlnaHQqb2Zmc2V0X3NjYWxlKSsnIG0wICcrKDAuNSooMS1hYnNfbWluX3ZhbCkqaGVpZ2h0KmhlaWdodF9zY2FsZSkrJyBsJytyZW5kZXJlci5fc2VxdWVuY2VfZWxzLmxlbmd0aCpSUysnIDAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF4aXMuc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLDAuMipSUy9yZW5kZXJlci56b29tKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fbGF5ZXJfY29udGFpbmVyc1tsYXllck5hbWVdLnB1c2goYXhpcyk7XG4gICAgfVxuICAgIHZhciByZW5kZXJlciA9IHRoaXM7XG5cbiAgICBpZiAob3B0aW9ucy5sYWJlbCkge1xuICAgICAgICB2YXIgdGV4dCA9IHRoaXMuX2NhbnZhcy50ZXh0KDAsMCwgb3B0aW9ucy5sYWJlbC5tYXggfHwgb3B0aW9ucy5sYWJlbC5taW4gKTtcbiAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsJ3RyYW5zbGF0ZSgwLDApJyk7XG4gICAgICAgIHRleHQuc2V0QXR0cmlidXRlKCdmb250LXNpemUnLCAoNCpSUykrJ3B0Jyk7XG4gICAgICAgIHRleHQuc2V0SGVpZ2h0ID0gZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZSgneScsaGVpZ2h0Km9mZnNldF9zY2FsZSk7XG4gICAgICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZSgnZm9udC1zaXplJywoNCpSUy9yZW5kZXJlci56b29tKSsncHQnKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fbGF5ZXJfY29udGFpbmVyc1tsYXllck5hbWVdLnB1c2godGV4dCk7XG4gICAgfVxuXG4gICAgcGxvdC5zZXRIZWlnaHQgPSBmdW5jdGlvbihoZWlnaHQpIHtcbiAgICAgICAgdmFyIHBhdGhfdmFscyA9IHJlY2FsY3VsYXRlX3Bsb3QoMC41KmhlaWdodC9SUyk7XG4gICAgICAgIHBsb3Quc2V0QXR0cmlidXRlKCdkJywnTTAgMCBNMCAwIG0wICcrKGhlaWdodCpvZmZzZXRfc2NhbGUpKycgbTAgJysoMC41KmhlaWdodCpoZWlnaHRfc2NhbGUpKycgJytwYXRoX3ZhbHMpO1xuICAgICAgICBwbG90LnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywoKG9wdGlvbnMudGhpY2tuZXNzIHx8IDAuMzUpKlJTKS9yZW5kZXJlci56b29tKTtcbiAgICB9O1xuICAgIHJldHVybiBwbG90O1xufTtcblxuKGZ1bmN0aW9uKCkge1xudmFyIGFkZEVsZW1lbnRUb0xheWVyID0gZnVuY3Rpb24obGF5ZXJOYW1lLG9wdHMpIHtcbiAgICB2YXIgY2FudmFzID0gdGhpcy5fcmVuZGVyZXIuX2NhbnZhcztcblxuICAgIGlmICggISBjYW52YXMgKSB7ICAgICAgICBcbiAgICAgICAgdmFyIG9yaWdfZnVuYyA9IGFyZ3VtZW50cy5jYWxsZWU7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgYmVhbi5hZGQodGhpcy5fcmVuZGVyZXIsJ3NlcXVlbmNlY2hhbmdlJyxmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGJlYW4ucmVtb3ZlKHRoaXMuX3JlbmRlcmVyLCdzZXF1ZW5jZWNoYW5nZScsYXJndW1lbnRzLmNhbGxlZSk7ICAgICAgICAgICAgXG4gICAgICAgICAgICBvcmlnX2Z1bmMuY2FsbChzZWxmLGxheWVyTmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBsb2coXCJEZWxheWluZyByZW5kZXJpbmcsIHdhaXRpbmcgZm9yIHNlcXVlbmNlIGNoYW5nZVwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0cmFjZXIgPSBudWxsO1xuICAgIHZhciB0cmFjZXJfbWFya2VyID0gbnVsbDtcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcblxuICAgIGlmICggISBvcHRzICkge1xuICAgICAgICBvcHRzID0ge307XG4gICAgfVxuXG4gICAgdmFyIHNjYWxlID0gMTtcbiAgICBpZiAob3B0cy5oZWlnaHQpIHtcbiAgICAgICAgb3B0cy5oZWlnaHQgPSBwYXJzZUZsb2F0KG9wdHMuaGVpZ2h0KTtcbiAgICAgICAgaWYgKHR5cGVvZihvcHRzLmhlaWdodCkgIT09ICd1bmRlZmluZWQnICYmIG9wdHMuYmFyZV9lbGVtZW50ICkge1xuICAgICAgICAgICAgb3B0cy5oZWlnaHQgKj0gMjtcbiAgICAgICAgfVxuICAgICAgICBzY2FsZSA9IG9wdHMuaGVpZ2h0IC8gdGhpcy5fcmVuZGVyZXIuX2xheWVyX2NvbnRhaW5lcnNbbGF5ZXJOYW1lXS50cmFja19oZWlnaHQ7XG4gICAgICAgIGlmICh0eXBlb2Yob3B0cy5vZmZzZXQpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgb3B0cy5vZmZzZXQgID0gLTEuMjUgLTEuMjUgKyAob3B0cy5vZmZzZXQgLyBvcHRzLmhlaWdodCkgKiA1Oy8vICggLTI1MC80ICsgKHggLyBoZWlnaHQpICogMjUwICkgd2hlcmUgMjUwIGlzIGdyb3dpbmcgbWFya2VyIGhlaWdodFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRyYWNlcl9tYXJrZXIgPSBjYW52YXMuZ3Jvd2luZ01hcmtlcigwLDAsb3B0cy5jb250ZW50IHx8IGxheWVyTmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSxvcHRzKTtcbiAgICB0cmFjZXJfbWFya2VyLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywndHJhbnNsYXRlKCcrKCh0aGlzLl9pbmRleCArIDAuNSkgKiB0aGlzLl9yZW5kZXJlci5fUlMpICsnLDAuMDEpIHNjYWxlKCcrc2NhbGUrJyknKTtcbiAgICB0cmFjZXJfbWFya2VyLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywnMjUwJyk7XG4gICAgdHJhY2VyX21hcmtlci5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgtMTAwLDApIHJvdGF0ZSgwLDEwMCwwLjAwMSknKTtcbiAgICBpZiAoIG9wdHMuYnJlYWtfdmlld2JveCApIHtcbiAgICAgICAgdHJhY2VyX21hcmtlci5jb250YWluZXIucmVtb3ZlQXR0cmlidXRlKCd2aWV3Qm94Jyk7XG4gICAgICAgIHRyYWNlcl9tYXJrZXIuY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMTAwJScpO1xuICAgICAgICB0cmFjZXJfbWFya2VyLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsJzEwMCUnKTtcbiAgICB9XG4gICAgaWYgKCEgb3B0cy5ub190cmFjZXIgKSB7XG5cbiAgICAgICAgdmFyIGJvYmJsZSA9IGNhbnZhcy5jaXJjbGUodGhpcy5faW5kZXgrMC41LDEwLDAuMjUpO1xuICAgICAgICBib2JibGUuc2V0QXR0cmlidXRlKCd2aXNpYmlsaXR5JywnaGlkZGVuJyk7XG4gICAgICAgIGJvYmJsZS5zdHlsZS5vcGFjaXR5ID0gJzAuNCc7XG4gICAgICAgIHRyYWNlciA9IGNhbnZhcy5yZWN0KHRoaXMuX2luZGV4KzAuNSwxMCwwLjA1LDApO1xuICAgICAgICB0cmFjZXIuX2luZGV4ID0gdGhpcy5faW5kZXg7XG4gICAgICAgIHRyYWNlci5zdHlsZS5zdHJva2VXaWR0aCA9ICcwJztcbiAgICAgICAgdHJhY2VyLnN0eWxlLmZpbGwgPSBNQVNDUC5sYXllcnNbbGF5ZXJOYW1lXS5jb2xvcjtcbiAgICAgICAgdHJhY2VyLnNldEF0dHJpYnV0ZSgndmlzaWJpbGl0eScsJ2hpZGRlbicpO1xuICAgICAgICBjYW52YXMuaW5zZXJ0QmVmb3JlKHRyYWNlcixjYW52YXMuZmlyc3RDaGlsZC5uZXh0U2libGluZyk7XG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuXG4gICAgICAgIGlmICggISB0aGlzLl9yZW5kZXJlci5fbGF5ZXJfY29udGFpbmVyc1tsYXllck5hbWVdLnRyYWNlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLl9sYXllcl9jb250YWluZXJzW2xheWVyTmFtZV0udHJhY2VycyA9IGNhbnZhcy5zZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoICEgY2FudmFzLnRyYWNlcnMgKSB7XG4gICAgICAgICAgICBjYW52YXMudHJhY2VycyA9IGNhbnZhcy5zZXQoKTtcbiAgICAgICAgICAgIGNhbnZhcy5fdmlzaWJsZVRyYWNlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyZXIuX3Zpc2libGVUcmFjZXJzKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRyYWNlci5zZXRIZWlnaHQgPSBmdW5jdGlvbihoZWlnaHQpIHtcbiAgICAgICAgICAgIGlmICh0cmFjZXIuZ2V0QXR0cmlidXRlKCd2aXNpYmlsaXR5JykgPT0gJ2hpZGRlbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1fYXR0ciA9IHRyYWNlcl9tYXJrZXIuZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKTtcbiAgICAgICAgICAgIHZhciBtYXRjaGVzID0gL3RyYW5zbGF0ZVxcKC4qWyxcXHNdKC4qKVxcKSBzY2FsZVxcKCguKilcXCkvLmV4ZWModHJhbnNmb3JtX2F0dHIpO1xuICAgICAgICAgICAgaWYgKG1hdGNoZXNbMV0gJiYgbWF0Y2hlc1syXSkge1xuICAgICAgICAgICAgICAgIHZhciBzY2FsZSA9IHBhcnNlRmxvYXQobWF0Y2hlc1syXSk7XG4gICAgICAgICAgICAgICAgdmFyIHkgPSBwYXJzZUZsb2F0KG1hdGNoZXNbMV0pO1xuICAgICAgICAgICAgICAgIHZhciBuZXdfaGVpZ2h0ID0geSArIHNjYWxlKigoKHRyYWNlcl9tYXJrZXIub2Zmc2V0IHx8IDApICogNTApICsgMTI1KSAtIHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKCd5JykpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLG5ld19oZWlnaHQgPCAwID8gMCA6IG5ld19oZWlnaHQgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuX2xheWVyX2NvbnRhaW5lcnNbbGF5ZXJOYW1lXS50cmFjZXJzLnB1c2godHJhY2VyKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuX2xheWVyX2NvbnRhaW5lcnNbbGF5ZXJOYW1lXS50cmFjZXJzLnB1c2goYm9iYmxlKTtcbiAgICAgICAgdHJhY2VyLnNldEF0dHJpYnV0ZSgncG9pbnRlci1ldmVudHMnLCdub25lJyk7XG4gICAgICAgIGJvYmJsZS5zZXRBdHRyaWJ1dGUoJ3BvaW50ZXItZXZlbnRzJywnbm9uZScpO1xuICAgICAgICBjYW52YXMudHJhY2Vycy5wdXNoKHRyYWNlcik7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5vZmZzZXQgPT0gJ3VuZGVmaW5lZCcgfHwgb3B0cy5vZmZzZXQgPT09IG51bGwpIHtcbiAgICAgICAgLy8gdHJhY2VyX21hcmtlci5vZmZzZXQgPSAyLjUqdGhpcy5fcmVuZGVyZXIuX2xheWVyX2NvbnRhaW5lcnNbbGF5ZXJOYW1lXS50cmFja19oZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdHJhY2VyX21hcmtlci5vZmZzZXQgPSBvcHRzLm9mZnNldDtcbiAgICB9XG5cblxuICAgIC8vIHRyYWNlcl9tYXJrZXIuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCdzY2FsZSgwLjUpJyk7XG4gICAgLy8gdHJhY2VyX21hcmtlci56b29tX2xldmVsID0gJ3RleHQnO1xuICAgIHRyYWNlcl9tYXJrZXIuc2V0QXR0cmlidXRlKCd2aXNpYmlsaXR5JywnaGlkZGVuJyk7XG5cbiAgICB0aGlzLl9yZW5kZXJlci5fbGF5ZXJfY29udGFpbmVyc1tsYXllck5hbWVdLnB1c2godHJhY2VyX21hcmtlcik7XG4gICAgdmFyIHJlc3VsdCA9IFt0cmFjZXIsdHJhY2VyX21hcmtlcixib2JibGVdO1xuICAgIHRyYWNlcl9tYXJrZXIuc2V0QXR0cmlidXRlKCdjbGFzcycsbGF5ZXJOYW1lKTtcbiAgICByZXN1bHQubW92ZSA9IGZ1bmN0aW9uKHgsd2lkdGgpIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybV9hdHRyID0gdHJhY2VyX21hcmtlci5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpO1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IC90cmFuc2xhdGVcXCguKlssXFxzXSguKilcXCkgc2NhbGVcXCgoLiopXFwpLy5leGVjKHRyYW5zZm9ybV9hdHRyKTtcbiAgICAgICAgaWYgKG1hdGNoZXNbMV0gJiYgbWF0Y2hlc1syXSkge1xuICAgICAgICAgICAgdHJhY2VyX21hcmtlci5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsJ3RyYW5zbGF0ZSgnKygoeCswLjUpKnJlbmRlcmVyLl9SUykrJywnK21hdGNoZXNbMV0rJykgc2NhbGUoJyttYXRjaGVzWzJdKycpJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNlcikge1xuICAgICAgICAgICAgdHJhY2VyLm1vdmUoeCswLjUsMC4wNSk7XG4gICAgICAgICAgICBib2JibGUubW92ZSh4KzAuNSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGlmICh0cmFjZXIpIHtcbiAgICAgICAgdHJhY2VyX21hcmtlci50cmFjZXIgPSB0cmFjZXI7XG4gICAgICAgIHRyYWNlcl9tYXJrZXIuYm9iYmxlID0gYm9iYmxlO1xuICAgIH1cbiAgICB0aGlzLl9yZW5kZXJlci5fbGF5ZXJfY29udGFpbmVyc1tsYXllck5hbWVdLnB1c2gocmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIGFkZEJveE92ZXJsYXlUb0VsZW1lbnQgPSBmdW5jdGlvbihsYXllck5hbWUsd2lkdGgsZnJhY3Rpb24sb3B0cykge1xuICAgIFxuICAgIHZhciBjYW52YXMgPSB0aGlzLl9yZW5kZXJlci5fY2FudmFzO1xuICAgIHZhciByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuICAgIGlmICggISBvcHRzICkge1xuICAgICAgICBvcHRzID0geyB9O1xuICAgIH1cblxuICAgIGlmICggdHlwZW9mKGZyYWN0aW9uKSA9PT0gJ3VuZGVmaW5lZCcgfHwgZnJhY3Rpb24gPT09IG51bGwgKSB7XG4gICAgICAgIGZyYWN0aW9uID0gdHlwZW9mKG9wdHMub3BhY2l0eSkgIT09ICd1bmRlZmluZWQnID8gb3B0cy5vcGFjaXR5IDogMTtcbiAgICB9XG5cbiAgICBpZiAoICEgY2FudmFzICkge1xuICAgICAgICB2YXIgb3JpZ19mdW5jID0gYXJndW1lbnRzLmNhbGxlZTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBiZWFuLmFkZCh0aGlzLl9yZW5kZXJlciwnc2VxdWVuY2VjaGFuZ2UnLGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYmVhbi5yZW1vdmUodGhpcy5fcmVuZGVyZXIsJ3NlcXVlbmNlY2hhbmdlJyxhcmd1bWVudHMuY2FsbGVlKTtcbiAgICAgICAgICAgIG9yaWdfZnVuYy5jYWxsKHNlbGYsbGF5ZXJOYW1lLHdpZHRoLG9wdHMpO1xuICAgICAgICB9KTtcbiAgICAgICAgbG9nKFwiRGVsYXlpbmcgcmVuZGVyaW5nLCB3YWl0aW5nIGZvciBzZXF1ZW5jZSBjaGFuZ2VcIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cblxuICAgIHZhciByZWN0ID0gIGNhbnZhcy5yZWN0KC0wLjI1K3RoaXMuX2luZGV4LDYwLHdpZHRoIHx8IDEsIG9wdHMuaGVpZ2h0IHx8IDQgLG9wdHMpO1xuICAgIHZhciByZWN0X3ggPSBwYXJzZUZsb2F0KHJlY3QuZ2V0QXR0cmlidXRlKCd4JykpO1xuICAgIHZhciByZWN0X21heF94ID0gcmVjdF94ICsgcGFyc2VGbG9hdChyZWN0LmdldEF0dHJpYnV0ZSgnd2lkdGgnKSk7XG4gICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX3JlbmRlcmVyLl9sYXllcl9jb250YWluZXJzW2xheWVyTmFtZV07XG4gICAgaWYgKCB0eXBlb2Yob3B0cy5tZXJnZSkgIT09ICd1bmRlZmluZWQnICYmIG9wdHMubWVyZ2UgKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGFpbmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyW2ldLnZhbHVlICE9IGZyYWN0aW9uICkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGVsX3ggPSBwYXJzZUZsb2F0KGNvbnRhaW5lcltpXS5nZXRBdHRyaWJ1dGUoJ3gnKSk7XG4gICAgICAgICAgICB2YXIgZWxfbWF4X3ggPSBlbF94ICsgcGFyc2VGbG9hdChjb250YWluZXJbaV0uZ2V0QXR0cmlidXRlKCd3aWR0aCcpKTtcbiAgICAgICAgICAgIGlmICgoZWxfeCA8PSByZWN0X3ggJiYgcmVjdF94IDw9IGVsX21heF94KSB8fFxuICAgICAgICAgICAgICAgIChyZWN0X3ggPD0gZWxfeCAmJiBlbF94IDw9IHJlY3RfbWF4X3gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcltpXS5zZXRBdHRyaWJ1dGUoJ3gnLCBcIlwiK01hdGgubWluKGVsX3gscmVjdF94KSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcltpXS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgXCJcIisoTWF0aC5tYXgoZWxfbWF4X3gscmVjdF9tYXhfeCktTWF0aC5taW4oZWxfeCxyZWN0X3gpKSApO1xuICAgICAgICAgICAgICAgICAgICByZWN0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocmVjdCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250YWluZXJbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3JlbmRlcmVyLl9sYXllcl9jb250YWluZXJzW2xheWVyTmFtZV0ucHVzaChyZWN0KTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZSgnY2xhc3MnLGxheWVyTmFtZSk7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJyk7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsJzBweCcpO1xuICAgIGlmICh0eXBlb2YoZnJhY3Rpb24pICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZWN0LnNldEF0dHJpYnV0ZSgnb3BhY2l0eScsZnJhY3Rpb24pO1xuICAgICAgICByZWN0LnZhbHVlID0gZnJhY3Rpb247XG4gICAgfVxuICAgIHJlY3Quc2V0QXR0cmlidXRlKCdmaWxsJyxvcHRzLmZpbGwgfHwgTUFTQ1AubGF5ZXJzW2xheWVyTmFtZV0uY29sb3IpO1xuICAgIHJlY3QucG9zaXRpb25fc3RhcnQgPSB0aGlzLl9pbmRleDtcbiAgICByZWN0LnBvc2l0aW9uX2VuZCA9IHRoaXMuX2luZGV4ICsgd2lkdGg7XG4gICAgaWYgKCh0eXBlb2Yob3B0cy5vZmZzZXQpICE9PSBcInVuZGVmaW5lZFwiKSB8fCBvcHRzLmhlaWdodF9zY2FsZSkge1xuICAgICAgICB2YXIgb2Zmc2V0X3ZhbCA9IG9wdHMub2Zmc2V0O1xuICAgICAgICByZWN0LnNldEhlaWdodCA9IGZ1bmN0aW9uKGhnaHQpIHtcbiAgICAgICAgICAgIHZhciBoZWlnaHRfdmFsID0gb3B0cy5oZWlnaHQgPyAob3B0cy5oZWlnaHQqcmVuZGVyZXIuX1JTL3JlbmRlcmVyLnpvb20pIDogaGdodCoob3B0cy5oZWlnaHRfc2NhbGUgfHwgMSk7XG4gICAgICAgICAgICBpZiAob3B0cy5hbGlnbiA9PSAnYm90dG9tJykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCd5Jywob2Zmc2V0X3ZhbCpyZW5kZXJlci5fUlMvcmVuZGVyZXIuem9vbSktKGhnaHQqKG9wdHMuaGVpZ2h0X3NjYWxlIHx8IDEpKSApO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLGhlaWdodF92YWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgneScsb2Zmc2V0X3ZhbCpyZW5kZXJlci5fUlMvcmVuZGVyZXIuem9vbSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsaGVpZ2h0X3ZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiByZWN0O1xufTtcblxudmFyIGFkZFRleHRUb0VsZW1lbnQgPSBmdW5jdGlvbihsYXllck5hbWUsd2lkdGgsb3B0cykge1xuICAgIHZhciBjYW52YXMgPSB0aGlzLl9yZW5kZXJlci5fY2FudmFzO1xuICAgIHZhciByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuICAgIGlmICggISBjYW52YXMgKSB7XG4gICAgICAgIHZhciBvcmlnX2Z1bmMgPSBhcmd1bWVudHMuY2FsbGVlO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGJlYW4uYWRkKHRoaXMuX3JlbmRlcmVyLCdzZXF1ZW5jZWNoYW5nZScsZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBiZWFuLnJlbW92ZSh0aGlzLl9yZW5kZXJlciwnc2VxdWVuY2VjaGFuZ2UnLGFyZ3VtZW50cy5jYWxsZWUpO1xuICAgICAgICAgICAgb3JpZ19mdW5jLmNhbGwoc2VsZixsYXllck5hbWUsd2lkdGgsb3B0cyk7XG4gICAgICAgIH0pO1xuICAgICAgICBsb2coXCJEZWxheWluZyByZW5kZXJpbmcsIHdhaXRpbmcgZm9yIHNlcXVlbmNlIGNoYW5nZVwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoICEgb3B0cyApIHtcbiAgICAgICAgb3B0cyA9IHt9O1xuICAgIH1cbiAgICBpZiAob3B0cy5oZWlnaHQpIHtcbiAgICAgICAgb3B0cy5oZWlnaHQgPSBvcHRzLmhlaWdodCAqIHRoaXMuX3JlbmRlcmVyLl9SUztcbiAgICB9XG4gICAgdmFyIGhlaWdodCA9IG9wdHMuaGVpZ2h0IHx8IHRoaXMuX3JlbmRlcmVyLl9sYXllcl9jb250YWluZXJzW2xheWVyTmFtZV0udHJhY2tIZWlnaHQgfHwgNDtcbiAgICB2YXIgcG9zaXRpb24gPSB0aGlzLl9pbmRleDtcbiAgICBpZiAod2lkdGggPiAxKSB7XG4gICAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gKyBNYXRoLmZsb29yKDAuNSp3aWR0aCk7XG4gICAgfVxuICAgIHZhciB0ZXh0X3NjYWxlID0gKDQvMyk7XG4gICAgdmFyIHRleHQgPSBjYW52YXMudGV4dChwb3NpdGlvbiwwLG9wdHMudHh0IHx8IG9wdHMuY29udGVudCB8fCBcIlRleHRcIik7XG4gICAgdGV4dC5zZXRBdHRyaWJ1dGUoJ2ZvbnQtc2l6ZScsdGV4dF9zY2FsZSpoZWlnaHQpO1xuICAgIHRleHQuY2FjaGVkX3dpZHRoID0gdGV4dC5nZXRDb21wdXRlZFRleHRMZW5ndGgoKSAvIGhlaWdodDtcbiAgICB0ZXh0LnNldEF0dHJpYnV0ZSgnZm9udC13ZWlnaHQnLCdib2xkZXInKTtcbiAgICB0ZXh0LnNldEF0dHJpYnV0ZSgnZmlsbCcsIG9wdHMuZmlsbCB8fCAnI2ZmZmZmZicpO1xuICAgIHRleHQuc2V0QXR0cmlidXRlKCdzdHJva2UnLCcjMDAwMDAwJyk7XG4gICAgaWYgKCEgKFwic3Ryb2tlX3dpZHRoXCIgaW4gb3B0cykpIHtcbiAgICAgICAgb3B0cy5zdHJva2Vfd2lkdGggPSA1O1xuICAgIH1cbiAgICB0ZXh0LnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJyxvcHRzLnN0cm9rZV93aWR0aCsnJyk7XG4gICAgdGV4dC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywnZm9udC1mYW1pbHk6ICcrY2FudmFzLmZvbnRfb3JkZXIpO1xuICAgIHRleHQuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoJ2R5JywnMS4zZXgnKTtcbiAgICB0ZXh0LnNldEF0dHJpYnV0ZSgndGV4dC1hbmNob3InLCdtaWRkbGUnKTtcbiAgICBpZiAob3B0cy5hbGlnbikge1xuICAgICAgICBpZiAob3B0cy5hbGlnbiA9PSBcImxlZnRcIikge1xuICAgICAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGUoJ3RleHQtYW5jaG9yJywgJ3N0YXJ0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuYWxpZ24gPT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGUoJ3RleHQtYW5jaG9yJywgJ2VuZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh3aWR0aCA+IDEpIHtcbiAgICAgICAgdmFyIGNsaXAgPSBjYW52YXMuY2xpcFBhdGgoKTtcbiAgICAgICAgdmFyIG1hc2sgPSBjYW52YXMucmVjdCgtMC41KndpZHRoLG9wdHMub2Zmc2V0IHx8IDAsd2lkdGgsaGVpZ2h0KTtcbiAgICAgICAgY2xpcC5wdXNoKG1hc2spO1xuICAgICAgICBtYXNrLnJlbW92ZUF0dHJpYnV0ZSgneScpO1xuICAgICAgICB2YXIgbWFza19pZCA9ICdpZCcgKyAobmV3IERhdGUoKSkuZ2V0VGltZSgpK1wiX1wiK2NsaXAucGFyZW50Tm9kZS5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgICAgY2xpcC5zZXRBdHRyaWJ1dGUoJ2lkJyxtYXNrX2lkKTtcbiAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGUoJ2NsaXAtcGF0aCcsJ3VybCgjJyttYXNrX2lkKycpJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5vZmZzZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRleHQuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCd0cmFuc2xhdGUoJyt0ZXh0LmdldEF0dHJpYnV0ZSgneCcpKycsJyt0ZXh0LmdldEF0dHJpYnV0ZSgneScpKycpJyk7XG4gICAgICAgIHRleHQub2Zmc2V0ID0gb3B0cy5vZmZzZXQ7XG4gICAgICAgIHRleHQuc2V0SGVpZ2h0ID0gZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgdG9wX29mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3gnLDApO1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3knLHRvcF9vZmZzZXQqcmVuZGVyZXIuX1JTIC8gcmVuZGVyZXIuem9vbSk7XG4gICAgICAgICAgICBpZiAobWFzaykgbWFzay5zZXRBdHRyaWJ1dGUoJ3knLHRoaXMuZ2V0QXR0cmlidXRlKCd5JykpO1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIDUvcmVuZGVyZXIuem9vbSk7XG4gICAgICAgICAgICBpZiAob3B0cy5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnZm9udC1zaXplJywgdGV4dF9zY2FsZSpvcHRzLmhlaWdodC9yZW5kZXJlci56b29tKTtcbiAgICAgICAgICAgICAgICBpZiAobWFzaykgbWFzay5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsb3B0cy5oZWlnaHQvcmVuZGVyZXIuem9vbSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdmb250LXNpemUnLCB0ZXh0X3NjYWxlKmhlaWdodCk7XG4gICAgICAgICAgICAgICAgaWYgKG1hc2spIG1hc2suc2V0QXR0cmlidXRlKCdoZWlnaHQnLGhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgbWFzaywgd2Ugd2FudCB0byBtb3ZlIHRoZSB0ZXh0IHRvIHRoZSBsZWZ0LlxuICAgICAgICAgICAgaWYgKCBtYXNrICkge1xuICAgICAgICAgICAgICAgIGlmICgodGhpcy5jYWNoZWRfd2lkdGgqaGVpZ2h0KSA+ICh3aWR0aCAqNTApKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCd4JywoLTAuNSp3aWR0aCo1MCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgndGV4dC1hbmNob3InLCdzdGFydCcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCd4JywnMCcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgndGV4dC1hbmNob3InLCdtaWRkbGUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCd4JywnMCcpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCd0ZXh0LWFuY2hvcicsJ21pZGRsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQuc2V0SGVpZ2h0ID0gZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgNS9yZW5kZXJlci56b29tKTtcbiAgICAgICAgICAgIGlmIChvcHRzLmhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRleHQuc2V0QXR0cmlidXRlKCdmb250LXNpemUnLCB0ZXh0X3NjYWxlKm9wdHMuaGVpZ2h0L3JlbmRlcmVyLnpvb20pO1xuICAgICAgICAgICAgICAgIGlmIChtYXNrKSBtYXNrLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JyxvcHRzLmhlaWdodC9yZW5kZXJlci56b29tKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGUoJ2ZvbnQtc2l6ZScsIHRleHRfc2NhbGUqaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBpZiAobWFzaykgbWFzay5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHdpZHRoID4gMSkge1xuICAgICAgICB0ZXh0Lm1vdmUgPSBmdW5jdGlvbihuZXdfeCxuZXdfd2lkdGgpIHtcbiAgICAgICAgICAgIGlmIChtYXNrKSBtYXNrLnNldEF0dHJpYnV0ZSgneCcsKC0xKm5ld193aWR0aCpyZW5kZXJlci5fUlMqMC41KSk7XG4gICAgICAgICAgICBpZiAobWFzaykgbWFzay5zZXRBdHRyaWJ1dGUoJ3dpZHRoJyxuZXdfd2lkdGgqcmVuZGVyZXIuX1JTKTtcbiAgICAgICAgICAgIHRleHQuc2V0QXR0cmlidXRlKCd4JywobmV3X3ggKyBwYXJzZUludCgwLjUqbmV3X3dpZHRoKSkqcmVuZGVyZXIuX1JTICk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHRoaXMuX3JlbmRlcmVyLl9sYXllcl9jb250YWluZXJzW2xheWVyTmFtZV0ucHVzaCh0ZXh0KTtcbiAgICByZXR1cm4gdGV4dDtcbn1cblxudmFyIGFkZFNoYXBlVG9FbGVtZW50ID0gZnVuY3Rpb24obGF5ZXJOYW1lLHdpZHRoLG9wdHMpIHtcbiAgICB2YXIgY2FudmFzID0gdGhpcy5fcmVuZGVyZXIuX2NhbnZhcztcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcblxuICAgIGlmICggISBjYW52YXMgKSB7XG4gICAgICAgIHZhciBvcmlnX2Z1bmMgPSBhcmd1bWVudHMuY2FsbGVlO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGJlYW4uYWRkKHRoaXMuX3JlbmRlcmVyLCdzZXF1ZW5jZWNoYW5nZScsZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBiZWFuLnJlbW92ZSh0aGlzLl9yZW5kZXJlciwnc2VxdWVuY2VjaGFuZ2UnLGFyZ3VtZW50cy5jYWxsZWUpO1xuICAgICAgICAgICAgb3JpZ19mdW5jLmNhbGwoc2VsZixsYXllck5hbWUsd2lkdGgsb3B0cyk7XG4gICAgICAgIH0pO1xuICAgICAgICBsb2coXCJEZWxheWluZyByZW5kZXJpbmcsIHdhaXRpbmcgZm9yIHNlcXVlbmNlIGNoYW5nZVwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBtZXRob2RzID0ge1xuICAgICAgICBcInBlbnRhZ29uXCIgOiBjYW52YXMucGVudGFnb24sXG4gICAgICAgIFwiaGV4YWdvblwiICA6IGNhbnZhcy5oZXhhZ29uLFxuICAgICAgICBcInJlY3RhbmdsZVwiOiBjYW52YXMucmVjdCxcbiAgICAgICAgXCJlbGxpcHNlXCIgIDogY2FudmFzLmVsbGlwdGljYWxSZWN0LFxuICAgICAgICBcInJvdW5kcmVjdFwiOiBmdW5jdGlvbih4LHksd2lkdGgsaGVpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4gY2FudmFzLnJvdW5kUmVjdCh4LHksd2lkdGgsaGVpZ2h0LDAuMjUqaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoICEgb3B0cy5yb3RhdGUgKSB7XG4gICAgICAgIG9wdHMucm90YXRlID0gMDtcbiAgICB9XG4gICAgdmFyIHNoYXBlID0gbnVsbDtcbiAgICB2YXIgc2hhcGVfbmFtZSA9IChvcHRzLnNoYXBlLnNwbGl0KCctJykgfHwgJycpWzBdO1xuICAgIGlmIChzaGFwZV9uYW1lIGluIG1ldGhvZHMpIHtcbiAgICAgICAgdmFyIGlzX3JvdGF0ZWQgPSBvcHRzLnNoYXBlLnNwbGl0KCctJylbMV07XG4gICAgICAgIGlmIChpc19yb3RhdGVkID09ICdsZWZ0JyAmJiAhIG9wdHMucm90YXRlKSB7XG4gICAgICAgICAgICBvcHRzLnJvdGF0ZSA9IDkwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc19yb3RhdGVkID09ICdyaWdodCcgJiYgISBvcHRzLnJvdGF0ZSkge1xuICAgICAgICAgICAgb3B0cy5yb3RhdGUgPSAyNzA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzX3JvdGF0ZWQgPT0gJ2ZsaXAnICYmICEgb3B0cy5yb3RhdGUpIHtcbiAgICAgICAgICAgIG9wdHMucm90YXRlID0gMTgwO1xuICAgICAgICB9XG4gICAgICAgIHNoYXBlID0gbWV0aG9kc1tzaGFwZV9uYW1lXS5jYWxsKGNhbnZhcyx0aGlzLl9pbmRleCw2MCx3aWR0aCB8fCAxLG9wdHMuaGVpZ2h0IHx8IDQsb3B0cy5yb3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCh0eXBlb2Ygb3B0cy5vZmZzZXQpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgeF9wb3MgPSBzaGFwZS5nZXRBdHRyaWJ1dGUoJ3gnKTtcbiAgICAgICAgdmFyIHlfcG9zID0gc2hhcGUuZ2V0QXR0cmlidXRlKCd5Jyk7XG4gICAgICAgIHNoYXBlLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywndHJhbnNsYXRlKCcreF9wb3MrJywnK3lfcG9zKycpJyk7XG4gICAgICAgIHNoYXBlLnNldEF0dHJpYnV0ZSgneCcsJzAnKTtcbiAgICAgICAgdmFyIG9mZnNldF92YWwgPSBvcHRzLm9mZnNldCB8fCAwO1xuICAgICAgICB2YXIgb3JpZ19oZWlnaHQgPSBvcHRzLmhlaWdodCB8fCA0O1xuICAgICAgICBzaGFwZS5zZXRBdHRyaWJ1dGUoJ3knLG9mZnNldF92YWwqdGhpcy5fcmVuZGVyZXIuX1JTKTtcbiAgICAgICAgc2hhcGUuc2V0SGVpZ2h0ID0gZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgICAgICAgICBpZiAoICEgdGhpcy5fb3JpZ19zdHJva2Vfd2lkdGggKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3JpZ19zdHJva2Vfd2lkdGggPSBwYXJzZUludCh0aGlzLmdldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2hhcGUuc2V0QXR0cmlidXRlKCd5JywgKG9mZnNldF92YWwqcmVuZGVyZXIuX1JTL3JlbmRlcmVyLnpvb20pKTtcbiAgICAgICAgICAgIHNoYXBlLnNldEF0dHJpYnV0ZSgnaGVpZ2h0Jywob3JpZ19oZWlnaHQqcmVuZGVyZXIuX1JTKS9yZW5kZXJlci56b29tKTtcbiAgICAgICAgICAgIHNoYXBlLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJyx0aGlzLl9vcmlnX3N0cm9rZV93aWR0aC9yZW5kZXJlci56b29tKTtcbiAgICAgICAgICAgIGlmICggb3B0cy5zaGFwZSA9PSAnZWxsaXBzZScgKSB7XG4gICAgICAgICAgICAgICAgc2hhcGUuc2V0QXR0cmlidXRlKCdyeScsIDAuNSoob3JpZ19oZWlnaHQqcmVuZGVyZXIuX1JTKS9yZW5kZXJlci56b29tICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5zaGFwZSA9PSAncm91bmRyZWN0Jykge1xuICAgICAgICAgICAgICAgIHNoYXBlLnNldEF0dHJpYnV0ZSgncngnLCAwLjI1KihvcmlnX2hlaWdodCpyZW5kZXJlci5fUlMpL3JlbmRlcmVyLnpvb20gKTtcbiAgICAgICAgICAgICAgICBzaGFwZS5zZXRBdHRyaWJ1dGUoJ3J5JywgMC4yNSoob3JpZ19oZWlnaHQqcmVuZGVyZXIuX1JTKS9yZW5kZXJlci56b29tICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHNoYXBlLm1vdmUgPSBmdW5jdGlvbihuZXdfeCxuZXdfd2lkdGgpIHtcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1fYXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKTtcbiAgICAgICAgICAgIHZhciBtYXRjaGVzID0gL3RyYW5zbGF0ZVxcKC4qWyxcXHNdKC4qKVxcKS8uZXhlYyh0cmFuc2Zvcm1fYXR0cik7XG4gICAgICAgICAgICBpZiAobWF0Y2hlc1sxXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCd0cmFuc2xhdGUoJysobmV3X3gqcmVuZGVyZXIuX1JTKSsnLCcrbWF0Y2hlc1sxXSsnKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJyxuZXdfd2lkdGgqcmVuZGVyZXIuX1JTKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoKCh0eXBlb2Ygb3B0cy5vZmZzZXQpICE9PSAndW5kZWZpbmVkJykgJiYgKG9wdHMuc2hhcGUgPT0gXCJoZXhhZ29uXCIgfHwgb3B0cy5zaGFwZSA9PSBcInBlbnRhZ29uXCIgKSkge1xuICAgICAgICB2YXIgb2Zmc2V0X3ZhbCA9IG9wdHMub2Zmc2V0IHx8IDA7XG4gICAgICAgIHZhciBvcmlnX2hlaWdodCA9IG9wdHMuaGVpZ2h0IHx8IDQ7XG4gICAgICAgIHZhciBhZGp1c3RtZW50X2cgPSBjYW52YXMuZ3JvdXAoKTtcbiAgICAgICAgYWRqdXN0bWVudF9nLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJyxzaGFwZS5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpKTtcbiAgICAgICAgYWRqdXN0bWVudF9nLnB1c2goc2hhcGUpO1xuICAgICAgICBzaGFwZS5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsJ3RyYW5zbGF0ZSgwLDApJyk7XG4gICAgICAgIGFkanVzdG1lbnRfZy5zZXRIZWlnaHQgPSBmdW5jdGlvbihoZWlnaHQpIHtcbiAgICAgICAgICAgIGlmICggISBzaGFwZS5fb3JpZ19zdHJva2Vfd2lkdGggKSB7XG4gICAgICAgICAgICAgICAgc2hhcGUuX29yaWdfc3Ryb2tlX3dpZHRoID0gcGFyc2VJbnQoc2hhcGUuZ2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnKSkgfHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNoYXBlLnNldEhlaWdodChvcmlnX2hlaWdodCpyZW5kZXJlci5fUlMvcmVuZGVyZXIuem9vbSk7XG4gICAgICAgICAgICBzaGFwZS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsdGhpcy5fb3JpZ19zdHJva2Vfd2lkdGgvcmVuZGVyZXIuem9vbSk7XG4gICAgICAgICAgICBzaGFwZS5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsJ3RyYW5zbGF0ZSgwLDApJyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLl9sYXllcl9jb250YWluZXJzW2xheWVyTmFtZV0ucHVzaChhZGp1c3RtZW50X2cpO1xuICAgICAgICBhZGp1c3RtZW50X2cuc2V0QXR0cmlidXRlKCd2aXNpYmlsaXR5JywgJ2hpZGRlbicpO1xuICAgICAgICBhZGp1c3RtZW50X2cuc2V0QXR0cmlidXRlKCdjbGFzcycsbGF5ZXJOYW1lKTtcbiAgICAgICAgYWRqdXN0bWVudF9nLnBvc2l0aW9uX3N0YXJ0ID0gdGhpcy5faW5kZXg7XG4gICAgICAgIGFkanVzdG1lbnRfZy5wb3NpdGlvbl9lbmQgPSB0aGlzLl9pbmRleCArIHdpZHRoO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuX2xheWVyX2NvbnRhaW5lcnNbbGF5ZXJOYW1lXS5wdXNoKHNoYXBlKTtcbiAgICAgICAgc2hhcGUuc2V0QXR0cmlidXRlKCd2aXNpYmlsaXR5JywgJ2hpZGRlbicpO1xuICAgICAgICBzaGFwZS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJyxsYXllck5hbWUpO1xuICAgICAgICBzaGFwZS5wb3NpdGlvbl9zdGFydCA9IHRoaXMuX2luZGV4O1xuICAgICAgICBzaGFwZS5wb3NpdGlvbl9lbmQgPSB0aGlzLl9pbmRleCArIHdpZHRoO1xuXG4gICAgfVxuICAgIHNoYXBlLnNldEF0dHJpYnV0ZSgnZmlsbCcsb3B0cy5maWxsIHx8IE1BU0NQLmxheWVyc1tsYXllck5hbWVdLmNvbG9yKTtcbiAgICBpZiAob3B0cy5zdHJva2UpIHtcbiAgICAgICAgc2hhcGUuc2V0QXR0cmlidXRlKCdzdHJva2UnLG9wdHMuc3Ryb2tlKTtcbiAgICB9XG4gICAgaWYgKG9wdHMuc3Ryb2tlX3dpZHRoKSB7XG4gICAgICAgIHNoYXBlLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJyxyZW5kZXJlci5fUlMqb3B0cy5zdHJva2Vfd2lkdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNoYXBlLnN0eWxlLnN0cm9rZVdpZHRoID0gJzAnO1xuICAgIH1cbiAgICByZXR1cm4gc2hhcGU7XG59O1xuXG52YXIgYWRkRWxlbWVudFRvTGF5ZXJXaXRoTGluayA9IGZ1bmN0aW9uKGxheWVyTmFtZSx1cmwsd2lkdGgpIHtcbiAgICB2YXIgY2FudmFzID0gdGhpcy5fcmVuZGVyZXIuX2NhbnZhcztcblxuICAgIGlmICggISBjYW52YXMgKSB7XG4gICAgICAgIHZhciBvcmlnX2Z1bmMgPSBhcmd1bWVudHMuY2FsbGVlO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGJlYW4uYWRkKHRoaXMuX3JlbmRlcmVyLCdzZXF1ZW5jZWNoYW5nZScsZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBiZWFuLnJlbW92ZSh0aGlzLl9yZW5kZXJlciwnc2VxdWVuY2VjaGFuZ2UnLGFyZ3VtZW50cy5jYWxsZWUpOyAgICAgICAgICAgIFxuICAgICAgICAgICAgb3JpZ19mdW5jLmNhbGwoc2VsZixsYXllck5hbWUsdXJsLHdpZHRoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxvZyhcIkRlbGF5aW5nIHJlbmRlcmluZywgd2FpdGluZyBmb3Igc2VxdWVuY2UgY2hhbmdlXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG5cbiAgICB2YXIgcmVjdCA9ICBjYW52YXMucmVjdCgtMC4yNSt0aGlzLl9pbmRleCw2MCx3aWR0aCB8fCAxLDQpO1xuICAgIHRoaXMuX3JlbmRlcmVyLl9sYXllcl9jb250YWluZXJzW2xheWVyTmFtZV0ucHVzaChyZWN0KTtcbiAgICByZWN0LnN0eWxlLnN0cm9rZVdpZHRoID0gJzBweCc7ICAgIFxuICAgIHJlY3Quc2V0QXR0cmlidXRlKCdmaWxsJyxNQVNDUC5sYXllcnNbbGF5ZXJOYW1lXS5jb2xvcik7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJyk7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJyxsYXllck5hbWUpO1xuICAgIHJldHVybiByZWN0O1xufTtcblxudmFyIGFkZENhbGxvdXRUb0xheWVyID0gZnVuY3Rpb24obGF5ZXJOYW1lLGVsZW1lbnQsb3B0cykge1xuICAgIHZhciBjYW52YXMgPSB0aGlzLl9yZW5kZXJlci5fY2FudmFzO1xuXG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XG4gICAgXG4gICAgaWYgKHR5cGVvZiBlbGVtZW50ID09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBhX2VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHJlbmRlcmVyLmZpbGxUZW1wbGF0ZShlbGVtZW50LG9wdHMsZnVuY3Rpb24oZXJyLGVsKSB7XG4gICAgICAgICAgICBhX2VsLmlubmVySFRNTCA9IGVsO1xuICAgICAgICB9KTtcbiAgICAgICAgZWxlbWVudCA9IGFfZWw7XG4gICAgfVxuICAgIFxuICAgIGlmICggISBjYW52YXMgKSB7XG4gICAgICAgIHZhciBvcmlnX2Z1bmMgPSBhcmd1bWVudHMuY2FsbGVlO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGJlYW4uYWRkKHRoaXMuX3JlbmRlcmVyLCdzZXF1ZW5jZWNoYW5nZScsZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBiZWFuLnJlbW92ZSh0aGlzLl9yZW5kZXJlciwnc2VxdWVuY2VjaGFuZ2UnLGFyZ3VtZW50cy5jYWxsZWUpOyAgICAgICAgICAgIFxuICAgICAgICAgICAgb3JpZ19mdW5jLmNhbGwoc2VsZixsYXllck5hbWUsd2lkdGgsb3B0cyk7XG4gICAgICAgIH0pO1xuICAgICAgICBsb2coXCJEZWxheWluZyByZW5kZXJpbmcsIHdhaXRpbmcgZm9yIHNlcXVlbmNlIGNoYW5nZVwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY2FsbG91dCA9IGNhbnZhcy5jYWxsb3V0KHRoaXMuX2luZGV4KzAuNSwwLjAxLGVsZW1lbnQseyd3aWR0aCcgOiAoMTAqb3B0cy53aWR0aCkgfHwgMTAwICwnaGVpZ2h0JzogKG9wdHMuaGVpZ2h0ICogMTApIHx8IDEwMCwgJ2FsaWduJyA6IG9wdHMuYWxpZ24sICdmb250LXNpemUnIDogb3B0c1snZm9udC1zaXplJ10gfSk7XG4gICAgY2FsbG91dC5zZXRIZWlnaHQob3B0cy5oZWlnaHQqdGhpcy5fcmVuZGVyZXIuX1JTKTtcbiAgICB0aGlzLl9yZW5kZXJlci5fY2FudmFzX2NhbGxvdXRfcGFkZGluZyA9IE1hdGgubWF4KCgoMTAqb3B0cy5oZWlnaHQpIHx8IDEwMCksdGhpcy5fcmVuZGVyZXIuX2NhbnZhc19jYWxsb3V0X3BhZGRpbmd8fDApO1xuICAgIHRoaXMuX3JlbmRlcmVyLl9sYXllcl9jb250YWluZXJzW2xheWVyTmFtZV0ucHVzaChjYWxsb3V0KTtcbiAgICBjYWxsb3V0LmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb250ID0gcmVuZGVyZXIuX2xheWVyX2NvbnRhaW5lcnNbbGF5ZXJOYW1lXTtcbiAgICAgICAgaWYgKGNvbnQuaW5kZXhPZihjYWxsb3V0KSA+IDApIHtcbiAgICAgICAgICAgIGNvbnQuc3BsaWNlKGNvbnQuaW5kZXhPZihjYWxsb3V0KSwxKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsb3V0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2FsbG91dCk7XG4gICAgfTtcbiAgICByZXR1cm4gY2FsbG91dDtcbn07XG5cbnZhciBzY2FsZWRBZGRTaGFwZU92ZXJsYXkgPSBmdW5jdGlvbihsYXllcm5hbWUsd2lkdGgsb3B0cykge1xuICAgIHZhciBzdGFydCA9IHRoaXMuX2luZGV4O1xuICAgIHZhciBlbmQgPSBNYXRoLmFicyh0aGlzLl9yZW5kZXJlci5zY2FsZVBvc2l0aW9uKHRoaXMub3JpZ2luYWxfaW5kZXgrd2lkdGgsbGF5ZXJuYW1lKSkgLSAxO1xuICAgIHZhciByZXMgPSBhZGRTaGFwZVRvRWxlbWVudC5jYWxsKHN0YXJ0IDwgZW5kID8gdGhpcyA6IHRoaXMuX3JlbmRlcmVyLl9zZXF1ZW5jZV9lbHNbZW5kXSxsYXllcm5hbWUsIE1hdGguYWJzKGVuZCAtIHN0YXJ0KSxvcHRzKTtcbiAgICByZXMuYWEgPSB0aGlzLm9yaWdpbmFsX2luZGV4O1xuICAgIHJlcy5hYV93aWR0aCA9IHdpZHRoO1xuICAgIHJldHVybiByZXM7XG59O1xuXG52YXIgc2NhbGVkQWRkQm94T3ZlcmxheSA9IGZ1bmN0aW9uKGxheWVybmFtZSx3aWR0aCxmcmFjdGlvbixvcHRzKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5faW5kZXg7XG4gICAgdmFyIGVuZCA9IE1hdGguYWJzKHRoaXMuX3JlbmRlcmVyLnNjYWxlUG9zaXRpb24odGhpcy5vcmlnaW5hbF9pbmRleCt3aWR0aCxsYXllcm5hbWUpKSAtIDE7XG5cbiAgICB2YXIgcmVzID0gYWRkQm94T3ZlcmxheVRvRWxlbWVudC5jYWxsKHN0YXJ0IDwgZW5kID8gdGhpcyA6IHRoaXMuX3JlbmRlcmVyLl9zZXF1ZW5jZV9lbHNbZW5kXSxsYXllcm5hbWUsTWF0aC5hYnMoZW5kIC0gc3RhcnQpLGZyYWN0aW9uLG9wdHMpO1xuXG4gICAgaWYgKCEgKG9wdHMgfHwge30pLm1lcmdlICkge1xuICAgICAgICByZXMuYWFfd2lkdGggPSB3aWR0aDtcbiAgICAgICAgcmVzLmFhID0gdGhpcy5vcmlnaW5hbF9pbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXMuYWFfd2lkdGggPSBwYXJzZUludChyZXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcpKSAvIHRoaXMuX3JlbmRlcmVyLl9SUztcbiAgICAgICAgaWYgKHJlcy5hYV93aWR0aCA9PSB3aWR0aCkge1xuICAgICAgICAgICAgcmVzLmFhID0gdGhpcy5vcmlnaW5hbF9pbmRleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufTtcblxudmFyIHNjYWxlZEFkZFRleHRPdmVybGF5ID0gZnVuY3Rpb24obGF5ZXJuYW1lLHdpZHRoLG9wdHMpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLl9pbmRleDtcbiAgICB2YXIgZW5kID0gTWF0aC5hYnModGhpcy5fcmVuZGVyZXIuc2NhbGVQb3NpdGlvbih0aGlzLm9yaWdpbmFsX2luZGV4K3dpZHRoLGxheWVybmFtZSkpIC0gMTtcbiAgICB2YXIgcmVzID0gYWRkVGV4dFRvRWxlbWVudC5jYWxsKHN0YXJ0IDwgZW5kID8gdGhpcyA6IHRoaXMuX3JlbmRlcmVyLl9zZXF1ZW5jZV9lbHNbZW5kXSxsYXllcm5hbWUsTWF0aC5hYnMoZW5kIC0gc3RhcnQpLG9wdHMpO1xuICAgIHJlcy5hYSA9IHRoaXMub3JpZ2luYWxfaW5kZXg7XG4gICAgcmVzLmFhX3dpZHRoID0gd2lkdGg7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbnZhciBzY2FsZWRBZGRUb0xheWVyV2l0aExpbmsgPSBmdW5jdGlvbihsYXllcm5hbWUsdXJsLHdpZHRoKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5faW5kZXg7XG4gICAgdmFyIGVuZCA9IE1hdGguYWJzKHRoaXMuX3JlbmRlcmVyLnNjYWxlUG9zaXRpb24odGhpcy5vcmlnaW5hbF9pbmRleCt3aWR0aCxsYXllcm5hbWUpKSAtIDE7XG4gICAgdmFyIHJlcyA9IGFkZEVsZW1lbnRUb0xheWVyV2l0aExpbmsuY2FsbChzdGFydCA8IGVuZCA/IHRoaXMgOiB0aGlzLl9yZW5kZXJlci5fc2VxdWVuY2VfZWxzW2VuZF0sbGF5ZXJuYW1lLHVybCxNYXRoLmFicyhlbmQgLSBzdGFydCkpO1xuICAgIHJlcy5hYSA9IHRoaXMub3JpZ2luYWxfaW5kZXg7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbnZhciBzY2FsZWRBZGRUb0xheWVyID0gZnVuY3Rpb24obGF5ZXJuYW1lLG9wdHMpIHtcbiAgICB2YXIgcmVzID0gYWRkRWxlbWVudFRvTGF5ZXIuY2FsbCh0aGlzLGxheWVybmFtZSxvcHRzKTtcbiAgICByZXMuYWEgPSB0aGlzLm9yaWdpbmFsX2luZGV4O1xuICAgIHJlcy5hYV93aWR0aCA9IDE7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbkNvbmRlbnNlZFNlcXVlbmNlUmVuZGVyZXIucHJvdG90eXBlLmVuYWJsZVNjYWxpbmcgPSBmdW5jdGlvbigpIHtcbiAgICBiZWFuLmFkZCh0aGlzLCdyZWFkZXJSZWdpc3RlcmVkJyxmdW5jdGlvbihyZWFkZXIpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0VuYWJsaW5nIHNjYWxpbmcgZm9yIGxlZ2FjeSByZWFkZXJzJyk7XG4gICAgICAgIHZhciBvbGRfcmVzdWx0ID0gcmVhZGVyLmdvdFJlc3VsdDtcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcztcbiAgICAgICAgcmVhZGVyLmdvdFJlc3VsdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHdhbnRlZF9pZCA9IHJlYWRlci5hY2MgfHwgcmVhZGVyLmFnaSB8fCBcIlwiO1xuXG4gICAgICAgICAgICB2YXIgb2xkX2dldF9hYXMgPSBDb25kZW5zZWRTZXF1ZW5jZVJlbmRlcmVyLnByb3RvdHlwZS5nZXRBbWlub0FjaWRzQnlQb3NpdGlvbjtcbiAgICAgICAgICAgIHZhciBvbGRfZ2V0X3BlcCA9IENvbmRlbnNlZFNlcXVlbmNlUmVuZGVyZXIucHJvdG90eXBlLmdldEFtaW5vQWNpZHNCeVBlcHRpZGU7XG4gICAgICAgICAgICB2YXIgb2xkX3NlcXVlbmNlID0gcmVuZGVyZXIuc2VxdWVuY2U7XG4gICAgICAgICAgICBpZiAocmVuZGVyZXIuc2VxdWVuY2VzKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuc2VxdWVuY2UgPSAocmVuZGVyZXIuc2VxdWVuY2VzIFsgKCByZW5kZXJlci5zZXF1ZW5jZXMubWFwKGZ1bmN0aW9uKHNlcSkgeyAgcmV0dXJuIChzZXEuYWdpIHx8IHNlcS5hY2MgfHwgXCJcIikudG9Mb3dlckNhc2UoKTsgIH0pICkuaW5kZXhPZih3YW50ZWRfaWQudG9Mb3dlckNhc2UoKSkgXSB8fCBcIlwiKS50b1N0cmluZygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvbGRfc2VxdWVuY2UgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVuZGVyZXIuZ2V0QW1pbm9BY2lkc0J5UG9zaXRpb24gPSBmdW5jdGlvbihhYXMsbGF5LGFjY2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIGlmICggISBsYXkgJiYgISBhY2Nlc3Npb24gKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdHdWVzc2luZyBzY2FsaW5nIGlkZW50aWZpZXIgYXMnLHdhbnRlZF9pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBvbGRfZ2V0X2Fhcy5jYWxsKHRoaXMsYWFzLGxheSB8fCB3YW50ZWRfaWQsYWNjZXNzaW9uIHx8IHdhbnRlZF9pZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVuZGVyZXIuZ2V0QW1pbm9BY2lkc0J5UGVwdGlkZSA9IGZ1bmN0aW9uKHBlcHRpZGUsbGF5LGFjY2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIGlmICggISBsYXkgJiYgISBhY2Nlc3Npb24gKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdHdWVzc2luZyBzY2FsaW5nIGlkZW50aWZpZXIgYXMnLHdhbnRlZF9pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBvbGRfZ2V0X3BlcC5jYWxsKHRoaXMscGVwdGlkZSxsYXkgfHwgd2FudGVkX2lkLGFjY2Vzc2lvbiB8fCB3YW50ZWRfaWQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG9sZF9yZXN1bHQuY2FsbChyZWFkZXIpO1xuXG4gICAgICAgICAgICBpZiAob2xkX3NlcXVlbmNlKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuc2VxdWVuY2UgPSBvbGRfc2VxdWVuY2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlbmRlcmVyLmdldEFtaW5vQWNpZHNCeVBvc2l0aW9uID0gb2xkX2dldF9hYXM7XG4gICAgICAgICAgICByZW5kZXJlci5nZXRBbWlub0FjaWRzQnlQZXB0aWRlID0gb2xkX2dldF9wZXA7XG4gICAgICAgIH07XG4gICAgfSk7XG59O1xuXG5cbkNvbmRlbnNlZFNlcXVlbmNlUmVuZGVyZXIucHJvdG90eXBlLl9leHRlbmRFbGVtZW50ID0gZnVuY3Rpb24oZWwpIHtcbiAgICBlbC5hZGRUb0xheWVyID0gc2NhbGVkQWRkVG9MYXllcjtcbiAgICBlbC5hZGRCb3hPdmVybGF5ID0gc2NhbGVkQWRkQm94T3ZlcmxheTtcbiAgICBlbC5hZGRTaGFwZU92ZXJsYXkgPSBzY2FsZWRBZGRTaGFwZU92ZXJsYXk7XG4gICAgZWwuYWRkVGV4dE92ZXJsYXkgPSBzY2FsZWRBZGRUZXh0T3ZlcmxheTtcbiAgICBlbC5hZGRUb0xheWVyV2l0aExpbmsgPSBzY2FsZWRBZGRUb0xheWVyV2l0aExpbms7XG4gICAgZWwuY2FsbG91dCA9IGFkZENhbGxvdXRUb0xheWVyO1xuICAgIGVsWydfcmVuZGVyZXInXSA9IHRoaXM7XG59O1xuXG5Db25kZW5zZWRTZXF1ZW5jZVJlbmRlcmVyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihsYXksZWwpIHtcbiAgICBpZiAoICEgZWwgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2xheWVyX2NvbnRhaW5lcnNbbGF5XSAmJiB0aGlzLl9sYXllcl9jb250YWluZXJzW2xheV0uaW5kZXhPZihlbCkgPj0gMCkge1xuICAgICAgICB0aGlzLl9sYXllcl9jb250YWluZXJzW2xheV0uc3BsaWNlKHRoaXMuX2xheWVyX2NvbnRhaW5lcnNbbGF5XS5pbmRleE9mKGVsKSwxKTtcbiAgICAgICAgYmVhbi5maXJlKGVsLCdyZW1vdmVkJyk7XG4gICAgICAgIGlmIChlbC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWwudHJhY2VyICYmIGVsLnRyYWNlci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBlbC50cmFjZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbC50cmFjZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbC5ib2JibGUgJiYgZWwuYm9iYmxlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGVsLmJvYmJsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsLmJvYmJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbnZhciBtYXJrX2dyb3VwcyA9IGZ1bmN0aW9uKHJlbmRlcmVyLG9iamVjdHMpIHtcbiAgICB2YXIgZ3JvdXAgPSBbXTtcbiAgICB2YXIgbmV3X29iamVjdHMgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgb2JqZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGN1cnJlbnQgPSBvYmplY3RzW2ldLCBuZXh0ID0gbnVsbDtcbiAgICAgIGlmICggISBjdXJyZW50ICkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3RzW2krMV0pIHtcbiAgICAgICAgbmV4dCA9IG9iamVjdHNbaSsxXTtcbiAgICAgIH1cbiAgICAgIGlmICggKCEgbmV4dCB8fCAocGFyc2VJbnQobmV4dC5hYSkgLSBwYXJzZUludChjdXJyZW50LmFhKSA+IDEwKSB8fCByZW5kZXJlci5zZXF1ZW5jZS5zdWJzdHJpbmcoY3VycmVudCxuZXh0LTEpLm1hdGNoKC9bU1RdLykpICkge1xuICAgICAgICBpZiAoZ3JvdXAubGVuZ3RoIDwgMykge1xuICAgICAgICAgIGdyb3VwLnB1c2goY3VycmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ3JvdXAucHVzaChjdXJyZW50KTtcbiAgICAgICAgICBncm91cC5mb3JFYWNoKGZ1bmN0aW9uKHNpdGUpe1xuICAgICAgICAgICAgc2l0ZS5vcHRpb25zLnpvb21fbGV2ZWwgPSAndGV4dCc7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIGNvYWxlc2NlX29wdGlvbnMgPSBncm91cFswXS5jb2FsZXNjZSB8fCBvYmplY3RzWzBdLmNvYWxlc2NlO1xuICAgICAgICAgIG5ld19vYmplY3RzLnB1c2goe1xuICAgICAgICAgICAgJ2FhJyA6IGdyb3VwWzBdLmFhLFxuICAgICAgICAgICAgJ3R5cGUnIDogJ3NoYXBlJyxcbiAgICAgICAgICAgICd3aWR0aCcgOiBwYXJzZUludChjdXJyZW50LmFhKS1wYXJzZUludChncm91cFswXS5hYSkrMSxcbiAgICAgICAgICAgICdvcHRpb25zJyA6IHsgICAnem9vbV9sZXZlbCcgOiAnc3VtbWFyeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3NoYXBlJyA6ICdyb3VuZHJlY3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmaWxsJyA6IGNvYWxlc2NlX29wdGlvbnMuZmlsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc3Ryb2tlJyA6IGNvYWxlc2NlX29wdGlvbnMuc3Ryb2tlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzdHJva2Vfd2lkdGgnIDogY29hbGVzY2Vfb3B0aW9ucy5zdHJva2Vfd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2hlaWdodCcgOiBncm91cFswXS5vcHRpb25zLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb2Zmc2V0JyA6IGdyb3VwWzBdLm9wdGlvbnMub2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBncm91cCA9IFtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JvdXAucHVzaChjdXJyZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgbmV3X29iamVjdHMuZm9yRWFjaChmdW5jdGlvbihvYmopIHtcbiAgICAgICAgb2JqZWN0cy5wdXNoKG9iaik7XG4gICAgfSk7XG59O1xuXG5Db25kZW5zZWRTZXF1ZW5jZVJlbmRlcmVyLnByb3RvdHlwZS5maXhfaWNvbnMgPSBmdW5jdGlvbihpY29uX3JlZikge1xuICAgIGlmICggISB0aGlzLmljb25zX2ZhaWxlZCApIHtcbiAgICAgICAgcmV0dXJuIGljb25fcmVmO1xuICAgIH1cbiAgICBpZiAodHlwZW9mKGljb25fcmVmKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHZhbHMgPSBpY29uX3JlZi5zcGxpdCgnXycpO1xuICAgICAgICBpZiAodmFsc1swXSAmJiB0aGlzLmljb25zX2ZhaWxlZFt2YWxzWzBdLnJlcGxhY2UoJyMnLCcnKV0pIHtcbiAgICAgICAgICAgIHZhbHNbMF0gPSB0aGlzLmljb25zX2ZhaWxlZFt2YWxzWzBdLnJlcGxhY2UoJyMnLCcnKV0rJyMnO1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdmFscy5zaGlmdCgpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coaWNvbl9yZWYsc3RhcnQrdmFscy5qb2luKCdfJykpO1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0K3ZhbHMuam9pbignXycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpY29uX3JlZjtcbn1cblxuQ29uZGVuc2VkU2VxdWVuY2VSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyT2JqZWN0cyA9IGZ1bmN0aW9uKHRyYWNrLG9iamVjdHMpIHtcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzO1xuICAgIGlmIChvYmplY3RzLmxlbmd0aCA+IDAgJiYgb2JqZWN0c1swXS5jb2FsZXNjZSApIHtcbiAgICAgICAgbWFya19ncm91cHMocmVuZGVyZXIsb2JqZWN0cyk7XG4gICAgfVxuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICB2YXIgcG90ZW50aWFsX2hlaWdodCA9IG9iamVjdC5vcHRpb25zID8gKG9iamVjdC5vcHRpb25zLmhlaWdodCB8fCByZW5kZXJlci5fbGF5ZXJfY29udGFpbmVyc1t0cmFja10udHJhY2tfaGVpZ2h0KSArIChvYmplY3Qub3B0aW9ucy5vZmZzZXQgKyBvYmplY3Qub3B0aW9ucy5oZWlnaHQgfHwgMCkgOiAwO1xuICAgICAgICBpZiAob2JqZWN0Lm9wdGlvbnMgJiYgKHBvdGVudGlhbF9oZWlnaHQgPiByZW5kZXJlci5fbGF5ZXJfY29udGFpbmVyc1t0cmFja10udHJhY2tfaGVpZ2h0KSApIHtcbiAgICAgICAgICAgIHZhciBuZXdfaGVpZ2h0ID0gcmVuZGVyZXIuX2xheWVyX2NvbnRhaW5lcnNbdHJhY2tdLnRyYWNrX2hlaWdodCArIG9iamVjdC5vcHRpb25zLm9mZnNldCArIChvYmplY3Qub3B0aW9ucy5oZWlnaHQgfHwgcmVuZGVyZXIuX2xheWVyX2NvbnRhaW5lcnNbdHJhY2tdLnRyYWNrX2hlaWdodCk7XG4gICAgICAgICAgICBpZiAoKHJlbmRlcmVyLl9sYXllcl9jb250YWluZXJzW3RyYWNrXS5maXhlZF90cmFja19oZWlnaHQgfHwgMCkgPCBuZXdfaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuX2xheWVyX2NvbnRhaW5lcnNbdHJhY2tdLmZpeGVkX3RyYWNrX2hlaWdodCA9IG5ld19oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2xpY2tfcmV2ZWFsO1xuICAgICAgICB2YXIgcmVuZGVyZWQ7XG4gICAgICAgIGlmIChvYmplY3QuYWEgJiYgKCAhIHJlbmRlcmVyLmdldEFBKHBhcnNlSW50KG9iamVjdC5hYSksdHJhY2spKSApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHR5cGVvZiBvYmplY3QuYWEgIT09ICd1bmRlZmluZWQnKSAmJiBpc05hTihvYmplY3QuYWEpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC50eXBlID09IFwidGV4dFwiKSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmFhKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdC53aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJlZCA9IHJlbmRlcmVyLmdldEFBKHBhcnNlSW50KG9iamVjdC5hYSksdHJhY2spLmFkZFRleHRPdmVybGF5KHRyYWNrLG9iamVjdC53aWR0aCxvYmplY3Qub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWQgPSByZW5kZXJlci5nZXRBQShwYXJzZUludChvYmplY3QuYWEpLHRyYWNrKS5hZGRUZXh0T3ZlcmxheSh0cmFjaywxLG9iamVjdC5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9iamVjdC5wZXB0aWRlKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZWQgPSByZW5kZXJlci5nZXRBbWlub0FjaWRzQnlQZXB0aWRlKG9iamVjdC5wZXB0aWRlLHRyYWNrKS5hZGRUZXh0T3ZlcmxheSh0cmFjaywxLG9iamVjdC5vcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LnR5cGUgPT09IFwiYm94XCIpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QuYWEpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlZCA9IHJlbmRlcmVyLmdldEFBKHBhcnNlSW50KG9iamVjdC5hYSksdHJhY2spLmFkZEJveE92ZXJsYXkodHJhY2sscGFyc2VJbnQob2JqZWN0LndpZHRoKSxudWxsLG9iamVjdC5vcHRpb25zKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob2JqZWN0LnBlcHRpZGUpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlZCA9IHJlbmRlcmVyLmdldEFtaW5vQWNpZHNCeVBlcHRpZGUob2JqZWN0LnBlcHRpZGUsdHJhY2spLmFkZFRvTGF5ZXIodHJhY2ssbnVsbCxvYmplY3Qub3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC50eXBlID09IFwic2hhcGVcIikge1xuICAgICAgICAgICAgaWYgKG9iamVjdC5hYSkge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVkID0gcmVuZGVyZXIuZ2V0QUEocGFyc2VJbnQob2JqZWN0LmFhKSx0cmFjaykuYWRkU2hhcGVPdmVybGF5KHRyYWNrLHBhcnNlSW50KG9iamVjdC53aWR0aCksb2JqZWN0Lm9wdGlvbnMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvYmplY3QucGVwdGlkZSkge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVkID0gcmVuZGVyZXIuZ2V0QW1pbm9BY2lkc0J5UGVwdGlkZShvYmplY3QucGVwdGlkZSx0cmFjaylbMF0uYWRkU2hhcGVPdmVybGF5KHRyYWNrLCBvYmplY3QucGVwdGlkZS5sZW5ndGgsIG9iamVjdC5vcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LnR5cGUgPT0gJ2xpbmUnKSB7XG4gICAgICAgICAgICByZW5kZXJlZCA9IHJlbmRlcmVyLmFkZFZhbHVlc1RvTGF5ZXIodHJhY2ssb2JqZWN0LnZhbHVlcyxvYmplY3Qub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC50eXBlID09IFwibWFya2VyXCIpIHtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gKG9iamVjdC5vcHRpb25zIHx8IHt9KS5jb250ZW50O1xuICAgICAgICAgICAgdmFyIHdhbnRlZF9oZWlnaHQgPSBvYmplY3Qub3B0aW9ucy5oZWlnaHQ7XG5cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5ICYmIEFycmF5LmlzQXJyYXkoY29udGVudCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xvbmVkX29wdGlvbnNfYXJyYXkgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IoIHZhciBrZXkgaW4gb2JqZWN0Lm9wdGlvbnMgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmplY3Qub3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZWRfb3B0aW9uc19hcnJheVtrZXldID0gb2JqZWN0Lm9wdGlvbnNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0Lm9wdGlvbnMuY29udGVudCAmJiBBcnJheS5pc0FycmF5KGNvbnRlbnRfZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkX29wdGlvbnNfYXJyYXkuY29udGVudCA9IG9iamVjdC5vcHRpb25zLmNvbnRlbnQubWFwKHJlbmRlcmVyLmZpeF9pY29ucy5iaW5kKHJlbmRlcmVyKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2xpY2tfcmV2ZWFsID0gcmVuZGVyZXIuZ2V0QUEocGFyc2VJbnQob2JqZWN0LmFhKSx0cmFjaykuYWRkVG9MYXllcih0cmFjayxjbG9uZWRfb3B0aW9uc19hcnJheSk7XG4gICAgICAgICAgICAgICAgY2xpY2tfcmV2ZWFsID0gY2xpY2tfcmV2ZWFsWzFdO1xuICAgICAgICAgICAgICAgIGNsaWNrX3JldmVhbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgIG9iamVjdC5vcHRpb25zLmNvbnRlbnQgPSBvYmplY3Qub3B0aW9ucy5hbHRfY29udGVudDtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gb2JqZWN0Lm9wdGlvbnMuY29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YoY29udGVudCkgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudF9lbDtcbiAgICAgICAgICAgICAgICBpZiAoY29udGVudC50eXBlID09IFwiY2lyY2xlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudF9lbCA9IHJlbmRlcmVyLl9jYW52YXMuY2lyY2xlKC0wLjUsLTAuNSwxLDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29udGVudC50eXBlID09ICd0ZXh0X2NpcmNsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudF9lbCA9IHJlbmRlcmVyLl9jYW52YXMudGV4dF9jaXJjbGUoMC41LDAuNSwxLGNvbnRlbnQudGV4dCxjb250ZW50Lm9wdGlvbnMgfHwge30pO1xuICAgICAgICAgICAgICAgICAgICBvYmplY3Qub3B0aW9ucy5icmVha192aWV3Ym94ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnQudHlwZSA9PSBcImxlZnRfdHJpYW5nbGVcIikge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50X2VsID0gcmVuZGVyZXIuX2NhbnZhcy5wb2x5KCctMTAwLDAgMCwtMTAwIDAsMTAwJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb250ZW50LnR5cGUgPT0gXCJyaWdodF90cmlhbmdsZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRfZWwgPSByZW5kZXJlci5fY2FudmFzLnBvbHkoJzAsMTAwIDEwMCwwIDAsLTEwMCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIFtcImZpbGxcIixcInN0cm9rZVwiLFwic3Ryb2tlLXdpZHRoXCIsXCJmaWxsLW9wYWNpdHlcIixcInN0cm9rZS1vcGFjaXR5XCIsXCJvcGFjaXR5XCJdLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudFtwcm9wXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudF9lbC5zZXRBdHRyaWJ1dGUocHJvcCxjb250ZW50W3Byb3BdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG9iamVjdC5vcHRpb25zLmNvbnRlbnQgPSBjb250ZW50X2VsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNsb25lZF9vcHRpb25zID0ge307XG4gICAgICAgICAgICBmb3IoIHZhciBrZXkgaW4gb2JqZWN0Lm9wdGlvbnMgKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdC5vcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkX29wdGlvbnNba2V5XSA9IG9iamVjdC5vcHRpb25zW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNvbnRlbnRfZGF0YSA9IChvYmplY3Qub3B0aW9ucyB8fCB7fSkuY29udGVudDtcbiAgICAgICAgICAgIGlmIChjb250ZW50X2RhdGEgJiYgdHlwZW9mIGNvbnRlbnRfZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjbG9uZWRfb3B0aW9ucy5jb250ZW50ID0gcmVuZGVyZXIuZml4X2ljb25zKGNvbnRlbnRfZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29udGVudF9kYXRhICYmIEFycmF5LmlzQXJyYXkoY29udGVudF9kYXRhKSkge1xuICAgICAgICAgICAgICAgIGNsb25lZF9vcHRpb25zLmNvbnRlbnQgPSBjb250ZW50X2RhdGEubWFwKHJlbmRlcmVyLmZpeF9pY29ucy5iaW5kKHJlbmRlcmVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYWRkZWQgPSByZW5kZXJlci5nZXRBQShwYXJzZUludChvYmplY3QuYWEpLHRyYWNrKS5hZGRUb0xheWVyKHRyYWNrLGNsb25lZF9vcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChjbGlja19yZXZlYWwpIHtcblxuICAgICAgICAgICAgICAgIGNsaWNrX3JldmVhbC50b2dnbGVSZXZlYWwgPSBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyLnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGFkZGVkWzFdLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBjbGlja19yZXZlYWwudG9nZ2xlUmV2ZWFsLmJpbmQoY2xpY2tfcmV2ZWFsKSx0cnVlKTtcbiAgICAgICAgICAgICAgICBhZGRlZFsxXS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsY2xpY2tfcmV2ZWFsLnRvZ2dsZVJldmVhbC5iaW5kKGNsaWNrX3JldmVhbCksZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVuZGVyZWQgPSBhZGRlZFsxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKG9iamVjdC5vcHRpb25zIHx8IHt9KS56b29tX2xldmVsKSB7XG4gICAgICAgICAgICByZW5kZXJlZC56b29tX2xldmVsID0gb2JqZWN0Lm9wdGlvbnMuem9vbV9sZXZlbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0LmlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIHJlbmRlcmVkLnNldEF0dHJpYnV0ZSgnaWRlbnRpZmllcicsb2JqZWN0LmlkZW50aWZpZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgob2JqZWN0Lm9wdGlvbnMgfHwge30pLmV2ZW50cyAmJiByZW5kZXJlZCApIHtcbiAgICAgICAgICAgIG9iamVjdC5vcHRpb25zLmV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICAgICAgKGV2LnR5cGUgfHwgXCJcIikuc3BsaXQoXCIsXCIpLmZvckVhY2goZnVuY3Rpb24oZXZ0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldnR5cGUgPT0gJ2NsaWNrJyAmJiByZW5kZXJlZC5zdHlsZSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkLnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZW5kZXJlZC5hZGRFdmVudExpc3RlbmVyKGV2dHlwZSxmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLmV2ZW50X2RhdGEgPSBldi5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5sYXllciA9IHRyYWNrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5hYSA9IG9iamVjdC5hYTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRzLnB1c2gocmVuZGVyZWQpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xufTtcblxuQ29uZGVuc2VkU2VxdWVuY2VSZW5kZXJlci5wcm90b3R5cGUuYWRkVGV4dFRyYWNrID0gZnVuY3Rpb24oc2VxLGNvbnRhaW5lcikge1xuICAgIHZhciBSUyA9IHRoaXMuX1JTO1xuICAgIHZhciByZW5kZXJlciA9IHRoaXM7XG4gICAgdmFyIG1heF9sZW5ndGggPSAzMDA7XG4gICAgdmFyIGNhbnZhcyA9IHJlbmRlcmVyLl9jYW52YXM7XG4gICAgdmFyIHNlcV9jaGFycyA9IHNlcS5zcGxpdCgnJyk7XG5cbiAgICB2YXIgYW1pbm9fYWNpZHMgPSBjYW52YXMuc2V0KCk7XG4gICAgdmFyIGFtaW5vX2FjaWRzX3Nob3duID0gZmFsc2U7XG4gICAgdmFyIHggPSAwO1xuXG4gICAgdmFyIGhhc190ZXh0TGVuZ3RoID0gdHJ1ZTtcbiAgICB2YXIgbm9fb3AgPSBmdW5jdGlvbigpIHt9O1xuICAgIHRyeSB7XG4gICAgICAgIHZhciB0ZXN0X2VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2Z25zLCd0ZXh0Jyk7XG4gICAgICAgIHRlc3RfZWwuc2V0QXR0cmlidXRlKCd0ZXh0TGVuZ3RoJywxMCk7XG4gICAgICAgIG5vX29wKHRlc3RfZWwudGV4dExlbmd0aCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYXNfdGV4dExlbmd0aCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qIFdlIHVzZWQgdG8gdGVzdCB0byBzZWUgaWYgdGhlcmUgd2FzIGEgdG91Y2ggZXZlbnRcbiAgICAgICB3aGVuIGRvaW5nIHRoZSB0ZXh0TGVuZ3RoIG1ldGhvZCBvZiBhbWlubyBhY2lkXG4gICAgICAgbGF5b3V0LCBidXQgaU9TIHNlZW1zIHRvIHN1cHBvcnQgdGhpcyBub3cuXG4gICAgICAgXG4gICAgICAgVGVzdCBjYXNlIGZvciB0ZXh0TGVuZ3RoIGNhbiBiZSBmb3VuZCBoZXJlXG4gICAgICAgXG4gICAgICAgaHR0cDovL2pzZmlkZGxlLm5ldC9ua21MdS8xMS9lbWJlZGRlZC9yZXN1bHQvXG4gICAgKi9cblxuICAgIC8qIFdlIGFsc28gbmVlZCB0byB0ZXN0IGZvciBzdXBwb3J0IGZvciBhZGp1c3RpbmcgdGV4dExlbmd0aFxuICAgICAgIHdoaWxlIGFsc28gYWRqdXN0aW5nIHRoZSBkeCB2YWx1ZS4gSW50ZXJuZXQgRXhwbG9yZXIgMTBcbiAgICAgICBzcXVlZXplcyB0ZXh0IHdoZW4gc2V0dGluZyBhIGR4IHZhbHVlIGFzIHdlbGwgYXMgYSB0ZXh0TGVuZ3RoLlxuICAgICAgIEkuZS4gdGhlIHJpZ2h0LW1vc3QgcG9zaXRpb24gb2YgdGhlIGNoYXJhY3RlciBpcyBjYWxjdWxhdGVkIHRvXG4gICAgICAgYmUgeCArIHRleHRMZW5ndGgsIHJhdGhlciB0aGFuIHggKyBkeCArIHRleHRMZW5ndGguXG4gICAgICovXG5cbiAgICB2YXIgc3VwcG9ydHNfZHggPSBmYWxzZTtcbiAgICBpZiAodHlwZW9mIE1BU0NQLnN1cHBvcnRzX2R4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzdXBwb3J0c19keCA9IE1BU0NQLnN1cHBvcnRzX2R4O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIChmdW5jdGlvbihzdXBwb3J0c190ZXh0TGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoISBzdXBwb3J0c190ZXh0TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc3VwcG9ydHNfZHggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdGVzdF9lbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzdmducywndGV4dCcpO1xuICAgICAgICAgICAgdGVzdF9lbC5zZXRBdHRyaWJ1dGUoJ3RleHRMZW5ndGgnLDMwKTtcblxuICAgICAgICAgICAgaWYgKCAhIHRlc3RfZWwuZ2V0RXh0ZW50T2ZDaGFyICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRlc3RfZWwuc2V0QXR0cmlidXRlKCd4JywnMCcpO1xuICAgICAgICAgICAgdGVzdF9lbC5zZXRBdHRyaWJ1dGUoJ3knLCcwJyk7XG4gICAgICAgICAgICB0ZXN0X2VsLnRleHRDb250ZW50ID0gJ0FCQyc7XG4gICAgICAgICAgICBjYW52YXMuYXBwZW5kQ2hpbGQodGVzdF9lbCk7XG4gICAgICAgICAgICB2YXIgZXh0ZW50ID0gdGVzdF9lbC5nZXRFeHRlbnRPZkNoYXIoMikueDtcbiAgICAgICAgICAgIHRlc3RfZWwuc2V0QXR0cmlidXRlKCdkeCcsJzEwJyk7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGVzdF9lbC5nZXRFeHRlbnRPZkNoYXIoMikueCAtIGV4dGVudCkgPCA5LjUpIHtcbiAgICAgICAgICAgICAgICBzdXBwb3J0c19keCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdXBwb3J0c19keCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBNQVNDUC5zdXBwb3J0c19keCA9IHN1cHBvcnRzX2R4O1xuICAgICAgICAgICAgdGVzdF9lbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRlc3RfZWwpO1xuICAgICAgICB9KShoYXNfdGV4dExlbmd0aCk7XG4gICAgfVxuXG4gICAgdmFyIGFfdGV4dDtcblxuICAgIGlmIChoYXNfdGV4dExlbmd0aCAmJiAoJ2xlbmd0aEFkanVzdCcgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2Z25zLCd0ZXh0JykpICYmICgndGV4dExlbmd0aCcgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2Z25zLCd0ZXh0JykpKSB7XG4gICAgICAgIGlmIChzZXEubGVuZ3RoIDw9IG1heF9sZW5ndGgpIHtcbiAgICAgICAgICAgIGFfdGV4dCA9IGNhbnZhcy50ZXh0KDAsMTIsZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc2VxKSk7XG4gICAgICAgICAgICBhX3RleHQuc2V0QXR0cmlidXRlKCd0ZXh0TGVuZ3RoJyxSUypzZXEubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFfdGV4dCA9IGNhbnZhcy50ZXh0KDAsMTIsZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc2VxLnN1YnN0cigwLG1heF9sZW5ndGgpKSk7XG4gICAgICAgICAgICBhX3RleHQuc2V0QXR0cmlidXRlKCd0ZXh0TGVuZ3RoJyxSUyptYXhfbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBjYW52YXMuaW5zZXJ0QmVmb3JlKGFfdGV4dCxjYW52YXMuZmlyc3RDaGlsZC5uZXh0U2libGluZyk7XG5cbiAgICAgICAgYV90ZXh0LnN0eWxlLmZvbnRGYW1pbHkgPSBcIidMdWNpZGEgQ29uc29sZScsICdDb3VyaWVyIE5ldycsIE1vbmFjbywgbW9ub3NwYWNlXCI7XG4gICAgICAgIGFfdGV4dC5zZXRBdHRyaWJ1dGUoJ2xlbmd0aEFkanVzdCcsJ3NwYWNpbmcnKTtcbiAgICAgICAgYV90ZXh0LnNldEF0dHJpYnV0ZSgndGV4dC1hbmNob3InLCAnc3RhcnQnKTtcbiAgICAgICAgYV90ZXh0LnNldEF0dHJpYnV0ZSgnZHgnLDUpO1xuICAgICAgICBhX3RleHQuc2V0QXR0cmlidXRlKCdkeScsJzEuNWV4Jyk7XG4gICAgICAgIGFfdGV4dC5zZXRBdHRyaWJ1dGUoJ2ZvbnQtc2l6ZScsIFJTKTtcbiAgICAgICAgYV90ZXh0LnNldEF0dHJpYnV0ZSgnZmlsbCcsICcjMDAwMDAwJyk7XG4gICAgICAgIGFtaW5vX2FjaWRzLnB1c2goYV90ZXh0KTtcbiAgICAgICAgY29udGFpbmVyLnB1c2goYV90ZXh0KTtcbiAgICB9IGVsc2UgeyAgICBcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXFfY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFfdGV4dCA9IGNhbnZhcy50ZXh0KHgsMTIsc2VxX2NoYXJzW2ldKTtcbiAgICAgICAgICAgIGFfdGV4dC5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSgnZHknLCcxLjVleCcpO1xuICAgICAgICAgICAgYW1pbm9fYWNpZHMucHVzaChhX3RleHQpO1xuICAgICAgICAgICAgY29udGFpbmVyLnB1c2goYV90ZXh0KTtcbiAgICAgICAgICAgIGFfdGV4dC5zdHlsZS5mb250RmFtaWx5ID0gXCInTHVjaWRhIENvbnNvbGUnLCBNb25hY28sIG1vbm9zcGFjZVwiO1xuICAgICAgICAgICAgeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGFtaW5vX2FjaWRzLmF0dHIoIHsgJ3dpZHRoJzogUlMsJ3RleHQtYW5jaG9yJzonc3RhcnQnLCdoZWlnaHQnOiBSUywnZm9udC1zaXplJzpSUywnZmlsbCc6JyMwMDAwMDAnfSk7XG4gICAgfVxuICAgIHZhciB1cGRhdGVfc2VxdWVuY2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHNlcS5sZW5ndGggPD0gbWF4X2xlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb250YWluZXJfd2lkdGggPSByZW5kZXJlci5fY29udGFpbmVyX2NhbnZhcy5wYXJlbnROb2RlLmNhY2hlZF93aWR0aDtcbiAgICAgICAgaWYgKCAhIGNvbnRhaW5lcl93aWR0aCApIHtcbiAgICAgICAgICAgIGNvbnRhaW5lcl93aWR0aCA9IHJlbmRlcmVyLl9jb250YWluZXJfY2FudmFzLnBhcmVudE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgICAgICAgICB2YXIgZG9jd2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgICAgICAgICBpZiAoZG9jd2lkdGggPiBjb250YWluZXJfd2lkdGgpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXJfd2lkdGggPSBkb2N3aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbWF4X3NpemUgPSBNYXRoLmNlaWwoMTAqY29udGFpbmVyX3dpZHRoICogcmVuZGVyZXIuem9vbSAvIFJTKTtcbiAgICAgICAgaWYgKG1heF9zaXplID4gc2VxLmxlbmd0aCkge1xuICAgICAgICAgICAgbWF4X3NpemUgPSBzZXEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgYV90ZXh0LnNldEF0dHJpYnV0ZSgndGV4dExlbmd0aCcsUlMqbWF4X3NpemUpO1xuXG4gICAgICAgIHZhciBzdGFydCA9IHBhcnNlSW50KHJlbmRlcmVyLmxlZnRWaXNpYmxlUmVzaWR1ZSgpKTtcbiAgICAgICAgc3RhcnQgLT0gNTA7XG4gICAgICAgIGlmIChzdGFydCA8IDApIHsgXG4gICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzdGFydCArIG1heF9zaXplKSA+PSBzZXEubGVuZ3RoKSB7XG4gICAgICAgICAgICBzdGFydCA9IHNlcS5sZW5ndGggLSBtYXhfc2l6ZTtcbiAgICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYV90ZXh0LnJlcGxhY2VDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzZXEuc3Vic3RyKHN0YXJ0LG1heF9zaXplKSksYV90ZXh0LmZpcnN0Q2hpbGQpO1xuICAgICAgICBhX3RleHQuc2V0QXR0cmlidXRlKHN1cHBvcnRzX2R4ID8gJ2R4JyA6ICd4Jyw1Kygoc3RhcnQpKlJTKSk7XG4gICAgfTtcbiAgICB2YXIgcGFuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbWlub19hY2lkc19zaG93bikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFtaW5vX2FjaWRzLmF0dHIoIHsgJ2Rpc3BsYXknIDogJ25vbmUnfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgdmFyIHBhbmVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFtaW5vX2FjaWRzX3Nob3duKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW1pbm9fYWNpZHMuYXR0ciggeydkaXNwbGF5JyA6ICdibG9jayd9ICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlX3NlcXVlbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgdmFyIHpvb21jaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbnZhcy56b29tID4gMy42KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBhbWlub19hY2lkcy5hdHRyKHsnZGlzcGxheScgOiAnYmxvY2snfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBhbWlub19hY2lkc19zaG93biA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVfc2VxdWVuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjYW52YXMuem9vbSA+IDAuMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgYW1pbm9fYWNpZHMuYXR0cih7J2Rpc3BsYXknIDogJ25vbmUnfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBhbWlub19hY2lkc19zaG93biA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgYW1pbm9fYWNpZHMuYXR0cih7J2Rpc3BsYXknIDogJ25vbmUnfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBhbWlub19hY2lkc19zaG93biA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgfTtcbiAgICBpZiAoICEgY29udGFpbmVyLnBhbmV2ZW50cyApIHtcbiAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3BhbnN0YXJ0JywgcGFuc3RhcnQsZmFsc2UpO1xuICAgICAgICBiZWFuLmFkZChjYW52YXMsJ3BhbmVuZCcsIHBhbmVuZCk7XG4gICAgICAgIGNvbnRhaW5lci5wYW5ldmVudHMgPSB0cnVlO1xuICAgIH1cbiAgICAgICBcbiAgICBiZWFuLmFkZChjYW52YXMsJ3pvb21DaGFuZ2UnLCB6b29tY2hhbmdlLGZhbHNlKTtcbiAgICBiZWFuLmFkZChhbWlub19hY2lkc1swXSwncmVtb3ZlZCcsZnVuY3Rpb24oKSB7XG4gICAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdwYW5zdGFydCcscGFuc3RhcnQpO1xuICAgICAgICBiZWFuLnJlbW92ZShjYW52YXMsJ3BhbmVuZCcscGFuZW5kKTtcbiAgICAgICAgYmVhbi5yZW1vdmUoY2FudmFzLCd6b29tQ2hhbmdlJyx6b29tY2hhbmdlKTtcbiAgICAgICAgZGVsZXRlIGNvbnRhaW5lci5wYW5ldmVudHM7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFtaW5vX2FjaWRzO1xufTtcblxuQ29uZGVuc2VkU2VxdWVuY2VSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyVGV4dFRyYWNrID0gZnVuY3Rpb24obGF5LGluX3RleHQpIHtcbiAgICB2YXIgbGF5ZXJOYW1lID0gbGF5O1xuICAgIGlmICh0eXBlb2YgbGF5ZXJOYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICBsYXllck5hbWUgPSBsYXkubmFtZTtcbiAgICB9XG4gICAgdmFyIGNhbnZhcyA9IHRoaXMuX2NhbnZhcztcbiAgICBpZiAoICEgY2FudmFzIHx8IHR5cGVvZiBsYXllck5hbWUgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzO1xuICAgIHZhciBjb250YWluZXIgPSB0aGlzLl9sYXllcl9jb250YWluZXJzW2xheWVyTmFtZV07XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuYWRkVGV4dFRyYWNrKGluX3RleHQsY29udGFpbmVyKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxufSkoKTtcblxuQ29uZGVuc2VkU2VxdWVuY2VSZW5kZXJlci5wcm90b3R5cGUuRW5hYmxlSGlnaGxpZ2h0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZW5kZXJlciA9IHRoaXM7XG4gICAgdmFyIGhpZ2hsaWdodHMgPSBbXTtcbiAgICB2YXIgY3JlYXRlTmV3SGlnaGxpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoaWdobGlnaHQgPSByZW5kZXJlci5fY2FudmFzLnJlY3QoMCwwLDAsJzEwMCUnKTtcbiAgICAgICAgaGlnaGxpZ2h0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2KSA9PiB7XG4gICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGhpZ2hsaWdodC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCAoZXYpID0+IHtcbiAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcblxuICAgICAgICBoaWdobGlnaHQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIChldikgPT4ge1xuICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGhpZ2hsaWdodC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCcjZmZkZGRkJyk7XG4gICAgICAgIGhpZ2hsaWdodC5yZW1vdmVBdHRyaWJ1dGUoJ3N0cm9rZScpO1xuICAgICAgICB2YXIgcG5vZGUgPSBoaWdobGlnaHQucGFyZW50Tm9kZTtcbiAgICAgICAgcG5vZGUuaW5zZXJ0QmVmb3JlKGhpZ2hsaWdodCxwbm9kZS5maXJzdENoaWxkLm5leHRTaWJsaW5nKTtcbiAgICAgICAgaGlnaGxpZ2h0cy5wdXNoKGhpZ2hsaWdodCk7XG4gICAgfTtcbiAgICBjcmVhdGVOZXdIaWdobGlnaHQoKTtcblxuICAgIHJlbmRlcmVyLm1vdmVIaWdobGlnaHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICB2YXIgUlMgPSB0aGlzLl9SUztcbiAgICAgICAgdmFyIGkgPSAwLCBpZHggPSAwO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmFscy5sZW5ndGg7IGkrPSAyKSB7XG4gICAgICAgICAgICB2YXIgZnJvbSA9IHZhbHNbaV07XG4gICAgICAgICAgICB2YXIgdG8gPSB2YWxzW2krMV07XG4gICAgICAgICAgICB2YXIgaGlnaGxpZ2h0ID0gaGlnaGxpZ2h0c1tpZHhdO1xuICAgICAgICAgICAgaWYgKCAhIGhpZ2hsaWdodCApIHtcbiAgICAgICAgICAgICAgICBjcmVhdGVOZXdIaWdobGlnaHQoKTtcbiAgICAgICAgICAgICAgICBoaWdobGlnaHQgPSBoaWdobGlnaHRzW2lkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIGhpZ2hsaWdodC5wcmV2aW91c1NpYmxpbmcucHJldmlvdXNTaWJsaW5nICYmIGhpZ2hsaWdodHMuaW5kZXhPZihoaWdobGlnaHQucHJldmlvdXNTaWJsaW5nLnByZXZpb3VzU2libGluZykgPCAwICkge1xuICAgICAgICAgICAgICAgIGhpZ2hsaWdodC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShoaWdobGlnaHQsaGlnaGxpZ2h0LnBhcmVudE5vZGUuZmlyc3RDaGlsZC5uZXh0U2libGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoaWdobGlnaHQuc2V0QXR0cmlidXRlKCd4JywoZnJvbSAtIDEpICogUlMgKTtcbiAgICAgICAgICAgIGhpZ2hsaWdodC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywodG8gLSAoZnJvbSAtIDEpKSAqIFJTICk7XG4gICAgICAgICAgICBoaWdobGlnaHQuc2V0QXR0cmlidXRlKCd2aXNpYmlsaXR5JywndmlzaWJsZScpO1xuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gaWR4OyBpIDwgaGlnaGxpZ2h0cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBoaWdobGlnaHRzW2ldLnNldEF0dHJpYnV0ZSgndmlzaWJpbGl0eScsJ2hpZGRlbicpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbihmdW5jdGlvbigpIHtcblxuICAgIHZhciBiaW5kQ2xpY2sgPSBmdW5jdGlvbihlbGVtZW50LGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKFwib250b3VjaHN0YXJ0XCIgaW4gd2luZG93KSB7XG4gICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0WCA9IGV2LnRvdWNoZXNbMF0uY2xpZW50WDtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRZID0gZXYudG91Y2hlc1swXS5jbGllbnRZO1xuICAgICAgICAgICAgICAgIHZhciByZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsbW92ZSk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLGVuZCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLmNhbGwobnVsbCxldik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBtb3ZlID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGV2LnRvdWNoZXNbMF0uY2xpZW50WCAtIHN0YXJ0WCkgPiAxMCB8fCBNYXRoLmFicyhldi50b3VjaGVzWzBdLmNsaWVudFkgLSBzdGFydFkpID4gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vRklYTUUgLSBQQVNTSVZFXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBtb3ZlICwge3Bhc3NpdmU6dHJ1ZX0pO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLGVuZCxmYWxzZSk7XG4gICAgICAgICAgICB9LHtwYXNzaXZlIDogdHJ1ZX0pO1xuICAgICAgICAgICAgLy9GSVhNRSAtIFBBU1NJVkVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLGhhbmRsZXIsZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gIHZhciBtb3VzZVBvc2l0aW9uID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICB2YXIgcG9zeCA9IDA7XG4gICAgICB2YXIgcG9zeSA9IDA7XG4gICAgICBpZiAoIWV2dCkge1xuICAgICAgICAgIGV2dCA9IHdpbmRvdy5ldmVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2dC5wYWdlWCB8fCBldnQucGFnZVkpICAgICB7XG4gICAgICAgICAgcG9zeCA9IGV2dC5wYWdlWCAtIChkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQgKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCk7XG4gICAgICAgICAgcG9zeSA9IGV2dC5wYWdlWSAtIChkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCArIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3ApO1xuICAgICAgfSBlbHNlIGlmIChldnQuY2xpZW50WCB8fCBldnQuY2xpZW50WSkgIHtcbiAgICAgICAgICBwb3N4ID0gZXZ0LmNsaWVudFggKyBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQgKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICAgICAgICBwb3N5ID0gZXZ0LmNsaWVudFkgKyBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCArIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZi50YXJnZXRFbGVtZW50KSB7XG4gICAgICAgICAgcG9zeCA9IGV2dC5zY3JlZW5YO1xuICAgICAgICAgIHBvc3kgPSBldnQuc2NyZWVuWTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbIHBvc3gsIHBvc3kgXTtcbiAgfTtcblxuICB2YXIgc3ZnUG9zaXRpb24gPSBmdW5jdGlvbihldixzdmdlbCkge1xuICAgICAgdmFyIHBvc2l0aW9ucyA9IG1vdXNlUG9zaXRpb24oZXYuY2hhbmdlZFRvdWNoZXMgPyBldi5jaGFuZ2VkVG91Y2hlc1swXSA6IGV2KTtcbiAgICAgIHZhciBwID0ge307XG4gICAgICBpZiAoc3ZnZWwubm9kZU5hbWUgPT0gJ3N2ZycpIHtcbiAgICAgICAgICBwID0gc3ZnZWwuY3JlYXRlU1ZHUG9pbnQoKTtcbiAgICAgICAgICB2YXIgcm9vdENUTSA9IHN2Z2VsLmdldFNjcmVlbkNUTSgpO1xuICAgICAgICAgIHAueCA9IHBvc2l0aW9uc1swXTtcbiAgICAgICAgICBwLnkgPSBwb3NpdGlvbnNbMV07XG5cbiAgICAgICAgICBzZWxmLm1hdHJpeCA9IHJvb3RDVE0uaW52ZXJzZSgpO1xuICAgICAgICAgIHAgPSBwLm1hdHJpeFRyYW5zZm9ybShzZWxmLm1hdHJpeCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHAueCA9IHBvc2l0aW9uc1swXTtcbiAgICAgICAgICBwLnkgPSBwb3NpdGlvbnNbMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcDtcbiAgfTtcblxuICB2YXIgbm90aWZ5U2VsZWN0aW9uVG9MYXllcnMgPSBmdW5jdGlvbihzdGFydCxlbmQscmVuZGVyZXIpIHtcbiAgICBsZXQgc2VsZWN0aW9ucyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgc2VsZWN0aW9ucy5zZXQocmVuZGVyZXIsW3N0YXJ0LGVuZF0pO1xuICAgIGZvciAobGV0IGxheW5hbWUgb2YgT2JqZWN0LmtleXMocmVuZGVyZXIuX2xheWVyX2NvbnRhaW5lcnMgfHwge30pKSB7XG4gICAgICAgIHZhciBsYXkgPSBNQVNDUC5nZXRMYXllcihsYXluYW1lKTtcbiAgICAgICAgbGV0IHZhbHVlcyA9IFsgbnVsbCwgbnVsbCBdO1xuICAgICAgICBpZiAoc3RhcnQgJiYgZW5kKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSBbIHJlbmRlcmVyLnNjYWxlUG9zaXRpb24oc3RhcnQsbGF5bmFtZSx0cnVlKSwgcmVuZGVyZXIuc2NhbGVQb3NpdGlvbihlbmQsbGF5bmFtZSx0cnVlKSBdO1xuICAgICAgICB9XG4gICAgICAgIGJlYW4uZmlyZShsYXksJ3NlbGVjdGlvbicsdmFsdWVzKTtcbiAgICAgICAgc2VsZWN0aW9ucy5zZXQobGF5LHZhbHVlcyk7XG4gICAgfVxuICAgIGJlYW4uZmlyZShyZW5kZXJlciwnc2VsZWN0aW9uJywgc2VsZWN0aW9ucyk7XG4gIH07XG5cbkNvbmRlbnNlZFNlcXVlbmNlUmVuZGVyZXIucHJvdG90eXBlLmVuYWJsZVNlbGVjdGlvbiA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKCAhIHNlbGYuX2NhbnZhcykge1xuICAgICAgYmVhbi5hZGQoc2VsZiwnc2VxdWVuY2VDaGFuZ2UnLGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLmVuYWJsZVNlbGVjdGlvbigpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNhbnZhcyA9IHNlbGYuX2NhbnZhcztcbiAgICB2YXIgc3RhcnQ7XG4gICAgdmFyIGVuZDtcbiAgICB2YXIgZW5kX2Z1bmM7XG4gICAgdmFyIGxvY2FsX3N0YXJ0O1xuICAgIHZhciBsb2NhbF9lbmQ7XG5cbiAgICBsZXQgaW5fZHJhZyA9IGZhbHNlO1xuXG5cbiAgICB2YXIgbW92aW5nX2Z1bmMgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgdmFyIHAgPSBzdmdQb3NpdGlvbihldnQsY2FudmFzKTtcbiAgICAgICAgZW5kID0gcC54O1xuXG4gICAgICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgICAgICAgbG9jYWxfZW5kID0gcGFyc2VJbnQoc3RhcnQgLyA1MCk7XG4gICAgICAgICAgICBsb2NhbF9zdGFydCA9IHBhcnNlSW50KGVuZCAvIDUwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvY2FsX2VuZCA9IHBhcnNlSW50KGVuZC81MCk7XG4gICAgICAgICAgICBsb2NhbF9zdGFydCA9IHBhcnNlSW50KHN0YXJ0LzUwKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLnNlbGVjdChsb2NhbF9zdGFydCsxLGxvY2FsX2VuZCk7XG4gICAgfTtcblxuICAgIC8vIERvIG5vdCBzZW5kIHRoZSBjbGljayBldmVudCB0byB0aGUgY2FudmFzXG4gICAgLy8gdGhpcyBzY3Jld3MgdXAgd2l0aCBkb2luZyB0aGluZ3Mgb24gdGhlIHNlbGVjdGlvblxuICAgIC8vIE5lZWQgYWx0ZXJuYXRpdmUgbWV0aG9kIHRvIGNsZWFyIHNlbGVjdGlvblxuICAgIC8vXG4gICAgYmluZENsaWNrKGNhbnZhcyxmdW5jdGlvbihldnQpIHtcbiAgICAgICAgaWYgKCEgc2VsZi5zZWxlY3RpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIGlmICghIHNlbGYuc2VsZWN0aW5nICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGluX2RyYWcgPSB0cnVlO1xuICAgICAgICBzZWxmLnNlbGVjdCgpO1xuICAgICAgICB2YXIgcG9zaXRpb25zID0gbW91c2VQb3NpdGlvbihldnQpO1xuICAgICAgICB2YXIgcCA9IHt9O1xuICAgICAgICBpZiAoY2FudmFzLm5vZGVOYW1lID09ICdzdmcnKSB7XG4gICAgICAgICAgICAgICAgcCA9IGNhbnZhcy5jcmVhdGVTVkdQb2ludCgpO1xuICAgICAgICAgICAgICAgIHZhciByb290Q1RNID0gdGhpcy5nZXRTY3JlZW5DVE0oKTtcbiAgICAgICAgICAgICAgICBwLnggPSBwb3NpdGlvbnNbMF07XG4gICAgICAgICAgICAgICAgcC55ID0gcG9zaXRpb25zWzFdO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5tYXRyaXggPSByb290Q1RNLmludmVyc2UoKTtcbiAgICAgICAgICAgICAgICBwID0gcC5tYXRyaXhUcmFuc2Zvcm0oc2VsZi5tYXRyaXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHAueCA9IHBvc2l0aW9uc1swXTtcbiAgICAgICAgICAgICAgICBwLnkgPSBwb3NpdGlvbnNbMV07XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnQgPSBwLng7XG4gICAgICAgIGVuZCA9IHAueDtcbiAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsbW92aW5nX2Z1bmMsZmFsc2UpO1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9LGZhbHNlKTtcblxuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJyxmdW5jdGlvbihldnQpIHtcbiAgICAgICAgaWYgKGluX2RyYWcpIHtcbiAgICAgICAgICAgIG5vdGlmeVNlbGVjdGlvblRvTGF5ZXJzKGxvY2FsX3N0YXJ0ID09PSBudWxsID8gbnVsbCA6IGxvY2FsX3N0YXJ0KzEsbG9jYWxfZW5kLHNlbGYpO1xuICAgICAgICAgICAgbG9jYWxfc3RhcnQgPSBudWxsO1xuICAgICAgICAgICAgbG9jYWxfZW5kID0gbnVsbDtcbiAgICAgICAgICAgIGluX2RyYWcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJyxtb3ZpbmdfZnVuYyk7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0pO1xuXG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJyxmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGluX2RyYWcpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgbm90aWZ5U2VsZWN0aW9uVG9MYXllcnMobG9jYWxfc3RhcnQgPT09IG51bGwgPyBudWxsIDogbG9jYWxfc3RhcnQrMSxsb2NhbF9lbmQsc2VsZik7XG4gICAgICAgICAgICAgICAgbG9jYWxfc3RhcnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxvY2FsX2VuZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaW5fZHJhZyA9IGZhbHNlO1xuICAgICAgICAgICAgfSw1MDApO1xuICAgICAgICB9XG4gICAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLG1vdmluZ19mdW5jKTtcbiAgICB9KTtcblxuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JyxmdW5jdGlvbihldnQpIHtcbiAgICAgICAgaWYgKCEgc2VsZi5zZWxlY3RpbmcgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2dC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgaW5fZHJhZyA9IHRydWU7XG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbnMgPSBtb3VzZVBvc2l0aW9uKGV2dC5jaGFuZ2VkVG91Y2hlc1swXSk7XG4gICAgICAgICAgICB2YXIgcCA9IHt9O1xuICAgICAgICAgICAgaWYgKGNhbnZhcy5ub2RlTmFtZSA9PSAnc3ZnJykge1xuICAgICAgICAgICAgICAgICAgICBwID0gY2FudmFzLmNyZWF0ZVNWR1BvaW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByb290Q1RNID0gdGhpcy5nZXRTY3JlZW5DVE0oKTtcbiAgICAgICAgICAgICAgICAgICAgcC54ID0gcG9zaXRpb25zWzBdO1xuICAgICAgICAgICAgICAgICAgICBwLnkgPSBwb3NpdGlvbnNbMV07XG5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5tYXRyaXggPSByb290Q1RNLmludmVyc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAubWF0cml4VHJhbnNmb3JtKHNlbGYubWF0cml4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHAueCA9IHBvc2l0aW9uc1swXTtcbiAgICAgICAgICAgICAgICAgICAgcC55ID0gcG9zaXRpb25zWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnQgPSBwLng7XG4gICAgICAgICAgICBlbmQgPSBwLng7XG4gICAgICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJyxtb3ZpbmdfZnVuYyx7cGFzc2l2ZTpmYWxzZX0pO1xuICAgICAgICB9XG4gICAgfSx7cGFzc2l2ZTpmYWxzZX0pO1xuICAgIC8vRklYTUUgLSBQQVNTSVZFXG59O1xuXG59KSgpO1xuXG4vKlxuICogR2V0IGEgY2FudmFzIHNldCBvZiB0aGUgdmlzaWJsZSB0cmFjZXJzIG9uIHRoaXMgcmVuZGVyZXJcbiAqL1xuQ29uZGVuc2VkU2VxdWVuY2VSZW5kZXJlci5wcm90b3R5cGUuX3Zpc2libGVUcmFjZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRyYWNlcnMgPSBudWxsO1xuICAgIGZvciAodmFyIGkgaW4gTUFTQ1AubGF5ZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTGF5ZXJBY3RpdmUoaSkgJiYgdGhpcy5fbGF5ZXJfY29udGFpbmVyc1tpXSAmJiB0aGlzLl9sYXllcl9jb250YWluZXJzW2ldLnRyYWNlcnMpIHtcbiAgICAgICAgICAgIGlmICggISB0cmFjZXJzICkge1xuICAgICAgICAgICAgICAgIHRyYWNlcnMgPSB0aGlzLl9sYXllcl9jb250YWluZXJzW2ldLnRyYWNlcnM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyYWNlcnMuY29uY2F0KHRoaXMuX2xheWVyX2NvbnRhaW5lcnNbaV0udHJhY2Vycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRyYWNlcnM7XG59O1xuXG5Db25kZW5zZWRTZXF1ZW5jZVJlbmRlcmVyLnByb3RvdHlwZS5fcmVzaXplQ29udGFpbmVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIFJTID0gdGhpcy5fUlM7XG4gICAgaWYgKHRoaXMuX2NvbnRhaW5lciAmJiB0aGlzLl9jYW52YXMpIHtcbiAgICAgICAgXG4gICAgICAgIHZhciB3aWR0aCA9ICh0aGlzLnpvb20gfHwgMSkqMip0aGlzLnNlcXVlbmNlLmxlbmd0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9ICh0aGlzLnpvb20gfHwgMSkqMioodGhpcy5fY2FudmFzLl9jYW52YXNfaGVpZ2h0L3RoaXMuX1JTKTtcbiAgICAgICAgaWYgKHRoaXMuX2NhbnZhc19jYWxsb3V0X3BhZGRpbmcpIHtcbiAgICAgICAgICAgIGhlaWdodCArPSB0aGlzLl9jYW52YXNfY2FsbG91dF9wYWRkaW5nO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhbnZhcy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgd2lkdGgpO1xuICAgICAgICB0aGlzLl9jYW52YXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLGhlaWdodCk7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvbi5zZXREaW1lbnNpb25zKHdpZHRoLGhlaWdodCk7XG4gICAgICAgIFxuICAgICAgICBpZiAodGhpcy5ncm93X2NvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyX2NhbnZhcy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsaGVpZ2h0KTtcbiAgICAgICAgICAgIC8vIHRoaXMuX2NvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBoZWlnaHQrJ3B4JzsgICAgICAgIFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyX2NhbnZhcy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsJzEwMCUnKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lcl9jYW52YXMuc2V0QXR0cmlidXRlKCd3aWR0aCcsJzEwMCUnKTtcblxuICAgICAgICAgICAgLy8gdGhpcy5fY29udGFpbmVyLnN0eWxlLmhlaWdodCA9ICdhdXRvJztcbiAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvbi5zZXRab29tKHRoaXMuem9vbSk7XG4gICAgICAgIH0gICAgICAgIFxuICAgIH1cbn07XG5cbihmdW5jdGlvbihjbGF6eikge1xuXG52YXIgdmlzX2NoYW5nZV9ldmVudCA9IGZ1bmN0aW9uKHJlbmRlcmVyLHZpc2liaWxpdHkpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCAhIHJlbmRlcmVyLl9sYXllcl9jb250YWluZXJzW3NlbGYubmFtZV0gfHwgcmVuZGVyZXIuX2xheWVyX2NvbnRhaW5lcnNbc2VsZi5uYW1lXS5sZW5ndGggPD0gMCApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBpZiAoISB2aXNpYmlsaXR5KSB7XG4gICAgICAgIGlmIChyZW5kZXJlci5fbGF5ZXJfY29udGFpbmVyc1tzZWxmLm5hbWVdLnRyYWNlcnMpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLl9sYXllcl9jb250YWluZXJzW3NlbGYubmFtZV0udHJhY2Vycy5oaWRlKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIEFkZCBhIGxheWVyIHRvIHRoaXMgcmVuZGVyZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gbGF5ZXIgICAgTGF5ZXIgb2JqZWN0IHRvIGFkZC4gVGhlIGxheWVyIGRhdGEgaXMgdXNlZCB0byBjcmVhdGUgYSB0cmFjayB0aGF0IGNhbiBiZSBpbmRlcGVuZGVudGx5IHNob3duL2hpZGRlbi5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgdHJhY2sgaXRzZWxmIGlzIGJ5IGRlZmF1bHQgaGlkZGVuLlxuICovXG5jbGF6ei5wcm90b3R5cGUuYWRkVHJhY2sgPSBmdW5jdGlvbihsYXllcikge1xuICAgIHZhciBSUyA9IHRoaXMuX1JTO1xuICAgIHZhciByZW5kZXJlciA9IHRoaXM7XG4gICAgXG4gICAgaWYgKCAhIHRoaXMuX2NhbnZhcyApIHtcbiAgICAgICAgYmVhbi5hZGQodGhpcywnc2VxdWVuY2VjaGFuZ2UnLGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5hZGRUcmFjayhsYXllcik7XG4gICAgICAgICAgICBiZWFuLnJlbW92ZSh0aGlzLCdzZXF1ZW5jZWNoYW5nZScsYXJndW1lbnRzLmNhbGxlZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zb2xlLmxvZyhcIk5vIGNhbnZhcywgY2Fubm90IGFkZCB0cmFjaywgd2FpdGluZyBmb3Igc2VxdWVuY2VjaGFuZ2UgZXZlbnRcIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbGF5ZXJfY29udGFpbmVycyA9IHRoaXMuX2xheWVyX2NvbnRhaW5lcnMgfHwgW107XG5cbiAgICBpZiAoICEgbGF5ZXJfY29udGFpbmVyc1tsYXllci5uYW1lXSB8fCBsYXllcl9jb250YWluZXJzW2xheWVyLm5hbWVdID09PSBudWxsKSB7XG4gICAgICAgIGxheWVyX2NvbnRhaW5lcnNbbGF5ZXIubmFtZV0gPSB0aGlzLl9jYW52YXMuc2V0KCk7XG4gICAgICAgIGlmICggISBsYXllcl9jb250YWluZXJzW2xheWVyLm5hbWVdLnRyYWNrX2hlaWdodCkge1xuICAgICAgICAgICAgbGF5ZXJfY29udGFpbmVyc1tsYXllci5uYW1lXS50cmFja19oZWlnaHQgPSByZW5kZXJlci50cmFja0hlaWdodCB8fCA0O1xuICAgICAgICB9XG4gICAgICAgIGJlYW4ucmVtb3ZlKGxheWVyLCd2aXNpYmlsaXR5Q2hhbmdlJyx2aXNfY2hhbmdlX2V2ZW50KTtcbiAgICAgICAgYmVhbi5hZGQobGF5ZXIsJ3Zpc2liaWxpdHlDaGFuZ2UnLHZpc19jaGFuZ2VfZXZlbnQpO1xuICAgICAgICB2YXIgZXZlbnRfbmFtZXMgPSBbJ2NsaWNrJywnbW91c2VvdmVyJywnbW91c2Vkb3duJywnbW91c2Vtb3ZlJywnbW91c2VvdXQnLCdtb3VzZXVwJywnbW91c2VlbnRlcicsJ21vdXNlbGVhdmUnXTtcbiAgICAgICAgdmFyIGV2X2Z1bmN0aW9uID0gZnVuY3Rpb24oZXYsb3JpZ2luYWxfZXZlbnQsZWxlbWVudCkge1xuICAgICAgICAgICAgYmVhbi5maXJlKGxheWVyLGV2LnR5cGUsW29yaWdpbmFsX2V2ZW50LGVsZW1lbnQucG9zaXRpb25fc3RhcnQsZWxlbWVudC5wb3NpdGlvbl9lbmRdKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZm9yICh2YXIgaSA9IDAgOyBpIDwgZXZlbnRfbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gICAgIGJlYW4uYWRkKGxheWVyX2NvbnRhaW5lcnNbbGF5ZXIubmFtZV0uX2V2ZW50X3Byb3h5LGV2ZW50X25hbWVzW2ldLGV2X2Z1bmN0aW9uKTtcbiAgICAgICAgLy8gfVxuICAgICAgICBiZWFuLnJlbW92ZShsYXllciwncmVtb3ZlZCcpO1xuICAgICAgICBiZWFuLmFkZChsYXllciwncmVtb3ZlZCcsZnVuY3Rpb24ocmVuZCkge1xuICAgICAgICAgICAgaWYgKHJlbmQpIHtcbiAgICAgICAgICAgICAgICByZW5kLnJlbW92ZVRyYWNrKHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNle1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnJlbW92ZVRyYWNrKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgdGhpcy5fbGF5ZXJfY29udGFpbmVycyA9IGxheWVyX2NvbnRhaW5lcnM7XG4gICAgXG59O1xuXG5jbGF6ei5wcm90b3R5cGUucmVtb3ZlVHJhY2sgPSBmdW5jdGlvbihsYXllcikge1xuICAgIGlmICghIHRoaXMuX2xheWVyX2NvbnRhaW5lcnMgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGxheWVyX2NvbnRhaW5lcnMgPSB0aGlzLl9sYXllcl9jb250YWluZXJzIHx8IFtdO1xuICAgIGlmICggbGF5ZXJfY29udGFpbmVyc1tsYXllci5uYW1lXSApIHtcbiAgICAgICAgbGV0IGVsZW1lbnRzID0gW10uY29uY2F0KGxheWVyX2NvbnRhaW5lcnNbbGF5ZXIubmFtZV0pO1xuICAgICAgICBmb3IobGV0IGVsIG9mIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZShsYXllci5uYW1lLGVsKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5fbGF5ZXJfY29udGFpbmVyc1tsYXllci5uYW1lXTtcbiAgICAgICAgbGF5ZXIuZGlzYWJsZWQgPSB0cnVlO1xuICAgIH1cblxufTtcblxudmFyIHJlZnJlc2hfaWQgPSAwO1xuY2xhenoucHJvdG90eXBlLmRpc2FibGVQcmludFJlc2l6aW5nID0gZnVuY3Rpb24oKSB7XG4gICAgZGVsZXRlIHRoaXMuX21lZGlhX2Z1bmM7XG59O1xuXG5jbGF6ei5wcm90b3R5cGUuZW5hYmxlUHJpbnRSZXNpemluZyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICggISAodGhpcy53aW4oKSB8fCB3aW5kb3cpLm1hdGNoTWVkaWEgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX21lZGlhX2Z1bmMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhX2Z1bmM7XG4gICAgfVxuICAgIHRoaXMuX21lZGlhX2Z1bmMgPSBmdW5jdGlvbihtYXRjaGVyKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKCAhIHNlbGYuX2NhbnZhcyApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIHNlbGYuZ3Jvd19jb250YWluZXIgKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2hlci5tYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNlbGYuX2NvbnRhaW5lcl9jYW52YXMucGFyZW50Tm9kZS5jYWNoZWRfd2lkdGg7XG4gICAgICAgICAgICAgICAgYmVhbi5maXJlKHNlbGYuX2NhbnZhcywncGFuZW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hdGNoPW1hdGNoZXI7XG4gICAgICAgIGlmICghIG1hdGNoLm1hdGNoZXMgKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5vbGRfem9vbSkge1xuICAgICAgICAgICAgICAgIHZhciBhX3pvb20gPSBzZWxmLm9sZF96b29tO1xuICAgICAgICAgICAgICAgIHNlbGYub2xkX3pvb20gPSBudWxsO1xuICAgICAgICAgICAgICAgIHNlbGYuem9vbUNlbnRlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgc2VsZi53aXRob3V0UmVmcmVzaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIHNlbGYuem9vbSA9IGFfem9vbTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzZWxmLl9jYW52YXMuc2V0Q3VycmVudFRyYW5zbGF0ZVhZKHNlbGYub2xkX3RyYW5zbGF0ZSwwKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9jb250YWluZXJfY2FudmFzLnNldEF0dHJpYnV0ZSgndmlld0JveCcsc2VsZi5vbGRfdmlld2JveCk7XG4gICAgICAgICAgICAgICAgLy8gc2VsZi5fY29udGFpbmVyLnN0eWxlLmhlaWdodCA9ICdhdXRvJztcbiAgICAgICAgICAgICAgICBzZWxmLm9sZF96b29tID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzZWxmLm9sZF90cmFuc2xhdGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHNlbGYucmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgIGJlYW4uZmlyZShzZWxmLl9jYW52YXMsJ3pvb21DaGFuZ2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHNlbGYuX2NvbnRhaW5lcjtcbiAgICAgICAgICAgIHNlbGYub2xkX3RyYW5zbGF0ZSA9IHNlbGYuX2NhbnZhcy5jdXJyZW50VHJhbnNsYXRlQ2FjaGUueDtcbiAgICAgICAgICAgIHNlbGYuX2NhbnZhcy5zZXRDdXJyZW50VHJhbnNsYXRlWFkoMCwwKTtcbiAgICAgICAgICAgIHZhciB6b29tRmFjdG9yID0gMC45NSAqIChjb250YWluZXIuY2xpZW50V2lkdGgpIC8gKHNlbGYuc2VxdWVuY2UubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmICggISBzZWxmLm9sZF96b29tICkge1xuICAgICAgICAgICAgICBzZWxmLm9sZF96b29tID0gc2VsZi56b29tO1xuICAgICAgICAgICAgICBzZWxmLm9sZF92aWV3Ym94ID0gc2VsZi5fY29udGFpbmVyX2NhbnZhcy5nZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuem9vbUNlbnRlciA9IG51bGw7XG4gICAgICAgICAgICBzZWxmLl9jb250YWluZXJfY2FudmFzLnJlbW92ZUF0dHJpYnV0ZSgndmlld0JveCcpO1xuICAgICAgICAgICAgc2VsZi53aXRob3V0UmVmcmVzaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnpvb20gPSB6b29tRmFjdG9yO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxmLnJlZnJlc2goKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coZXJyLnN0YWNrKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIHJlbmQgPSB0aGlzO1xuICAgIGlmICggISByZW5kLl9ib3VuZF9tZWRpYSApIHtcbiAgICAgICAgKHRoaXMud2luKCkgfHwgd2luZG93KS5tYXRjaE1lZGlhKCdwcmludCcpLmFkZExpc3RlbmVyKGZ1bmN0aW9uKG1hdGNoZXIpIHtcbiAgICAgICAgICAgIGlmIChyZW5kLl9tZWRpYV9mdW5jKSB7XG4gICAgICAgICAgICAgICAgcmVuZC5fbWVkaWFfZnVuYyhtYXRjaGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbmQuX2JvdW5kX21lZGlhID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogQ2F1c2UgYSByZWZyZXNoIG9mIHRoZSByZW5kZXJlciwgcmUtYXJyYW5naW5nIHRoZSB0cmFja3Mgb24gdGhlIGNhbnZhcywgYW5kIHJlc2l6aW5nIHRoZSBjYW52YXMgaWYgbmVjZXNzYXJ5LlxuICogQHBhcmFtIHtCb29sZWFufSBhbmltYXRlZHMgQ2F1c2UgdGhpcyByZWZyZXNoIHRvIGJlIGFuIGFuaW1hdGVkIHJlZnJlc2hcbiAqL1xuY2xhenoucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbihhbmltYXRlZCkge1xuICAgIGlmICggISB0aGlzLl9jYW52YXMgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbGF5ZXJfY29udGFpbmVycyA9IHRoaXMuX2xheWVyX2NvbnRhaW5lcnMgfHwgW107XG5cbiAgICB2YXIgUlMgPSB0aGlzLl9SUztcbiAgICB2YXIgdHJhY2tfaGVpZ2h0cyA9IDA7XG4gICAgdmFyIG9yZGVyID0gdGhpcy50cmFja09yZGVyIHx8IFtdO1xuICAgIHZhciBmaXhlZF9mb250X3NjYWxlID0gdGhpcy5maXhlZEZvbnRTY2FsZTtcbiAgICBcbiAgICBpZiAodGhpcy5uYXZpZ2F0aW9uKSB7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvbi5yZXNldCgpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyLmxlbmd0aDsgaSsrICkge1xuICAgICAgICBcbiAgICAgICAgdmFyIG5hbWUgPSBvcmRlcltpXTtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGxheWVyX2NvbnRhaW5lcnNbbmFtZV07XG4gICAgICAgIGlmICggISBjb250YWluZXIgKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeV92YWw7XG4gICAgICAgIGlmICghIHRoaXMuaXNMYXllckFjdGl2ZShuYW1lKSkge1xuICAgICAgICAgICAgdmFyIGF0dHJzID0geyAneScgOiAtMSoodGhpcy5fYXhpc19oZWlnaHQpKlJTLCAnaGVpZ2h0JyA6ICBSUyAqIGNvbnRhaW5lci50cmFja19oZWlnaHQgLyB0aGlzLnpvb20gLCd2aXNpYmlsaXR5JyA6ICdoaWRkZW4nIH07XG4vLyAgICAgICAgICAgIHZhciBhdHRycyA9IHsgJ3knIDogKHRoaXMuX2F4aXNfaGVpZ2h0ICArICh0cmFja19oZWlnaHRzIC0gY29udGFpbmVyLnRyYWNrX2hlaWdodCApLyB0aGlzLnpvb20pKlJTLCAnaGVpZ2h0JyA6ICBSUyAqIGNvbnRhaW5lci50cmFja19oZWlnaHQgLyB0aGlzLnpvb20gLCd2aXNpYmlsaXR5JyA6ICdoaWRkZW4nIH07XG4gICAgICAgICAgICBpZiAoTUFTQ1AuZ2V0TGF5ZXIobmFtZSkuZ3JvdXApIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udHJvbGxlcl90cmFjayA9IHRoaXMubmF2aWdhdGlvbi5nZXRDb250cm9sbGVyKE1BU0NQLmdldExheWVyKG5hbWUpLmdyb3VwKTtcbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbGxlcl90cmFjayAmJiB0aGlzLmlzTGF5ZXJBY3RpdmUoY29udHJvbGxlcl90cmFjaykpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cnMueSA9IGxheWVyX2NvbnRhaW5lcnNbY29udHJvbGxlcl90cmFjay5uYW1lXS5jdXJyZW50eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGNvbnRhaW5lci5maXhlZF90cmFja19oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgYXR0cnMuaGVpZ2h0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYW5pbWF0ZWQpIHsgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmFuaW1hdGUoYXR0cnMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuYXR0cihhdHRycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyLnRyYWNlcnMpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY29udGFpbmVyLmF0dHIoeyAnb3BhY2l0eScgOiAnMScgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdHJhY2VyX3RvcCA9IHRyYWNrX2hlaWdodHM7XG5cbiAgICAgICAgaWYgKGNvbnRhaW5lci5maXhlZF90cmFja19oZWlnaHQpIHtcblxuICAgICAgICAgICAgdmFyIHRyYWNrX2hlaWdodCA9IGNvbnRhaW5lci5maXhlZF90cmFja19oZWlnaHQ7XG5cbiAgICAgICAgICAgIHlfdmFsID0gdGhpcy5fYXhpc19oZWlnaHQgKyB0cmFja19oZWlnaHRzICAvIHRoaXMuem9vbTtcblxuICAgICAgICAgICAgaWYgKGFuaW1hdGVkKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmFuaW1hdGUoeyAndmlzaWJpbGl0eSc6ICd2aXNpYmxlJywgJ3knIDogeV92YWwqUlMsICdoZWlnaHQnIDogIFJTICogY29udGFpbmVyLnRyYWNrX2hlaWdodCAvIHRoaXMuem9vbSB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmF0dHIoeyAndmlzaWJpbGl0eSc6ICd2aXNpYmxlJywgJ3knIDogeV92YWwqUlMsICdoZWlnaHQnIDogIFJTICogY29udGFpbmVyLnRyYWNrX2hlaWdodCAvIHRoaXMuem9vbSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm5hdmlnYXRpb24pIHtcbiAgICAgICAgICAgICAgICB5X3ZhbCAtPSAxKmNvbnRhaW5lci50cmFja19oZWlnaHQvdGhpcy56b29tO1xuICAgICAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvbi5yZW5kZXJUcmFjayhNQVNDUC5nZXRMYXllcihuYW1lKSwgeV92YWwqUlMgLCBSUyAqIGNvbnRhaW5lci5maXhlZF90cmFja19oZWlnaHQgLyB0aGlzLnpvb20sIHsgJ2ZvbnQtc2NhbGUnIDogKChmaXhlZF9mb250X3NjYWxlIHx8IDEpICogMyAqY29udGFpbmVyLnRyYWNrX2hlaWdodCkgLyBjb250YWluZXIuZml4ZWRfdHJhY2tfaGVpZ2h0IH0gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNrX2hlaWdodHMgKz0gY29udGFpbmVyLmZpeGVkX3RyYWNrX2hlaWdodCArIHRoaXMudHJhY2tHYXAgLSBjb250YWluZXIudHJhY2tfaGVpZ2h0O1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5X3ZhbCA9IHRoaXMuX2F4aXNfaGVpZ2h0ICsgdHJhY2tfaGVpZ2h0cyAvIHRoaXMuem9vbTtcbiAgICAgICAgICAgIGlmIChhbmltYXRlZCkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hbmltYXRlKHsgJ3Zpc2liaWxpdHknOiAndmlzaWJsZScsICd5JyA6IHlfdmFsKlJTLCAnaGVpZ2h0JyA6ICBSUyAqIGNvbnRhaW5lci50cmFja19oZWlnaHQgLyB0aGlzLnpvb20gfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hdHRyKHsgJ3Zpc2liaWxpdHknOiAndmlzaWJsZScsICd5JyA6IHlfdmFsKlJTLCAnaGVpZ2h0JyA6ICBSUyAqIGNvbnRhaW5lci50cmFja19oZWlnaHQgLyB0aGlzLnpvb20gfSk7ICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubmF2aWdhdGlvbikge1xuICAgICAgICAgICAgICAgIHlfdmFsIC09IDEqY29udGFpbmVyLnRyYWNrX2hlaWdodC90aGlzLnpvb207XG4gICAgICAgICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uLnJlbmRlclRyYWNrKE1BU0NQLmdldExheWVyKG5hbWUpLCB5X3ZhbCpSUyAsIFJTICogMyAqIGNvbnRhaW5lci50cmFja19oZWlnaHQgLyB0aGlzLnpvb20sIGZpeGVkX2ZvbnRfc2NhbGUgPyB7ICdmb250LXNjYWxlJyA6IGZpeGVkX2ZvbnRfc2NhbGUgfSA6IG51bGwgKTtcbiAgICAgICAgICAgICAgICB0cmFja19oZWlnaHRzICs9IGNvbnRhaW5lci50cmFja19oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFja19oZWlnaHRzICs9IGNvbnRhaW5lci50cmFja19oZWlnaHQgKyB0aGlzLnRyYWNrR2FwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRhaW5lci5yZWZyZXNoX3pvb20oKTtcblxuICAgICAgICBpZiAoY29udGFpbmVyLnRyYWNlcnMpIHtcbiAgICAgICAgICAgIHZhciBkaXNwX3N0eWxlID0gKHRoaXMuaXNMYXllckFjdGl2ZShuYW1lKSAmJiAodGhpcy56b29tID4gMy42KSkgPyAndmlzaWJsZScgOiAnaGlkZGVuJztcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSAoMS41ICsgdHJhY2VyX3RvcCAvIHRoaXMuem9vbSApKlJTO1xuXG4gICAgICAgICAgICBpZihhbmltYXRlZCkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci50cmFjZXJzLmFuaW1hdGUoeyd2aXNpYmlsaXR5JyA6IGRpc3Bfc3R5bGUgLCAneScgOiAwLjY1Kih0aGlzLl9heGlzX2hlaWdodCkqUlMsJ2hlaWdodCcgOiBoZWlnaHQgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci50cmFjZXJzLmF0dHIoeyd2aXNpYmlsaXR5JyA6IGRpc3Bfc3R5bGUgLCAneScgOiAwLjY1Kih0aGlzLl9heGlzX2hlaWdodCkqUlMsJ2hlaWdodCcgOiBoZWlnaHQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgfVxuICAgIFxuICAgIHZhciB2aWV3Qm94ID0gWy0xLDAsMCwwXTtcbiAgICB2aWV3Qm94WzBdID0gLTIqUlM7XG4gICAgdmlld0JveFsyXSA9ICh0aGlzLnNlcXVlbmNlLnNwbGl0KCcnKS5sZW5ndGgrKHRoaXMucGFkZGluZykrMikqUlM7XG4gICAgdmlld0JveFszXSA9ICh0aGlzLl9heGlzX2hlaWdodCArICh0cmFja19oZWlnaHRzIC8gdGhpcy56b29tKSsgKHRoaXMucGFkZGluZyAvIHRoaXMuem9vbSkpKlJTO1xuICAgIHRoaXMuX2NhbnZhcy5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCB2aWV3Qm94LmpvaW4oJyAnKSk7XG4gICAgdGhpcy5fY2FudmFzLl9jYW52YXNfaGVpZ2h0ID0gdmlld0JveFszXTtcblxuXG4gICAgdmFyIG91dGVyX3ZpZXdib3ggPSBbXS5jb25jYXQodmlld0JveCk7XG5cbiAgICBvdXRlcl92aWV3Ym94WzBdID0gMDtcbiAgICBvdXRlcl92aWV3Ym94WzJdID0gKHRoaXMuem9vbSkqKDIqdGhpcy5zZXF1ZW5jZS5sZW5ndGgpKyh0aGlzLnBhZGRpbmcpO1xuICAgIG91dGVyX3ZpZXdib3hbM10gPSAodGhpcy56b29tKSoyKih0aGlzLl9heGlzX2hlaWdodCArICh0cmFja19oZWlnaHRzIC8gdGhpcy56b29tKSsgKHRoaXMucGFkZGluZyAvIHRoaXMuem9vbSkpO1xuICAgIGlmICghIHRoaXMuZ3Jvd19jb250YWluZXIgKSB7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lcl9jYW52YXMuc2V0QXR0cmlidXRlKCd2aWV3Qm94Jywgb3V0ZXJfdmlld2JveC5qb2luKCcgJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lcl9jYW52YXMucmVtb3ZlQXR0cmlidXRlKCd2aWV3Qm94Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVzaXplQ29udGFpbmVyKCk7XG5cbiAgICB2aWV3Qm94WzBdID0gMDtcbiAgICBpZiAodGhpcy5uYXZpZ2F0aW9uKSB7XG4gICAgICAgIGlmICggdGhpcy5ncm93X2NvbnRhaW5lciApIHtcbiAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvbi5uYXZfd2lkdGhfYmFzZSA9IG91dGVyX3ZpZXdib3hbM10gPCAyMDAgPyBvdXRlcl92aWV3Ym94WzNdIDogMjAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmF2aWdhdGlvbi5tb3ZlX2Nsb3NlcigpO1xuICAgICAgICBpZiAodGhpcy5uYXZpZ2F0aW9uLnZpc2libGUoKSkge1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLkdvbWFwU2Nyb2xsTGVmdE1hcmdpbiA9IDEwMCAqIFJTIC8gdGhpcy56b29tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLkdvbWFwU2Nyb2xsTGVmdE1hcmdpbiA9IDEwMDA7ICAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uLnNldFZpZXdCb3godmlld0JveC5qb2luKCcgJykpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm5hdmlnYXRpb24pIHtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uLnJlZnJlc2goKTtcbiAgICB9XG5cbn07XG5cblxuLypcblxuTW9kaWZpZWQgZnJvbTpcblxuaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81NDMzODA2L2NvbnZlcnQtZW1iZWRkZWQtc3ZnLXRvLXBuZy1pbi1wbGFjZVxuXG5Ob25lIG9mIHRoZSBTYWZhcmkgYnJvd3NlcnMgd29yayB3aXRoIHRoaXMsIGdpdmluZyBET00gRXhjZXB0aW9uIDE4XG5cbmh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODE1ODMxMi9yYXN0ZXJpemluZy1hbi1pbi1kb2N1bWVudC1zdmctdG8tY2FudmFzXG5cbkkgdGhpbmsgdGhpcyBpcyB0aGUgcmVsZXZhbnQgYnVnLlxuXG5odHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTE5NDkyXG5cbiovXG5cbnZhciBzdmdEYXRhVVJMID0gZnVuY3Rpb24oc3ZnKSB7XG4gIHN2Zy5zZXRBdHRyaWJ1dGUoJ3htbG5zJywnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnKTtcbiAgc3ZnLnNldEF0dHJpYnV0ZSgneG1sbnM6eGxpbmsnLCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyk7XG5cbiAgdmFyIHN2Z0FzWE1MID0gKG5ldyBYTUxTZXJpYWxpemVyKS5zZXJpYWxpemVUb1N0cmluZyhzdmcpO1xuICByZXR1cm4gXCJkYXRhOmltYWdlL3N2Zyt4bWwsXCIgKyBlbmNvZGVVUklDb21wb25lbnQoc3ZnQXNYTUwpO1xufTtcblxuY2xhenoucHJvdG90eXBlLnBuZ1VSTCA9IGZ1bmN0aW9uKHBuZ1JlYWR5LG91dF93aWR0aCkge1xuICAgIC8vdmFyIHN2ZyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmb29iYXInKTsvL3RoaXMuX2NhbnZhcztcbiAgICB2YXIgc3ZnX2RhdGEgPSB0aGlzLl9jYW52YXMuY2xvbmVOb2RlKHRydWUpO1xuICAgIHZhciBzZXF1ZW5jZXMgPSBzdmdfZGF0YS5xdWVyeVNlbGVjdG9yQWxsKCd0ZXh0W2RhdGEtc3BhY2VzXScpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VxdWVuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlcXVlbmNlc1tpXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNlcXVlbmNlc1tpXSk7XG4gICAgfVxuXG4gICAgLy8gU2V0IHVwIHRoZSBhc3BlY3QgcmF0aW8gb2YgdGhlIG91dHB1dCBlbGVtZW50XG4gICAgdmFyIHN2ZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzdmducywnc3ZnJyk7XG4gICAgc3ZnLnNldEF0dHJpYnV0ZSgnd2lkdGgnLHRoaXMuX2NvbnRhaW5lcl9jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgpO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsdGhpcy5fY29udGFpbmVyX2NhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQpO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLCd4TWluWU1pbiBtZWV0Jyk7XG5cbiAgICB2YXIgdHJhbnNmb3JtX2dyb3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2Z25zLCdnJyk7XG4gICAgdHJhbnNmb3JtX2dyb3VwLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJyx0aGlzLl9jYW52YXMucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpKTtcbiAgICBzdmcuYXBwZW5kQ2hpbGQodHJhbnNmb3JtX2dyb3VwKTtcbiAgICB0cmFuc2Zvcm1fZ3JvdXAuYXBwZW5kQ2hpbGQoc3ZnX2RhdGEpO1xuXG4gICAgLy8gV2UgYXJlIG1pc3NpbmcgdGhlIGRlZnMgZWxlbWVudHMgZnJvbSB0aGUgY29udGFpbmluZyBub2RlXG5cbiAgICB2YXIgYWxsX2RlZnMgPSB0aGlzLl9jb250YWluZXJfY2FudmFzLnF1ZXJ5U2VsZWN0b3JBbGwoJ2RlZnMnKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbF9kZWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN2Zy5hcHBlbmRDaGlsZChhbGxfZGVmc1tpXS5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgIH1cbiAgICB2YXIgY2FuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdmFyIHRvdGFsX3dpZHRoID0gMipwYXJzZUludChzdmcuZ2V0QXR0cmlidXRlKCd3aWR0aCcpKTtcbiAgICB2YXIgdG90YWxfaGVpZ2h0ID0gMipwYXJzZUludChzdmcuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSk7XG4gICAgaWYgKG91dF93aWR0aCkge1xuICAgICAgICBpZiAodG90YWxfd2lkdGggPiBvdXRfd2lkdGgpIHtcbiAgICAgICAgICAgIHZhciByYXRpbyA9IHRvdGFsX3dpZHRoIC8gb3V0X3dpZHRoO1xuICAgICAgICAgICAgdG90YWxfd2lkdGggPSBvdXRfd2lkdGg7XG4gICAgICAgICAgICB0b3RhbF9oZWlnaHQgPSBwYXJzZUludCh0b3RhbF9oZWlnaHQgLyByYXRpbyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FuLndpZHRoID0gdG90YWxfd2lkdGg7XG4gICAgY2FuLmhlaWdodCA9IHRvdGFsX2hlaWdodDtcbiAgICB2YXIgc3ZnSW1nID0gbmV3IEltYWdlO1xuICAgIHN2Z0ltZy53aWR0aCAgPSAxO1xuICAgIHN2Z0ltZy5oZWlnaHQgPSAxO1xuICAgIHZhciBjdHggPSBjYW4uZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBzdmdJbWcub25sb2FkID0gZnVuY3Rpb24oKXtcbiAgICAgIGN0eC5kcmF3SW1hZ2Uoc3ZnSW1nLDAsMCxjYW4ud2lkdGgsY2FuLmhlaWdodCk7XG4gICAgICBwbmdSZWFkeShjYW4udG9EYXRhVVJMKCkpO1xuICAgIH07XG4gICAgc3ZnSW1nLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiR290IGFuIGVycm9yXCIpO1xuICAgIH07XG4gICAgdmFyIGRhdGF1cmwgPSBzdmdEYXRhVVJMKHN2Zyk7XG4gICAgc3ZnSW1nLnNyYyA9IGRhdGF1cmw7XG59O1xuXG59KShDb25kZW5zZWRTZXF1ZW5jZVJlbmRlcmVyKTtcblxuLyoqXG4gKiBab29tIGxldmVsIGhhcyBjaGFuZ2VkIGZvciB0aGlzIHJlbmRlcmVyXG4gKiBAbmFtZSAgICBDb25kZW5zZWRTZXF1ZW5jZVJlbmRlcmVyI3pvb21DaGFuZ2VcbiAqIEBldmVudFxuICogQHBhcmFtICAge09iamVjdH0gICAgZVxuICovXG5cbkNvbmRlbnNlZFNlcXVlbmNlUmVuZGVyZXIuWm9vbSA9IGZ1bmN0aW9uKHJlbmRlcmVyKSB7XG5cbi8qKlxuICogIEBsZW5kcyBDb25kZW5zZWRTZXF1ZW5jZVJlbmRlcmVyLnByb3RvdHlwZVxuICogIEBwcm9wZXJ0eSAgIHtOdW1iZXJ9ICAgIHpvb20gICAgICAgIFRoZSB6b29tIGxldmVsIGZvciBhIHJlbmRlcmVyLiBNaW5pbXVtIHpvb20gbGV2ZWwgaXMgemVybywgYW5kIGRlZmF1bHRzIHRvIHRoZSBkZWZhdWx0IHpvb20gdmFsdWVcbiAqICBAcHJvcGVydHkgICB7QXJyYXl9ICAgICB0cmFja09yZGVyICBUaGUgb3JkZXIgb2YgdHJhY2tzIG9uIHRoZSByZW5kZXJlciwgYW4gYXJyYXkgb2YgbGF5ZXIvZ3JvdXAgbmFtZXMuXG4gKiAgQHByb3BlcnR5ICAge051bWJlcn0gICAgcGFkZGluZyAgICAgUGFkZGluZyB0byBhcHBseSB0byB0aGUgcmlnaHQgYW5kIHRvcCBvZiBwbG90cyAoZGVmYXVsdCAxMCkuXG4gKiAgQHByb3BlcnR5ICAge051bWJlcn0gICAgdHJhY2tHYXAgICAgVmVydGljYWwgZ2FwIGJldHdlZW4gdHJhY2tzIChkZWZhdWx0IDEwKVxuICovXG4gICAgdmFyIHRpbWVvdXQgPSBudWxsO1xuICAgIHZhciBzdGFydF96b29tID0gbnVsbDtcbiAgICB2YXIgem9vbV9sZXZlbCA9IG51bGw7XG4gICAgdmFyIGNlbnRlcl9yZXNpZHVlID0gbnVsbDtcbiAgICB2YXIgc3RhcnRfeCA9IG51bGw7XG4gICAgdmFyIHRyYW5zZm9ybWVyO1xuICAgIHZhciBzaGlmdGVyO1xuICAgIHZhciBhY2Nlc3NvcnMgPSB7IFxuICAgICAgICBzZXRab29tOiBmdW5jdGlvbih6b29tTGV2ZWwpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXJfd2lkdGggPSByZW5kZXJlci5fY29udGFpbmVyLmNhY2hlZF93aWR0aDtcbiAgICAgICAgICAgIGlmICggISBjb250YWluZXJfd2lkdGggKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyX3dpZHRoID0gcmVuZGVyZXIuX2NvbnRhaW5lci5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICggISByZW5kZXJlci5zZXF1ZW5jZSApIHtcbiAgICAgICAgICAgICAgICB6b29tX2xldmVsID0gem9vbUxldmVsO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtaW5fem9vbV9sZXZlbCA9IGNvbnRhaW5lcl93aWR0aCAvICgyICogcmVuZGVyZXIuc2VxdWVuY2UubGVuZ3RoKTtcbiAgICAgICAgICAgIC8vIGlmICAoISByZW5kZXJlci5ncm93X2NvbnRhaW5lciApIHtcbiAgICAgICAgICAgIC8vICAgICBtaW5fem9vbV9sZXZlbCA9IDAuMyAvIDIgKiBtaW5fem9vbV9sZXZlbDtcbiAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgLy8gdmFyIG1pbl96b29tX2xldmVsID0gcmVuZGVyZXIuc2VxdWVuY2UgPyAoMC4zIC8gMikgKiBjb250YWluZXJfd2lkdGggLyByZW5kZXJlci5zZXF1ZW5jZS5sZW5ndGggOiAwLjU7XG4gICAgICAgICAgICBpZiAoem9vbUxldmVsIDwgbWluX3pvb21fbGV2ZWwpIHtcbiAgICAgICAgICAgICAgICB6b29tTGV2ZWwgPSBtaW5fem9vbV9sZXZlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh6b29tTGV2ZWwgPiAxMCkge1xuICAgICAgICAgICAgICAgIHpvb21MZXZlbCA9IDEwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIGlmICh6b29tTGV2ZWwgPT0gem9vbV9sZXZlbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlZnJlc2guc3VzcGVuZGVkICYmIHNlbGYuX2NhbnZhcyAmJiBzZWxmLl9jYW52YXMuem9vbSAhPT0gcGFyc2VGbG9hdCh6b29tX2xldmVsKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9jYW52YXMuem9vbSA9IHBhcnNlRmxvYXQoem9vbV9sZXZlbCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2NhbnZhcy5zZXRTY2FsZSgxKTtcblxuICAgICAgICAgICAgICAgICAgICBiZWFuLmZpcmUoc2VsZi5fY2FudmFzLCd6b29tQ2hhbmdlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICBpZiAoISBzZWxmLl9jYW52YXMpIHtcbiAgICAgICAgICAgICAgICB6b29tX2xldmVsID0gem9vbUxldmVsO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG5vX3RvdWNoX2NlbnRlciA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoc2VsZi56b29tQ2VudGVyID09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICAgICAgbm9fdG91Y2hfY2VudGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzZWxmLnpvb21DZW50ZXIgPSB7J3gnIDogc2VsZi5fUlMqMC41KihzZWxmLmxlZnRWaXNpYmxlUmVzaWR1ZSgpK3NlbGYucmlnaHRWaXNpYmxlUmVzaWR1ZSgpKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoIHNlbGYuem9vbUNlbnRlciAmJiAhIGNlbnRlcl9yZXNpZHVlICkge1xuICAgICAgICAgICAgICAgIHN0YXJ0X3ggPSBzZWxmLl9jYW52YXMuY3VycmVudFRyYW5zbGF0ZUNhY2hlLnggfHwgMDtcbiAgICAgICAgICAgICAgICBjZW50ZXJfcmVzaWR1ZSA9IHNlbGYuem9vbUNlbnRlciA/IHNlbGYuem9vbUNlbnRlci54IDogMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2VudGVyX3Jlc2lkdWUgJiYgISBzZWxmLnpvb21DZW50ZXIgKSB7XG4gICAgICAgICAgICAgICAgLy8gV2Ugc2hvdWxkIG5vdCBiZSB6b29taW5nIGlmIHRoZXJlIGlzIGEgY2VudGVyIHJlc2lkdWUgYW5kIG5vIHpvb21DZW50ZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIHRpbWVvdXQgKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFydF96b29tID0gcGFyc2VGbG9hdCh6b29tX2xldmVsIHx8IDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB6b29tX2xldmVsID0gcGFyc2VGbG9hdCh6b29tTGV2ZWwpOyAgICAgICAgXG5cbiAgICAgICAgICAgIHZhciBzY2FsZV92YWx1ZSA9IE1hdGguYWJzKHBhcnNlRmxvYXQoem9vbUxldmVsKS9zdGFydF96b29tKTtcblxuICAgICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRyYW5zZm9ybWVyKTtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVyID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBSZW5kZXJpbmcgYm90dGxlbmVja1xuICAgICAgICAgICAgICAgIHNlbGYuX2NhbnZhcy5zZXRTY2FsZShzY2FsZV92YWx1ZSk7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBiZWFuLmZpcmUoc2VsZi5fY2FudmFzLCdfYW5pbV9iZWdpbicpO1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LmNyZWF0ZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2T2JqID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50cycpO1xuICAgICAgICAgICAgICAgIGV2T2JqLmluaXRFdmVudCgncGFuc3RhcnQnLGZhbHNlLHRydWUpO1xuICAgICAgICAgICAgICAgIHNlbGYuX2NhbnZhcy5kaXNwYXRjaEV2ZW50KGV2T2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvbGRfeCA9IHNlbGYuX2NhbnZhcy5jdXJyZW50VHJhbnNsYXRlQ2FjaGUueDtcbiAgICAgICAgICAgIGlmIChjZW50ZXJfcmVzaWR1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBkZWx0YSA9ICgoc3RhcnRfem9vbSAtIHpvb21fbGV2ZWwpLyhzY2FsZV92YWx1ZSoyNSkpKmNlbnRlcl9yZXNpZHVlO1xuICAgICAgICAgICAgICAgIGRlbHRhICs9IHN0YXJ0X3gvKHNjYWxlX3ZhbHVlKTtcbiAgICAgICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShzaGlmdGVyKTtcbiAgICAgICAgICAgICAgICBzaGlmdGVyID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSZW5kZXJpbmcgYm90dGxlbmVja1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9jYW52YXMuc2V0Q3VycmVudFRyYW5zbGF0ZVhZKGRlbHRhLCgoc3RhcnRfem9vbSAtIHpvb21fbGV2ZWwpLyhzY2FsZV92YWx1ZSkpKnNlbGYuX2F4aXNfaGVpZ2h0KjIpO1xuXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAgICAgdmFyIGVuZF9mdW5jdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBzY2FsZV92YWx1ZSA9IE1hdGguYWJzKHBhcnNlRmxvYXQoem9vbV9sZXZlbCkvc3RhcnRfem9vbSk7XG5cbiAgICAgICAgICAgICAgICBzZWxmLl9jYW52YXMuc2V0U2NhbGUobnVsbCk7XG5cbiAgICAgICAgICAgICAgICBiZWFuLmZpcmUoc2VsZi5fY2FudmFzLCdwYW5lbmQnKTtcbiAgICAgICAgICAgICAgICBiZWFuLmZpcmUoc2VsZi5fY2FudmFzLCdfYW5pbV9lbmQnKTtcbiAgICAgICAgICAgICAgICBsZXQgem9vbWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBiZWFuLnJlbW92ZShzZWxmLl9jYW52YXMsJ3pvb21DaGFuZ2UnLHpvb21jaGFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjZW50ZXJfcmVzaWR1ZSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHRhID0gKChzdGFydF96b29tIC0gem9vbV9sZXZlbCkvKDI1KSkqY2VudGVyX3Jlc2lkdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YSArPSBzdGFydF94O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9yZXNpemVDb250YWluZXIoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX2NhbnZhcy5zaGlmdFBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fY2FudmFzLnNoaWZ0UG9zaXRpb24oZGVsdGEsMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2NhbnZhcy5zZXRDdXJyZW50VHJhbnNsYXRlWFkoZGVsdGEsMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2VudGVyX3Jlc2lkdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBzdGFydF94ID0gbnVsbDsgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiZWFuLmFkZChzZWxmLl9jYW52YXMsJ3pvb21DaGFuZ2UnLHpvb21jaGFuZ2UpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX2NhbnZhcykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9jYW52YXMuem9vbSA9IHBhcnNlRmxvYXQoem9vbV9sZXZlbCk7XG4gICAgICAgICAgICAgICAgICAgIGJlYW4uZmlyZShzZWxmLl9jYW52YXMsJ3pvb21DaGFuZ2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmVhbi5maXJlKHNlbGYsJ3pvb21DaGFuZ2UnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICAgICAgaWYgKCEgdGhpcy5yZWZyZXNoLnN1c3BlbmRlZCkge1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGVuZF9mdW5jdGlvbiwxMDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmRfZnVuY3Rpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZml0Wm9vbTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyX3dpZHRoID0gcmVuZGVyZXIuX2NvbnRhaW5lci5jYWNoZWRfd2lkdGg7XG4gICAgICAgICAgICBpZiAoICEgY29udGFpbmVyX3dpZHRoICkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lcl93aWR0aCA9IHJlbmRlcmVyLl9jb250YWluZXIuY2xpZW50V2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbWluX3pvb21fbGV2ZWwgPSAwLjU7XG4gICAgICAgICAgICBpZiAocmVuZGVyZXIuc2VxdWVuY2UpIHtcbiAgICAgICAgICAgICAgICBtaW5fem9vbV9sZXZlbCA9IGNvbnRhaW5lcl93aWR0aCAvICgyICogcmVuZGVyZXIuc2VxdWVuY2UubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbmRlcmVyLnpvb20gPSBtaW5fem9vbV9sZXZlbDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Wm9vbTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gem9vbV9sZXZlbCB8fCAxO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgISBNQVNDUC5JRTgpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlbmRlcmVyLFwiem9vbVwiLCB7XG4gICAgICAgICAgICBnZXQgOiBhY2Nlc3NvcnMuZ2V0Wm9vbSxcbiAgICAgICAgICAgIHNldCA6IGFjY2Vzc29ycy5zZXRab29tXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlbmRlcmVyLmZpdFpvb20gPSBhY2Nlc3NvcnMuZml0Wm9vbTtcblxufTtcblxuLyogQWRkIHNvbWUgcHJvcGVydGllcyB0aGF0IHdpbGwgdHJpZ2dlciBhIHJlZnJlc2ggb24gdGhlIHJlbmRlcmVyIHdoZW4gdGhleSBhcmUgY2hhbmdlZC5cbiAgIFRoZXNlIGFyZSBhbGwgc3RhdGVsZXNzXG4gKi9cblxuKGZ1bmN0aW9uKGNsYXp6KSB7XG5cbiAgICB2YXIgYWNjZXNzb3JzID0ge1xuICAgICAgICBnZXRQYWRkaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYWRkaW5nIHx8IDEwO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldFBhZGRpbmc6IGZ1bmN0aW9uKHBhZGRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhZGRpbmcgPSBwYWRkaW5nO1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0VHJhY2tHYXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCEgdGhpcy5fdHJhY2tfZ2FwKXtcbiAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdF92YWx1ZSA9IChcIm9udG91Y2hlbmRcIiBpbiBkb2N1bWVudCkgPyAyMCA6IDEwO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyYWNrX2dhcCA9IHRoaXMuX3RyYWNrX2dhcCB8fCBkZWZhdWx0X3ZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhY2tfZ2FwO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldFRyYWNrR2FwOiBmdW5jdGlvbih0cmFja0dhcCkge1xuICAgICAgICAgICAgdGhpcy5fdHJhY2tfZ2FwID0gdHJhY2tHYXA7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmICEgTUFTQ1AuSUU4ICkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xhenoucHJvdG90eXBlLFwicGFkZGluZ1wiLCB7XG4gICAgICAgICAgICBnZXQgOiBhY2Nlc3NvcnMuZ2V0UGFkZGluZyxcbiAgICAgICAgICAgIHNldCA6IGFjY2Vzc29ycy5zZXRQYWRkaW5nXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xhenoucHJvdG90eXBlLFwidHJhY2tHYXBcIiwge1xuICAgICAgICAgICAgZ2V0IDogYWNjZXNzb3JzLmdldFRyYWNrR2FwLFxuICAgICAgICAgICAgc2V0IDogYWNjZXNzb3JzLnNldFRyYWNrR2FwXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBcbn0pKENvbmRlbnNlZFNlcXVlbmNlUmVuZGVyZXIpO1xuXG5Db25kZW5zZWRTZXF1ZW5jZVJlbmRlcmVyLk5hdmlnYXRpb24gPSBOYXZpZ2F0aW9uO1xuXG5leHBvcnQgZGVmYXVsdCBDb25kZW5zZWRTZXF1ZW5jZVJlbmRlcmVyO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFRQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBU0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBUUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF2QkE7QUF5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFKQTtBQWFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBU0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBRUE7QUFFQTs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQWVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFFQTs7Ozs7Ozs7QUFPQTtBQUVBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWxKQTtBQUNBO0FBb0pBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUVBOzs7OztBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQXRCQTtBQUNBO0FBd0JBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBRUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../gator/js/lib/CondensedSequenceRenderer.js\n")},"../gator/js/lib/CondensedSequenceRendererNavigation.js":
/*!**************************************************************!*\
  !*** ../gator/js/lib/CondensedSequenceRendererNavigation.js ***!
  \**************************************************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _SVGCanvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SVGCanvas */ \"../gator/js/lib/SVGCanvas.js\");\n/* harmony import */ var _bean__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../bean */ \"../gator/js/bean.js\");\n/* harmony import */ var _MASCP__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MASCP */ \"../gator/js/lib/MASCP.js\");\nconst svgns = 'http://www.w3.org/2000/svg';\n\n\n\nvar touch_scale = 1,\n    touch_enabled = false;\n\nif (\"ontouchend\" in document) {\n  touch_scale = window.devicePixelRatio > 1 ? 2 : 1;\n  touch_enabled = true;\n}\n\nvar Navigation = function Navigation(parent_canvas, renderer) {\n  Object(_SVGCanvas__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(parent_canvas);\n\n  this.win = function () {\n    return renderer.win();\n  };\n\n  buildNavPane.call(this, parent_canvas);\n  var track_group = parent_canvas.group();\n  parent_canvas.insertBefore(track_group, parent_canvas.lastChild);\n  var track_canvas = document.createElementNS(svgns, 'svg');\n  buildTrackPane.call(this, track_canvas, connectRenderer.call(this, renderer));\n  track_group.appendChild(track_canvas);\n  track_group.setAttribute('clip-path', 'url(#' + this.clipping_id + ')');\n\n  this.disable = function () {\n    parent_canvas.style.display = 'none';\n    track_canvas.style.display = 'none';\n  };\n\n  this.enable = function () {\n    parent_canvas.style.display = 'block';\n    track_canvas.style.display = 'block';\n  };\n\n  this.demote = function () {\n    track_canvas.hide();\n    return;\n  };\n\n  this.promote = function () {\n    if (this.visible()) {\n      track_canvas.show();\n    } else {\n      track_canvas.hide();\n    }\n  };\n\n  this.setDimensions = function (width, height) {\n    parent_canvas.setAttribute('width', width);\n    parent_canvas.setAttribute('height', height);\n  };\n};\n\nvar connectRenderer = function connectRenderer(renderer) {\n  /**\n   * Create a layer based controller for a group. Clicking on the nominated layer will animate out the expansion of the\n   * group.\n   * @param {Object} lay Layer to turn into a group controller\n   * @param {Object} grp Group to be controlled by this layer.\n   */\n  var controller_map = {};\n  var expanded_map = {};\n  var old_remove_track = renderer.removeTrack;\n\n  renderer.removeTrack = function (layer) {\n    old_remove_track.call(this, layer);\n    delete controller_map[layer.name];\n    delete expanded_map[layer.name];\n  };\n\n  this.isController = function (layer) {\n    if (controller_map[layer.name]) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  this.getController = function (group) {\n    for (var lay in controller_map) {\n      if (controller_map.hasOwnProperty(lay) && controller_map[lay] == group) {\n        return _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getLayer(lay);\n      }\n    }\n\n    return null;\n  };\n\n  this.isControllerExpanded = function (layer) {\n    return expanded_map[layer.name];\n  };\n\n  renderer.createGroupController = function (lay, grp) {\n    var layer = _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getLayer(lay);\n    var group = _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getGroup(grp);\n\n    if (!layer || !group) {\n      return;\n    }\n\n    if (controller_map[layer.name]) {\n      return;\n    }\n\n    controller_map[layer.name] = group;\n    expanded_map[layer.name] = false;\n    var self = this;\n    _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(layer, 'removed', function (ev, rend) {\n      self.setGroupVisibility(group);\n    });\n    _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(layer, 'visibilityChange', function (rend, visible) {\n      if (group.size() > 0) {\n        if (!expanded_map.hasOwnProperty(layer.name)) {\n          expanded_map[layer.name] = false;\n        }\n\n        self.setGroupVisibility(group, expanded_map[layer.name] && visible, true);\n        renderer.refresh();\n      }\n    });\n    _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(group, 'visibilityChange', function (rend, visible) {\n      if (visible) {\n        self.showLayer(layer, true);\n        expanded_map[layer.name] = true;\n      }\n    });\n    _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].remove(layer, '_expandevent');\n    _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(layer, '_expandevent', function (ev) {\n      expanded_map[layer.name] = !expanded_map[layer.name];\n      self.withoutRefresh(function () {\n        self.setGroupVisibility(group, expanded_map[layer.name]);\n      });\n      self.refresh(true);\n    });\n  };\n\n  return DragAndDrop(function (track, before, after) {\n    var t_order = renderer.trackOrder;\n\n    t_order.trackIndex = function (tr) {\n      if (!tr) {\n        return this.length;\n      }\n\n      return this.indexOf(tr.name);\n    };\n\n    if (after && !before) {\n      before = _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getLayer(t_order[t_order.trackIndex(after) + 1]);\n    }\n\n    t_order.splice(t_order.trackIndex(track), 1);\n    var extra_to_push = [];\n\n    if (controller_map[track.name]) {\n      let layer_func = function layer_func(lay) {\n        if (_MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getGroup(lay) === lay) {\n          _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getGroup(lay).eachLayer(layer_func);\n        }\n\n        if (t_order.trackIndex(lay) >= 0) {\n          extra_to_push = [t_order.splice(t_order.trackIndex(lay), 1)[0]].concat(extra_to_push);\n        }\n      };\n\n      _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getGroup(controller_map[track.name]).eachLayer(layer_func);\n    }\n\n    if (before) {\n      t_order.splice(t_order.trackIndex(before), 1, track.name, before ? before.name : undefined);\n\n      for (var i = 0; i < extra_to_push.length; i++) {\n        if (extra_to_push[i]) {\n          t_order.splice(t_order.trackIndex(before), 0, extra_to_push[i]);\n        }\n      }\n    } else {\n      renderer.hideLayer(track);\n      _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getLayer(track).disabled = true;\n      extra_to_push.forEach(function (lay) {\n        renderer.hideLayer(lay);\n        _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getLayer(lay).disabled = true;\n      });\n      t_order.push(track.name);\n      t_order = t_order.concat(extra_to_push);\n    }\n\n    renderer.trackOrder = t_order;\n  });\n};\n\nvar DragAndDrop = function DragAndDrop(spliceFunction) {\n  var targets = [];\n  var in_drag = false,\n      drag_el;\n  var splice_before, splice_after, trackToSplice;\n  var last_target;\n  var timeouts = {};\n  var nav_reset_set = null;\n  let spliceBefore;\n  let spliceAfter;\n\n  var drag_func = function drag_func(handle, element, track, canvas) {\n    var nav = this;\n    var old_reset = nav.reset;\n\n    if (nav_reset_set === null) {\n      nav.reset = function () {\n        targets = [];\n        old_reset.call(this);\n      };\n\n      nav_reset_set = true;\n    }\n\n    var resetDrag = function resetDrag() {\n      window.clearTimeout(timeouts.anim);\n      window.clearTimeout(timeouts.hover);\n\n      for (var i = 0; i < targets.length; i++) {\n        if (targets[i] != drag_el) {\n          targets[i].removeAttribute('dragging');\n          targets[i].removeAttribute('transform');\n          targets[i].setAttribute('pointer-events', 'all');\n        }\n      }\n    };\n\n    targets.push(element);\n    element.track = track;\n\n    var single_touch_event = function single_touch_event(fn) {\n      return function (e) {\n        if (e.touches && e.touches.length == 1) {\n          fn.call(this, e);\n        }\n      };\n    };\n\n    var beginDragging = function beginDragging(ev, tr, lbl_grp) {\n      if (drag_disabled()) {\n        return;\n      }\n\n      var target = canvas.nearestViewportElement;\n\n      if (in_drag) {\n        return;\n      }\n\n      lbl_grp.setAttribute('dragging', 'true');\n      spliceBefore = null;\n      spliceAfter = null;\n      var p_orig = lbl_grp.nearestViewportElement.createSVGPoint();\n      p_orig.x = ev.clientX || window.pageXOffset + ev.touches[0].clientX;\n      p_orig.y = ev.clientY || window.pageYOffset + ev.touches[0].clientY;\n      var rootCTM = lbl_grp.nearestViewportElement.getScreenCTM();\n      var matrix = rootCTM.inverse();\n      p_orig = p_orig.matrixTransform(matrix);\n      var oX = p_orig.x;\n      var oY = p_orig.y;\n\n      var dragfn = function dragfn(e) {\n        var p = lbl_grp.nearestViewportElement.createSVGPoint();\n        p.x = e.clientX || window.pageXOffset + e.touches[0].clientX;\n        p.y = e.clientY || window.pageYOffset + e.touches[0].clientY;\n        p = p.matrixTransform(matrix);\n        var dX = p.x - oX;\n        var dY = p.y - oY;\n        var curr_transform = lbl_grp.getAttribute('transform') || '';\n        curr_transform = curr_transform.replace(/\\s?translate\\([^\\)]+\\)/, '');\n        curr_transform += ' translate(' + dX + ',' + dY + ') ';\n        curr_transform = curr_transform.replace(/\\s*$/, '');\n        lbl_grp.setAttribute('transform', curr_transform);\n        targets.forEach(function (targ) {\n          var bb = targ.getBBox();\n\n          if (bb.y < p.y && bb.y > p.y - bb.height && bb.x < p.x && bb.x > p.x - bb.width) {\n            el_move.call(targ, e, targ.track);\n          }\n        });\n        e.stopPropagation();\n        e.preventDefault();\n        return false;\n      };\n\n      if (touch_enabled) {\n        dragfn = single_touch_event(dragfn);\n      }\n\n      var enddrag = function enddrag(e) {\n        if (e.relatedTarget && (e.relatedTarget == lbl_grp || e.relatedTarget.nearestViewportElement == lbl_grp.nearestViewportElement || e.relatedTarget.nearestViewportElement == target)) {\n          if (in_drag && targets.indexOf(e.relatedTarget) >= 0) {\n            resetDrag();\n          }\n\n          return;\n        }\n\n        if (in_drag && (e.type == 'mouseup' || e.type == 'touchend')) {\n          if (spliceBefore || spliceAfter) {\n            spliceFunction(trackToSplice, spliceBefore, spliceAfter);\n          }\n        }\n\n        target.removeEventListener('touchmove', dragfn, false);\n        target.removeEventListener('mousemove', dragfn, false);\n        target.removeEventListener('touchend', enddrag, false);\n        target.removeEventListener('mouseup', enddrag, false);\n        target.removeEventListener('mouseout', enddrag, false);\n\n        if (in_drag) {\n          lbl_grp.setAttributeNS(null, 'pointer-events', 'all');\n          lbl_grp.removeAttribute('transform');\n          resetDrag();\n          in_drag = false;\n          last_target = null;\n        }\n      };\n\n      lbl_grp.setAttributeNS(null, 'pointer-events', 'none');\n      lbl_grp.addEventListener('touchmove', dragfn, false);\n      lbl_grp.addEventListener('touchend', enddrag, false);\n      target.addEventListener('mousemove', dragfn, false);\n      target.addEventListener('mouseup', enddrag, false);\n      target.addEventListener('mouseout', enddrag, false);\n      in_drag = track;\n      drag_el = lbl_grp;\n    };\n\n    var handle_start = function handle_start(e) {\n      beginDragging(e, track, element);\n    };\n\n    var el_move = function el_move(e, trk) {\n      var trck = trk ? trk : track;\n      var elem = this ? this : element;\n\n      if (in_drag && in_drag != trck && trck != last_target) {\n        last_target = trck;\n\n        if (timeouts.hover) {\n          window.clearTimeout(timeouts.hover);\n        }\n\n        timeouts.hover = window.setTimeout(function () {\n          if ((in_drag.group || trck.group) && (in_drag.group ? trck.group : !trck.group)) {\n            if (in_drag.group.name != trck.group.name) {\n              return;\n            }\n          } else {\n            if (in_drag.group || trck.group) {\n              return;\n            }\n          }\n\n          if (timeouts.anim) {\n            window.clearInterval(timeouts.anim);\n            timeouts.anim = null;\n          }\n\n          resetDrag();\n          var current_sibling = elem;\n          var elements_to_shift = [];\n\n          while (current_sibling !== null) {\n            if (current_sibling != drag_el && targets.indexOf(current_sibling) >= 0) {\n              elements_to_shift.push(current_sibling);\n            }\n\n            current_sibling = current_sibling.nextSibling;\n\n            if (current_sibling == drag_el) {\n              break;\n            }\n          }\n\n          current_sibling = elem.previousSibling;\n          var elements_to_shift_up = [];\n\n          while (current_sibling !== null) {\n            if (current_sibling != drag_el && targets.indexOf(current_sibling) >= 0) {\n              elements_to_shift_up.push(current_sibling);\n            }\n\n            current_sibling = current_sibling.previousSibling;\n\n            if (current_sibling == drag_el) {\n              break;\n            }\n          }\n\n          var anim_steps = 1;\n          var height = drag_el.getBBox().height / 4;\n          timeouts.anim = window.setInterval(function () {\n            var curr_transform,\n                i = 0;\n\n            if (anim_steps < 5) {\n              for (i = 0; i < elements_to_shift.length; i++) {\n                curr_transform = elements_to_shift[i].getAttribute('transform') || '';\n                curr_transform = curr_transform.replace(/\\s?translate\\([^\\)]+\\)/, '');\n                curr_transform += ' translate(0,' + anim_steps * height + ')';\n                elements_to_shift[i].setAttribute('transform', curr_transform);\n              }\n\n              for (i = 0; elements_to_shift.length > 0 && i < elements_to_shift_up.length; i++) {\n                curr_transform = elements_to_shift_up[i].getAttribute('transform') || '';\n                curr_transform = curr_transform.replace(/\\s?translate\\([^\\)]+\\)/, '');\n                curr_transform += ' translate(0,' + anim_steps * -1 * height + ')';\n                elements_to_shift_up[i].setAttribute('transform', curr_transform);\n              }\n\n              anim_steps += 1;\n            } else {\n              spliceBefore = trck;\n              trackToSplice = in_drag;\n              window.clearInterval(timeouts.anim);\n              timeouts.anim = null;\n            }\n          }, 30);\n        }, 300);\n      }\n    };\n\n    handle.addEventListener('mousedown', handle_start, false);\n    handle.addEventListener('touchstart', single_touch_event(handle_start), false);\n  };\n\n  var drag_disabled = function drag_disabled() {\n    return drag_func.disabled;\n  };\n\n  drag_func.spliceFunction = spliceFunction;\n  return drag_func;\n};\n\nvar setElementTransform = function setElementTransform(el, transform) {\n  var ua = window.navigator.userAgent;\n\n  if (ua.indexOf('Edge/') >= 0) {\n    transform = transform.replace(/px/g, '');\n    el.setAttribute('transform', transform);\n  } else {\n    el.style.transform = transform;\n  }\n};\n\nvar buildNavPane = function buildNavPane(back_canvas) {\n  var self = this;\n  self.zoom = 1;\n  self.nav_width_base = 200;\n  var nav_width = self.nav_width_base;\n  self.nav_width = self.nav_width_base;\n  var panel_back = back_canvas.group();\n  var button_group = back_canvas.group();\n  var rect = back_canvas.rect(-10, 0, nav_width.toString(), '100%');\n  var base_rounded_corner = [12 * touch_scale, 10 * touch_scale];\n  rect.setAttribute('rx', base_rounded_corner[0].toString());\n  rect.setAttribute('ry', base_rounded_corner[1].toString());\n\n  if (!touch_enabled) {\n    rect.setAttribute('opacity', '0.8');\n  }\n\n  rect.style.stroke = '#000000';\n  rect.style.strokeWidth = '2px';\n  rect.style.fill = '#000000';\n  rect.id = 'nav_back';\n  panel_back.push(rect);\n  self.clipping_id = 'nav_clipping' + new Date().getTime();\n  var clipping = document.createElementNS(svgns, 'clipPath');\n  clipping.id = self.clipping_id;\n  var rect2 = rect.cloneNode();\n  rect2.removeAttribute('id');\n  rect2.removeAttribute('opacity');\n  rect2.setAttribute('x', '0');\n  rect2.setAttribute('width', \"\" + (parseInt(rect2.getAttribute('width')) - 10));\n  rect2.removeAttribute('style');\n  rect2.setAttribute('height', '10000');\n  back_canvas.insertBefore(clipping, back_canvas.firstChild);\n  clipping.appendChild(rect2);\n  var close_group = back_canvas.crossed_circle(nav_width - (10 + touch_scale * 11), 12 * touch_scale, 10 * touch_scale);\n  close_group.style.cursor = 'pointer';\n\n  if (typeof matchMedia !== 'undefined') {\n    (this.win() || window).matchMedia('print').addListener(function (match) {\n      if (match.matches) {\n        close_group.setAttribute('display', 'none');\n        tracks_button.setAttribute('display', 'none');\n      } else {\n        close_group.setAttribute('display', 'block');\n        tracks_button.setAttribute('display', 'none');\n      }\n    });\n  }\n\n  button_group.push(close_group);\n  var tracks_button = _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].IE ? back_canvas.svgbutton(10, 5, 65, 25, 'Edit') : back_canvas.button(10, 5, 65, 25, 'Edit');\n  tracks_button.id = 'controls';\n  tracks_button.parentNode.setAttribute('clip-path', 'url(#' + self.clipping_id + ')');\n  panel_back.push(_MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].IE ? tracks_button : tracks_button.parentNode);\n  tracks_button.addEventListener('click', function () {\n    _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire(self, 'toggleEdit');\n    _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire(self, 'click');\n  }, false);\n  panel_back.setAttribute('style', 'transition: all 0.25s;');\n  var old_tracks_style = tracks_button.getAttribute('style');\n  var transform_origin = \"\" + (nav_width - (10 + touch_scale * 11)) + \"px \" + 12 * touch_scale + \"px\";\n\n  var translate = function translate(amount, rotate) {\n    var trans = \" translate3d(\" + amount + \"px,0px,0px)\";\n\n    if (rotate) {\n      trans = trans + \" rotate(\" + rotate + \")\";\n    }\n\n    return \"-webkit-transform:\" + trans + \"; -moz-transform:\" + trans + \"; -ms-transform:\" + trans.replace('3d', '').replace(',0px)', ')') + \"; transform: \" + trans + \";\";\n  };\n\n  tracks_button.setAttribute('style', old_tracks_style + \" transition: all 0.25s;\");\n  close_group.style.transition = 'all 0.25s';\n  close_group.style.transformOrigin = transform_origin;\n  var visible = true;\n\n  var toggler = function toggler(vis, interactive) {\n    visible = vis === false || vis === true ? vis : !visible;\n    var close_transform;\n    var needs_transition = interactive ? \"all ease-in-out 0.4s\" : \"\";\n    let parent_transform = back_canvas.parentNode.style.transform;\n    let scaleval;\n    let yscale = touch_scale;\n\n    if (scaleval = parent_transform.match(/scale\\(([\\d\\.]+)\\)/)) {\n      yscale = 1;\n    }\n\n    var transform_origin = \"\" + (self.nav_width_base - (10 + touch_scale * 11)) + \"px \" + 12 * yscale + \"px\";\n\n    if (visible) {\n      self.promote();\n      setElementTransform(panel_back, 'translate(0,0)');\n      panel_back.style.transition = needs_transition;\n\n      close_group._button.removeAttribute('filter');\n\n      if (\"ontouchend\" in window || window.getComputedStyle(close_group).getPropertyValue(\"-ms-transform\")) {\n        setElementTransform(close_group, '');\n      }\n\n      setElementTransform(close_group, 'translate(0,0)');\n      close_group.style.transition = needs_transition;\n      close_group.style.transformOrigin = close_group.getBoundingClientRect().left + 'px ' + close_group.getBoundingClientRect().top + ' px';\n      self.refresh();\n    } else {\n      self.demote(); // Chrome bug Jan 2015 with the drop shadow\n      //close_group._button.setAttribute('filter','url(#drop_shadow)');\n\n      close_group.style.transition = needs_transition;\n      close_group.style.transition = needs_transition; // close_group.style.transformOrigin = transform_origin;\n\n      close_group.style.transformOrigin = close_group.getBoundingClientRect().left + 'px ' + close_group.getBoundingClientRect().top + ' px';\n      setElementTransform(close_group, 'translate(' + -0.75 * self.nav_width_base + 'px,0) rotate(405deg)');\n\n      if (\"ontouchend\" in window) {\n        // No longer special casing IE\n        setElementTransform(close_group, 'translate(' + -0.75 * self.nav_width_base + 'px,0) rotate(45,' + (self.nav_width_base - (10 + touch_scale * 11)) + 'px,' + 12 * touch_scale + 'px)');\n        setElementTransform(panel_back, 'translate(' + -1 * self.nav_width * self.zoom + 'px,0)');\n        panel_back.style.transition = needs_transition;\n      } else {\n        setElementTransform(panel_back, 'translate(' + -1 * self.nav_width * self.zoom + 'px,0)');\n        panel_back.style.transition = needs_transition;\n      }\n    }\n\n    return true;\n  };\n\n  self.move_closer = function () {\n    if (visible) {\n      return;\n    }\n\n    setElementTransform(close_group, 'translate(' + -0.75 * self.nav_width_base + 'px,0) rotate(405deg)');\n\n    if (\"ontouchend\" in window) {\n      // No longer special casing IE\n      setElementTransform(close_group, 'translate(' + -0.75 * self.nav_width_base + 'px,0) rotate(45,' + (self.nav_width_base - (10 + touch_scale * 11)) + 'px,' + 12 * touch_scale + 'px)');\n    }\n  };\n\n  self.hide = function (interactive) {\n    toggler.call(this, false, interactive);\n  };\n\n  self.show = function (interactive) {\n    toggler.call(this, true, interactive);\n  };\n\n  self.visible = function () {\n    return visible;\n  };\n\n  self.setZoom = function (zoom) {\n    self.nav_width = self.nav_width_base / zoom;\n    close_group.setAttribute('transform', 'scale(' + zoom + ',' + zoom + ') ');\n    let parent_transform = back_canvas.parentNode.style.transform;\n    let scaleval;\n    let yscale = touch_scale;\n\n    if (scaleval = parent_transform.match(/scale\\(([\\d\\.]+)\\)/)) {\n      yscale = 1;\n    }\n\n    var transform_origin = \"\" + (self.nav_width_base - (10 + touch_scale * 11)).toFixed(2) + \"px \" + 12 * yscale + \"px\";\n    close_group.style.transformOrigin = transform_origin;\n    close_group.move(self.nav_width_base - (10 + touch_scale * 11), 12 * touch_scale);\n    rect.setAttribute('transform', 'scale(' + zoom + ',1) ');\n    rect.setAttribute('ry', base_rounded_corner[1].toString());\n    rect.setAttribute('rx', (base_rounded_corner[0] / zoom).toString());\n    rect.setAttribute('x', parseInt(-10 / zoom).toString());\n    rect.setAttribute('width', self.nav_width.toString());\n    self.zoom = zoom;\n    toggler.call(this, visible);\n    self.refresh();\n  };\n\n  close_group.addEventListener('click', function () {\n    if (visible) {\n      self.hide(true);\n    } else {\n      self.show(true);\n    }\n  }, false);\n};\n\nvar buildTrackPane = function buildTrackPane(track_canvas, draganddrop) {\n  var self = this;\n  var close_buttons, controller_buttons, edit_enabled;\n  var nav_width_track_canvas_ctm = 0;\n  Object(_SVGCanvas__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(track_canvas);\n  track_canvas.setAttribute('preserveAspectRatio', 'xMinYMin meet');\n  var track_rects = [];\n\n  self.reset = function () {\n    while (track_canvas.firstChild) {\n      track_canvas.removeChild(track_canvas.firstChild);\n    }\n\n    track_rects = [];\n    ctm_refresh = []; //            self.refresh();\n  };\n\n  var ctm_refresh = [];\n\n  self.isEditing = function () {\n    return edit_enabled;\n  };\n\n  self.refresh = function () {\n    (close_buttons || []).forEach(function (button) {\n      button.setAttribute('visibility', edit_enabled ? 'visible' : 'hidden');\n    });\n    (controller_buttons || []).forEach(function (button) {\n      button.setAttribute('visibility', edit_enabled ? 'hidden' : 'visible');\n    });\n\n    if (edit_enabled) {\n      toggleMouseEvents.call(this, true);\n    } else {\n      toggleMouseEvents.call(this, false);\n    }\n\n    if (track_canvas.getAttribute('display') == 'none' || track_canvas.style.display == 'none') {\n      return;\n    }\n\n    if (ctm_refresh.length < 1) {\n      return;\n    }\n\n    var nav_back = track_canvas.ownerSVGElement.getElementById('nav_back');\n    var ctm = nav_back.getScreenCTM().inverse().multiply(track_canvas.getScreenCTM()).inverse();\n    var back_width = nav_back.getBBox().width + nav_back.getBBox().x;\n    var point = track_canvas.createSVGPoint();\n    point.x = back_width;\n    point.y = 0;\n    nav_width_track_canvas_ctm = point.matrixTransform(ctm).x;\n    ctm_refresh.forEach(function (el) {\n      var width = 0;\n\n      try {\n        width = el.getBBox().width;\n      } catch (err) {// This is a bug with Firefox on some elements getting\n        // the bounding box. We silently fail here, as I can't\n        // figure out why the call to getBBox fails.\n      }\n\n      if (width > 0) {\n        var a_y = /translate\\((-?\\d+\\.?\\d*)\\s*,?\\s*(-?\\d+\\.?\\d*)\\)/.exec(el.getAttribute('transform') || '');\n\n        if (typeof a_y != 'undefined') {\n          a_y = a_y[2];\n        } else {\n          return;\n        }\n\n        var new_x = nav_width_track_canvas_ctm - 1.5 * parseInt(el.getAttribute('width'), 10);\n        el.setAttribute('transform', 'translate(' + new_x + ',' + a_y + ')');\n      }\n    });\n  };\n\n  var toggleMouseEvents = function toggleMouseEvents(on) {\n    if (track_rects) {\n      (track_rects || []).forEach(function (el) {\n        el.setAttribute('opacity', on ? '1' : touch_enabled ? \"0.5\" : \"0.1\");\n        el.setAttribute('pointer-events', on ? 'all' : 'none');\n        on ? el.parentNode.setAttribute('dragenabled', 'true') : el.parentNode.removeAttribute('dragenabled');\n      });\n    }\n  };\n\n  _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(self, 'toggleEdit', function () {\n    edit_enabled = typeof edit_enabled == 'undefined' ? true : !edit_enabled;\n    draganddrop.disabled = !edit_enabled;\n    toggleMouseEvents.call(self, edit_enabled);\n    self.hide();\n    self.show();\n    (close_buttons || []).forEach(function (button) {\n      button.setAttribute('visibility', edit_enabled ? 'visible' : 'hidden');\n    });\n    (controller_buttons || []).forEach(function (button) {\n      button.setAttribute('visibility', edit_enabled ? 'hidden' : 'visible');\n    });\n  });\n\n  this.setViewBox = function (viewBox) {\n    track_canvas.setAttribute('viewBox', viewBox);\n  };\n\n  track_canvas.style.height = '100%';\n  track_canvas.style.width = '100%';\n  track_canvas.setAttribute('height', '100%');\n  track_canvas.setAttribute('width', '100%');\n\n  this.renderTrack = function (track, y, height, options) {\n    var label_group = track_canvas.group();\n    var a_rect = track_canvas.rect(0, y, '100%', height);\n    a_rect.setAttribute('stroke', '#000000');\n    a_rect.setAttribute('stroke-width', '2');\n    a_rect.setAttribute('fill', 'url(#simple_gradient)');\n    a_rect.setAttribute('opacity', touch_enabled ? '0.5' : '0.1');\n    a_rect.setAttribute('pointer-events', 'none');\n    track_rects = track_rects || [];\n    track_rects.push(a_rect);\n    label_group.push(a_rect); // Use these for debugging positioning\n    // var r = track_canvas.rect(0,y-height,height,height);\n    // r.setAttribute('fill','#ff0000');\n    // label_group.push(r);\n    // \n    // r = track_canvas.rect(0,y+height,height,height);\n    // r.setAttribute('fill','#ff0000');\n    // label_group.push(r);\n\n    var text_scale = options && options['font-scale'] ? options['font-scale'] : 1;\n    var text_left = 4 / 3 * touch_scale * height * text_scale;\n    var a_text = track_canvas.text(text_left, y + 0.5 * height, track.fullname || track.name);\n    a_text.setAttribute('height', height);\n    a_text.setAttribute('width', height);\n    a_text.setAttribute('font-size', 0.6 * height * text_scale);\n    a_text.setAttribute('fill', '#ffffff');\n    a_text.setAttribute('stroke', '#ffffff');\n    a_text.setAttribute('stroke-width', '0');\n    a_text.firstChild.setAttribute('dy', '0.5ex'); // r = track_canvas.rect(3*height*text_scale,y+0.5*height,2*height,2*height);\n    // r.setAttribute('fill','#00ff00');\n    // label_group.push(r);\n\n    label_group.push(a_text);\n    a_text.setAttribute('pointer-events', 'none');\n    var circ;\n\n    if (track.href) {\n      a_anchor = track_canvas.a(track.href);\n      var icon_name = null;\n      var icon_metrics = [0.5 * height * text_scale, 0, height * text_scale * touch_scale];\n      icon_metrics[1] = -0.5 * (icon_metrics[2] - height);\n      circ = track_canvas.circle(icon_metrics[0] + 0.5 * icon_metrics[2], 0.5 * height, 0.5 * icon_metrics[2]);\n      circ.setAttribute('fill', '#ffffff');\n      circ.setAttribute('opacity', '0.1');\n      a_anchor.appendChild(circ);\n      var url_type = track.href;\n\n      if (typeof url_type === 'string' && url_type.match(/^javascript\\:/)) {\n        icon_name = '#plus_icon';\n      } else if (typeof url_type === 'function') {\n        icon_name = '#plus_icon';\n        a_anchor.setAttribute('href', '#');\n        a_anchor.removeAttribute('target');\n        a_anchor.addEventListener('click', function (e) {\n          url_type.call();\n\n          if (e.preventDefault) {\n            e.preventDefault();\n          } else {\n            e.returnResult = false;\n          }\n\n          if (e.stopPropagation) {\n            e.stopPropagation();\n          } else {\n            e.cancelBubble = true;\n          }\n\n          return false;\n        }, false);\n      } else {\n        icon_name = '#new_link_icon';\n      }\n\n      if (track.icon) {\n        icon_name = track.icon;\n      }\n\n      var a_use = track_canvas.use(icon_name, icon_metrics[0], icon_metrics[1], icon_metrics[2], icon_metrics[2]);\n      a_use.style.cursor = 'pointer';\n      a_anchor.appendChild(a_use);\n      a_anchor.setAttribute('transform', 'translate(' + (nav_width_track_canvas_ctm - 1.5 * icon_metrics[2]) + ',' + y + ')');\n      a_anchor.setAttribute('width', icon_metrics[2].toString());\n      ctm_refresh.push(a_anchor);\n    }\n\n    label_group.addEventListener('touchstart', function () {\n      label_group.onmouseover = undefined;\n      label_group.onmouseout = undefined;\n    }, false);\n    label_group.addEventListener('touchend', function () {\n      label_group.onmouseover = undefined;\n      label_group.onmouseout = undefined;\n    }, false);\n    draganddrop.call(this, a_rect, label_group, track, track_canvas);\n\n    (function () {\n      if (track.group) {\n        return;\n      }\n\n      var t_height = 0.5 * height * touch_scale;\n\n      if (!close_buttons) {\n        close_buttons = [];\n      }\n\n      var closer = track_canvas.crossed_circle(1.5 * t_height, 0, t_height);\n      closer.setAttribute('transform', 'translate(0,' + (y + 0.5 * height) + ') scale(' + text_scale + ')');\n      closer.firstChild.setAttribute('fill', 'url(#red_3d)');\n\n      for (var nodes = closer.childNodes, i = 0, len = nodes.length; i < len; i++) {\n        nodes[i].setAttribute('stroke-width', (t_height / 4).toString());\n      }\n\n      closer.addEventListener('click', function () {\n        draganddrop.spliceFunction(track);\n      }, false);\n      label_group.push(closer);\n      close_buttons.push(closer);\n      closer.setAttribute('visibility', 'hidden');\n    })();\n\n    if (this.isController(track)) {\n      if (!controller_buttons) {\n        controller_buttons = [];\n      }\n\n      var t_height = 0.5 * height * touch_scale;\n      var expander = track_canvas.group();\n      circ = track_canvas.circle(1.5 * t_height, 0, t_height);\n      circ.setAttribute('fill', '#ffffff');\n      circ.setAttribute('opacity', '0.1');\n      expander.push(circ);\n      var t_metrics = [1.1 * t_height, -1.25 * t_height, 2.25 * t_height, -0.5 * t_height, 1.1 * t_height, 0.25 * t_height];\n      t_metrics[1] += 0.5 * (t_height - 0 * height);\n      t_metrics[3] += 0.5 * (t_height - 0 * height);\n      t_metrics[5] += 0.5 * (t_height - 0 * height);\n      var group_toggler = track_canvas.poly('' + t_metrics[0] + ',' + t_metrics[1] + ' ' + t_metrics[2] + ',' + t_metrics[3] + ' ' + t_metrics[4] + ',' + t_metrics[5]);\n\n      if (this.isControllerExpanded(track)) {\n        expander.setAttribute('transform', 'translate(0,' + (y + 0.5 * height) + ') scale(' + text_scale + ') rotate(90,' + 1.5 * t_height + ',' + t_metrics[3] + ')');\n      } else {\n        expander.setAttribute('transform', 'translate(0,' + (y + 0.5 * height) + ') scale(' + text_scale + ')');\n      }\n\n      group_toggler.setAttribute('height', 1.75 * t_height);\n      group_toggler.setAttribute('font-size', 1.5 * t_height);\n      group_toggler.setAttribute('fill', '#ffffff');\n      group_toggler.setAttribute('pointer-events', 'none');\n      expander.push(group_toggler);\n      expander.style.cursor = 'pointer';\n      expander.addEventListener('click', function (e) {\n        e.stopPropagation();\n        _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire(track, '_expandevent');\n\n        if (self.isControllerExpanded(track)) {\n          expander.setAttribute('transform', 'translate(0,' + (y + 0.5 * height) + ') scale(' + text_scale + ') rotate(90,' + 1.5 * t_height + ',' + t_metrics[3] + ')');\n        } else {\n          expander.setAttribute('transform', 'translate(0,' + (y + 0.5 * height) + ') scale(' + text_scale + ')');\n        }\n      }, false);\n      label_group.push(expander);\n      controller_buttons.push(expander);\n      expander.setAttribute('visibility', 'hidden');\n    }\n  };\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Navigation);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vZ2F0b3IvanMvbGliL0NvbmRlbnNlZFNlcXVlbmNlUmVuZGVyZXJOYXZpZ2F0aW9uLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL2dhdG9yL2pzL2xpYi9Db25kZW5zZWRTZXF1ZW5jZVJlbmRlcmVyTmF2aWdhdGlvbi5qcz9hODBiIl0sInNvdXJjZXNDb250ZW50IjpbIlxuY29uc3Qgc3ZnbnMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuXG5pbXBvcnQgU1ZHQ2FudmFzIGZyb20gJy4vU1ZHQ2FudmFzJztcbmltcG9ydCBiZWFuIGZyb20gJy4uL2JlYW4nO1xuaW1wb3J0IE1BU0NQIGZyb20gJy4vTUFTQ1AnO1xuXG52YXIgdG91Y2hfc2NhbGUgPSAxLCB0b3VjaF9lbmFibGVkID0gZmFsc2U7XG5pZiAoXCJvbnRvdWNoZW5kXCIgaW4gZG9jdW1lbnQpIHtcbiAgICB0b3VjaF9zY2FsZSA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvID4gMSA/IDIgOiAxO1xuICAgIHRvdWNoX2VuYWJsZWQgPSB0cnVlO1xufVxuXG52YXIgTmF2aWdhdGlvbiA9IGZ1bmN0aW9uKHBhcmVudF9jYW52YXMscmVuZGVyZXIpIHtcbiAgICBTVkdDYW52YXMocGFyZW50X2NhbnZhcyk7XG5cbiAgICB0aGlzLndpbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcmVuZGVyZXIud2luKCk7XG4gICAgfTtcblxuICAgIGJ1aWxkTmF2UGFuZS5jYWxsKHRoaXMscGFyZW50X2NhbnZhcyk7XG5cbiAgICB2YXIgdHJhY2tfZ3JvdXAgPSBwYXJlbnRfY2FudmFzLmdyb3VwKCk7XG5cbiAgICBwYXJlbnRfY2FudmFzLmluc2VydEJlZm9yZSh0cmFja19ncm91cCxwYXJlbnRfY2FudmFzLmxhc3RDaGlsZCk7XG5cbiAgICB2YXIgdHJhY2tfY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2Z25zLCdzdmcnKTsgICAgXG4gICAgYnVpbGRUcmFja1BhbmUuY2FsbCh0aGlzLHRyYWNrX2NhbnZhcyxjb25uZWN0UmVuZGVyZXIuY2FsbCh0aGlzLHJlbmRlcmVyKSk7XG5cbiAgICB0cmFja19ncm91cC5hcHBlbmRDaGlsZCh0cmFja19jYW52YXMpO1xuXG4gICAgdHJhY2tfZ3JvdXAuc2V0QXR0cmlidXRlKCdjbGlwLXBhdGgnLCd1cmwoIycrdGhpcy5jbGlwcGluZ19pZCsnKScpO1xuXG4gICAgdGhpcy5kaXNhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHBhcmVudF9jYW52YXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgdHJhY2tfY2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5lbmFibGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcGFyZW50X2NhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgdHJhY2tfY2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIH1cblxuICAgIHRoaXMuZGVtb3RlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRyYWNrX2NhbnZhcy5oaWRlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xuXG4gICAgdGhpcy5wcm9tb3RlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnZpc2libGUoKSkge1xuICAgICAgICAgICAgdHJhY2tfY2FudmFzLnNob3coKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyYWNrX2NhbnZhcy5oaWRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIHRoaXMuc2V0RGltZW5zaW9ucyA9IGZ1bmN0aW9uKHdpZHRoLGhlaWdodCkge1xuICAgICAgICBwYXJlbnRfY2FudmFzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLHdpZHRoKTtcbiAgICAgICAgcGFyZW50X2NhbnZhcy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsaGVpZ2h0KTtcbiAgICB9O1xuICAgIFxufTtcblxudmFyIGNvbm5lY3RSZW5kZXJlciA9IGZ1bmN0aW9uKHJlbmRlcmVyKSB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBsYXllciBiYXNlZCBjb250cm9sbGVyIGZvciBhIGdyb3VwLiBDbGlja2luZyBvbiB0aGUgbm9taW5hdGVkIGxheWVyIHdpbGwgYW5pbWF0ZSBvdXQgdGhlIGV4cGFuc2lvbiBvZiB0aGVcbiAgICAgKiBncm91cC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbGF5IExheWVyIHRvIHR1cm4gaW50byBhIGdyb3VwIGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZ3JwIEdyb3VwIHRvIGJlIGNvbnRyb2xsZWQgYnkgdGhpcyBsYXllci5cbiAgICAgKi9cbiAgICBcbiAgICB2YXIgY29udHJvbGxlcl9tYXAgPSB7fTtcbiAgICB2YXIgZXhwYW5kZWRfbWFwID0ge307XG4gICAgXG4gICAgdmFyIG9sZF9yZW1vdmVfdHJhY2sgPSByZW5kZXJlci5yZW1vdmVUcmFjaztcblxuICAgIHJlbmRlcmVyLnJlbW92ZVRyYWNrID0gZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgICAgb2xkX3JlbW92ZV90cmFjay5jYWxsKHRoaXMsbGF5ZXIpO1xuICAgICAgICBkZWxldGUgY29udHJvbGxlcl9tYXBbbGF5ZXIubmFtZV07XG4gICAgICAgIGRlbGV0ZSBleHBhbmRlZF9tYXBbbGF5ZXIubmFtZV07XG4gICAgfTtcblxuXG4gICAgdGhpcy5pc0NvbnRyb2xsZXIgPSBmdW5jdGlvbihsYXllcikge1xuICAgICAgICBpZiAoY29udHJvbGxlcl9tYXBbbGF5ZXIubmFtZV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLmdldENvbnRyb2xsZXIgPSBmdW5jdGlvbihncm91cCkge1xuICAgICAgICBmb3IgKHZhciBsYXkgaW4gY29udHJvbGxlcl9tYXApIHtcbiAgICAgICAgICAgIGlmIChjb250cm9sbGVyX21hcC5oYXNPd25Qcm9wZXJ0eShsYXkpICYmIGNvbnRyb2xsZXJfbWFwW2xheV0gPT0gZ3JvdXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTUFTQ1AuZ2V0TGF5ZXIobGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuaXNDb250cm9sbGVyRXhwYW5kZWQgPSBmdW5jdGlvbihsYXllcikge1xuICAgICAgICByZXR1cm4gZXhwYW5kZWRfbWFwW2xheWVyLm5hbWVdO1xuICAgIH07XG4gICAgXG4gICAgcmVuZGVyZXIuY3JlYXRlR3JvdXBDb250cm9sbGVyID0gZnVuY3Rpb24obGF5LGdycCkge1xuICAgICAgICB2YXIgbGF5ZXIgPSBNQVNDUC5nZXRMYXllcihsYXkpO1xuICAgICAgICB2YXIgZ3JvdXAgPSBNQVNDUC5nZXRHcm91cChncnApO1xuXG4gICAgICAgIGlmICggISBsYXllciB8fCAhIGdyb3VwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udHJvbGxlcl9tYXBbbGF5ZXIubmFtZV0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRyb2xsZXJfbWFwW2xheWVyLm5hbWVdID0gZ3JvdXA7XG4gICAgICAgIFxuICAgICAgICBleHBhbmRlZF9tYXBbbGF5ZXIubmFtZV0gPSBmYWxzZTtcbiAgICAgICAgXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICBiZWFuLmFkZChsYXllciwncmVtb3ZlZCcsZnVuY3Rpb24oZXYscmVuZCkge1xuICAgICAgICAgICAgc2VsZi5zZXRHcm91cFZpc2liaWxpdHkoZ3JvdXApO1xuICAgICAgICB9KTtcblxuICAgICAgICBiZWFuLmFkZChsYXllciwndmlzaWJpbGl0eUNoYW5nZScsZnVuY3Rpb24ocmVuZCx2aXNpYmxlKSB7XG4gICAgICAgICAgICBpZiAoZ3JvdXAuc2l6ZSgpID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICghIGV4cGFuZGVkX21hcC5oYXNPd25Qcm9wZXJ0eShsYXllci5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBleHBhbmRlZF9tYXBbbGF5ZXIubmFtZV0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5zZXRHcm91cFZpc2liaWxpdHkoZ3JvdXAsIGV4cGFuZGVkX21hcFtsYXllci5uYW1lXSAmJiB2aXNpYmxlLHRydWUpO1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnJlZnJlc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGJlYW4uYWRkKGdyb3VwLCd2aXNpYmlsaXR5Q2hhbmdlJyxmdW5jdGlvbihyZW5kLHZpc2libGUpIHtcbiAgICAgICAgICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zaG93TGF5ZXIobGF5ZXIsdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZXhwYW5kZWRfbWFwW2xheWVyLm5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGJlYW4ucmVtb3ZlKGxheWVyLCdfZXhwYW5kZXZlbnQnKVxuICAgICAgICBiZWFuLmFkZChsYXllciwnX2V4cGFuZGV2ZW50JyxmdW5jdGlvbihldikge1xuICAgICAgICAgICAgZXhwYW5kZWRfbWFwW2xheWVyLm5hbWVdID0gISBleHBhbmRlZF9tYXBbbGF5ZXIubmFtZV07XG4gICAgICAgICAgICBzZWxmLndpdGhvdXRSZWZyZXNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuc2V0R3JvdXBWaXNpYmlsaXR5KGdyb3VwLGV4cGFuZGVkX21hcFtsYXllci5uYW1lXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGYucmVmcmVzaCh0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBEcmFnQW5kRHJvcChmdW5jdGlvbih0cmFjayxiZWZvcmUsYWZ0ZXIpe1xuICAgICAgICB2YXIgdF9vcmRlciA9IHJlbmRlcmVyLnRyYWNrT3JkZXI7XG5cbiAgICAgICAgdF9vcmRlci50cmFja0luZGV4ID0gZnVuY3Rpb24odHIpIHtcbiAgICAgICAgICAgIGlmICghIHRyICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4T2YodHIubmFtZSk7XG4gICAgICAgIH07XG4gICAgXG4gICAgICAgIGlmIChhZnRlciAmJiAhIGJlZm9yZSkge1xuICAgICAgICAgICAgYmVmb3JlID0gTUFTQ1AuZ2V0TGF5ZXIodF9vcmRlclt0X29yZGVyLnRyYWNrSW5kZXgoYWZ0ZXIpICsgMV0pO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIHRfb3JkZXIuc3BsaWNlKHRfb3JkZXIudHJhY2tJbmRleCh0cmFjayksMSk7XG4gICAgICAgIHZhciBleHRyYV90b19wdXNoID0gW107XG4gICAgICAgIGlmIChjb250cm9sbGVyX21hcFt0cmFjay5uYW1lXSkge1xuICAgICAgICAgICAgbGV0IGxheWVyX2Z1bmMgPSBmdW5jdGlvbihsYXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoTUFTQ1AuZ2V0R3JvdXAobGF5KSA9PT0gbGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIE1BU0NQLmdldEdyb3VwKGxheSkuZWFjaExheWVyKGxheWVyX2Z1bmMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodF9vcmRlci50cmFja0luZGV4KGxheSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBleHRyYV90b19wdXNoID0gW3Rfb3JkZXIuc3BsaWNlKHRfb3JkZXIudHJhY2tJbmRleChsYXkpLDEpWzBdXS5jb25jYXQoZXh0cmFfdG9fcHVzaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgTUFTQ1AuZ2V0R3JvdXAoY29udHJvbGxlcl9tYXBbdHJhY2submFtZV0pLmVhY2hMYXllcihsYXllcl9mdW5jKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgICB0X29yZGVyLnNwbGljZSh0X29yZGVyLnRyYWNrSW5kZXgoYmVmb3JlKSwxLHRyYWNrLm5hbWUsIGJlZm9yZSA/IGJlZm9yZS5uYW1lIDogdW5kZWZpbmVkICk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4dHJhX3RvX3B1c2gubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4dHJhX3RvX3B1c2hbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdF9vcmRlci5zcGxpY2UodF9vcmRlci50cmFja0luZGV4KGJlZm9yZSksMCxleHRyYV90b19wdXNoW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW5kZXJlci5oaWRlTGF5ZXIodHJhY2spO1xuICAgICAgICAgICAgTUFTQ1AuZ2V0TGF5ZXIodHJhY2spLmRpc2FibGVkID0gdHJ1ZTsgICAgICAgICAgICAgICAgXG5cbiAgICAgICAgICAgIGV4dHJhX3RvX3B1c2guZm9yRWFjaChmdW5jdGlvbihsYXkpIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICByZW5kZXJlci5oaWRlTGF5ZXIobGF5KTtcbiAgICAgICAgICAgICAgICBNQVNDUC5nZXRMYXllcihsYXkpLmRpc2FibGVkID0gdHJ1ZTsgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0X29yZGVyLnB1c2godHJhY2submFtZSk7XG4gICAgICAgICAgICB0X29yZGVyID0gdF9vcmRlci5jb25jYXQoZXh0cmFfdG9fcHVzaCk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgcmVuZGVyZXIudHJhY2tPcmRlciA9IHRfb3JkZXI7XG4gICAgfSk7XG59O1xuXG52YXIgRHJhZ0FuZERyb3AgPSBmdW5jdGlvbihzcGxpY2VGdW5jdGlvbikgeyAgICBcbiAgICB2YXIgdGFyZ2V0cyA9IFtdO1xuICAgIHZhciBpbl9kcmFnID0gZmFsc2UsIGRyYWdfZWw7XG4gICAgXG4gICAgdmFyIHNwbGljZV9iZWZvcmUsIHNwbGljZV9hZnRlciwgdHJhY2tUb1NwbGljZTtcbiAgICBcbiAgICB2YXIgbGFzdF90YXJnZXQ7XG5cbiAgICB2YXIgdGltZW91dHMgPSB7fTtcbiAgICBcbiAgICB2YXIgbmF2X3Jlc2V0X3NldCA9IG51bGw7XG5cbiAgICBsZXQgc3BsaWNlQmVmb3JlO1xuICAgIGxldCBzcGxpY2VBZnRlcjtcblxuXG4gICAgdmFyIGRyYWdfZnVuYyA9IGZ1bmN0aW9uKGhhbmRsZSxlbGVtZW50LHRyYWNrLGNhbnZhcykge1xuICAgICAgICB2YXIgbmF2ID0gdGhpcztcblxuXG4gICAgICAgIHZhciBvbGRfcmVzZXQgPSBuYXYucmVzZXQ7XG4gICAgICAgIGlmIChuYXZfcmVzZXRfc2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICBuYXYucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRzID0gW107XG4gICAgICAgICAgICAgICAgb2xkX3Jlc2V0LmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbmF2X3Jlc2V0X3NldCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc2V0RHJhZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0cy5hbmltKTtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dHMuaG92ZXIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldHNbaV0gIT0gZHJhZ19lbCkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRzW2ldLnJlbW92ZUF0dHJpYnV0ZSgnZHJhZ2dpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0c1tpXS5yZW1vdmVBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRzW2ldLnNldEF0dHJpYnV0ZSgncG9pbnRlci1ldmVudHMnLCdhbGwnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgXG4gICAgICAgIHRhcmdldHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgZWxlbWVudC50cmFjayA9IHRyYWNrO1xuXG4gICAgICAgIHZhciBzaW5nbGVfdG91Y2hfZXZlbnQgPSBmdW5jdGlvbihmbikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmbi5jYWxsKHRoaXMsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYmVnaW5EcmFnZ2luZyA9IGZ1bmN0aW9uKGV2LHRyLGxibF9ncnApIHtcbiAgICAgICAgXG4gICAgICAgICAgICBpZiAoZHJhZ19kaXNhYmxlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gY2FudmFzLm5lYXJlc3RWaWV3cG9ydEVsZW1lbnQ7XG5cbiAgICAgICAgICAgIGlmIChpbl9kcmFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxibF9ncnAuc2V0QXR0cmlidXRlKCdkcmFnZ2luZycsJ3RydWUnKTtcblxuICAgICAgICAgICAgc3BsaWNlQmVmb3JlID0gbnVsbDtcbiAgICAgICAgICAgIHNwbGljZUFmdGVyID0gbnVsbDtcblxuICAgICAgICAgICAgdmFyIHBfb3JpZyA9IGxibF9ncnAubmVhcmVzdFZpZXdwb3J0RWxlbWVudC5jcmVhdGVTVkdQb2ludCgpO1xuXG4gICAgICAgICAgICBwX29yaWcueCA9IGV2LmNsaWVudFggfHwgKHdpbmRvdy5wYWdlWE9mZnNldCArIGV2LnRvdWNoZXNbMF0uY2xpZW50WCk7XG4gICAgICAgICAgICBwX29yaWcueSA9IGV2LmNsaWVudFkgfHwgKHdpbmRvdy5wYWdlWU9mZnNldCArIGV2LnRvdWNoZXNbMF0uY2xpZW50WSk7XG5cbiAgICAgICAgICAgIHZhciByb290Q1RNID0gbGJsX2dycC5uZWFyZXN0Vmlld3BvcnRFbGVtZW50LmdldFNjcmVlbkNUTSgpO1xuICAgICAgICAgICAgdmFyIG1hdHJpeCA9IHJvb3RDVE0uaW52ZXJzZSgpO1xuXG4gICAgICAgICAgICBwX29yaWcgPSBwX29yaWcubWF0cml4VHJhbnNmb3JtKG1hdHJpeCk7XG5cbiAgICAgICAgICAgIHZhciBvWCA9IHBfb3JpZy54O1xuICAgICAgICAgICAgdmFyIG9ZID0gcF9vcmlnLnk7XG5cbiAgICAgICAgICAgIHZhciBkcmFnZm4gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBsYmxfZ3JwLm5lYXJlc3RWaWV3cG9ydEVsZW1lbnQuY3JlYXRlU1ZHUG9pbnQoKTtcbiAgICAgICAgICAgICAgICBwLnggPSBlLmNsaWVudFggfHwgKHdpbmRvdy5wYWdlWE9mZnNldCArIGUudG91Y2hlc1swXS5jbGllbnRYKTtcbiAgICAgICAgICAgICAgICBwLnkgPSBlLmNsaWVudFkgfHwgKHdpbmRvdy5wYWdlWU9mZnNldCArIGUudG91Y2hlc1swXS5jbGllbnRZKTtcbiAgICAgICAgICAgICAgICBwID0gcC5tYXRyaXhUcmFuc2Zvcm0obWF0cml4KTtcblxuICAgICAgICAgICAgICAgIHZhciBkWCA9IChwLnggLSBvWCk7XG4gICAgICAgICAgICAgICAgdmFyIGRZID0gKHAueSAtIG9ZKTtcbiAgICAgICAgICAgICAgICB2YXIgY3Vycl90cmFuc2Zvcm0gPSBsYmxfZ3JwLmdldEF0dHJpYnV0ZSgndHJhbnNmb3JtJykgfHwgJyc7XG4gICAgICAgICAgICAgICAgY3Vycl90cmFuc2Zvcm0gPSBjdXJyX3RyYW5zZm9ybS5yZXBsYWNlKC9cXHM/dHJhbnNsYXRlXFwoW15cXCldK1xcKS8sJycpO1xuICAgICAgICAgICAgICAgIGN1cnJfdHJhbnNmb3JtICs9ICcgdHJhbnNsYXRlKCcrZFgrJywnK2RZKycpICc7XG4gICAgICAgICAgICAgICAgY3Vycl90cmFuc2Zvcm0gPSBjdXJyX3RyYW5zZm9ybS5yZXBsYWNlKC9cXHMqJC8sJycpO1xuICAgICAgICAgICAgICAgIGxibF9ncnAuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLGN1cnJfdHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICB0YXJnZXRzLmZvckVhY2goZnVuY3Rpb24odGFyZyl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYiA9IHRhcmcuZ2V0QkJveCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmIueSA8IHAueSAmJiBiYi55ID4gKHAueSAtIGJiLmhlaWdodCkgJiYgYmIueCA8IHAueCAmJiBiYi54ID4gKHAueCAtIGJiLndpZHRoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxfbW92ZS5jYWxsKHRhcmcsZSx0YXJnLnRyYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodG91Y2hfZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGRyYWdmbiA9IHNpbmdsZV90b3VjaF9ldmVudChkcmFnZm4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZW5kZHJhZyA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS5yZWxhdGVkVGFyZ2V0ICYmIChlLnJlbGF0ZWRUYXJnZXQgPT0gbGJsX2dycCB8fCBlLnJlbGF0ZWRUYXJnZXQubmVhcmVzdFZpZXdwb3J0RWxlbWVudCA9PSBsYmxfZ3JwLm5lYXJlc3RWaWV3cG9ydEVsZW1lbnQgfHwgZS5yZWxhdGVkVGFyZ2V0Lm5lYXJlc3RWaWV3cG9ydEVsZW1lbnQgPT0gdGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5fZHJhZyAmJiB0YXJnZXRzLmluZGV4T2YoZS5yZWxhdGVkVGFyZ2V0KSA+PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNldERyYWcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGluX2RyYWcgJiYgKGUudHlwZSA9PSAnbW91c2V1cCcgfHwgZS50eXBlID09ICd0b3VjaGVuZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGxpY2VCZWZvcmUgfHwgc3BsaWNlQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwbGljZUZ1bmN0aW9uKHRyYWNrVG9TcGxpY2UsIHNwbGljZUJlZm9yZSwgc3BsaWNlQWZ0ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLGRyYWdmbixmYWxzZSk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsZHJhZ2ZuLGZhbHNlKTtcbiAgICAgICAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLGVuZGRyYWcsZmFsc2UpO1xuICAgICAgICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJyxlbmRkcmFnLGZhbHNlKTtcbiAgICAgICAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLGVuZGRyYWcsZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmIChpbl9kcmFnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxibF9ncnAuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3BvaW50ZXItZXZlbnRzJywgJ2FsbCcpO1xuICAgICAgICAgICAgICAgICAgICBsYmxfZ3JwLnJlbW92ZUF0dHJpYnV0ZSgndHJhbnNmb3JtJyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc2V0RHJhZygpO1xuICAgICAgICAgICAgICAgICAgICBpbl9kcmFnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RfdGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGJsX2dycC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAncG9pbnRlci1ldmVudHMnLCAnbm9uZScpO1xuICAgICAgICAgICAgbGJsX2dycC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLGRyYWdmbixmYWxzZSk7XG4gICAgICAgICAgICBsYmxfZ3JwLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJyxlbmRkcmFnLGZhbHNlKTtcbiAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLGRyYWdmbixmYWxzZSk7XG4gICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsZW5kZHJhZyxmYWxzZSk7XG4gICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLGVuZGRyYWcsZmFsc2UpO1xuICAgICAgICBcbiAgICAgICAgICAgIGluX2RyYWcgPSB0cmFjaztcbiAgICAgICAgICAgIGRyYWdfZWwgPSBsYmxfZ3JwO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBoYW5kbGVfc3RhcnQgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBiZWdpbkRyYWdnaW5nKGUsdHJhY2ssZWxlbWVudCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGVsX21vdmUgPSBmdW5jdGlvbihlLHRyaykge1xuICAgICAgICAgICAgdmFyIHRyY2sgPSB0cmsgPyB0cmsgOiB0cmFjaztcbiAgICAgICAgICAgIHZhciBlbGVtID0gdGhpcyA/IHRoaXMgOiBlbGVtZW50O1xuICAgICAgICBcbiAgICAgICAgICAgIGlmICggaW5fZHJhZyAmJiBpbl9kcmFnICE9IHRyY2sgJiYgdHJjayAhPSBsYXN0X3RhcmdldCkge1xuICAgICAgICAgICAgICAgIGxhc3RfdGFyZ2V0ID0gdHJjaztcbiAgICAgICAgICAgICAgICBpZiAodGltZW91dHMuaG92ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0cy5ob3Zlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRpbWVvdXRzLmhvdmVyID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggKGluX2RyYWcuZ3JvdXAgfHwgdHJjay5ncm91cCkgJiYgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgIChpbl9kcmFnLmdyb3VwID8gdHJjay5ncm91cCA6ICAhIHRyY2suZ3JvdXAgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbl9kcmFnLmdyb3VwLm5hbWUgIT0gdHJjay5ncm91cC5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpbl9kcmFnLmdyb3VwIHx8IHRyY2suZ3JvdXAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVvdXRzLmFuaW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRpbWVvdXRzLmFuaW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dHMuYW5pbSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgcmVzZXREcmFnKCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50X3NpYmxpbmcgPSBlbGVtO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudHNfdG9fc2hpZnQgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY3VycmVudF9zaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudF9zaWJsaW5nICE9IGRyYWdfZWwgJiYgdGFyZ2V0cy5pbmRleE9mKGN1cnJlbnRfc2libGluZykgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzX3RvX3NoaWZ0LnB1c2goY3VycmVudF9zaWJsaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfc2libGluZyA9IGN1cnJlbnRfc2libGluZy5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50X3NpYmxpbmcgPT0gZHJhZ19lbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfc2libGluZyA9IGVsZW0ucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudHNfdG9fc2hpZnRfdXAgPSBbXTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnRfc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRfc2libGluZyAhPSBkcmFnX2VsICYmIHRhcmdldHMuaW5kZXhPZihjdXJyZW50X3NpYmxpbmcpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50c190b19zaGlmdF91cC5wdXNoKGN1cnJlbnRfc2libGluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50X3NpYmxpbmcgPSBjdXJyZW50X3NpYmxpbmcucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRfc2libGluZyA9PSBkcmFnX2VsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1fc3RlcHMgPSAxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gZHJhZ19lbC5nZXRCQm94KCkuaGVpZ2h0IC8gNDtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dHMuYW5pbSA9IHdpbmRvdy5zZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyX3RyYW5zZm9ybSwgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFuaW1fc3RlcHMgPCA1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGVsZW1lbnRzX3RvX3NoaWZ0Lmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyX3RyYW5zZm9ybSA9IGVsZW1lbnRzX3RvX3NoaWZ0W2ldLmdldEF0dHJpYnV0ZSgndHJhbnNmb3JtJykgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJfdHJhbnNmb3JtID0gY3Vycl90cmFuc2Zvcm0ucmVwbGFjZSgvXFxzP3RyYW5zbGF0ZVxcKFteXFwpXStcXCkvLCcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vycl90cmFuc2Zvcm0gKz0gJyB0cmFuc2xhdGUoMCwnK2FuaW1fc3RlcHMqaGVpZ2h0KycpJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNfdG9fc2hpZnRbaV0uc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLGN1cnJfdHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyAoZWxlbWVudHNfdG9fc2hpZnQubGVuZ3RoID4gMCkgJiYgaSA8IGVsZW1lbnRzX3RvX3NoaWZ0X3VwLmxlbmd0aDsgaSsrICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJfdHJhbnNmb3JtID0gZWxlbWVudHNfdG9fc2hpZnRfdXBbaV0uZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKSB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vycl90cmFuc2Zvcm0gPSBjdXJyX3RyYW5zZm9ybS5yZXBsYWNlKC9cXHM/dHJhbnNsYXRlXFwoW15cXCldK1xcKS8sJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyX3RyYW5zZm9ybSArPSAnIHRyYW5zbGF0ZSgwLCcrYW5pbV9zdGVwcyotMSpoZWlnaHQrJyknO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50c190b19zaGlmdF91cFtpXS5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsY3Vycl90cmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbV9zdGVwcyArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGxpY2VCZWZvcmUgPSB0cmNrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrVG9TcGxpY2UgPSBpbl9kcmFnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRpbWVvdXRzLmFuaW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXRzLmFuaW0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LDMwKTtcblxuICAgICAgICAgICAgICAgIH0sMzAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICBcbiAgICAgICAgaGFuZGxlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGhhbmRsZV9zdGFydCxmYWxzZSk7XG4gICAgICAgIGhhbmRsZS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JyxzaW5nbGVfdG91Y2hfZXZlbnQoaGFuZGxlX3N0YXJ0KSxmYWxzZSk7XG4gICAgfTtcblxuICAgIHZhciBkcmFnX2Rpc2FibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBkcmFnX2Z1bmMuZGlzYWJsZWQ7XG4gICAgfTtcblxuICAgIGRyYWdfZnVuYy5zcGxpY2VGdW5jdGlvbiA9IHNwbGljZUZ1bmN0aW9uO1xuICAgIFxuICAgIHJldHVybiBkcmFnX2Z1bmM7XG59O1xuXG52YXIgc2V0RWxlbWVudFRyYW5zZm9ybSA9IGZ1bmN0aW9uKGVsLHRyYW5zZm9ybSkge1xuICAgIHZhciB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuICAgIGlmICh1YS5pbmRleE9mKCdFZGdlLycpID49IDApIHtcbiAgICAgICAgdHJhbnNmb3JtID0gdHJhbnNmb3JtLnJlcGxhY2UoL3B4L2csJycpO1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsdHJhbnNmb3JtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBlbC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgfVxufTtcblxudmFyIGJ1aWxkTmF2UGFuZSA9IGZ1bmN0aW9uKGJhY2tfY2FudmFzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYuem9vbSA9IDE7XG4gICAgc2VsZi5uYXZfd2lkdGhfYmFzZSA9IDIwMDtcbiAgICB2YXIgbmF2X3dpZHRoID0gc2VsZi5uYXZfd2lkdGhfYmFzZTtcbiAgICBzZWxmLm5hdl93aWR0aCA9IHNlbGYubmF2X3dpZHRoX2Jhc2U7XG4gICAgdmFyIHBhbmVsX2JhY2sgPSBiYWNrX2NhbnZhcy5ncm91cCgpO1xuICAgIHZhciBidXR0b25fZ3JvdXAgPSBiYWNrX2NhbnZhcy5ncm91cCgpO1xuICAgIFxuICAgIHZhciByZWN0ID0gYmFja19jYW52YXMucmVjdCgtMTAsMCxuYXZfd2lkdGgudG9TdHJpbmcoKSwnMTAwJScpO1xuICAgIHZhciBiYXNlX3JvdW5kZWRfY29ybmVyID0gWzEyKnRvdWNoX3NjYWxlLDEwKnRvdWNoX3NjYWxlXTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZSgncngnLGJhc2Vfcm91bmRlZF9jb3JuZXJbMF0udG9TdHJpbmcoKSk7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3J5JyxiYXNlX3JvdW5kZWRfY29ybmVyWzFdLnRvU3RyaW5nKCkpOyAgICBcbiAgICBpZiAoISB0b3VjaF9lbmFibGVkKSB7XG4gICAgICAgIHJlY3Quc2V0QXR0cmlidXRlKCdvcGFjaXR5JywnMC44Jyk7XG4gICAgfVxuICAgIHJlY3Quc3R5bGUuc3Ryb2tlID0gJyMwMDAwMDAnO1xuICAgIHJlY3Quc3R5bGUuc3Ryb2tlV2lkdGggPSAnMnB4JztcbiAgICByZWN0LnN0eWxlLmZpbGwgPSAnIzAwMDAwMCc7XG4gICAgcmVjdC5pZCA9ICduYXZfYmFjayc7XG5cbiAgICBwYW5lbF9iYWNrLnB1c2gocmVjdCk7XG5cbiAgICBzZWxmLmNsaXBwaW5nX2lkID0gJ25hdl9jbGlwcGluZycrKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICB2YXIgY2xpcHBpbmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnbnMsJ2NsaXBQYXRoJyk7XG4gICAgY2xpcHBpbmcuaWQgPSBzZWxmLmNsaXBwaW5nX2lkO1xuICAgIHZhciByZWN0MiA9IHJlY3QuY2xvbmVOb2RlKCk7XG4gICAgcmVjdDIucmVtb3ZlQXR0cmlidXRlKCdpZCcpO1xuICAgIHJlY3QyLnJlbW92ZUF0dHJpYnV0ZSgnb3BhY2l0eScpO1xuICAgIHJlY3QyLnNldEF0dHJpYnV0ZSgneCcsJzAnKTtcbiAgICByZWN0Mi5zZXRBdHRyaWJ1dGUoJ3dpZHRoJyxcIlwiKyhwYXJzZUludChyZWN0Mi5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykpIC0gMTApKTtcbiAgICByZWN0Mi5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgcmVjdDIuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCcxMDAwMCcpO1xuXG4gICAgYmFja19jYW52YXMuaW5zZXJ0QmVmb3JlKGNsaXBwaW5nLGJhY2tfY2FudmFzLmZpcnN0Q2hpbGQpO1xuICAgIGNsaXBwaW5nLmFwcGVuZENoaWxkKHJlY3QyKTtcblxuICAgIHZhciBjbG9zZV9ncm91cCA9IGJhY2tfY2FudmFzLmNyb3NzZWRfY2lyY2xlKG5hdl93aWR0aC0oMTAgKyB0b3VjaF9zY2FsZSoxMSksKDEyKnRvdWNoX3NjYWxlKSwoMTAqdG91Y2hfc2NhbGUpKTtcblxuICAgIGNsb3NlX2dyb3VwLnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICBpZiAodHlwZW9mIG1hdGNoTWVkaWEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICh0aGlzLndpbigpIHx8IHdpbmRvdykubWF0Y2hNZWRpYSgncHJpbnQnKS5hZGRMaXN0ZW5lcihmdW5jdGlvbihtYXRjaCkge1xuICAgICAgICAgICAgaWYgKG1hdGNoLm1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICBjbG9zZV9ncm91cC5zZXRBdHRyaWJ1dGUoJ2Rpc3BsYXknLCdub25lJyk7XG4gICAgICAgICAgICAgICAgdHJhY2tzX2J1dHRvbi5zZXRBdHRyaWJ1dGUoJ2Rpc3BsYXknLCdub25lJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsb3NlX2dyb3VwLnNldEF0dHJpYnV0ZSgnZGlzcGxheScsJ2Jsb2NrJyk7IFxuICAgICAgICAgICAgICAgIHRyYWNrc19idXR0b24uc2V0QXR0cmlidXRlKCdkaXNwbGF5Jywnbm9uZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBidXR0b25fZ3JvdXAucHVzaChjbG9zZV9ncm91cCk7XG5cbiAgICB2YXIgdHJhY2tzX2J1dHRvbiA9IE1BU0NQLklFID8gYmFja19jYW52YXMuc3ZnYnV0dG9uKDEwLDUsNjUsMjUsJ0VkaXQnKSA6IGJhY2tfY2FudmFzLmJ1dHRvbigxMCw1LDY1LDI1LCdFZGl0Jyk7XG4gICAgdHJhY2tzX2J1dHRvbi5pZCA9ICdjb250cm9scyc7XG4gICAgdHJhY2tzX2J1dHRvbi5wYXJlbnROb2RlLnNldEF0dHJpYnV0ZSgnY2xpcC1wYXRoJywndXJsKCMnK3NlbGYuY2xpcHBpbmdfaWQrJyknKTtcblxuICAgIHBhbmVsX2JhY2sucHVzaChNQVNDUC5JRSA/IHRyYWNrc19idXR0b24gOiB0cmFja3NfYnV0dG9uLnBhcmVudE5vZGUpO1xuXG4gICAgdHJhY2tzX2J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsZnVuY3Rpb24oKSB7XG4gICAgICAgIGJlYW4uZmlyZShzZWxmLCd0b2dnbGVFZGl0Jyk7XG4gICAgICAgIGJlYW4uZmlyZShzZWxmLCdjbGljaycpO1xuICAgIH0sZmFsc2UpO1xuXG5cbiAgICBwYW5lbF9iYWNrLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCd0cmFuc2l0aW9uOiBhbGwgMC4yNXM7Jyk7XG5cbiAgICB2YXIgb2xkX3RyYWNrc19zdHlsZSA9IHRyYWNrc19idXR0b24uZ2V0QXR0cmlidXRlKCdzdHlsZScpO1xuICAgIHZhciB0cmFuc2Zvcm1fb3JpZ2luID0gXCJcIisobmF2X3dpZHRoLSgxMCArIHRvdWNoX3NjYWxlKjExKSkrXCJweCBcIisoMTIqdG91Y2hfc2NhbGUpK1wicHhcIjtcbiAgICB2YXIgdHJhbnNsYXRlID0gZnVuY3Rpb24oYW1vdW50LHJvdGF0ZSkge1xuICAgICAgICB2YXIgdHJhbnMgPSBcIiB0cmFuc2xhdGUzZChcIithbW91bnQrXCJweCwwcHgsMHB4KVwiO1xuICAgICAgICBpZiAocm90YXRlKSB7XG4gICAgICAgICAgICB0cmFucyA9IHRyYW5zICsgXCIgcm90YXRlKFwiK3JvdGF0ZStcIilcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCItd2Via2l0LXRyYW5zZm9ybTpcIit0cmFucytcIjsgLW1vei10cmFuc2Zvcm06XCIrdHJhbnMrXCI7IC1tcy10cmFuc2Zvcm06XCIrdHJhbnMucmVwbGFjZSgnM2QnLCcnKS5yZXBsYWNlKCcsMHB4KScsJyknKStcIjsgdHJhbnNmb3JtOiBcIit0cmFucytcIjtcIjtcbiAgICB9O1xuXG5cbiAgICB0cmFja3NfYnV0dG9uLnNldEF0dHJpYnV0ZSgnc3R5bGUnLG9sZF90cmFja3Nfc3R5bGUrXCIgdHJhbnNpdGlvbjogYWxsIDAuMjVzO1wiKTtcbiAgICBjbG9zZV9ncm91cC5zdHlsZS50cmFuc2l0aW9uID0gJ2FsbCAwLjI1cyc7XG4gICAgY2xvc2VfZ3JvdXAuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gdHJhbnNmb3JtX29yaWdpbjtcbiAgICB2YXIgdmlzaWJsZSA9IHRydWU7XG5cbiAgICBcbiAgICB2YXIgdG9nZ2xlciA9IGZ1bmN0aW9uKHZpcyxpbnRlcmFjdGl2ZSkge1xuICAgICAgICB2aXNpYmxlID0gKCB2aXMgPT09IGZhbHNlIHx8IHZpcyA9PT0gdHJ1ZSApID8gdmlzIDogISB2aXNpYmxlO1xuICAgICAgICB2YXIgY2xvc2VfdHJhbnNmb3JtO1xuICAgICAgICB2YXIgbmVlZHNfdHJhbnNpdGlvbiA9IGludGVyYWN0aXZlID8gXCJhbGwgZWFzZS1pbi1vdXQgMC40c1wiIDogXCJcIjtcbiAgICAgICAgbGV0IHBhcmVudF90cmFuc2Zvcm0gPSBiYWNrX2NhbnZhcy5wYXJlbnROb2RlLnN0eWxlLnRyYW5zZm9ybTtcbiAgICAgICAgbGV0IHNjYWxldmFsO1xuICAgICAgICBsZXQgeXNjYWxlID0gdG91Y2hfc2NhbGU7XG4gICAgICAgIGlmIChzY2FsZXZhbCA9IHBhcmVudF90cmFuc2Zvcm0ubWF0Y2goL3NjYWxlXFwoKFtcXGRcXC5dKylcXCkvKSkge1xuICAgICAgICAgICAgeXNjYWxlID0gMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdHJhbnNmb3JtX29yaWdpbiA9IFwiXCIrKHNlbGYubmF2X3dpZHRoX2Jhc2UtKDEwICsgdG91Y2hfc2NhbGUqMTEpKStcInB4IFwiKygxMip5c2NhbGUpK1wicHhcIjtcblxuICAgICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICAgICAgc2VsZi5wcm9tb3RlKCk7XG4gICAgICAgICAgICBzZXRFbGVtZW50VHJhbnNmb3JtKHBhbmVsX2JhY2ssJ3RyYW5zbGF0ZSgwLDApJyk7XG4gICAgICAgICAgICBwYW5lbF9iYWNrLnN0eWxlLnRyYW5zaXRpb24gPSBuZWVkc190cmFuc2l0aW9uO1xuXG4gICAgICAgICAgICBjbG9zZV9ncm91cC5fYnV0dG9uLnJlbW92ZUF0dHJpYnV0ZSgnZmlsdGVyJyk7XG4gICAgICAgICAgICBpZiAoXCJvbnRvdWNoZW5kXCIgaW4gd2luZG93IHx8IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGNsb3NlX2dyb3VwKS5nZXRQcm9wZXJ0eVZhbHVlKFwiLW1zLXRyYW5zZm9ybVwiKSkge1xuICAgICAgICAgICAgICAgIHNldEVsZW1lbnRUcmFuc2Zvcm0oY2xvc2VfZ3JvdXAsJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0RWxlbWVudFRyYW5zZm9ybShjbG9zZV9ncm91cCwgJ3RyYW5zbGF0ZSgwLDApJyk7XG4gICAgICAgICAgICBjbG9zZV9ncm91cC5zdHlsZS50cmFuc2l0aW9uID0gbmVlZHNfdHJhbnNpdGlvbjtcbiAgICAgICAgICAgIGNsb3NlX2dyb3VwLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IGNsb3NlX2dyb3VwLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQrJ3B4ICcgK2Nsb3NlX2dyb3VwLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCsnIHB4JztcbiAgICAgICAgICAgIHNlbGYucmVmcmVzaCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5kZW1vdGUoKTtcbiAgICAgICAgICAgIC8vIENocm9tZSBidWcgSmFuIDIwMTUgd2l0aCB0aGUgZHJvcCBzaGFkb3dcbiAgICAgICAgICAgIC8vY2xvc2VfZ3JvdXAuX2J1dHRvbi5zZXRBdHRyaWJ1dGUoJ2ZpbHRlcicsJ3VybCgjZHJvcF9zaGFkb3cpJyk7XG4gICAgICAgICAgICBjbG9zZV9ncm91cC5zdHlsZS50cmFuc2l0aW9uID0gbmVlZHNfdHJhbnNpdGlvbjtcbiAgICAgICAgICAgIGNsb3NlX2dyb3VwLnN0eWxlLnRyYW5zaXRpb24gPSBuZWVkc190cmFuc2l0aW9uO1xuICAgICAgICAgICAgLy8gY2xvc2VfZ3JvdXAuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gdHJhbnNmb3JtX29yaWdpbjtcbiAgICAgICAgICAgIGNsb3NlX2dyb3VwLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IGNsb3NlX2dyb3VwLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQrJ3B4ICcgK2Nsb3NlX2dyb3VwLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCsnIHB4JztcblxuICAgICAgICAgICAgc2V0RWxlbWVudFRyYW5zZm9ybShjbG9zZV9ncm91cCwgJ3RyYW5zbGF0ZSgnKy0wLjc1KnNlbGYubmF2X3dpZHRoX2Jhc2UrJ3B4LDApIHJvdGF0ZSg0MDVkZWcpJyk7XG4gICAgICAgICAgICBpZiAoXCJvbnRvdWNoZW5kXCIgaW4gd2luZG93KSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gbG9uZ2VyIHNwZWNpYWwgY2FzaW5nIElFXG4gICAgICAgICAgICAgICAgc2V0RWxlbWVudFRyYW5zZm9ybShjbG9zZV9ncm91cCwndHJhbnNsYXRlKCcrLTAuNzUqc2VsZi5uYXZfd2lkdGhfYmFzZSsncHgsMCkgcm90YXRlKDQ1LCcrKHNlbGYubmF2X3dpZHRoX2Jhc2UtKDEwICsgdG91Y2hfc2NhbGUqMTEpKSsncHgsJysoMTIqdG91Y2hfc2NhbGUpKydweCknKTtcbiAgICAgICAgICAgICAgICBzZXRFbGVtZW50VHJhbnNmb3JtKHBhbmVsX2JhY2ssICd0cmFuc2xhdGUoJysoLTEqc2VsZi5uYXZfd2lkdGgqc2VsZi56b29tKSsncHgsMCknKTtcbiAgICAgICAgICAgICAgICBwYW5lbF9iYWNrLnN0eWxlLnRyYW5zaXRpb24gPSBuZWVkc190cmFuc2l0aW9uO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRFbGVtZW50VHJhbnNmb3JtKHBhbmVsX2JhY2ssJ3RyYW5zbGF0ZSgnKygtMSpzZWxmLm5hdl93aWR0aCpzZWxmLnpvb20pKydweCwwKScpO1xuICAgICAgICAgICAgICAgIHBhbmVsX2JhY2suc3R5bGUudHJhbnNpdGlvbiA9IG5lZWRzX3RyYW5zaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIHNlbGYubW92ZV9jbG9zZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXRFbGVtZW50VHJhbnNmb3JtKGNsb3NlX2dyb3VwLCd0cmFuc2xhdGUoJystMC43NSpzZWxmLm5hdl93aWR0aF9iYXNlKydweCwwKSByb3RhdGUoNDA1ZGVnKScpO1xuICAgICAgICBpZiAoXCJvbnRvdWNoZW5kXCIgaW4gd2luZG93KSB7XG4gICAgICAgICAgICAvLyBObyBsb25nZXIgc3BlY2lhbCBjYXNpbmcgSUVcbiAgICAgICAgICAgIHNldEVsZW1lbnRUcmFuc2Zvcm0oY2xvc2VfZ3JvdXAsJ3RyYW5zbGF0ZSgnKy0wLjc1KnNlbGYubmF2X3dpZHRoX2Jhc2UrJ3B4LDApIHJvdGF0ZSg0NSwnKyhzZWxmLm5hdl93aWR0aF9iYXNlLSgxMCArIHRvdWNoX3NjYWxlKjExKSkrJ3B4LCcrKDEyKnRvdWNoX3NjYWxlKSsncHgpJyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgc2VsZi5oaWRlID0gZnVuY3Rpb24oaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgdG9nZ2xlci5jYWxsKHRoaXMsZmFsc2UsaW50ZXJhY3RpdmUpO1xuICAgIH07XG4gICAgc2VsZi5zaG93ID0gZnVuY3Rpb24oaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgdG9nZ2xlci5jYWxsKHRoaXMsdHJ1ZSxpbnRlcmFjdGl2ZSk7XG4gICAgfTtcblxuICAgIHNlbGYudmlzaWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmlzaWJsZTtcbiAgICB9O1xuXG4gICAgc2VsZi5zZXRab29tID0gZnVuY3Rpb24oem9vbSkge1xuICAgICAgICBzZWxmLm5hdl93aWR0aCA9IHNlbGYubmF2X3dpZHRoX2Jhc2UgLyB6b29tO1xuICAgICAgICBjbG9zZV9ncm91cC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsJ3NjYWxlKCcrem9vbSsnLCcrem9vbSsnKSAnKTtcbiAgICAgICAgbGV0IHBhcmVudF90cmFuc2Zvcm0gPSBiYWNrX2NhbnZhcy5wYXJlbnROb2RlLnN0eWxlLnRyYW5zZm9ybTtcbiAgICAgICAgbGV0IHNjYWxldmFsO1xuICAgICAgICBsZXQgeXNjYWxlID0gdG91Y2hfc2NhbGU7XG4gICAgICAgIGlmIChzY2FsZXZhbCA9IHBhcmVudF90cmFuc2Zvcm0ubWF0Y2goL3NjYWxlXFwoKFtcXGRcXC5dKylcXCkvKSkge1xuICAgICAgICAgICAgeXNjYWxlID0gMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdHJhbnNmb3JtX29yaWdpbiA9IFwiXCIrKHNlbGYubmF2X3dpZHRoX2Jhc2UtKDEwICsgdG91Y2hfc2NhbGUqMTEpKS50b0ZpeGVkKDIpK1wicHggXCIrKDEyKnlzY2FsZSkrXCJweFwiO1xuXG4gICAgICAgIGNsb3NlX2dyb3VwLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IHRyYW5zZm9ybV9vcmlnaW47XG5cbiAgICAgICAgY2xvc2VfZ3JvdXAubW92ZShzZWxmLm5hdl93aWR0aF9iYXNlLSgxMCArIHRvdWNoX3NjYWxlKjExKSwxMip0b3VjaF9zY2FsZSk7XG4gICAgICAgIHJlY3Quc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCdzY2FsZSgnK3pvb20rJywxKSAnKTtcbiAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3J5JywgKGJhc2Vfcm91bmRlZF9jb3JuZXJbMV0pLnRvU3RyaW5nKCkpO1xuICAgICAgICByZWN0LnNldEF0dHJpYnV0ZSgncngnLCAoYmFzZV9yb3VuZGVkX2Nvcm5lclswXS96b29tKS50b1N0cmluZygpKTtcbiAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3gnLCBwYXJzZUludCgtMTAgLyB6b29tKS50b1N0cmluZygpKTtcbiAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgKHNlbGYubmF2X3dpZHRoKS50b1N0cmluZygpKTtcbiAgICAgICAgc2VsZi56b29tID0gem9vbTtcbiAgICAgICAgdG9nZ2xlci5jYWxsKHRoaXMsdmlzaWJsZSk7XG4gICAgICAgIHNlbGYucmVmcmVzaCgpO1xuICAgIH07XG5cbiAgICBjbG9zZV9ncm91cC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICAgICAgICBzZWxmLmhpZGUodHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLnNob3codHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9LGZhbHNlKTtcbn07XG5cbnZhciBidWlsZFRyYWNrUGFuZSA9IGZ1bmN0aW9uKHRyYWNrX2NhbnZhcyxkcmFnYW5kZHJvcCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBjbG9zZV9idXR0b25zLCBjb250cm9sbGVyX2J1dHRvbnMsIGVkaXRfZW5hYmxlZDtcblxuICAgIHZhciBuYXZfd2lkdGhfdHJhY2tfY2FudmFzX2N0bSA9IDA7XG5cbiAgICBTVkdDYW52YXModHJhY2tfY2FudmFzKTtcbiAgICB0cmFja19jYW52YXMuc2V0QXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJywneE1pbllNaW4gbWVldCcpO1xuXG5cblxuICAgIHZhciB0cmFja19yZWN0cyA9IFtdO1xuXG4gICAgc2VsZi5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB3aGlsZSAodHJhY2tfY2FudmFzLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIHRyYWNrX2NhbnZhcy5yZW1vdmVDaGlsZCh0cmFja19jYW52YXMuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2tfcmVjdHMgPSBbXTtcbiAgICAgICAgY3RtX3JlZnJlc2ggPSBbXTtcbi8vICAgICAgICAgICAgc2VsZi5yZWZyZXNoKCk7XG4gICAgfTtcblxuICAgIHZhciBjdG1fcmVmcmVzaCA9IFtdO1xuXG4gICAgc2VsZi5pc0VkaXRpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGVkaXRfZW5hYmxlZDtcbiAgICB9O1xuXG4gICAgc2VsZi5yZWZyZXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIChjbG9zZV9idXR0b25zIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uKGJ1dHRvbikge1xuICAgICAgICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZSgndmlzaWJpbGl0eScsIGVkaXRfZW5hYmxlZCA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nKTtcbiAgICAgICAgfSk7XG4gICAgICAgIChjb250cm9sbGVyX2J1dHRvbnMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24oYnV0dG9uKSB7XG4gICAgICAgICAgICBidXR0b24uc2V0QXR0cmlidXRlKCd2aXNpYmlsaXR5JywgZWRpdF9lbmFibGVkID8gJ2hpZGRlbicgOiAndmlzaWJsZScpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGVkaXRfZW5hYmxlZCkge1xuICAgICAgICAgICAgdG9nZ2xlTW91c2VFdmVudHMuY2FsbCh0aGlzLHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9nZ2xlTW91c2VFdmVudHMuY2FsbCh0aGlzLGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFja19jYW52YXMuZ2V0QXR0cmlidXRlKCdkaXNwbGF5JykgPT0gJ25vbmUnIHx8IHRyYWNrX2NhbnZhcy5zdHlsZS5kaXNwbGF5ID09ICdub25lJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdG1fcmVmcmVzaC5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hdl9iYWNrID0gdHJhY2tfY2FudmFzLm93bmVyU1ZHRWxlbWVudC5nZXRFbGVtZW50QnlJZCgnbmF2X2JhY2snKTtcblxuICAgICAgICB2YXIgY3RtID0gbmF2X2JhY2suZ2V0U2NyZWVuQ1RNKCkuaW52ZXJzZSgpLm11bHRpcGx5KHRyYWNrX2NhbnZhcy5nZXRTY3JlZW5DVE0oKSkuaW52ZXJzZSgpO1xuICAgICAgICB2YXIgYmFja193aWR0aCA9IChuYXZfYmFjay5nZXRCQm94KCkud2lkdGggKyBuYXZfYmFjay5nZXRCQm94KCkueCk7XG4gICAgICAgIHZhciBwb2ludCA9IHRyYWNrX2NhbnZhcy5jcmVhdGVTVkdQb2ludCgpO1xuICAgICAgICBwb2ludC54ID0gYmFja193aWR0aDtcbiAgICAgICAgcG9pbnQueSA9IDA7XG4gICAgICAgIG5hdl93aWR0aF90cmFja19jYW52YXNfY3RtID0gcG9pbnQubWF0cml4VHJhbnNmb3JtKGN0bSkueDtcbiAgICAgICAgY3RtX3JlZnJlc2guZm9yRWFjaChmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgd2lkdGggPSBlbC5nZXRCQm94KCkud2lkdGg7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgYnVnIHdpdGggRmlyZWZveCBvbiBzb21lIGVsZW1lbnRzIGdldHRpbmdcbiAgICAgICAgICAgICAgICAvLyB0aGUgYm91bmRpbmcgYm94LiBXZSBzaWxlbnRseSBmYWlsIGhlcmUsIGFzIEkgY2FuJ3RcbiAgICAgICAgICAgICAgICAvLyBmaWd1cmUgb3V0IHdoeSB0aGUgY2FsbCB0byBnZXRCQm94IGZhaWxzLlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCB3aWR0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgYV95ID0gL3RyYW5zbGF0ZVxcKCgtP1xcZCtcXC4/XFxkKilcXHMqLD9cXHMqKC0/XFxkK1xcLj9cXGQqKVxcKS8uZXhlYyhlbC5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpIHx8ICcnKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFfeSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBhX3kgPSBhX3lbMl07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgbmV3X3ggPSBuYXZfd2lkdGhfdHJhY2tfY2FudmFzX2N0bS0gMS41KnBhcnNlSW50KGVsLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSwxMCk7XG4gICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCd0cmFuc2xhdGUoJytuZXdfeCsnLCcrYV95KycpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgdG9nZ2xlTW91c2VFdmVudHMgPSBmdW5jdGlvbihvbikge1xuICAgICAgICBpZiAodHJhY2tfcmVjdHMpIHtcbiAgICAgICAgICAgICh0cmFja19yZWN0cyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnb3BhY2l0eScsb24gPyAnMSc6ICh0b3VjaF9lbmFibGVkID8gXCIwLjVcIiA6IFwiMC4xXCIpICk7XG4gICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdwb2ludGVyLWV2ZW50cycsIG9uID8gJ2FsbCcgOiAnbm9uZScpO1xuICAgICAgICAgICAgICAgIG9uID8gZWwucGFyZW50Tm9kZS5zZXRBdHRyaWJ1dGUoJ2RyYWdlbmFibGVkJywndHJ1ZScpIDogZWwucGFyZW50Tm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ2RyYWdlbmFibGVkJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBiZWFuLmFkZChzZWxmLCd0b2dnbGVFZGl0JyxmdW5jdGlvbigpIHtcbiAgICAgICAgZWRpdF9lbmFibGVkID0gdHlwZW9mIGVkaXRfZW5hYmxlZCA9PSAndW5kZWZpbmVkJyA/IHRydWUgOiAhIGVkaXRfZW5hYmxlZDtcbiAgICAgICAgZHJhZ2FuZGRyb3AuZGlzYWJsZWQgPSAhIGVkaXRfZW5hYmxlZDtcbiAgICAgICAgdG9nZ2xlTW91c2VFdmVudHMuY2FsbChzZWxmLGVkaXRfZW5hYmxlZCk7XG4gICAgXG4gICAgICAgIHNlbGYuaGlkZSgpO1xuICAgICAgICBzZWxmLnNob3coKTtcbiAgICAgICAgXG4gICAgICAgIChjbG9zZV9idXR0b25zIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uKGJ1dHRvbikge1xuICAgICAgICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZSgndmlzaWJpbGl0eScsIGVkaXRfZW5hYmxlZCA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nKTtcbiAgICAgICAgfSk7XG4gICAgICAgIChjb250cm9sbGVyX2J1dHRvbnMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24oYnV0dG9uKSB7XG4gICAgICAgICAgICBidXR0b24uc2V0QXR0cmlidXRlKCd2aXNpYmlsaXR5JywgZWRpdF9lbmFibGVkID8gJ2hpZGRlbicgOiAndmlzaWJsZScpO1xuICAgICAgICB9KTtcblxuICAgIH0pO1xuICAgIFxuICAgIHRoaXMuc2V0Vmlld0JveCA9IGZ1bmN0aW9uKHZpZXdCb3gpIHtcbiAgICAgICAgdHJhY2tfY2FudmFzLnNldEF0dHJpYnV0ZSgndmlld0JveCcsdmlld0JveCk7XG4gICAgfTtcblxuICAgIHRyYWNrX2NhbnZhcy5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgdHJhY2tfY2FudmFzLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIHRyYWNrX2NhbnZhcy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsJzEwMCUnKTsgICAgICAgIFxuICAgIHRyYWNrX2NhbnZhcy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywnMTAwJScpO1xuXG5cbiAgICB0aGlzLnJlbmRlclRyYWNrID0gZnVuY3Rpb24odHJhY2sseSxoZWlnaHQsb3B0aW9ucykge1xuICAgICAgICB2YXIgbGFiZWxfZ3JvdXAgPSB0cmFja19jYW52YXMuZ3JvdXAoKTtcbiAgICAgICAgdmFyIGFfcmVjdCA9IHRyYWNrX2NhbnZhcy5yZWN0KDAseSwnMTAwJScsaGVpZ2h0KTtcbiAgICAgICAgYV9yZWN0LnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywnIzAwMDAwMCcpO1xuICAgICAgICBhX3JlY3Quc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCcyJyk7XG4gICAgICAgIGFfcmVjdC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCd1cmwoI3NpbXBsZV9ncmFkaWVudCknKTtcbiAgICAgICAgYV9yZWN0LnNldEF0dHJpYnV0ZSgnb3BhY2l0eScsdG91Y2hfZW5hYmxlZCA/ICcwLjUnIDogJzAuMScpO1xuICAgICAgICBhX3JlY3Quc2V0QXR0cmlidXRlKCdwb2ludGVyLWV2ZW50cycsJ25vbmUnKTtcbiAgICAgICAgdHJhY2tfcmVjdHMgPSB0cmFja19yZWN0cyB8fCBbXTtcbiAgICBcbiAgICAgICAgdHJhY2tfcmVjdHMucHVzaChhX3JlY3QpO1xuICAgIFxuICAgICAgICBsYWJlbF9ncm91cC5wdXNoKGFfcmVjdCk7XG5cbiAgICAgICAgLy8gVXNlIHRoZXNlIGZvciBkZWJ1Z2dpbmcgcG9zaXRpb25pbmdcbiAgICBcbiAgICAgICAgLy8gdmFyIHIgPSB0cmFja19jYW52YXMucmVjdCgwLHktaGVpZ2h0LGhlaWdodCxoZWlnaHQpO1xuICAgICAgICAvLyByLnNldEF0dHJpYnV0ZSgnZmlsbCcsJyNmZjAwMDAnKTtcbiAgICAgICAgLy8gbGFiZWxfZ3JvdXAucHVzaChyKTtcbiAgICAgICAgLy8gXG4gICAgICAgIC8vIHIgPSB0cmFja19jYW52YXMucmVjdCgwLHkraGVpZ2h0LGhlaWdodCxoZWlnaHQpO1xuICAgICAgICAvLyByLnNldEF0dHJpYnV0ZSgnZmlsbCcsJyNmZjAwMDAnKTtcbiAgICAgICAgLy8gbGFiZWxfZ3JvdXAucHVzaChyKTtcbiAgICBcbiAgICBcbiAgICAgICAgdmFyIHRleHRfc2NhbGUgPSAob3B0aW9ucyAmJiBvcHRpb25zWydmb250LXNjYWxlJ10pID8gb3B0aW9uc1snZm9udC1zY2FsZSddIDogMTtcbiAgICAgICAgdmFyIHRleHRfbGVmdCA9IDQvMyp0b3VjaF9zY2FsZSpoZWlnaHQqdGV4dF9zY2FsZTsgICAgICAgICAgICBcbiAgICAgICAgdmFyIGFfdGV4dCA9IHRyYWNrX2NhbnZhcy50ZXh0KHRleHRfbGVmdCx5KzAuNSpoZWlnaHQsdHJhY2suZnVsbG5hbWUgfHwgdHJhY2submFtZSk7XG4gICAgICAgIGFfdGV4dC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGhlaWdodCk7XG4gICAgICAgIGFfdGV4dC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgaGVpZ2h0KTtcbiAgICAgICAgYV90ZXh0LnNldEF0dHJpYnV0ZSgnZm9udC1zaXplJywwLjYqaGVpZ2h0KnRleHRfc2NhbGUpO1xuICAgICAgICBhX3RleHQuc2V0QXR0cmlidXRlKCdmaWxsJywnI2ZmZmZmZicpO1xuICAgICAgICBhX3RleHQuc2V0QXR0cmlidXRlKCdzdHJva2UnLCcjZmZmZmZmJyk7XG4gICAgICAgIGFfdGV4dC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsJzAnKTtcbiAgICAgICAgYV90ZXh0LmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCdkeScsICcwLjVleCcpO1xuXG4gICAgICAgIC8vIHIgPSB0cmFja19jYW52YXMucmVjdCgzKmhlaWdodCp0ZXh0X3NjYWxlLHkrMC41KmhlaWdodCwyKmhlaWdodCwyKmhlaWdodCk7XG4gICAgICAgIC8vIHIuc2V0QXR0cmlidXRlKCdmaWxsJywnIzAwZmYwMCcpO1xuICAgICAgICAvLyBsYWJlbF9ncm91cC5wdXNoKHIpO1xuXG4gICAgICAgIGxhYmVsX2dyb3VwLnB1c2goYV90ZXh0KTtcbiAgICBcbiAgICAgICAgYV90ZXh0LnNldEF0dHJpYnV0ZSgncG9pbnRlci1ldmVudHMnLCdub25lJyk7XG4gICAgXG4gICAgICAgIHZhciBjaXJjO1xuICAgIFxuICAgICAgICBpZiAodHJhY2suaHJlZiApIHtcbiAgICAgICAgICAgIGFfYW5jaG9yID0gdHJhY2tfY2FudmFzLmEodHJhY2suaHJlZik7XG4gICAgICAgICAgICB2YXIgaWNvbl9uYW1lID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBpY29uX21ldHJpY3MgPSBbMC41KmhlaWdodCp0ZXh0X3NjYWxlLDAsaGVpZ2h0KnRleHRfc2NhbGUqdG91Y2hfc2NhbGVdO1xuICAgICAgICAgICAgaWNvbl9tZXRyaWNzWzFdID0gLTAuNSooaWNvbl9tZXRyaWNzWzJdIC0gaGVpZ2h0KTtcblxuICAgICAgICAgICAgY2lyYyA9IHRyYWNrX2NhbnZhcy5jaXJjbGUoaWNvbl9tZXRyaWNzWzBdKzAuNSppY29uX21ldHJpY3NbMl0sMC41KmhlaWdodCwwLjUqaWNvbl9tZXRyaWNzWzJdKTtcbiAgICAgICAgICAgIGNpcmMuc2V0QXR0cmlidXRlKCdmaWxsJywnI2ZmZmZmZicpO1xuICAgICAgICAgICAgY2lyYy5zZXRBdHRyaWJ1dGUoJ29wYWNpdHknLCcwLjEnKTtcbiAgICAgICAgICAgIGFfYW5jaG9yLmFwcGVuZENoaWxkKGNpcmMpO1xuICAgICAgICBcbiAgICAgICAgICAgIHZhciB1cmxfdHlwZSA9IHRyYWNrLmhyZWY7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHVybF90eXBlID09PSAnc3RyaW5nJyAmJiB1cmxfdHlwZS5tYXRjaCgvXmphdmFzY3JpcHRcXDovKSkge1xuICAgICAgICAgICAgICAgIGljb25fbmFtZSA9ICcjcGx1c19pY29uJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHVybF90eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWNvbl9uYW1lID0gJyNwbHVzX2ljb24nO1xuICAgICAgICAgICAgICAgIGFfYW5jaG9yLnNldEF0dHJpYnV0ZSgnaHJlZicsJyMnKTtcbiAgICAgICAgICAgICAgICBhX2FuY2hvci5yZW1vdmVBdHRyaWJ1dGUoJ3RhcmdldCcpO1xuICAgICAgICAgICAgICAgIGFfYW5jaG9yLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJyxmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHVybF90eXBlLmNhbGwoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5yZXR1cm5SZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSxmYWxzZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGljb25fbmFtZSA9ICcjbmV3X2xpbmtfaWNvbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhY2suaWNvbikge1xuICAgICAgICAgICAgICAgIGljb25fbmFtZSA9IHRyYWNrLmljb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYV91c2UgPSB0cmFja19jYW52YXMudXNlKGljb25fbmFtZSxpY29uX21ldHJpY3NbMF0saWNvbl9tZXRyaWNzWzFdLGljb25fbWV0cmljc1syXSxpY29uX21ldHJpY3NbMl0pO1xuICAgICAgICAgICAgYV91c2Uuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgICAgICAgICAgYV9hbmNob3IuYXBwZW5kQ2hpbGQoYV91c2UpO1xuICAgICAgICAgICAgYV9hbmNob3Iuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCd0cmFuc2xhdGUoJysobmF2X3dpZHRoX3RyYWNrX2NhbnZhc19jdG0gLSAxLjUqaWNvbl9tZXRyaWNzWzJdKSsnLCcreSsnKScpO1xuICAgICAgICAgICAgYV9hbmNob3Iuc2V0QXR0cmlidXRlKCd3aWR0aCcsaWNvbl9tZXRyaWNzWzJdLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgY3RtX3JlZnJlc2gucHVzaChhX2FuY2hvcik7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgbGFiZWxfZ3JvdXAuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBsYWJlbF9ncm91cC5vbm1vdXNlb3ZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGxhYmVsX2dyb3VwLm9ubW91c2VvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0sZmFsc2UpO1xuXG4gICAgICAgIGxhYmVsX2dyb3VwLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJyxmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGxhYmVsX2dyb3VwLm9ubW91c2VvdmVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgbGFiZWxfZ3JvdXAub25tb3VzZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSxmYWxzZSk7XG4gICAgXG4gICAgICAgIGRyYWdhbmRkcm9wLmNhbGwodGhpcyxhX3JlY3QsbGFiZWxfZ3JvdXAsdHJhY2ssdHJhY2tfY2FudmFzKTtcbiAgICBcbiAgICAgICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICBcbiAgICAgICAgICAgIGlmICh0cmFjay5ncm91cCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgICAgICB2YXIgdF9oZWlnaHQgPSAwLjUqaGVpZ2h0KnRvdWNoX3NjYWxlOyAgICAgICAgICAgIFxuXG4gICAgICAgICAgICBpZiAoICEgY2xvc2VfYnV0dG9ucykge1xuICAgICAgICAgICAgICAgIGNsb3NlX2J1dHRvbnMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgICAgICB2YXIgY2xvc2VyID0gdHJhY2tfY2FudmFzLmNyb3NzZWRfY2lyY2xlKDEuNSp0X2hlaWdodCwwLHRfaGVpZ2h0KTtcbiAgICAgICAgICAgIGNsb3Nlci5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsJ3RyYW5zbGF0ZSgwLCcrKHkrMC41KmhlaWdodCkrJykgc2NhbGUoJyt0ZXh0X3NjYWxlKycpJyk7XG4gICAgICAgICAgICBjbG9zZXIuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCd1cmwoI3JlZF8zZCknKTtcbiAgICAgICAgICAgIGZvciAodmFyIG5vZGVzID0gY2xvc2VyLmNoaWxkTm9kZXMsIGkgPSAwLCBsZW4gPSBub2Rlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIG5vZGVzW2ldLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywodF9oZWlnaHQvNCkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbG9zZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGRyYWdhbmRkcm9wLnNwbGljZUZ1bmN0aW9uKHRyYWNrKTtcbiAgICAgICAgICAgIH0sZmFsc2UpO1xuICAgICAgICAgICAgbGFiZWxfZ3JvdXAucHVzaChjbG9zZXIpO1xuICAgICAgICAgICAgY2xvc2VfYnV0dG9ucy5wdXNoKGNsb3Nlcik7XG4gICAgICAgICAgICBjbG9zZXIuc2V0QXR0cmlidXRlKCd2aXNpYmlsaXR5JywgJ2hpZGRlbicpO1xuICAgICAgICBcbiAgICAgICAgfSkoKTtcbiAgICAgICAgaWYgKHRoaXMuaXNDb250cm9sbGVyKHRyYWNrKSkge1xuICAgICAgICAgICAgaWYgKCAhIGNvbnRyb2xsZXJfYnV0dG9ucykge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXJfYnV0dG9ucyA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdF9oZWlnaHQgPSAwLjUqaGVpZ2h0KnRvdWNoX3NjYWxlO1xuICAgICAgICAgICAgdmFyIGV4cGFuZGVyID0gdHJhY2tfY2FudmFzLmdyb3VwKCk7XG4gICAgICAgICAgICBjaXJjID0gdHJhY2tfY2FudmFzLmNpcmNsZSgxLjUqdF9oZWlnaHQsMCx0X2hlaWdodCk7XG4gICAgICAgICAgICBjaXJjLnNldEF0dHJpYnV0ZSgnZmlsbCcsJyNmZmZmZmYnKTtcbiAgICAgICAgICAgIGNpcmMuc2V0QXR0cmlidXRlKCdvcGFjaXR5JywnMC4xJyk7XG4gICAgICAgICAgICBleHBhbmRlci5wdXNoKGNpcmMpO1xuXG4gICAgICAgICAgICB2YXIgdF9tZXRyaWNzID0gWzEuMSp0X2hlaWdodCwtMS4yNSp0X2hlaWdodCwyLjI1KnRfaGVpZ2h0LCgtMC41KnRfaGVpZ2h0KSwxLjEqdF9oZWlnaHQsMC4yNSp0X2hlaWdodF07XG4gICAgICAgIFxuICAgICAgICAgICAgdF9tZXRyaWNzWzFdICs9IDAuNSoodF9oZWlnaHQgLSAwKmhlaWdodCk7XG4gICAgICAgICAgICB0X21ldHJpY3NbM10gKz0gMC41Kih0X2hlaWdodCAtIDAqaGVpZ2h0KTtcbiAgICAgICAgICAgIHRfbWV0cmljc1s1XSArPSAwLjUqKHRfaGVpZ2h0IC0gMCpoZWlnaHQpO1xuXG4gICAgICAgIFxuICAgICAgICAgICAgdmFyIGdyb3VwX3RvZ2dsZXIgPSB0cmFja19jYW52YXMucG9seSgnJyt0X21ldHJpY3NbMF0rJywnK3RfbWV0cmljc1sxXSsnICcrdF9tZXRyaWNzWzJdKycsJyt0X21ldHJpY3NbM10rJyAnK3RfbWV0cmljc1s0XSsnLCcrdF9tZXRyaWNzWzVdKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ29udHJvbGxlckV4cGFuZGVkKHRyYWNrKSkge1xuICAgICAgICAgICAgICAgIGV4cGFuZGVyLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywndHJhbnNsYXRlKDAsJysoeSswLjUqaGVpZ2h0KSsnKSBzY2FsZSgnK3RleHRfc2NhbGUrJykgcm90YXRlKDkwLCcrKDEuNSp0X2hlaWdodCkrJywnK3RfbWV0cmljc1szXSsnKScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHBhbmRlci5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsJ3RyYW5zbGF0ZSgwLCcrKHkrMC41KmhlaWdodCkrJykgc2NhbGUoJyt0ZXh0X3NjYWxlKycpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBncm91cF90b2dnbGVyLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgMS43NSp0X2hlaWdodCk7XG4gICAgICAgICAgICBncm91cF90b2dnbGVyLnNldEF0dHJpYnV0ZSgnZm9udC1zaXplJywxLjUqdF9oZWlnaHQpO1xuICAgICAgICAgICAgZ3JvdXBfdG9nZ2xlci5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCcjZmZmZmZmJyk7XG4gICAgICAgICAgICBncm91cF90b2dnbGVyLnNldEF0dHJpYnV0ZSgncG9pbnRlci1ldmVudHMnLCdub25lJyk7XG4gICAgICAgIFxuICAgICAgICAgICAgZXhwYW5kZXIucHVzaChncm91cF90b2dnbGVyKTtcblxuICAgICAgICAgICAgZXhwYW5kZXIuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgICAgICAgICAgZXhwYW5kZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGJlYW4uZmlyZSh0cmFjaywnX2V4cGFuZGV2ZW50Jyk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuaXNDb250cm9sbGVyRXhwYW5kZWQodHJhY2spKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGFuZGVyLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywndHJhbnNsYXRlKDAsJysoeSswLjUqaGVpZ2h0KSsnKSBzY2FsZSgnK3RleHRfc2NhbGUrJykgcm90YXRlKDkwLCcrKDEuNSp0X2hlaWdodCkrJywnK3RfbWV0cmljc1szXSsnKScpOyAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBleHBhbmRlci5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsJ3RyYW5zbGF0ZSgwLCcrKHkrMC41KmhlaWdodCkrJykgc2NhbGUoJyt0ZXh0X3NjYWxlKycpJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxmYWxzZSk7XG4gICAgICAgICAgICBsYWJlbF9ncm91cC5wdXNoKGV4cGFuZGVyKTtcblxuICAgICAgICAgICAgY29udHJvbGxlcl9idXR0b25zLnB1c2goZXhwYW5kZXIpO1xuICAgICAgICAgICAgZXhwYW5kZXIuc2V0QXR0cmlidXRlKCd2aXNpYmlsaXR5JywgJ2hpZGRlbicpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE5hdmlnYXRpb247XG4iXSwibWFwcGluZ3MiOiJBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQU9BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../gator/js/lib/CondensedSequenceRendererNavigation.js\n")},"../gator/js/lib/Dragger.js":
/*!**********************************!*\
  !*** ../gator/js/lib/Dragger.js ***!
  \**********************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _hammer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../hammer.js */ \"../gator/js/hammer.js\");\n/* harmony import */ var _bean__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../bean */ \"../gator/js/bean.js\");\n/**\n *  @fileOverview   Basic classes and defitions for a Gene Ontology ID based map\n */\n\n\n/**\n * @class       State class for adding panning functionality to an element. Each element that is to be panned needs a new instance\n *              of the Dragger to store state.\n * @author      hjjoshi\n * @requires    svgweb\n */\n\nconst Dragger = function Dragger() {\n  this.oX = 0;\n  this.oY = 0;\n  this.dX = 0;\n  this.dY = 0;\n  this.dragging = false;\n  this.targetElement = null;\n};\n/**\n * Connect this dragger to a particular element. If an SVG element is given, panning occurs within the bounding box of the SVG, and\n * the image is shifted by using the currentTranslate property. If a regular HTML element is given, the scrollLeft and scrollTop attributes\n * are used to move the viewport around. \n * @param {Element} targetElement Element to enable panning upon.\n */\n\n\nDragger.prototype.applyToElement = function (targetElement, enabled) {\n  var self = this;\n\n  if (typeof enabled !== 'undefined') {\n    self.enabled = enabled;\n  }\n\n  var momentum = [];\n\n  if (targetElement.nodeName == 'svg') {\n    targetElement.getPosition = function () {\n      var translate = targetElement.currentTranslateCache || targetElement.currentTranslate;\n      var dX = translate.x;\n      var dY = translate.y;\n      return [dX, dY];\n    };\n\n    targetElement.shiftPosition = function (x, y) {\n      var p = {\n        'x': x,\n        'y': y\n      };\n      var viewBoxScale = 1;\n      var vbox = this.getAttribute('viewBox');\n      var min_x, min_y, width, height;\n\n      if (vbox) {\n        var viewBox = this.getAttribute('viewBox').split(' ');\n        viewBoxScale = parseFloat(this.width.baseVal.value) / parseFloat(viewBox[2]);\n        min_x = 0;\n        min_y = parseInt(viewBox[1], 10);\n        width = parseInt(viewBox[2], 10);\n        height = parseInt(viewBox[3], 10);\n      } else {\n        min_x = 0;\n        min_y = 0;\n        width = targetElement.width;\n        height = targetElement.height;\n      }\n\n      if (targetElement.style.GomapScrollLeftMargin) {\n        min_x += targetElement.style.GomapScrollLeftMargin;\n      }\n\n      if (self.dragging) {\n        p.x = viewBoxScale * (p.x - self.oX);\n        p.y = viewBoxScale * (p.y - self.oY);\n        p.x += self.dX;\n        p.y += self.dY;\n        p.y = 0;\n      }\n\n      if (targetElement._snapback) {\n        clearTimeout(targetElement._snapback);\n        targetElement._snapback = null;\n      }\n\n      if (p.x > viewBoxScale * min_x && self.enabled) {\n        /* Element has shifted too far to the right\n           Induce some gravity towards the left side\n           of the screen\n        */\n        let do_snapback = function do_snapback() {\n          var evObj;\n          var translate = targetElement.currentTranslateCache || targetElement.currentTranslate;\n\n          if (Math.abs(translate.x - viewBoxScale * min_x) > 35) {\n            var new_pos = 0.95 * (translate.x - viewBoxScale * min_x);\n\n            if (new_pos < viewBoxScale * min_x) {\n              new_pos = viewBoxScale * min_x;\n            }\n\n            targetElement.setCurrentTranslateXY(new_pos, 0);\n            window.requestAnimationFrame(do_snapback, targetElement); //                        targetElement._snapback = setTimeout(arguments.callee,10);\n\n            if (document.createEvent) {\n              var evObj = document.createEvent('Events');\n              evObj.initEvent('panstart', false, true);\n              targetElement.dispatchEvent(evObj);\n            }\n          } else {\n            targetElement.setCurrentTranslateXY(viewBoxScale * min_x, 0);\n\n            if (document.createEvent) {\n              var evObj = document.createEvent('Events');\n              evObj.initEvent('pan', false, true);\n              targetElement.dispatchEvent(evObj);\n            }\n\n            if (!self.dragging) {\n              _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire(targetElement, 'panend');\n            }\n\n            targetElement._snapback = null;\n          }\n        };\n\n        targetElement._snapback = setTimeout(do_snapback, 300);\n      }\n\n      var min_val = viewBoxScale * (width - 2 * min_x);\n\n      if (min_x === 0) {\n        min_val *= 0.90;\n      }\n\n      if (p.x < 0 && Math.abs(p.x) > min_val && self.enabled) {\n        /* Element has shifted too far to the left\n           Induce some gravity to the right side of the screen\n        */\n        let do_snapback = function do_snapback() {\n          var evObj;\n          var translate = targetElement.currentTranslateCache || targetElement.currentTranslate;\n\n          if (Math.abs(translate.x - -1 * min_val) > 35) {\n            var new_pos = 0.95 * translate.x;\n\n            if (new_pos > -1 * min_val) {\n              new_pos = -1 * min_val;\n            }\n\n            targetElement.setCurrentTranslateXY(new_pos, 0);\n            window.requestAnimationFrame(do_snapback, targetElement); //                        targetElement._snapback = setTimeout(arguments.callee,10);\n\n            if (document.createEvent) {\n              evObj = document.createEvent('Events');\n              evObj.initEvent('panstart', false, true);\n              targetElement.dispatchEvent(evObj);\n            }\n          } else {\n            targetElement.setCurrentTranslateXY(-1 * min_val, 0);\n\n            if (document.createEvent) {\n              evObj = document.createEvent('Events');\n              evObj.initEvent('pan', false, true);\n              targetElement.dispatchEvent(evObj);\n            }\n\n            if (!self.dragging) {\n              _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire(targetElement, 'panend');\n            }\n\n            targetElement._snapback = null;\n          }\n        };\n\n        targetElement._snapback = setTimeout(do_snapback, 300);\n      }\n\n      if (p.y > viewBoxScale * min_y) {\n        p.y = viewBoxScale * min_y;\n      }\n\n      if (Math.abs(p.y) > 0.50 * viewBoxScale * height) {\n        p.y = -0.50 * viewBoxScale * height;\n      }\n\n      if (this.setCurrentTranslateXY) {\n        this.setCurrentTranslateXY(p.x, p.y);\n      } else if (this.currentTranslate.setXY) {\n        this.currentTranslate.setXY(p.x, p.y);\n      } else {\n        this.currentTranslate.x = p.x;\n        this.currentTranslate.y = p.y;\n      }\n\n      if (document.createEvent) {\n        var evObj = document.createEvent('Events');\n        evObj.initEvent('pan', false, true);\n        this.dispatchEvent(evObj);\n      }\n    };\n  } else {\n    targetElement.getPosition = function () {\n      return [this.scrollLeft, this.scrollTop];\n    };\n\n    targetElement.shiftPosition = function (x, y) {\n      this.scrollLeft = self.dX + (self.oX - x);\n      this.scrollTop = self.dY + (self.oY - y);\n\n      if (document.createEvent) {\n        var evObj = document.createEvent('Events');\n        evObj.initEvent('pan', false, true);\n        this.dispatchEvent(evObj);\n      }\n    };\n  }\n\n  var stationary;\n\n  var svgMouseDown = function svgMouseDown(evt) {\n    if (!self.enabled) {\n      return true;\n    }\n\n    var targ = self.targetElement ? self.targetElement : targetElement;\n    var positions = mousePosition(evt);\n    self.dragging = true;\n    self.moved = false;\n    targ.setAttribute('dragging', 'true');\n\n    if (self.targetElement) {\n      self.oX = positions[0];\n      self.oY = positions[1];\n      self.dX = self.targetElement.scrollLeft;\n      self.dY = self.targetElement.scrollTop;\n      evt.preventDefault(true);\n      return;\n    }\n\n    var p = targetElement.createSVGPoint();\n    positions = mousePosition(evt);\n    p.x = positions[0];\n    p.y = positions[1];\n    var rootCTM = this.firstElementChild.getScreenCTM();\n    self.matrix = rootCTM.inverse();\n    p = p.matrixTransform(self.matrix);\n    self.dX = targetElement.getPosition()[0];\n    self.dY = targetElement.getPosition()[1];\n    self.oX = p.x;\n    self.oY = p.y;\n    evt.preventDefault(true);\n\n    if (document.createEvent) {\n      self.clicktimeout = setTimeout(function () {\n        var evObj = document.createEvent('Events');\n        self.clicktimeout = null;\n        evObj.initEvent('panstart', false, true);\n        targ.dispatchEvent(evObj);\n      }, 200);\n    }\n  };\n\n  var mousePosition = function mousePosition(evt) {\n    var posx = 0;\n    var posy = 0;\n\n    if (!evt) {\n      evt = window.event;\n    }\n\n    if (evt.pageX || evt.pageY) {\n      posx = evt.pageX;\n      posy = evt.pageY;\n    } else if (evt.clientX || evt.clientY) {\n      posx = evt.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;\n      posy = evt.clientY + document.body.scrollTop + document.documentElement.scrollTop;\n    }\n\n    if (self.targetElement) {\n      posx = evt.screenX;\n      posy = evt.screenY;\n    }\n\n    return [posx, posy];\n  };\n\n  var mouseMove = function mouseMove(evt) {\n    var positions = mousePosition(evt);\n\n    if (self.clicktimeout && Math.abs(positions[0] - self.oX) < 10) {\n      mouseUp();\n    }\n\n    if (!self.dragging) {\n      return;\n    }\n\n    targetElement.shiftPosition(positions[0], positions[1]);\n    evt.preventDefault(true);\n  };\n\n  var mouseDown = function mouseDown(evt) {\n    self.dragging = true;\n    self.moved = false;\n    var positions = mousePosition(evt);\n    self.oX = positions[0];\n    self.oY = positions[1];\n    self.dX = targetElement.getPosition()[0];\n    self.dY = targetElement.getPosition()[1];\n    evt.preventDefault(true);\n    var targ = self.targetElement ? self.targetElement : targetElement;\n    targ.setAttribute('dragging', 'true');\n\n    if (document.createEvent) {\n      var evObj = document.createEvent('Events');\n      evObj.initEvent('panstart', false, true);\n      targ.dispatchEvent(evObj);\n    }\n  };\n\n  var svgMouseMove = function svgMouseMove(evt) {\n    if (!self.enabled) {\n      return true;\n    } // this.style.cursor = 'url(http://maps.gstatic.com/intl/en_us/mapfiles/openhand_8_8.cur), move';\n\n\n    if (!self.dragging) {\n      return;\n    } // if (stationary) {\n    //     clearTimeout(stationary);\n    //     stationary = null;\n    // }\n    // \n    // stationary = window.setTimeout(function() {\n    //     self.dragging = false;\n    // },200);        \n\n\n    doMouseMove.call(this, evt);\n  };\n\n  var doMouseMove = function doMouseMove(evt) {\n    var positions = mousePosition(evt); // this.style.cursor = 'url(http://maps.gstatic.com/intl/en_us/mapfiles/closedhand_8_8.cur), -moz-grabbing';\n\n    if (self.targetElement) {\n      self.targetElement.shiftPosition(positions[0], positions[1]);\n      self.moved = true;\n      return;\n    }\n\n    var p = targetElement._cachedpoint || targetElement.createSVGPoint();\n    targetElement._cachedpoint = p;\n    positions = mousePosition(evt);\n    p.x = positions[0];\n    p.y = positions[1];\n    var rootCTM = targetElement._cachedrctm || targetElement.firstElementChild.getScreenCTM();\n    targetElement._cachedrctm = rootCTM;\n    p = p.matrixTransform(self.matrix);\n    targetElement.shiftPosition(p.x, p.y);\n    self.moved = true; //        momentum = p.x;        \n  };\n\n  var captureClick = function captureClick(evt) {\n    evt.stopPropagation();\n    this.removeEventListener('click', captureClick, true);\n  };\n\n  var mouseUp = function mouseUp(evt) {\n    if (self.clicktimeout) {\n      clearTimeout(self.clicktimeout);\n      self.clicktimeout = null;\n    }\n\n    if (!self.enabled) {\n      return true;\n    }\n\n    self.oX = 0;\n    self.oY = 0;\n    self.dX = null;\n    self.dY = null;\n    self.dragging = false;\n    evt.preventDefault(true);\n    var targ = self.targetElement ? self.targetElement : targetElement;\n    targ.removeAttribute('dragging');\n\n    if (!targ._snapback) {\n      _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire(targ, 'panend', true);\n    }\n\n    if (evt.type == 'mouseup' && self.moved) {\n      targ.addEventListener('click', captureClick, true);\n    }\n\n    self.moved = false;\n  };\n\n  var mouseOut = function mouseOut(e) {\n    if (!self.dragging || !self.enabled) {\n      return true;\n    }\n\n    if (this == self.targetElement) {\n      mouseUp(e);\n    }\n\n    if (e.target != this && !e.currentTarget) {\n      return;\n    }\n\n    var toTarget = e.relatedTarget ? e.relatedTarget : e.toElement;\n\n    while (toTarget !== null) {\n      if (toTarget == this) {\n        return;\n      }\n\n      toTarget = toTarget.parentNode;\n    }\n\n    mouseUp(e);\n  };\n\n  if (!targetElement.addEventListener) {\n    targetElement.addEventListener = function (name, func, bool) {\n      this.attachEvent(name, func);\n    };\n  }\n\n  targetElement.addEventListener('touchstart', function (e) {\n    if (!self.enabled) {\n      return;\n    }\n\n    var targ = self.targetElement ? self.targetElement : targetElement;\n\n    if (self.momentum) {\n      window.clearTimeout(self.momentum);\n      self.momentum = null;\n    }\n\n    if (e.touches.length == 1) {\n      var positions = mousePosition(e.touches[0]);\n      var p;\n\n      if (targ.nodeName == 'svg') {\n        p = targ.createSVGPoint();\n        p.x = positions[0];\n        p.y = positions[1];\n        var rootCTM = this.getScreenCTM();\n        self.matrix = rootCTM.inverse();\n        p = p.matrixTransform(self.matrix);\n      } else {\n        p.x = positions[0];\n        p.y = positions[1];\n      }\n\n      self.oX = p.x;\n      self.oY = p.y;\n      self.dragging = true;\n      self.dX = targ.getPosition()[0];\n      self.dY = targ.getPosition()[1];\n      self._momentum_shrinker = setInterval(function () {\n        momentum.shift();\n      }, 20);\n\n      if (document.createEvent) {\n        var evObj = document.createEvent('Events');\n        evObj.initEvent('panstart', false, true);\n        targ.dispatchEvent(evObj);\n      }\n\n      e.preventDefault();\n    }\n  }, false); // document.addEventListener('touchmove',function(e) {\n  //     console.log('touchmove for the document');\n  //     console.log(self.dragging);\n  //     if ( ! self.dragging ) {\n  //         return;\n  //     }\n  //     console.log(\"Ending the drag for document move\");\n  //     self.oX = 0;\n  //     self.oY = 0;\n  //     self.dX = null;\n  //     self.dY = null;\n  //     self.dragging = false;\n  // \n  //     var targ = self.targetElement ? self.targetElement : targetElement;      \n  // \n  //     if (document.createEvent) {\n  //         var evObj = document.createEvent('Events');\n  //         evObj.initEvent('panend',false,true);\n  //         targ.dispatchEvent(evObj);\n  //     }      \n  // },false);\n\n  targetElement.addEventListener('touchmove', function (e) {\n    if (self.drag_zoom) {\n      return;\n    }\n\n    if (self.momentum) {\n      window.clearTimeout(self.momentum);\n      self.momentum = null;\n    }\n\n    if (e.touches.length != 1) {\n      self.dragging = false;\n    }\n\n    var targ = self.targetElement ? self.targetElement : targetElement;\n    var positions = mousePosition(e.touches[0]);\n\n    if (!positions || !self.matrix) {\n      return;\n    }\n\n    var p;\n\n    if (targ.nodeName == 'svg') {\n      p = targ.createSVGPoint();\n      p.x = positions[0];\n      p.y = positions[1];\n      p = p.matrixTransform(self.matrix);\n    } else {\n      p.x = positions[0];\n      p.y = positions[1];\n    }\n\n    if (self.dragging && 6 * Math.abs(self.oX - p.x) > Math.abs(self.oY - p.y)) {// FIXME - PASSIVE\n      // e.preventDefault();\n    }\n\n    if (!self.dragging) {\n      self.oX = 0;\n      self.oY = 0;\n      self.dX = null;\n      self.dY = null;\n      return;\n    }\n\n    if (momentum.length > 3) {\n      momentum.splice(2);\n    }\n\n    targ.shiftPosition(p.x, p.y);\n    momentum.push(targ.getPosition()[0] - self.dX);\n  }, {\n    passive: true\n  }); // FIXME - PASSIVE\n\n  var momentum_func = function momentum_func(e) {\n    if (!self.enabled) {\n      return true;\n    }\n\n    if (!self.dragging) {\n      clearInterval(self._momentum_shrinker);\n      mouseUp(e);\n      return;\n    }\n\n    var targ = self.targetElement ? self.targetElement : targetElement;\n    var delta = 0;\n\n    if (momentum.length > 0) {\n      var last_val = momentum[0];\n      momentum.forEach(function (m) {\n        if (typeof last_val != 'undefined') {\n          delta += m - last_val;\n        }\n\n        last_val = m;\n      });\n      delta = delta / momentum.length;\n    }\n\n    var start = targ.getPosition()[0];\n    var start_delta = delta;\n    self.dragging = false;\n\n    if (self.momentum) {\n      window.clearTimeout(self.momentum);\n    }\n\n    self.momentum = 1;\n\n    let moment = function moment() {\n      start = targ.getPosition()[0];\n\n      if (self.dragging) {\n        start += self.oX - self.dX;\n      } else {\n        self.oX = 0;\n        self.dX = 0;\n      }\n\n      targ.shiftPosition(start + delta, 0);\n      start = start + delta;\n      delta = delta * 0.5;\n\n      if (delta > 0 && Math.abs(start_delta / delta) < 10) {\n        window.requestAnimationFrame(moment, targ); //                window.setTimeout(arguments.callee,50);\n      } else {\n        self.momentum = null;\n        clearInterval(self._momentum_shrinker);\n        mouseUp(e);\n      }\n    };\n\n    moment();\n  };\n\n  targetElement.addEventListener('touchend', momentum_func, false);\n\n  if (targetElement.nodeName == 'svg') {\n    targetElement.addEventListener('mousedown', svgMouseDown, false);\n    targetElement.addEventListener('mousemove', svgMouseMove, false);\n    targetElement.addEventListener('mouseup', mouseUp, false);\n    targetElement.addEventListener('mouseout', mouseOut, false);\n\n    if (self.targetElement) {\n      self.targetElement.addEventListener('mouseout', mouseOut, false);\n    } // targetElement.addEventListener('click',function(ev) { ev.preventDefault(); ev.stopPropagation(); },false);\n\n  } else {\n    targetElement.addEventListener('mousedown', mouseDown, false);\n    targetElement.addEventListener('mousemove', mouseMove, false);\n    targetElement.addEventListener('mouseup', mouseUp, false);\n    targetElement.addEventListener('mouseout', mouseOut, false);\n  }\n};\n\nDragger.addTouchZoomControls = function (zoomElement, touchElement, controller) {\n  if (!controller) {\n    controller = {\n      \"enabled\": true\n    };\n  }\n\n  Dragger.prototype.addTouchZoomControls.call(controller, zoomElement, touchElement);\n  return controller;\n};\n\nDragger.prototype.addTouchZoomControls = function (zoomElement, touchElement) {\n  var self = this;\n  var last_touch_start = null;\n  var xform = null;\n  var max_y = null;\n\n  var mousePosition = function mousePosition(evt) {\n    var posx = 0;\n    var posy = 0;\n\n    if (!evt) {\n      evt = window.event;\n    }\n\n    if (evt.pageX || evt.pageY) {\n      posx = evt.pageX;\n      posy = evt.pageY;\n    } else if (evt.clientX || evt.clientY) {\n      posx = evt.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;\n      posy = evt.clientY + document.body.scrollTop + document.documentElement.scrollTop;\n    }\n\n    if (self.targetElement) {\n      posx = evt.screenX;\n      posy = evt.screenY;\n    }\n\n    return [posx, posy];\n  };\n\n  var drag_zoom_move = function drag_zoom_move(evt) {\n    if (!self.enabled || !self.drag_zoom) {\n      return;\n    }\n\n    if (evt.touches.length == 1) {\n      var positions = mousePosition(evt.touches[0]);\n      var p = {};\n      p.x = positions[0];\n      p.y = positions[1];\n\n      if (touchElement.nodeName == 'svg') {\n        p = touchElement.createSVGPoint();\n        p.x = positions[0];\n        p.y = positions[1];\n        p = p.matrixTransform(xform);\n      }\n\n      zoomElement.zoom = self.zoom_start * Math.pow(10, (p.y - zoomElement.zoomCenter.y) / max_y);\n    }\n  };\n\n  var drag_zoom_end = function drag_zoom_end(evt) {\n    touchElement.removeEventListener('touchmove', drag_zoom_move);\n    touchElement.removeEventListener('touchend', drag_zoom_end);\n    self.drag_zoom = false;\n  };\n\n  touchElement.addEventListener('touchstart', function (e) {\n    if (!self.enabled) {\n      return;\n    }\n\n    if (e.touches.length == 1) {\n      if (new Date().getTime() - last_touch_start <= 300) {\n        self.drag_zoom = true;\n        self.zoom_start = zoomElement.zoom;\n        var positions = mousePosition(e.touches[0]);\n        var positions2 = mousePosition(e.touches[0]);\n        var p;\n\n        if (touchElement.nodeName == 'svg') {\n          p = touchElement.createSVGPoint();\n          p.x = 0.5 * (positions[0] + positions2[0]);\n          p.y = 0.5 * (positions[1] + positions2[1]);\n          var rootCTM = this.getScreenCTM();\n          xform = rootCTM.inverse();\n          p = p.matrixTransform(xform);\n          max_y = parseInt(touchElement.getAttribute('viewBox').split(' ')[3]);\n        } else {\n          p.x = 0.5 * (positions[0] + positions2[0]);\n          p.y = 0.5 * (positions[1] + positions2[1]);\n        }\n\n        zoomElement.zoomCenter = p;\n        touchElement.addEventListener('touchmove', drag_zoom_move, {\n          passive: true\n        });\n        touchElement.addEventListener('touchend', drag_zoom_end, false);\n        e.preventDefault();\n        return;\n      }\n\n      last_touch_start = new Date().getTime();\n      return;\n    }\n\n    if (e.touches.length == 2) {\n      var positions = mousePosition(e.touches[0]);\n      var positions2 = mousePosition(e.touches[1]);\n      var p;\n\n      if (touchElement.nodeName == 'svg') {\n        p = touchElement.createSVGPoint();\n        p.x = 0.5 * (positions[0] + positions2[0]);\n        p.y = 0.5 * (positions[1] + positions2[1]);\n        var rootCTM = this.getScreenCTM();\n        self.matrix = rootCTM.inverse();\n        p = p.matrixTransform(self.matrix);\n      } else {\n        p.x = 0.5 * (positions[0] + positions2[0]);\n        p.y = 0.5 * (positions[1] + positions2[1]);\n      }\n\n      zoomElement.zoomCenter = p;\n      e.preventDefault();\n    }\n  }, false); // touchElement.addEventListener('gesturestart',function(e) {\n\n  Hammer(touchElement).on(\"touch\", function (e) {\n    if (!self.enabled) {\n      return;\n    } // zoomElement.zoomLeft = null;\n\n\n    var zoomStart = zoomElement.zoom;\n\n    var zoomscale = function zoomscale(ev) {\n      if (zoomElement.zoomCenter) {\n        zoomElement.zoom = zoomStart * ev.gesture.scale;\n      }\n\n      ev.preventDefault();\n    };\n\n    Hammer(touchElement).on('pinch', zoomscale, false);\n\n    let hammer_release = function hammer_release(ev) {\n      Hammer(touchElement).off('pinch', zoomscale);\n      Hammer(touchElement).off('release', hammer_release);\n      zoomElement.zoomCenter = null;\n      zoomElement.zoomLeft = null;\n      _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire(zoomElement, 'gestureend');\n    };\n\n    Hammer(touchElement).on('release', hammer_release, false);\n    e.preventDefault();\n  }, false);\n};\n/**\n * Given an element that implements a zoom attribute, creates a div that contains controls for controlling the zoom attribute. The\n * zoomElement must have a zoom attribute, and can fire the zoomChange event whenever the zoom value is changed on the object. The\n * scrollwheel is connected to this element so that when the mouse hovers over the controls, it can control the zoom using only\n * the scroll wheel.\n * @param {Object} zoomElement Element to control the zooming for.\n * @param {Number} min Minimum value for the zoom attribute (default 0)\n * @param {Number} max Maximum value for the zoom attribute (default 10)\n * @param {Number} precision Step precision for the zoom control (default 0.5)\n * @param {Number} value Default value for this control\n * @returns DIV element containing the controls\n * @type Element\n * @see GOMap.Diagram#event:zoomChange\n */\n\n\nDragger.addZoomControls = function (zoomElement, min, max, precision, value) {\n  min = min || 0;\n  max = max || 10;\n  precision = precision || 0.5;\n  value = value || zoomElement.zoom || min;\n  var controls_container = document.createElement('div');\n  var zoomIn = document.createElement('input');\n  zoomIn.setAttribute('type', 'button');\n  zoomIn.setAttribute('value', '+');\n  var zoomOut = document.createElement('input');\n  zoomOut.setAttribute('type', 'button');\n  zoomOut.setAttribute('value', '-');\n  var reset = document.createElement('input');\n  reset.setAttribute('type', 'button');\n  reset.setAttribute('value', 'Reset');\n  controls_container.appendChild(reset);\n  reset.addEventListener('click', function () {\n    zoomElement.zoom = zoomElement.defaultZoom || value;\n  }, false);\n  var range = document.createElement('input');\n  range.setAttribute('min', min);\n  range.setAttribute('max', max);\n  range.setAttribute('step', precision);\n  range.setAttribute('value', value);\n  range.setAttribute('type', 'range');\n  range.setAttribute('style', '-webkit-appearance: slider-horizontal; width: 100%; position: absolute; top: 0px; bottom: 0px; margin-top: 0.5em; left: 100%; margin-left: -0.5em;');\n\n  if (range.type == 'range') {\n    range.addEventListener('change', function () {\n      zoomElement.zoom = this.value;\n    }, false);\n    var evFunction = null;\n\n    if (zoomElement.addEventListener) {\n      evFunction = zoomElement.addEventListener;\n    } else if (zoomElement.bind) {\n      evFunction = zoomElement.bind;\n    }\n\n    evFunction.apply(zoomElement, ['zoomChange', function () {\n      range.value = zoomElement.zoom;\n    }, false]);\n    reset.style.margin = '0px';\n    reset.style.display = 'block';\n    reset.style.position = 'absolute';\n    reset.style.top = '0px';\n    controls_container.appendChild(range);\n    controls_container.style.height = '100%';\n  } else {\n    if (!zoomIn.addEventListener) {\n      var addevlis = function addevlis(name, func) {\n        this.attachEvent(name, func);\n      };\n\n      zoomIn.addEventListener = addevlis;\n      reset.addEventListener = addevlis;\n      zoomOut.addEventListener = addevlis;\n    }\n\n    zoomIn.addEventListener('click', function () {\n      zoomElement.zoom += precision;\n    }, false);\n    zoomOut.addEventListener('click', function () {\n      zoomElement.zoom -= precision;\n    }, false);\n    zoomIn.style.margin = '0px';\n    zoomIn.style.display = 'block';\n    zoomIn.style.position = 'absolute';\n    zoomIn.style.top = '0px';\n    zoomIn.style.left = '29px';\n    zoomOut.style.margin = '0px';\n    zoomOut.style.display = 'block';\n    zoomOut.style.position = 'absolute';\n    zoomOut.style.top = '0px';\n    reset.style.margin = '0px';\n    reset.style.display = 'block';\n    reset.style.position = 'absolute';\n    reset.style.top = '23px';\n    reset.style.left = '3px';\n    controls_container.appendChild(zoomOut);\n    controls_container.appendChild(zoomIn);\n    controls_container.appendChild(reset);\n  }\n\n  this.addScrollZoomControls(zoomElement, controls_container, precision);\n  return controls_container;\n};\n\nDragger.addScrollBar = function (target, controlElement, scrollContainer) {\n  return;\n  var scroller = document.createElement('div');\n\n  while (scrollContainer.childNodes.length > 0) {\n    scrollContainer.removeChild(scrollContainer.firstChild);\n  }\n\n  scrollContainer.appendChild(scroller);\n\n  if (!scrollContainer.style.position) {\n    scrollContainer.style.position = 'relative';\n  }\n\n  scrollContainer.style.overflowX = 'scroll';\n  scrollContainer.style.overflowY = 'hidden';\n  scroller.style.position = 'absolute';\n  scroller.style.left = '0px';\n  scroller.style.width = '100%';\n  scroller.style.height = '100%';\n  _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].remove(scrollContainer, 'scroll');\n  _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].remove(scrollContainer, 'mouseenter');\n  _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(scrollContainer, 'mouseenter', function () {\n    var size = 100 * target.getTotalLength() / target.getVisibleLength();\n    scroller.cached_width = scroller.clientWidth / size;\n    disabled = true;\n    scrollContainer.scrollLeft += 1;\n    scrollContainer.scrollLeft -= 1;\n    setTimeout(function () {\n      disabled = false;\n    }, 0);\n    _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].remove(scrollContainer, 'scroll', scroll_func);\n    _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(scrollContainer, 'scroll', scroll_func);\n  });\n  var disabled = false;\n\n  if (window.matchMedia) {\n    window.matchMedia('print').addListener(function (matcher) {\n      disabled = true;\n      setTimeout(function () {\n        disabled = false;\n      }, 0);\n    });\n  }\n\n  var scroll_func = function scroll_func() {\n    if (disabled || !console) {\n      return;\n    }\n\n    if (document.createEvent) {\n      var evObj = document.createEvent('Events');\n      evObj.initEvent('panstart', false, true);\n      controlElement.dispatchEvent(evObj);\n    }\n\n    var size = 100 * target.getTotalLength() / target.getVisibleLength();\n    var width = scroller.cached_width ? parseInt(scroller.cached_width * size) : scroller.clientWidth;\n    target.setLeftPosition(parseInt(scrollContainer.scrollLeft * target.getTotalLength() / width));\n    _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire(controlElement, 'panend');\n  };\n\n  _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(scrollContainer, 'scroll', scroll_func);\n  var left_setter;\n  _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(controlElement, 'pan', function () {\n    cancelAnimationFrame(left_setter);\n    var size = 100 * target.getTotalLength() / target.getVisibleLength();\n    scroller.style.width = parseInt(size) + '%';\n    var width = scroller.cached_width ? parseInt(scroller.cached_width * size) : scroller.clientWidth;\n    scroller.cached_width = width / size;\n    var left_shift = parseInt(width * (target.getLeftPosition() / target.getTotalLength()));\n    _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].remove(scrollContainer, 'scroll', scroll_func);\n    left_setter = requestAnimationFrame(function () {\n      // Rendering bottleneck\n      scrollContainer.scrollLeft = left_shift;\n    });\n  });\n};\n/**\n * Connect the scroll wheel to the controls to control zoom\n */\n\n\nDragger.addScrollZoomControls = function (target, controlElement, precision) {\n  precision = precision || 0.5;\n  var self;\n\n  if (this.enabled === null) {\n    self = {\n      'enabled': true\n    };\n  } else {\n    self = this;\n  }\n\n  var hookEvent = function hookEvent(element, eventName, callback) {\n    if (typeof element == 'string') {\n      element = document.getElementById(element);\n    }\n\n    if (element === null) {\n      return;\n    }\n\n    if (element.addEventListener) {\n      if (eventName == 'mousewheel') {\n        element.addEventListener('DOMMouseScroll', callback, false);\n        element.addEventListener('wheel', callback, false);\n      }\n\n      element.addEventListener(eventName, callback, false);\n    } else if (element.attachEvent) {\n      element.attachEvent(\"on\" + eventName, callback);\n    }\n  };\n\n  var mousePosition = function mousePosition(evt) {\n    if (!self.enabled) {\n      return;\n    }\n\n    var posx = 0;\n    var posy = 0;\n\n    if (!evt) {\n      evt = window.event;\n    }\n\n    if (evt.pageX || evt.pageY) {\n      posx = evt.pageX;\n      posy = evt.pageY;\n    } else if (evt.clientX || evt.clientY) {\n      posx = evt.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;\n      posy = evt.clientY + document.body.scrollTop + document.documentElement.scrollTop;\n    }\n\n    var p = {};\n\n    if (controlElement.nodeName == 'svg') {\n      p = controlElement.createSVGPoint();\n      p.x = posx;\n      p.y = posy;\n      /* Fix for mouse position in firefox - http://jsfiddle.net/JNKgR/6/ */\n\n      var rootCTM = controlElement.firstElementChild.getScreenCTM();\n      self.matrix = rootCTM.inverse();\n      p = p.matrixTransform(self.matrix);\n    } else {\n      p.x = posx;\n      p.y = posy;\n    }\n\n    return p;\n  };\n\n  var mouseWheel = function mouseWheel(e) {\n    if (!self.enabled) {\n      return;\n    }\n\n    e = e ? e : window.event;\n    var wheelData = e.detail ? e.detail * -1 : e.wheelDelta;\n\n    if (!wheelData) {\n      wheelData = e.deltaY;\n    }\n\n    target.zoomCenter = mousePosition(e);\n\n    if (wheelData > 0) {\n      target.zoom = target.zoom += precision;\n    } else {\n      target.zoom = target.zoom -= precision;\n    }\n\n    if (e.preventDefault) {\n      e.preventDefault();\n    }\n\n    e.returnValue = false;\n    e.stopPropagation();\n    return false;\n  };\n\n  var isFF = false;\n\n  if (navigator.userAgent.indexOf('Gecko') >= 0) {\n    isFF = parseFloat(navigator.userAgent.split('Firefox/')[1]) || undefined;\n  }\n\n  if (isFF && typeof svgweb != 'undefined' && svgweb.getHandlerType() == 'native') {\n    hookEvent(controlElement, 'mousewheel', mouseWheel);\n  } else {\n    hookEvent(controlElement, 'mousewheel', mouseWheel);\n  }\n\n  hookEvent(controlElement, 'mousemove', function (e) {\n    if (!self.enabled) {\n      return;\n    }\n\n    if (target.zoomCenter && Math.abs(target.zoomCenter.x - mousePosition(e).x) > 100) {\n      target.zoomCenter = null;\n      target.zoomLeft = null;\n    }\n  });\n  return self;\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Dragger);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vZ2F0b3IvanMvbGliL0RyYWdnZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vZ2F0b3IvanMvbGliL0RyYWdnZXIuanM/MGRkOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBAZmlsZU92ZXJ2aWV3ICAgQmFzaWMgY2xhc3NlcyBhbmQgZGVmaXRpb25zIGZvciBhIEdlbmUgT250b2xvZ3kgSUQgYmFzZWQgbWFwXG4gKi9cblxuaW1wb3J0ICcuLi9oYW1tZXIuanMnO1xuaW1wb3J0IGJlYW4gZnJvbSAnLi4vYmVhbic7XG5cbi8qKlxuICogQGNsYXNzICAgICAgIFN0YXRlIGNsYXNzIGZvciBhZGRpbmcgcGFubmluZyBmdW5jdGlvbmFsaXR5IHRvIGFuIGVsZW1lbnQuIEVhY2ggZWxlbWVudCB0aGF0IGlzIHRvIGJlIHBhbm5lZCBuZWVkcyBhIG5ldyBpbnN0YW5jZVxuICogICAgICAgICAgICAgIG9mIHRoZSBEcmFnZ2VyIHRvIHN0b3JlIHN0YXRlLlxuICogQGF1dGhvciAgICAgIGhqam9zaGlcbiAqIEByZXF1aXJlcyAgICBzdmd3ZWJcbiAqL1xuY29uc3QgRHJhZ2dlciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLm9YID0gMDtcbiAgdGhpcy5vWSA9IDA7XG4gIHRoaXMuZFggPSAwO1xuICB0aGlzLmRZID0gMDtcbiAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICB0aGlzLnRhcmdldEVsZW1lbnQgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDb25uZWN0IHRoaXMgZHJhZ2dlciB0byBhIHBhcnRpY3VsYXIgZWxlbWVudC4gSWYgYW4gU1ZHIGVsZW1lbnQgaXMgZ2l2ZW4sIHBhbm5pbmcgb2NjdXJzIHdpdGhpbiB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBTVkcsIGFuZFxuICogdGhlIGltYWdlIGlzIHNoaWZ0ZWQgYnkgdXNpbmcgdGhlIGN1cnJlbnRUcmFuc2xhdGUgcHJvcGVydHkuIElmIGEgcmVndWxhciBIVE1MIGVsZW1lbnQgaXMgZ2l2ZW4sIHRoZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgYXR0cmlidXRlc1xuICogYXJlIHVzZWQgdG8gbW92ZSB0aGUgdmlld3BvcnQgYXJvdW5kLiBcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0RWxlbWVudCBFbGVtZW50IHRvIGVuYWJsZSBwYW5uaW5nIHVwb24uXG4gKi9cbkRyYWdnZXIucHJvdG90eXBlLmFwcGx5VG9FbGVtZW50ID0gZnVuY3Rpb24odGFyZ2V0RWxlbWVudCxlbmFibGVkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICh0eXBlb2YgZW5hYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc2VsZi5lbmFibGVkID0gZW5hYmxlZDsgICAgICAgIFxuICAgIH1cbiAgICBcbiAgICB2YXIgbW9tZW50dW0gPSBbXTtcblxuICAgIGlmICh0YXJnZXRFbGVtZW50Lm5vZGVOYW1lID09ICdzdmcnKSB7XG4gICAgICAgIHRhcmdldEVsZW1lbnQuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB0cmFuc2xhdGUgPSB0YXJnZXRFbGVtZW50LmN1cnJlbnRUcmFuc2xhdGVDYWNoZSB8fCB0YXJnZXRFbGVtZW50LmN1cnJlbnRUcmFuc2xhdGU7XG4gICAgICAgICAgICB2YXIgZFggPSB0cmFuc2xhdGUueDtcbiAgICAgICAgICAgIHZhciBkWSA9IHRyYW5zbGF0ZS55O1xuXG4gICAgICAgICAgICByZXR1cm4gW2RYLCBkWV07XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB0YXJnZXRFbGVtZW50LnNoaWZ0UG9zaXRpb24gPSBmdW5jdGlvbih4LHkpIHtcbiAgICAgICAgICAgIHZhciBwID0geyd4JyA6IHgsICd5JyA6IHkgfTtcbiAgICAgICAgICAgIHZhciB2aWV3Qm94U2NhbGUgPSAxO1xuICAgICAgICAgICAgdmFyIHZib3ggPSB0aGlzLmdldEF0dHJpYnV0ZSgndmlld0JveCcpO1xuXG4gICAgICAgICAgICB2YXIgbWluX3gsbWluX3ksd2lkdGgsaGVpZ2h0O1xuXG4gICAgICAgICAgICBpZiAodmJveCkge1xuICAgICAgICAgICAgICAgIHZhciB2aWV3Qm94ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgIHZpZXdCb3hTY2FsZSA9IHBhcnNlRmxvYXQodGhpcy53aWR0aC5iYXNlVmFsLnZhbHVlKSAvIHBhcnNlRmxvYXQodmlld0JveFsyXSk7XG4gICAgICAgICAgICAgICAgbWluX3ggPSAwO1xuICAgICAgICAgICAgICAgIG1pbl95ID0gcGFyc2VJbnQodmlld0JveFsxXSwxMCk7XG4gICAgICAgICAgICAgICAgd2lkdGggPSBwYXJzZUludCh2aWV3Qm94WzJdLDEwKTtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBwYXJzZUludCh2aWV3Qm94WzNdLDEwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWluX3ggPSAwO1xuICAgICAgICAgICAgICAgIG1pbl95ID0gMDtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IHRhcmdldEVsZW1lbnQud2lkdGg7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGFyZ2V0RWxlbWVudC5oZWlnaHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXRFbGVtZW50LnN0eWxlLkdvbWFwU2Nyb2xsTGVmdE1hcmdpbikge1xuICAgICAgICAgICAgICAgIG1pbl94ICs9IHRhcmdldEVsZW1lbnQuc3R5bGUuR29tYXBTY3JvbGxMZWZ0TWFyZ2luO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoIHNlbGYuZHJhZ2dpbmcgKSB7XG4gICAgICAgICAgICAgICAgcC54ID0gdmlld0JveFNjYWxlKihwLnggLSBzZWxmLm9YKTtcbiAgICAgICAgICAgICAgICBwLnkgPSB2aWV3Qm94U2NhbGUqKHAueSAtIHNlbGYub1kpO1xuXG4gICAgICAgICAgICAgICAgcC54ICs9IHNlbGYuZFg7XG4gICAgICAgICAgICAgICAgcC55ICs9IHNlbGYuZFk7XG4gICAgICAgICAgICAgICAgcC55ID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRhcmdldEVsZW1lbnQuX3NuYXBiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRhcmdldEVsZW1lbnQuX3NuYXBiYWNrKTtcbiAgICAgICAgICAgICAgICB0YXJnZXRFbGVtZW50Ll9zbmFwYmFjayA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChwLnggPiB2aWV3Qm94U2NhbGUgKiBtaW5feCAmJiBzZWxmLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAvKiBFbGVtZW50IGhhcyBzaGlmdGVkIHRvbyBmYXIgdG8gdGhlIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgSW5kdWNlIHNvbWUgZ3Jhdml0eSB0b3dhcmRzIHRoZSBsZWZ0IHNpZGVcbiAgICAgICAgICAgICAgICAgICBvZiB0aGUgc2NyZWVuXG4gICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgIGxldCBkb19zbmFwYmFjayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXZPYmo7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2xhdGUgPSB0YXJnZXRFbGVtZW50LmN1cnJlbnRUcmFuc2xhdGVDYWNoZSB8fCB0YXJnZXRFbGVtZW50LmN1cnJlbnRUcmFuc2xhdGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyh0cmFuc2xhdGUueCAtICh2aWV3Qm94U2NhbGUgKiBtaW5feCkpID4gMzUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3X3BvcyA9IDAuOTUqKHRyYW5zbGF0ZS54IC0gKHZpZXdCb3hTY2FsZSAqIG1pbl94KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3X3BvcyA8ICh2aWV3Qm94U2NhbGUgKiBtaW5feCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdfcG9zID0gKHZpZXdCb3hTY2FsZSAqIG1pbl94KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5zZXRDdXJyZW50VHJhbnNsYXRlWFkoIG5ld19wb3MsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShkb19zbmFwYmFjaywgdGFyZ2V0RWxlbWVudCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEVsZW1lbnQuX3NuYXBiYWNrID0gc2V0VGltZW91dChhcmd1bWVudHMuY2FsbGVlLDEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5jcmVhdGVFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBldk9iaiA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudHMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldk9iai5pbml0RXZlbnQoJ3BhbnN0YXJ0JyxmYWxzZSx0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZPYmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5zZXRDdXJyZW50VHJhbnNsYXRlWFkoICh2aWV3Qm94U2NhbGUgKiBtaW5feCksIDAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5jcmVhdGVFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBldk9iaiA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudHMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldk9iai5pbml0RXZlbnQoJ3BhbicsZmFsc2UsdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2T2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghIHNlbGYuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWFuLmZpcmUodGFyZ2V0RWxlbWVudCwncGFuZW5kJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbGVtZW50Ll9zbmFwYmFjayA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRhcmdldEVsZW1lbnQuX3NuYXBiYWNrID0gc2V0VGltZW91dChkb19zbmFwYmFjaywzMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgbWluX3ZhbCA9IHZpZXdCb3hTY2FsZSAqICggd2lkdGggLSAyICogbWluX3ggKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKG1pbl94ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbWluX3ZhbCAqPSAwLjkwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHAueCA8IDAgJiYgTWF0aC5hYnMocC54KSA+IG1pbl92YWwgJiYgc2VsZi5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgLyogRWxlbWVudCBoYXMgc2hpZnRlZCB0b28gZmFyIHRvIHRoZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgSW5kdWNlIHNvbWUgZ3Jhdml0eSB0byB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgc2NyZWVuXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBsZXQgZG9fc25hcGJhY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV2T2JqO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNsYXRlID0gdGFyZ2V0RWxlbWVudC5jdXJyZW50VHJhbnNsYXRlQ2FjaGUgfHwgdGFyZ2V0RWxlbWVudC5jdXJyZW50VHJhbnNsYXRlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnModHJhbnNsYXRlLnggLSAoLTEgKiBtaW5fdmFsKSkgPiAzNSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdfcG9zID0gMC45NSoodHJhbnNsYXRlLngpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld19wb3MgPiAoLTEqbWluX3ZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdfcG9zID0gLTEqbWluX3ZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEVsZW1lbnQuc2V0Q3VycmVudFRyYW5zbGF0ZVhZKCBuZXdfcG9zLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZG9fc25hcGJhY2ssIHRhcmdldEVsZW1lbnQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbGVtZW50Ll9zbmFwYmFjayA9IHNldFRpbWVvdXQoYXJndW1lbnRzLmNhbGxlZSwxMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQuY3JlYXRlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldk9iaiA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudHMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldk9iai5pbml0RXZlbnQoJ3BhbnN0YXJ0JyxmYWxzZSx0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZPYmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5zZXRDdXJyZW50VHJhbnNsYXRlWFkoIC0xKm1pbl92YWwsIDApOyAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LmNyZWF0ZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZPYmogPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnRzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZPYmouaW5pdEV2ZW50KCdwYW4nLGZhbHNlLHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEVsZW1lbnQuZGlzcGF0Y2hFdmVudChldk9iaik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISBzZWxmLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVhbi5maXJlKHRhcmdldEVsZW1lbnQsJ3BhbmVuZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5fc25hcGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0YXJnZXRFbGVtZW50Ll9zbmFwYmFjayA9IHNldFRpbWVvdXQoZG9fc25hcGJhY2ssMzAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHAueSA+IHZpZXdCb3hTY2FsZSAqIG1pbl95KSB7XG4gICAgICAgICAgICAgICAgcC55ID0gdmlld0JveFNjYWxlICogbWluX3k7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMocC55KSA+IDAuNTAqdmlld0JveFNjYWxlICogaGVpZ2h0ICkge1xuICAgICAgICAgICAgICAgIHAueSA9IC0wLjUwICogdmlld0JveFNjYWxlICogaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc2V0Q3VycmVudFRyYW5zbGF0ZVhZKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50VHJhbnNsYXRlWFkocC54LHAueSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY3VycmVudFRyYW5zbGF0ZS5zZXRYWSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFRyYW5zbGF0ZS5zZXRYWShwLngscC55KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50VHJhbnNsYXRlLnggPSBwLng7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50VHJhbnNsYXRlLnkgPSBwLnk7ICAgICAgICAgIFxuICAgICAgICAgICAgfSAgICAgICAgICAgIFxuXG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuY3JlYXRlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZPYmogPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnRzJyk7XG4gICAgICAgICAgICAgICAgZXZPYmouaW5pdEV2ZW50KCdwYW4nLGZhbHNlLHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldk9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0RWxlbWVudC5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLnNjcm9sbExlZnQsIHRoaXMuc2Nyb2xsVG9wXTtcbiAgICAgICAgfTtcbiAgICAgICAgdGFyZ2V0RWxlbWVudC5zaGlmdFBvc2l0aW9uID0gZnVuY3Rpb24oeCx5KSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbExlZnQgPSBzZWxmLmRYICsgKHNlbGYub1ggLSB4KTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9wID0gc2VsZi5kWSArIChzZWxmLm9ZIC0geSk7XG5cbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5jcmVhdGVFdmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBldk9iaiA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudHMnKTtcbiAgICAgICAgICAgICAgICBldk9iai5pbml0RXZlbnQoJ3BhbicsZmFsc2UsdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2T2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgc3RhdGlvbmFyeTtcblxuICAgIHZhciBzdmdNb3VzZURvd24gPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIGlmICggISBzZWxmLmVuYWJsZWQgKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciB0YXJnID0gc2VsZi50YXJnZXRFbGVtZW50ID8gc2VsZi50YXJnZXRFbGVtZW50IDogdGFyZ2V0RWxlbWVudDtcbiAgICAgIHZhciBwb3NpdGlvbnMgPSBtb3VzZVBvc2l0aW9uKGV2dCk7XG4gICAgICBzZWxmLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgIHNlbGYubW92ZWQgPSBmYWxzZTtcbiAgICAgIHRhcmcuc2V0QXR0cmlidXRlKCdkcmFnZ2luZycsJ3RydWUnKTtcblxuICAgICAgaWYgKHNlbGYudGFyZ2V0RWxlbWVudCkge1xuXG4gICAgICAgICAgc2VsZi5vWCA9IHBvc2l0aW9uc1swXTtcbiAgICAgICAgICBzZWxmLm9ZID0gcG9zaXRpb25zWzFdO1xuICAgICAgICAgIHNlbGYuZFggPSBzZWxmLnRhcmdldEVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICAgICAgICBzZWxmLmRZID0gc2VsZi50YXJnZXRFbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQodHJ1ZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcCA9IHRhcmdldEVsZW1lbnQuY3JlYXRlU1ZHUG9pbnQoKTtcbiAgICAgIHBvc2l0aW9ucyA9IG1vdXNlUG9zaXRpb24oZXZ0KTtcbiAgICAgIHAueCA9IHBvc2l0aW9uc1swXTtcbiAgICAgIHAueSA9IHBvc2l0aW9uc1sxXTtcblxuICAgICAgdmFyIHJvb3RDVE0gPSB0aGlzLmZpcnN0RWxlbWVudENoaWxkLmdldFNjcmVlbkNUTSgpO1xuICAgICAgc2VsZi5tYXRyaXggPSByb290Q1RNLmludmVyc2UoKTtcbiAgICAgIFxuICAgICAgcCA9IHAubWF0cml4VHJhbnNmb3JtKHNlbGYubWF0cml4KTtcblxuICAgICAgc2VsZi5kWCA9IHRhcmdldEVsZW1lbnQuZ2V0UG9zaXRpb24oKVswXTtcbiAgICAgIHNlbGYuZFkgPSB0YXJnZXRFbGVtZW50LmdldFBvc2l0aW9uKClbMV07XG5cbiAgICAgIHNlbGYub1ggPSBwLng7XG4gICAgICBzZWxmLm9ZID0gcC55O1xuXG4gICAgICBldnQucHJldmVudERlZmF1bHQodHJ1ZSk7XG4gICAgICBcbiAgICAgIGlmIChkb2N1bWVudC5jcmVhdGVFdmVudCkge1xuICAgICAgICAgIHNlbGYuY2xpY2t0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIGV2T2JqID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50cycpO1xuICAgICAgICAgICAgICBzZWxmLmNsaWNrdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgIGV2T2JqLmluaXRFdmVudCgncGFuc3RhcnQnLGZhbHNlLHRydWUpO1xuICAgICAgICAgICAgICB0YXJnLmRpc3BhdGNoRXZlbnQoZXZPYmopO1xuICAgICAgICAgIH0sMjAwKTtcbiAgICAgIH1cblxuICAgIH07XG4gICAgXG4gICAgdmFyIG1vdXNlUG9zaXRpb24gPSBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgdmFyIHBvc3ggPSAwO1xuICAgICAgICB2YXIgcG9zeSA9IDA7XG4gICAgICAgIGlmICghZXZ0KSB7XG4gICAgICAgICAgICBldnQgPSB3aW5kb3cuZXZlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2dC5wYWdlWCB8fCBldnQucGFnZVkpICAgICB7XG4gICAgICAgICAgICBwb3N4ID0gZXZ0LnBhZ2VYO1xuICAgICAgICAgICAgcG9zeSA9IGV2dC5wYWdlWTtcbiAgICAgICAgfSBlbHNlIGlmIChldnQuY2xpZW50WCB8fCBldnQuY2xpZW50WSkgIHtcbiAgICAgICAgICAgIHBvc3ggPSBldnQuY2xpZW50WCArIGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCArIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgcG9zeSA9IGV2dC5jbGllbnRZICsgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLnRhcmdldEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHBvc3ggPSBldnQuc2NyZWVuWDtcbiAgICAgICAgICAgIHBvc3kgPSBldnQuc2NyZWVuWTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWyBwb3N4LCBwb3N5IF07XG4gICAgfTtcbiAgICBcbiAgICB2YXIgbW91c2VNb3ZlID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHZhciBwb3NpdGlvbnMgPSBtb3VzZVBvc2l0aW9uKGV2dCk7XG4gICAgICAgIGlmIChzZWxmLmNsaWNrdGltZW91dCAmJiBNYXRoLmFicyhwb3NpdGlvbnNbMF0gLSBzZWxmLm9YKSA8IDEwICkge1xuICAgICAgICAgICAgbW91c2VVcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2VsZi5kcmFnZ2luZykge1xuICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXRFbGVtZW50LnNoaWZ0UG9zaXRpb24ocG9zaXRpb25zWzBdLHBvc2l0aW9uc1sxXSk7XG4gICAgICAgIFxuICAgICAgICBldnQucHJldmVudERlZmF1bHQodHJ1ZSk7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgbW91c2VEb3duID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHNlbGYuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICBzZWxmLm1vdmVkID0gZmFsc2U7XG4gICAgICAgIHZhciBwb3NpdGlvbnMgPSBtb3VzZVBvc2l0aW9uKGV2dCk7XG4gICAgICAgIHNlbGYub1ggPSBwb3NpdGlvbnNbMF07XG4gICAgICAgIHNlbGYub1kgPSBwb3NpdGlvbnNbMV07XG4gICAgICAgIHNlbGYuZFggPSB0YXJnZXRFbGVtZW50LmdldFBvc2l0aW9uKClbMF07XG4gICAgICAgIHNlbGYuZFkgPSB0YXJnZXRFbGVtZW50LmdldFBvc2l0aW9uKClbMV07XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCh0cnVlKTtcbiAgICAgICAgdmFyIHRhcmcgPSBzZWxmLnRhcmdldEVsZW1lbnQgPyBzZWxmLnRhcmdldEVsZW1lbnQgOiB0YXJnZXRFbGVtZW50O1xuICAgICAgICB0YXJnLnNldEF0dHJpYnV0ZSgnZHJhZ2dpbmcnLCd0cnVlJyk7XG4gICAgICAgIGlmIChkb2N1bWVudC5jcmVhdGVFdmVudCkge1xuICAgICAgICAgICAgdmFyIGV2T2JqID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50cycpO1xuICAgICAgICAgICAgZXZPYmouaW5pdEV2ZW50KCdwYW5zdGFydCcsZmFsc2UsdHJ1ZSk7XG4gICAgICAgICAgICB0YXJnLmRpc3BhdGNoRXZlbnQoZXZPYmopO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICB2YXIgc3ZnTW91c2VNb3ZlID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIGlmICghc2VsZi5lbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGlzLnN0eWxlLmN1cnNvciA9ICd1cmwoaHR0cDovL21hcHMuZ3N0YXRpYy5jb20vaW50bC9lbl91cy9tYXBmaWxlcy9vcGVuaGFuZF84XzguY3VyKSwgbW92ZSc7XG4gICAgICAgIGlmICghc2VsZi5kcmFnZ2luZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgKHN0YXRpb25hcnkpIHtcbiAgICAgICAgLy8gICAgIGNsZWFyVGltZW91dChzdGF0aW9uYXJ5KTtcbiAgICAgICAgLy8gICAgIHN0YXRpb25hcnkgPSBudWxsO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIFxuICAgICAgICAvLyBzdGF0aW9uYXJ5ID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vICAgICBzZWxmLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIC8vIH0sMjAwKTsgICAgICAgIFxuICAgICAgICBcbiAgICAgICAgZG9Nb3VzZU1vdmUuY2FsbCh0aGlzLGV2dCk7XG4gICAgfTtcblxuICAgIHZhciBkb01vdXNlTW92ZSA9IGZ1bmN0aW9uKGV2dCkgeyAgICAgICAgXG4gICAgICAgIHZhciBwb3NpdGlvbnMgPSBtb3VzZVBvc2l0aW9uKGV2dCk7XG4gICAgICAgIC8vIHRoaXMuc3R5bGUuY3Vyc29yID0gJ3VybChodHRwOi8vbWFwcy5nc3RhdGljLmNvbS9pbnRsL2VuX3VzL21hcGZpbGVzL2Nsb3NlZGhhbmRfOF84LmN1ciksIC1tb3otZ3JhYmJpbmcnO1xuXG4gICAgICAgIGlmIChzZWxmLnRhcmdldEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHNlbGYudGFyZ2V0RWxlbWVudC5zaGlmdFBvc2l0aW9uKHBvc2l0aW9uc1swXSxwb3NpdGlvbnNbMV0pO1xuICAgICAgICAgICAgc2VsZi5tb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBcbiAgICAgICAgdmFyIHAgPSB0YXJnZXRFbGVtZW50Ll9jYWNoZWRwb2ludCB8fCB0YXJnZXRFbGVtZW50LmNyZWF0ZVNWR1BvaW50KCk7XG4gICAgICAgIHRhcmdldEVsZW1lbnQuX2NhY2hlZHBvaW50ID0gcDtcbiAgICAgICAgXG4gICAgICAgIHBvc2l0aW9ucyA9IG1vdXNlUG9zaXRpb24oZXZ0KTtcblxuICAgICAgICBwLnggPSBwb3NpdGlvbnNbMF07XG4gICAgICAgIHAueSA9IHBvc2l0aW9uc1sxXTtcblxuICAgICAgICB2YXIgcm9vdENUTSA9IHRhcmdldEVsZW1lbnQuX2NhY2hlZHJjdG0gfHwgdGFyZ2V0RWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZC5nZXRTY3JlZW5DVE0oKTtcbiAgICAgICAgdGFyZ2V0RWxlbWVudC5fY2FjaGVkcmN0bSA9IHJvb3RDVE07XG4gICAgICAgIFxuICAgICAgICBwID0gcC5tYXRyaXhUcmFuc2Zvcm0oc2VsZi5tYXRyaXgpO1xuICAgICAgICB0YXJnZXRFbGVtZW50LnNoaWZ0UG9zaXRpb24ocC54LHAueSk7XG4gICAgICAgIHNlbGYubW92ZWQgPSB0cnVlO1xuLy8gICAgICAgIG1vbWVudHVtID0gcC54OyAgICAgICAgXG4gICAgfTtcblxuICAgIHZhciBjYXB0dXJlQ2xpY2sgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGNhcHR1cmVDbGljaywgdHJ1ZSk7XG4gICAgfTtcblxuICAgIHZhciBtb3VzZVVwID0gZnVuY3Rpb24oZXZ0KSB7IFxuICAgICAgaWYgKHNlbGYuY2xpY2t0aW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHNlbGYuY2xpY2t0aW1lb3V0KTtcbiAgICAgICAgICBzZWxmLmNsaWNrdGltZW91dCA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoICEgc2VsZi5lbmFibGVkICkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgc2VsZi5vWCA9IDA7XG4gICAgICBzZWxmLm9ZID0gMDtcbiAgICAgIHNlbGYuZFggPSBudWxsO1xuICAgICAgc2VsZi5kWSA9IG51bGw7XG4gICAgICBzZWxmLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICBldnQucHJldmVudERlZmF1bHQodHJ1ZSk7XG4gICAgICBcbiAgICAgIHZhciB0YXJnID0gc2VsZi50YXJnZXRFbGVtZW50ID8gc2VsZi50YXJnZXRFbGVtZW50IDogdGFyZ2V0RWxlbWVudDsgICAgICBcblxuICAgICAgdGFyZy5yZW1vdmVBdHRyaWJ1dGUoJ2RyYWdnaW5nJyk7XG4gICAgICBcbiAgICAgIGlmICghIHRhcmcuX3NuYXBiYWNrKSB7XG4gICAgICAgIGJlYW4uZmlyZSh0YXJnLCdwYW5lbmQnLHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZ0LnR5cGUgPT0gJ21vdXNldXAnICYmIHNlbGYubW92ZWQpIHtcbiAgICAgICAgdGFyZy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsY2FwdHVyZUNsaWNrLHRydWUpO1xuICAgICAgfVxuICAgICAgc2VsZi5tb3ZlZCA9IGZhbHNlO1xuXG4gICAgfTtcblxuICAgIHZhciBtb3VzZU91dCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCFzZWxmLmRyYWdnaW5nIHx8ICEgc2VsZi5lbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcyA9PSBzZWxmLnRhcmdldEVsZW1lbnQpIHtcbiAgICAgICAgICAgIG1vdXNlVXAoZSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBpZiAoIGUudGFyZ2V0ICE9IHRoaXMgJiYgISBlLmN1cnJlbnRUYXJnZXQgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG9UYXJnZXQgPSBlLnJlbGF0ZWRUYXJnZXQgPyBlLnJlbGF0ZWRUYXJnZXQgOiBlLnRvRWxlbWVudDtcbiAgICAgICAgXG4gICAgICAgIHdoaWxlICh0b1RhcmdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRvVGFyZ2V0ID09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b1RhcmdldCA9IHRvVGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgbW91c2VVcChlKTtcbiAgICB9O1xuICAgICAgICBcbiAgICBcbiAgICBpZiAoICEgdGFyZ2V0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIHRhcmdldEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKG5hbWUsZnVuYyxib29sKSB7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaEV2ZW50KG5hbWUsZnVuYyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIHRhcmdldEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoICEgc2VsZi5lbmFibGVkICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0YXJnID0gc2VsZi50YXJnZXRFbGVtZW50ID8gc2VsZi50YXJnZXRFbGVtZW50IDogdGFyZ2V0RWxlbWVudDtcbiAgICAgICAgaWYgKHNlbGYubW9tZW50dW0pIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoc2VsZi5tb21lbnR1bSk7XG4gICAgICAgICAgICBzZWxmLm1vbWVudHVtID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb25zID0gbW91c2VQb3NpdGlvbihlLnRvdWNoZXNbMF0pO1xuICAgICAgICAgICAgdmFyIHA7XG4gICAgICAgICAgICBpZiAodGFyZy5ub2RlTmFtZSA9PSAnc3ZnJykge1xuICAgICAgICAgICAgICAgIHAgPSB0YXJnLmNyZWF0ZVNWR1BvaW50KCk7XG4gICAgICAgICAgICAgICAgcC54ID0gcG9zaXRpb25zWzBdO1xuICAgICAgICAgICAgICAgIHAueSA9IHBvc2l0aW9uc1sxXTtcbiAgICAgICAgICAgICAgICB2YXIgcm9vdENUTSA9IHRoaXMuZ2V0U2NyZWVuQ1RNKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5tYXRyaXggPSByb290Q1RNLmludmVyc2UoKTtcbiAgICAgICAgICAgICAgICBwID0gcC5tYXRyaXhUcmFuc2Zvcm0oc2VsZi5tYXRyaXgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwLnggPSBwb3NpdGlvbnNbMF07XG4gICAgICAgICAgICAgICAgcC55ID0gcG9zaXRpb25zWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5vWCA9IHAueDtcbiAgICAgICAgICAgIHNlbGYub1kgPSBwLnk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHNlbGYuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgc2VsZi5kWCA9IHRhcmcuZ2V0UG9zaXRpb24oKVswXTtcbiAgICAgICAgICAgIHNlbGYuZFkgPSB0YXJnLmdldFBvc2l0aW9uKClbMV07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHNlbGYuX21vbWVudHVtX3Nocmlua2VyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgbW9tZW50dW0uc2hpZnQoKTtcbiAgICAgICAgICAgIH0sMjApO1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LmNyZWF0ZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2T2JqID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50cycpO1xuICAgICAgICAgICAgICAgIGV2T2JqLmluaXRFdmVudCgncGFuc3RhcnQnLGZhbHNlLHRydWUpO1xuICAgICAgICAgICAgICAgIHRhcmcuZGlzcGF0Y2hFdmVudChldk9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9LGZhbHNlKTtcblxuXG4gICAgLy8gZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJyxmdW5jdGlvbihlKSB7XG4gICAgLy8gICAgIGNvbnNvbGUubG9nKCd0b3VjaG1vdmUgZm9yIHRoZSBkb2N1bWVudCcpO1xuICAgIC8vICAgICBjb25zb2xlLmxvZyhzZWxmLmRyYWdnaW5nKTtcbiAgICAvLyAgICAgaWYgKCAhIHNlbGYuZHJhZ2dpbmcgKSB7XG4gICAgLy8gICAgICAgICByZXR1cm47XG4gICAgLy8gICAgIH1cbiAgICAvLyAgICAgY29uc29sZS5sb2coXCJFbmRpbmcgdGhlIGRyYWcgZm9yIGRvY3VtZW50IG1vdmVcIik7XG4gICAgLy8gICAgIHNlbGYub1ggPSAwO1xuICAgIC8vICAgICBzZWxmLm9ZID0gMDtcbiAgICAvLyAgICAgc2VsZi5kWCA9IG51bGw7XG4gICAgLy8gICAgIHNlbGYuZFkgPSBudWxsO1xuICAgIC8vICAgICBzZWxmLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgLy8gXG4gICAgLy8gICAgIHZhciB0YXJnID0gc2VsZi50YXJnZXRFbGVtZW50ID8gc2VsZi50YXJnZXRFbGVtZW50IDogdGFyZ2V0RWxlbWVudDsgICAgICBcbiAgICAvLyBcbiAgICAvLyAgICAgaWYgKGRvY3VtZW50LmNyZWF0ZUV2ZW50KSB7XG4gICAgLy8gICAgICAgICB2YXIgZXZPYmogPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnRzJyk7XG4gICAgLy8gICAgICAgICBldk9iai5pbml0RXZlbnQoJ3BhbmVuZCcsZmFsc2UsdHJ1ZSk7XG4gICAgLy8gICAgICAgICB0YXJnLmRpc3BhdGNoRXZlbnQoZXZPYmopO1xuICAgIC8vICAgICB9ICAgICAgXG4gICAgLy8gfSxmYWxzZSk7XG5cbiAgICB0YXJnZXRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoc2VsZi5kcmFnX3pvb20pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5tb21lbnR1bSkge1xuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChzZWxmLm1vbWVudHVtKTtcbiAgICAgICAgICAgIHNlbGYubW9tZW50dW0gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggIT0gMSkge1xuICAgICAgICAgICAgc2VsZi5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRhcmcgPSBzZWxmLnRhcmdldEVsZW1lbnQgPyBzZWxmLnRhcmdldEVsZW1lbnQgOiB0YXJnZXRFbGVtZW50O1xuXG4gICAgICAgIHZhciBwb3NpdGlvbnMgPSBtb3VzZVBvc2l0aW9uKGUudG91Y2hlc1swXSk7XG5cbiAgICAgICAgaWYgKCEgcG9zaXRpb25zIHx8ICEgc2VsZi5tYXRyaXgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwO1xuICAgICAgICBpZiAodGFyZy5ub2RlTmFtZSA9PSAnc3ZnJykge1xuICAgICAgICAgICAgcCA9IHRhcmcuY3JlYXRlU1ZHUG9pbnQoKTtcbiAgICAgICAgICAgIHAueCA9IHBvc2l0aW9uc1swXTtcbiAgICAgICAgICAgIHAueSA9IHBvc2l0aW9uc1sxXTtcbiAgICAgICAgICAgIHAgPSBwLm1hdHJpeFRyYW5zZm9ybShzZWxmLm1hdHJpeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwLnggPSBwb3NpdGlvbnNbMF07XG4gICAgICAgICAgICBwLnkgPSBwb3NpdGlvbnNbMV07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChzZWxmLmRyYWdnaW5nICYmICgoNipNYXRoLmFicyhzZWxmLm9YIC0gcC54KSkgPiBNYXRoLmFicyhzZWxmLm9ZIC0gcC55KSkpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FIC0gUEFTU0lWRVxuICAgICAgICAgICAgLy8gZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzZWxmLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICBzZWxmLm9YID0gMDtcbiAgICAgICAgICAgIHNlbGYub1kgPSAwO1xuICAgICAgICAgICAgc2VsZi5kWCA9IG51bGw7XG4gICAgICAgICAgICBzZWxmLmRZID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9tZW50dW0ubGVuZ3RoID4gMykge1xuICAgICAgICAgICAgbW9tZW50dW0uc3BsaWNlKDIpO1xuICAgICAgICB9XG4gICAgICAgIHRhcmcuc2hpZnRQb3NpdGlvbihwLngscC55KTtcbiAgICAgICAgbW9tZW50dW0ucHVzaCh0YXJnLmdldFBvc2l0aW9uKClbMF0gLSBzZWxmLmRYKTtcbiAgICB9LHtwYXNzaXZlOnRydWV9KTtcbiAgICAvLyBGSVhNRSAtIFBBU1NJVkVcbiAgICBcbiAgICB2YXIgbW9tZW50dW1fZnVuYyA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCAhIHNlbGYuZW5hYmxlZCApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICggISBzZWxmLmRyYWdnaW5nICkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChzZWxmLl9tb21lbnR1bV9zaHJpbmtlcik7XG4gICAgICAgICAgICBtb3VzZVVwKGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0YXJnID0gc2VsZi50YXJnZXRFbGVtZW50ID8gc2VsZi50YXJnZXRFbGVtZW50IDogdGFyZ2V0RWxlbWVudDtcbiAgICAgICAgdmFyIGRlbHRhID0gMDtcbiAgICAgICAgXG4gICAgICAgIGlmIChtb21lbnR1bS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgbGFzdF92YWwgPSBtb21lbnR1bVswXTtcbiAgICAgICAgICAgIG1vbWVudHVtLmZvckVhY2goZnVuY3Rpb24obSkge1xuICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIGxhc3RfdmFsKSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBkZWx0YSArPSBtIC0gbGFzdF92YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RfdmFsID0gbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVsdGEgPSBkZWx0YSAvIG1vbWVudHVtLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhcnQgPSB0YXJnLmdldFBvc2l0aW9uKClbMF07XG4gICAgICAgIHZhciBzdGFydF9kZWx0YSA9IGRlbHRhO1xuICAgICAgICBzZWxmLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChzZWxmLm1vbWVudHVtKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHNlbGYubW9tZW50dW0pO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYubW9tZW50dW0gPSAxO1xuICAgICAgICBsZXQgbW9tZW50ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc3RhcnQgPSB0YXJnLmdldFBvc2l0aW9uKClbMF07XG4gICAgICAgICAgICBpZiAoc2VsZi5kcmFnZ2luZykge1xuICAgICAgICAgICAgICAgIHN0YXJ0ICs9IHNlbGYub1ggLSBzZWxmLmRYO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLm9YID0gMDtcbiAgICAgICAgICAgICAgICBzZWxmLmRYID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmcuc2hpZnRQb3NpdGlvbihzdGFydCtkZWx0YSwwKTtcbiAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnQrZGVsdGE7XG4gICAgICAgICAgICBkZWx0YSA9IGRlbHRhICogMC41O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoZGVsdGEgPiAwICYmIE1hdGguYWJzKHN0YXJ0X2RlbHRhIC8gZGVsdGEpIDwgMTApIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKG1vbWVudCwgdGFyZyk7XG4vLyAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChhcmd1bWVudHMuY2FsbGVlLDUwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5tb21lbnR1bSA9IG51bGw7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChzZWxmLl9tb21lbnR1bV9zaHJpbmtlcik7XG4gICAgICAgICAgICAgICAgbW91c2VVcChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbW9tZW50KCk7XG4gICAgfTtcbiAgICBcbiAgICB0YXJnZXRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJyxtb21lbnR1bV9mdW5jLGZhbHNlKTtcblxuXG4gICAgaWYgKHRhcmdldEVsZW1lbnQubm9kZU5hbWUgPT0gJ3N2ZycpIHtcbiAgICAgICAgdGFyZ2V0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBzdmdNb3VzZURvd24sIGZhbHNlKTtcbiAgICAgICAgdGFyZ2V0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBzdmdNb3VzZU1vdmUsIGZhbHNlKTsgICAgICAgIFxuICAgICAgICB0YXJnZXRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLG1vdXNlVXAsZmFsc2UpO1xuICAgICAgICB0YXJnZXRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0Jyxtb3VzZU91dCwgZmFsc2UpOyBcbiAgICAgICAgaWYgKHNlbGYudGFyZ2V0RWxlbWVudCkge1xuICAgICAgICAgICAgc2VsZi50YXJnZXRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0Jyxtb3VzZU91dCxmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGFyZ2V0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsZnVuY3Rpb24oZXYpIHsgZXYucHJldmVudERlZmF1bHQoKTsgZXYuc3RvcFByb3BhZ2F0aW9uKCk7IH0sZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbW91c2VEb3duLCBmYWxzZSk7XG4gICAgICAgIHRhcmdldEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbW91c2VNb3ZlLCBmYWxzZSk7ICAgICAgICBcbiAgICAgICAgdGFyZ2V0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbW91c2VVcCwgZmFsc2UpOyAgICAgICAgXG4gICAgICAgIHRhcmdldEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLG1vdXNlT3V0LCBmYWxzZSk7XG4gICAgfVxuXG59O1xuXG5cbkRyYWdnZXIuYWRkVG91Y2hab29tQ29udHJvbHMgPSBmdW5jdGlvbih6b29tRWxlbWVudCx0b3VjaEVsZW1lbnQsY29udHJvbGxlcikge1xuICAgIGlmICggISBjb250cm9sbGVyICkge1xuICAgICAgICBjb250cm9sbGVyID0ge1wiZW5hYmxlZFwiIDogdHJ1ZX07XG4gICAgfVxuICAgIERyYWdnZXIucHJvdG90eXBlLmFkZFRvdWNoWm9vbUNvbnRyb2xzLmNhbGwoY29udHJvbGxlcix6b29tRWxlbWVudCx0b3VjaEVsZW1lbnQpO1xuICAgIHJldHVybiBjb250cm9sbGVyO1xufTtcblxuRHJhZ2dlci5wcm90b3R5cGUuYWRkVG91Y2hab29tQ29udHJvbHMgPSBmdW5jdGlvbih6b29tRWxlbWVudCx0b3VjaEVsZW1lbnQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGxhc3RfdG91Y2hfc3RhcnQgPSBudWxsO1xuICAgIHZhciB4Zm9ybSA9IG51bGw7XG4gICAgdmFyIG1heF95ID0gbnVsbDtcbiAgICB2YXIgbW91c2VQb3NpdGlvbiA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICB2YXIgcG9zeCA9IDA7XG4gICAgICAgIHZhciBwb3N5ID0gMDtcbiAgICAgICAgaWYgKCFldnQpIHtcbiAgICAgICAgICAgIGV2dCA9IHdpbmRvdy5ldmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZ0LnBhZ2VYIHx8IGV2dC5wYWdlWSkgICAgIHtcbiAgICAgICAgICAgIHBvc3ggPSBldnQucGFnZVg7XG4gICAgICAgICAgICBwb3N5ID0gZXZ0LnBhZ2VZO1xuICAgICAgICB9IGVsc2UgaWYgKGV2dC5jbGllbnRYIHx8IGV2dC5jbGllbnRZKSAge1xuICAgICAgICAgICAgcG9zeCA9IGV2dC5jbGllbnRYICsgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0ICsgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQ7XG4gICAgICAgICAgICBwb3N5ID0gZXZ0LmNsaWVudFkgKyBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCArIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYudGFyZ2V0RWxlbWVudCkge1xuICAgICAgICAgICAgcG9zeCA9IGV2dC5zY3JlZW5YO1xuICAgICAgICAgICAgcG9zeSA9IGV2dC5zY3JlZW5ZO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbIHBvc3gsIHBvc3kgXTtcbiAgICB9O1xuXG4gICAgdmFyIGRyYWdfem9vbV9tb3ZlID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIGlmICggISBzZWxmLmVuYWJsZWQgfHwgISBzZWxmLmRyYWdfem9vbSApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZ0LnRvdWNoZXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbnMgPSBtb3VzZVBvc2l0aW9uKGV2dC50b3VjaGVzWzBdKTtcbiAgICAgICAgICAgIHZhciBwID0ge307XG4gICAgICAgICAgICBwLnggPSBwb3NpdGlvbnNbMF07XG4gICAgICAgICAgICBwLnkgPSBwb3NpdGlvbnNbMV07XG5cbiAgICAgICAgICAgIGlmICh0b3VjaEVsZW1lbnQubm9kZU5hbWUgPT0gJ3N2ZycpIHtcbiAgICAgICAgICAgICAgICBwID0gdG91Y2hFbGVtZW50LmNyZWF0ZVNWR1BvaW50KCk7XG4gICAgICAgICAgICAgICAgcC54ID0gcG9zaXRpb25zWzBdO1xuICAgICAgICAgICAgICAgIHAueSA9IHBvc2l0aW9uc1sxXTtcbiAgICAgICAgICAgICAgICBwID0gcC5tYXRyaXhUcmFuc2Zvcm0oeGZvcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgem9vbUVsZW1lbnQuem9vbSA9IHNlbGYuem9vbV9zdGFydCAqIE1hdGgucG93KDEwLCAocC55IC0gem9vbUVsZW1lbnQuem9vbUNlbnRlci55KS9tYXhfeSApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBkcmFnX3pvb21fZW5kID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHRvdWNoRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLGRyYWdfem9vbV9tb3ZlKTtcbiAgICAgICAgdG91Y2hFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJyxkcmFnX3pvb21fZW5kKTtcbiAgICAgICAgc2VsZi5kcmFnX3pvb20gPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgdG91Y2hFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCAhIHNlbGYuZW5hYmxlZCApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICBpZiAoKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gbGFzdF90b3VjaF9zdGFydCkgPD0gMzAwKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5kcmFnX3pvb20gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNlbGYuem9vbV9zdGFydCA9IHpvb21FbGVtZW50Lnpvb207XG5cbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb25zID0gbW91c2VQb3NpdGlvbihlLnRvdWNoZXNbMF0pO1xuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbnMyID0gbW91c2VQb3NpdGlvbihlLnRvdWNoZXNbMF0pO1xuICAgICAgICAgICAgICAgIHZhciBwO1xuICAgICAgICAgICAgICAgIGlmICh0b3VjaEVsZW1lbnQubm9kZU5hbWUgPT0gJ3N2ZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHRvdWNoRWxlbWVudC5jcmVhdGVTVkdQb2ludCgpO1xuICAgICAgICAgICAgICAgICAgICBwLnggPSAwLjUqKHBvc2l0aW9uc1swXSArIHBvc2l0aW9uczJbMF0pO1xuICAgICAgICAgICAgICAgICAgICBwLnkgPSAwLjUqKHBvc2l0aW9uc1sxXSArIHBvc2l0aW9uczJbMV0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm9vdENUTSA9IHRoaXMuZ2V0U2NyZWVuQ1RNKCk7XG4gICAgICAgICAgICAgICAgICAgIHhmb3JtID0gcm9vdENUTS5pbnZlcnNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLm1hdHJpeFRyYW5zZm9ybSh4Zm9ybSk7XG4gICAgICAgICAgICAgICAgICAgIG1heF95ID0gcGFyc2VJbnQodG91Y2hFbGVtZW50LmdldEF0dHJpYnV0ZSgndmlld0JveCcpLnNwbGl0KCcgJylbM10pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHAueCA9IDAuNSoocG9zaXRpb25zWzBdICsgcG9zaXRpb25zMlswXSk7XG4gICAgICAgICAgICAgICAgICAgIHAueSA9IDAuNSoocG9zaXRpb25zWzFdICsgcG9zaXRpb25zMlsxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHpvb21FbGVtZW50Lnpvb21DZW50ZXIgPSBwO1xuICAgICAgICAgICAgICAgIHRvdWNoRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLGRyYWdfem9vbV9tb3ZlLHtwYXNzaXZlOnRydWV9KTtcbiAgICAgICAgICAgICAgICB0b3VjaEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLGRyYWdfem9vbV9lbmQsZmFsc2UpO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhc3RfdG91Y2hfc3RhcnQgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID09IDIpIHtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbnMgPSBtb3VzZVBvc2l0aW9uKGUudG91Y2hlc1swXSk7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb25zMiA9IG1vdXNlUG9zaXRpb24oZS50b3VjaGVzWzFdKTtcbiAgICAgICAgICAgIHZhciBwO1xuICAgICAgICAgICAgaWYgKHRvdWNoRWxlbWVudC5ub2RlTmFtZSA9PSAnc3ZnJykge1xuICAgICAgICAgICAgICAgIHAgPSB0b3VjaEVsZW1lbnQuY3JlYXRlU1ZHUG9pbnQoKTtcbiAgICAgICAgICAgICAgICBwLnggPSAwLjUqKHBvc2l0aW9uc1swXSArIHBvc2l0aW9uczJbMF0pO1xuICAgICAgICAgICAgICAgIHAueSA9IDAuNSoocG9zaXRpb25zWzFdICsgcG9zaXRpb25zMlsxXSk7XG4gICAgICAgICAgICAgICAgdmFyIHJvb3RDVE0gPSB0aGlzLmdldFNjcmVlbkNUTSgpO1xuICAgICAgICAgICAgICAgIHNlbGYubWF0cml4ID0gcm9vdENUTS5pbnZlcnNlKCk7XG4gICAgICAgICAgICAgICAgcCA9IHAubWF0cml4VHJhbnNmb3JtKHNlbGYubWF0cml4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcC54ID0gMC41Kihwb3NpdGlvbnNbMF0gKyBwb3NpdGlvbnMyWzBdKTtcbiAgICAgICAgICAgICAgICBwLnkgPSAwLjUqKHBvc2l0aW9uc1sxXSArIHBvc2l0aW9uczJbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgem9vbUVsZW1lbnQuem9vbUNlbnRlciA9IHA7ICBcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH0sZmFsc2UpO1xuXG5cbiAgICAvLyB0b3VjaEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZ2VzdHVyZXN0YXJ0JyxmdW5jdGlvbihlKSB7XG4gICAgSGFtbWVyKHRvdWNoRWxlbWVudCkub24oXCJ0b3VjaFwiLGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCAhIHNlbGYuZW5hYmxlZCApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyB6b29tRWxlbWVudC56b29tTGVmdCA9IG51bGw7XG4gICAgICAgIHZhciB6b29tU3RhcnQgPSB6b29tRWxlbWVudC56b29tO1xuXG4gICAgICAgIHZhciB6b29tc2NhbGUgPSBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgaWYgKCB6b29tRWxlbWVudC56b29tQ2VudGVyICkge1xuICAgICAgICAgICAgICAgIHpvb21FbGVtZW50Lnpvb20gPSB6b29tU3RhcnQgKiBldi5nZXN0dXJlLnNjYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgSGFtbWVyKHRvdWNoRWxlbWVudCkub24oJ3BpbmNoJyx6b29tc2NhbGUsZmFsc2UpO1xuICAgICAgICBsZXQgaGFtbWVyX3JlbGVhc2UgPSBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgSGFtbWVyKHRvdWNoRWxlbWVudCkub2ZmKCdwaW5jaCcsem9vbXNjYWxlKTtcbiAgICAgICAgICAgIEhhbW1lcih0b3VjaEVsZW1lbnQpLm9mZigncmVsZWFzZScsaGFtbWVyX3JlbGVhc2UpO1xuICAgICAgICAgICAgem9vbUVsZW1lbnQuem9vbUNlbnRlciA9IG51bGw7XG4gICAgICAgICAgICB6b29tRWxlbWVudC56b29tTGVmdCA9IG51bGw7XG4gICAgICAgICAgICBiZWFuLmZpcmUoem9vbUVsZW1lbnQsJ2dlc3R1cmVlbmQnKVxuICAgICAgICB9O1xuICAgICAgICBIYW1tZXIodG91Y2hFbGVtZW50KS5vbigncmVsZWFzZScsaGFtbWVyX3JlbGVhc2UsZmFsc2UpO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSxmYWxzZSk7XG5cbn07XG5cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCB0aGF0IGltcGxlbWVudHMgYSB6b29tIGF0dHJpYnV0ZSwgY3JlYXRlcyBhIGRpdiB0aGF0IGNvbnRhaW5zIGNvbnRyb2xzIGZvciBjb250cm9sbGluZyB0aGUgem9vbSBhdHRyaWJ1dGUuIFRoZVxuICogem9vbUVsZW1lbnQgbXVzdCBoYXZlIGEgem9vbSBhdHRyaWJ1dGUsIGFuZCBjYW4gZmlyZSB0aGUgem9vbUNoYW5nZSBldmVudCB3aGVuZXZlciB0aGUgem9vbSB2YWx1ZSBpcyBjaGFuZ2VkIG9uIHRoZSBvYmplY3QuIFRoZVxuICogc2Nyb2xsd2hlZWwgaXMgY29ubmVjdGVkIHRvIHRoaXMgZWxlbWVudCBzbyB0aGF0IHdoZW4gdGhlIG1vdXNlIGhvdmVycyBvdmVyIHRoZSBjb250cm9scywgaXQgY2FuIGNvbnRyb2wgdGhlIHpvb20gdXNpbmcgb25seVxuICogdGhlIHNjcm9sbCB3aGVlbC5cbiAqIEBwYXJhbSB7T2JqZWN0fSB6b29tRWxlbWVudCBFbGVtZW50IHRvIGNvbnRyb2wgdGhlIHpvb21pbmcgZm9yLlxuICogQHBhcmFtIHtOdW1iZXJ9IG1pbiBNaW5pbXVtIHZhbHVlIGZvciB0aGUgem9vbSBhdHRyaWJ1dGUgKGRlZmF1bHQgMClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXggTWF4aW11bSB2YWx1ZSBmb3IgdGhlIHpvb20gYXR0cmlidXRlIChkZWZhdWx0IDEwKVxuICogQHBhcmFtIHtOdW1iZXJ9IHByZWNpc2lvbiBTdGVwIHByZWNpc2lvbiBmb3IgdGhlIHpvb20gY29udHJvbCAoZGVmYXVsdCAwLjUpXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgRGVmYXVsdCB2YWx1ZSBmb3IgdGhpcyBjb250cm9sXG4gKiBAcmV0dXJucyBESVYgZWxlbWVudCBjb250YWluaW5nIHRoZSBjb250cm9sc1xuICogQHR5cGUgRWxlbWVudFxuICogQHNlZSBHT01hcC5EaWFncmFtI2V2ZW50Onpvb21DaGFuZ2VcbiAqL1xuRHJhZ2dlci5hZGRab29tQ29udHJvbHMgPSBmdW5jdGlvbih6b29tRWxlbWVudCxtaW4sbWF4LHByZWNpc2lvbix2YWx1ZSkge1xuICAgIG1pbiA9IG1pbiB8fCAwO1xuICAgIG1heCA9IG1heCB8fCAxMDtcbiAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24gfHwgMC41O1xuICAgIHZhbHVlID0gdmFsdWUgfHwgem9vbUVsZW1lbnQuem9vbSB8fCBtaW47IFxuICAgIFxuICAgIHZhciBjb250cm9sc19jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBcbiAgICB2YXIgem9vbUluID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICB6b29tSW4uc2V0QXR0cmlidXRlKCd0eXBlJywnYnV0dG9uJyk7XG4gICAgem9vbUluLnNldEF0dHJpYnV0ZSgndmFsdWUnLCcrJyk7XG4gICAgdmFyIHpvb21PdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIHpvb21PdXQuc2V0QXR0cmlidXRlKCd0eXBlJywnYnV0dG9uJyk7XG4gICAgem9vbU91dC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywnLScpO1xuICAgIHZhciByZXNldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgcmVzZXQuc2V0QXR0cmlidXRlKCd0eXBlJywnYnV0dG9uJyk7XG4gICAgcmVzZXQuc2V0QXR0cmlidXRlKCd2YWx1ZScsJ1Jlc2V0Jyk7XG5cbiAgICBjb250cm9sc19jb250YWluZXIuYXBwZW5kQ2hpbGQocmVzZXQpOyAgICBcblxuICAgIHJlc2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJyxmdW5jdGlvbigpIHtcbiAgICAgICAgem9vbUVsZW1lbnQuem9vbSA9IHpvb21FbGVtZW50LmRlZmF1bHRab29tIHx8IHZhbHVlO1xuICAgIH0sZmFsc2UpO1xuICAgIFxuICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgcmFuZ2Uuc2V0QXR0cmlidXRlKCdtaW4nLG1pbik7XG4gICAgcmFuZ2Uuc2V0QXR0cmlidXRlKCdtYXgnLG1heCk7XG4gICAgcmFuZ2Uuc2V0QXR0cmlidXRlKCdzdGVwJyxwcmVjaXNpb24pO1xuICAgIHJhbmdlLnNldEF0dHJpYnV0ZSgndmFsdWUnLHZhbHVlKTsgXG4gICAgcmFuZ2Uuc2V0QXR0cmlidXRlKCd0eXBlJywncmFuZ2UnKTtcbiAgICByYW5nZS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywnLXdlYmtpdC1hcHBlYXJhbmNlOiBzbGlkZXItaG9yaXpvbnRhbDsgd2lkdGg6IDEwMCU7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAwcHg7IGJvdHRvbTogMHB4OyBtYXJnaW4tdG9wOiAwLjVlbTsgbGVmdDogMTAwJTsgbWFyZ2luLWxlZnQ6IC0wLjVlbTsnKTtcblxuICAgIGlmIChyYW5nZS50eXBlID09ICdyYW5nZScpIHtcbiAgICAgICAgXG4gICAgICAgIHJhbmdlLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB6b29tRWxlbWVudC56b29tID0gdGhpcy52YWx1ZTtcbiAgICAgICAgfSxmYWxzZSk7XG4gICAgICAgIFxuICAgICAgICB2YXIgZXZGdW5jdGlvbiA9IG51bGw7XG4gICAgICAgIGlmICh6b29tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBldkZ1bmN0aW9uID0gem9vbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcjtcbiAgICAgICAgfSBlbHNlIGlmICh6b29tRWxlbWVudC5iaW5kKXtcbiAgICAgICAgICAgIGV2RnVuY3Rpb24gPSB6b29tRWxlbWVudC5iaW5kO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBldkZ1bmN0aW9uLmFwcGx5KHpvb21FbGVtZW50LFsnem9vbUNoYW5nZScsZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByYW5nZS52YWx1ZSA9IHpvb21FbGVtZW50Lnpvb207XG4gICAgICAgIH0sZmFsc2VdKTtcbiAgICAgICAgXG5cbiAgICAgICAgcmVzZXQuc3R5bGUubWFyZ2luID0gJzBweCc7XG4gICAgICAgIHJlc2V0LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICByZXNldC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIHJlc2V0LnN0eWxlLnRvcCA9ICcwcHgnO1xuICAgICAgICBcbiAgICAgICAgY29udHJvbHNfY29udGFpbmVyLmFwcGVuZENoaWxkKHJhbmdlKTtcbiAgICAgICAgY29udHJvbHNfY29udGFpbmVyLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoISB6b29tSW4uYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgdmFyIGFkZGV2bGlzID0gZnVuY3Rpb24obmFtZSxmdW5jKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hFdmVudChuYW1lLGZ1bmMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHpvb21Jbi5hZGRFdmVudExpc3RlbmVyID0gYWRkZXZsaXM7XG4gICAgICAgICAgICByZXNldC5hZGRFdmVudExpc3RlbmVyID0gYWRkZXZsaXM7XG4gICAgICAgICAgICB6b29tT3V0LmFkZEV2ZW50TGlzdGVuZXIgPSBhZGRldmxpczsgICAgICAgIFxuICAgICAgICB9XG4gICAgICAgIHpvb21Jbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB6b29tRWxlbWVudC56b29tICs9IHByZWNpc2lvbjtcbiAgICAgICAgfSxmYWxzZSk7XG4gICAgICAgIHpvb21PdXQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgem9vbUVsZW1lbnQuem9vbSAtPSBwcmVjaXNpb247XG4gICAgICAgIH0sZmFsc2UpO1xuXG4gICAgICAgIHpvb21Jbi5zdHlsZS5tYXJnaW4gPSAnMHB4JztcbiAgICAgICAgem9vbUluLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICB6b29tSW4uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICB6b29tSW4uc3R5bGUudG9wID0gJzBweCc7XG4gICAgICAgIHpvb21Jbi5zdHlsZS5sZWZ0ID0gJzI5cHgnO1xuXG4gICAgICAgIHpvb21PdXQuc3R5bGUubWFyZ2luID0gJzBweCc7XG4gICAgICAgIHpvb21PdXQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIHpvb21PdXQuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICB6b29tT3V0LnN0eWxlLnRvcCA9ICcwcHgnO1xuXG4gICAgICAgIHJlc2V0LnN0eWxlLm1hcmdpbiA9ICcwcHgnO1xuICAgICAgICByZXNldC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgcmVzZXQuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICByZXNldC5zdHlsZS50b3AgPSAnMjNweCc7XG4gICAgICAgIHJlc2V0LnN0eWxlLmxlZnQgPSAnM3B4JztcblxuICAgICAgICBjb250cm9sc19jb250YWluZXIuYXBwZW5kQ2hpbGQoem9vbU91dCk7XG4gICAgICAgIGNvbnRyb2xzX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh6b29tSW4pO1xuICAgICAgICBjb250cm9sc19jb250YWluZXIuYXBwZW5kQ2hpbGQocmVzZXQpO1xuICAgIH1cblxuICAgIHRoaXMuYWRkU2Nyb2xsWm9vbUNvbnRyb2xzKHpvb21FbGVtZW50LGNvbnRyb2xzX2NvbnRhaW5lcixwcmVjaXNpb24pO1xuXG4gICAgcmV0dXJuIGNvbnRyb2xzX2NvbnRhaW5lcjtcbn07XG5cbkRyYWdnZXIuYWRkU2Nyb2xsQmFyID0gZnVuY3Rpb24odGFyZ2V0LGNvbnRyb2xFbGVtZW50LHNjcm9sbENvbnRhaW5lcikge1xuICAgIHJldHVybjtcbiAgICB2YXIgc2Nyb2xsZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB3aGlsZSAoc2Nyb2xsQ29udGFpbmVyLmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBzY3JvbGxDb250YWluZXIucmVtb3ZlQ2hpbGQoc2Nyb2xsQ29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICBzY3JvbGxDb250YWluZXIuYXBwZW5kQ2hpbGQoc2Nyb2xsZXIpO1xuICAgIGlmICggISBzY3JvbGxDb250YWluZXIuc3R5bGUucG9zaXRpb24gKSB7XG4gICAgICAgIHNjcm9sbENvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgfVxuICAgIHNjcm9sbENvbnRhaW5lci5zdHlsZS5vdmVyZmxvd1ggPSAnc2Nyb2xsJztcbiAgICBzY3JvbGxDb250YWluZXIuc3R5bGUub3ZlcmZsb3dZID0gJ2hpZGRlbic7XG5cbiAgICBzY3JvbGxlci5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgc2Nyb2xsZXIuc3R5bGUubGVmdCA9ICcwcHgnO1xuICAgIHNjcm9sbGVyLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIHNjcm9sbGVyLnN0eWxlLmhlaWdodD0gJzEwMCUnO1xuXG4gICAgYmVhbi5yZW1vdmUoc2Nyb2xsQ29udGFpbmVyLCdzY3JvbGwnKTtcbiAgICBiZWFuLnJlbW92ZShzY3JvbGxDb250YWluZXIsJ21vdXNlZW50ZXInKTtcbiAgICBiZWFuLmFkZChzY3JvbGxDb250YWluZXIsJ21vdXNlZW50ZXInLGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2l6ZSA9IDEwMCp0YXJnZXQuZ2V0VG90YWxMZW5ndGgoKSAvICh0YXJnZXQuZ2V0VmlzaWJsZUxlbmd0aCgpKTtcbiAgICAgICAgc2Nyb2xsZXIuY2FjaGVkX3dpZHRoID0gc2Nyb2xsZXIuY2xpZW50V2lkdGggLyBzaXplO1xuICAgICAgICBkaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIHNjcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0ICs9IDE7XG4gICAgICAgIHNjcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0IC09IDE7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB9LDApO1xuICAgICAgICBiZWFuLnJlbW92ZShzY3JvbGxDb250YWluZXIsJ3Njcm9sbCcsc2Nyb2xsX2Z1bmMpO1xuICAgICAgICBiZWFuLmFkZChzY3JvbGxDb250YWluZXIsJ3Njcm9sbCcsc2Nyb2xsX2Z1bmMpO1xuICAgIH0pO1xuICAgIHZhciBkaXNhYmxlZCA9IGZhbHNlO1xuXG4gICAgaWYgKHdpbmRvdy5tYXRjaE1lZGlhKSB7XG4gICAgICAgIHdpbmRvdy5tYXRjaE1lZGlhKCdwcmludCcpLmFkZExpc3RlbmVyKGZ1bmN0aW9uKG1hdGNoZXIpIHtcbiAgICAgICAgICAgIGRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sMCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgc2Nyb2xsX2Z1bmMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGRpc2FibGVkIHx8ICEgY29uc29sZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb2N1bWVudC5jcmVhdGVFdmVudCkge1xuICAgICAgICAgICAgdmFyIGV2T2JqID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50cycpO1xuICAgICAgICAgICAgZXZPYmouaW5pdEV2ZW50KCdwYW5zdGFydCcsZmFsc2UsdHJ1ZSk7XG4gICAgICAgICAgICBjb250cm9sRWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2T2JqKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2l6ZSA9IDEwMCp0YXJnZXQuZ2V0VG90YWxMZW5ndGgoKSAvICh0YXJnZXQuZ2V0VmlzaWJsZUxlbmd0aCgpKTtcbiAgICAgICAgdmFyIHdpZHRoID0gc2Nyb2xsZXIuY2FjaGVkX3dpZHRoID8gcGFyc2VJbnQoc2Nyb2xsZXIuY2FjaGVkX3dpZHRoICogc2l6ZSkgOiBzY3JvbGxlci5jbGllbnRXaWR0aCA7XG4gICAgICAgIHRhcmdldC5zZXRMZWZ0UG9zaXRpb24ocGFyc2VJbnQoc2Nyb2xsQ29udGFpbmVyLnNjcm9sbExlZnQgKiB0YXJnZXQuZ2V0VG90YWxMZW5ndGgoKSAvIHdpZHRoKSk7XG4gICAgICAgIGJlYW4uZmlyZShjb250cm9sRWxlbWVudCwncGFuZW5kJyk7XG4gICAgfTtcblxuICAgIGJlYW4uYWRkKHNjcm9sbENvbnRhaW5lciwnc2Nyb2xsJyxzY3JvbGxfZnVuYyk7XG5cbiAgICB2YXIgbGVmdF9zZXR0ZXI7XG5cbiAgICBiZWFuLmFkZChjb250cm9sRWxlbWVudCwncGFuJyxmdW5jdGlvbigpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUobGVmdF9zZXR0ZXIpO1xuICAgICAgICB2YXIgc2l6ZSA9IDEwMCp0YXJnZXQuZ2V0VG90YWxMZW5ndGgoKSAvICh0YXJnZXQuZ2V0VmlzaWJsZUxlbmd0aCgpKTtcbiAgICAgICAgc2Nyb2xsZXIuc3R5bGUud2lkdGggPSBwYXJzZUludChzaXplKSsnJSc7XG4gICAgICAgIHZhciB3aWR0aCA9IHNjcm9sbGVyLmNhY2hlZF93aWR0aCA/IHBhcnNlSW50KHNjcm9sbGVyLmNhY2hlZF93aWR0aCAqIHNpemUpIDogc2Nyb2xsZXIuY2xpZW50V2lkdGggO1xuICAgICAgICBzY3JvbGxlci5jYWNoZWRfd2lkdGggPSB3aWR0aCAvIHNpemU7XG5cbiAgICAgICAgdmFyIGxlZnRfc2hpZnQgPSBwYXJzZUludCh3aWR0aCAqICh0YXJnZXQuZ2V0TGVmdFBvc2l0aW9uKCkgLyB0YXJnZXQuZ2V0VG90YWxMZW5ndGgoKSApKTtcbiAgICAgICAgYmVhbi5yZW1vdmUoc2Nyb2xsQ29udGFpbmVyLCdzY3JvbGwnLHNjcm9sbF9mdW5jKTtcbiAgICAgICAgbGVmdF9zZXR0ZXIgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBSZW5kZXJpbmcgYm90dGxlbmVja1xuICAgICAgICAgICAgc2Nyb2xsQ29udGFpbmVyLnNjcm9sbExlZnQgPSBsZWZ0X3NoaWZ0O1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQ29ubmVjdCB0aGUgc2Nyb2xsIHdoZWVsIHRvIHRoZSBjb250cm9scyB0byBjb250cm9sIHpvb21cbiAqL1xuRHJhZ2dlci5hZGRTY3JvbGxab29tQ29udHJvbHMgPSBmdW5jdGlvbih0YXJnZXQsY29udHJvbEVsZW1lbnQscHJlY2lzaW9uKSB7XG4gICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uIHx8IDAuNTtcbiAgICB2YXIgc2VsZjtcblxuICAgIGlmICh0aGlzLmVuYWJsZWQgPT09IG51bGwgKSB7XG4gICAgICAgIHNlbGYgPSB7J2VuYWJsZWQnIDogdHJ1ZSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYgPSB0aGlzO1xuICAgIH1cbiAgICB2YXIgaG9va0V2ZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgaWYgKHR5cGVvZihlbGVtZW50KSA9PSAnc3RyaW5nJykge1xuICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICBpZiAoZXZlbnROYW1lID09ICdtb3VzZXdoZWVsJykge1xuICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCBjYWxsYmFjaywgZmFsc2UpOyAgXG4gICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5hdHRhY2hFdmVudCkge1xuICAgICAgICBlbGVtZW50LmF0dGFjaEV2ZW50KFwib25cIiArIGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH07XG5cblxuICAgIHZhciBtb3VzZVBvc2l0aW9uID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgaWYgKCAhIHNlbGYuZW5hYmxlZCApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHBvc3ggPSAwO1xuICAgICAgICAgIHZhciBwb3N5ID0gMDtcbiAgICAgICAgICBpZiAoIWV2dCkge1xuICAgICAgICAgICAgICBldnQgPSB3aW5kb3cuZXZlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChldnQucGFnZVggfHwgZXZ0LnBhZ2VZKSAgIHtcbiAgICAgICAgICAgICAgcG9zeCA9IGV2dC5wYWdlWDtcbiAgICAgICAgICAgICAgcG9zeSA9IGV2dC5wYWdlWTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGV2dC5jbGllbnRYIHx8IGV2dC5jbGllbnRZKSAgICB7XG4gICAgICAgICAgICAgIHBvc3ggPSBldnQuY2xpZW50WCArIGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCArIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgICBwb3N5ID0gZXZ0LmNsaWVudFkgKyBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCArIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHAgPSB7fTtcblxuICAgICAgICAgIGlmIChjb250cm9sRWxlbWVudC5ub2RlTmFtZSA9PSAnc3ZnJykge1xuICAgICAgICAgICAgICBwID0gY29udHJvbEVsZW1lbnQuY3JlYXRlU1ZHUG9pbnQoKTtcbiAgICAgICAgICAgICAgcC54ID0gcG9zeDtcbiAgICAgICAgICAgICAgcC55ID0gcG9zeTtcbiAgICAgICAgICAgICAgLyogRml4IGZvciBtb3VzZSBwb3NpdGlvbiBpbiBmaXJlZm94IC0gaHR0cDovL2pzZmlkZGxlLm5ldC9KTktnUi82LyAqL1xuICAgICAgICAgICAgICB2YXIgcm9vdENUTSA9IGNvbnRyb2xFbGVtZW50LmZpcnN0RWxlbWVudENoaWxkLmdldFNjcmVlbkNUTSgpO1xuICAgICAgICAgICAgICBzZWxmLm1hdHJpeCA9IHJvb3RDVE0uaW52ZXJzZSgpO1xuICAgICAgICAgICAgICBwID0gcC5tYXRyaXhUcmFuc2Zvcm0oc2VsZi5tYXRyaXgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHAueCA9IHBvc3g7XG4gICAgICAgICAgICAgIHAueSA9IHBvc3k7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwO1xuICAgIH07XG5cbiAgICB2YXIgbW91c2VXaGVlbCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICggISBzZWxmLmVuYWJsZWQgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGUgPSBlID8gZSA6IHdpbmRvdy5ldmVudDtcbiAgICAgIHZhciB3aGVlbERhdGEgPSBlLmRldGFpbCA/IGUuZGV0YWlsICogLTEgOiBlLndoZWVsRGVsdGE7XG4gICAgICBpZiAoICEgd2hlZWxEYXRhICkge1xuICAgICAgICB3aGVlbERhdGEgPSBlLmRlbHRhWTtcbiAgICAgIH1cbiAgICAgIHRhcmdldC56b29tQ2VudGVyID0gbW91c2VQb3NpdGlvbihlKTtcblxuICAgICAgaWYgKHdoZWVsRGF0YSA+IDApIHtcbiAgICAgICAgdGFyZ2V0Lnpvb20gPSB0YXJnZXQuem9vbSArPSBwcmVjaXNpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXQuem9vbSA9IHRhcmdldC56b29tIC09IHByZWNpc2lvbjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgXG4gICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgdmFyIGlzRkYgPSBmYWxzZTtcblxuICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0dlY2tvJykgPj0gMCkge1xuICAgICAgaXNGRiA9IHBhcnNlRmxvYXQobmF2aWdhdG9yLnVzZXJBZ2VudC5zcGxpdCgnRmlyZWZveC8nKVsxXSkgfHwgdW5kZWZpbmVkO1xuICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgXG5cbiAgICBpZiAoaXNGRiAmJiAodHlwZW9mIHN2Z3dlYiAhPSAndW5kZWZpbmVkJykmJiBzdmd3ZWIuZ2V0SGFuZGxlclR5cGUoKSA9PSAnbmF0aXZlJykge1xuICAgICAgaG9va0V2ZW50KGNvbnRyb2xFbGVtZW50LCAnbW91c2V3aGVlbCcsXG4gICAgICAgICAgICAgICAgbW91c2VXaGVlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhvb2tFdmVudChjb250cm9sRWxlbWVudCwgJ21vdXNld2hlZWwnLCBtb3VzZVdoZWVsKTtcbiAgICB9XG5cbiAgICBob29rRXZlbnQoY29udHJvbEVsZW1lbnQsJ21vdXNlbW92ZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCEgc2VsZi5lbmFibGVkICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXJnZXQuem9vbUNlbnRlciAmJiBNYXRoLmFicyh0YXJnZXQuem9vbUNlbnRlci54IC0gbW91c2VQb3NpdGlvbihlKS54KSA+IDEwMCkge1xuICAgICAgICAgICAgdGFyZ2V0Lnpvb21DZW50ZXIgPSBudWxsO1xuICAgICAgICAgICAgdGFyZ2V0Lnpvb21MZWZ0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNlbGY7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBEcmFnZ2VyO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTs7O0FBSUE7QUFDQTtBQUVBOzs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7O0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../gator/js/lib/Dragger.js\n")},"../gator/js/lib/GatorComponent.js":
/*!*****************************************!*\
  !*** ../gator/js/lib/GatorComponent.js ***!
  \*****************************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Dragger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Dragger */ \"../gator/js/lib/Dragger.js\");\n/* harmony import */ var _CondensedSequenceRenderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CondensedSequenceRenderer */ \"../gator/js/lib/CondensedSequenceRenderer.js\");\n/* harmony import */ var _Service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Service */ \"../gator/js/lib/Service.js\");\n/* harmony import */ var _MASCP__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MASCP */ \"../gator/js/lib/MASCP.js\");\n\n\n\n\nconst component_symbol = Symbol('component');\n\nclass DraggableRenderer extends _CondensedSequenceRenderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n  constructor(container, component) {\n    super(container);\n    this[component_symbol] = component;\n  }\n\n  getVisibleLength() {\n    return this.rightVisibleResidue() - this.leftVisibleResidue();\n  }\n\n  getTotalLength() {\n    return this.sequence.length;\n  }\n\n  getLeftPosition() {\n    return this.leftVisibleResidue();\n  }\n\n  setLeftPosition(pos) {\n    return this.setLeftVisibleResidue(pos);\n  }\n\n  get selecting() {\n    return this[component_symbol].selecting;\n  }\n\n}\n\nconst tmpl = document.createElement('template');\ntmpl.innerHTML = \"\\n<style>\\n  :host {\\n    display: block;\\n    position: relative;\\n  }\\n  :host([resizeable]) {\\n    resize: both;\\n    overflow: auto;\\n    padding-right: 5px;\\n    padding-bottom: 5px;\\n  }\\n  #container, .widget_contents {\\n    width: 100%;\\n    height: 100%;\\n  }\\n  #container {\\n  }\\n</style>\\n<div class=\\\"widget_contents\\\" >\\n  <div id=\\\"container\\\">\\n  </div>\\n</div>\\n<slot></slot>\\n\";\nconst interactive_symb = Symbol('interactive');\n\nclass InteractiveState {\n  constructor(component) {\n    this.component = component;\n  }\n\n  get enabled() {\n    return this.component.interactive && !this.component.selecting;\n  }\n\n  set enabled(toggle) {\n    this.component.interactive = toggle;\n  }\n\n}\n\nclass ComponentDragger extends _Dragger__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor(component) {\n    super();\n    this.component = component;\n  }\n\n  get enabled() {\n    return this.component.interactive && !this.component.selecting;\n  }\n\n  set enabled(toggle) {\n    this.component.interactive = toggle;\n  }\n\n}\n\nfunction WrapHTML() {\n  return Reflect.construct(HTMLElement, [], Object.getPrototypeOf(this).constructor);\n}\n\nObject.setPrototypeOf(WrapHTML.prototype, HTMLElement.prototype);\nObject.setPrototypeOf(WrapHTML, HTMLElement);\n\nif (window.ShadyCSS) {\n  ShadyCSS.prepareTemplate(tmpl, 'x-protviewer');\n}\n\nlet setup_renderer = function setup_renderer(renderer) {\n  renderer.font_order = 'Helvetica, Arial, sans-serif';\n  renderer.zoom = 0.81;\n  renderer.padding = 10;\n  renderer.trackOrder = [];\n  renderer.reset();\n  renderer.trackGap = 6;\n  renderer.trackHeight = 5;\n  renderer.fixedFontScale = 1;\n};\n\nlet create_renderer = function create_renderer(container) {\n  let renderer = new DraggableRenderer(container, this);\n  setup_renderer(renderer);\n  wire_renderer_sequence_change.call(this, renderer);\n  return renderer;\n};\n\nlet try_import_symbols = (renderer, namespace, url) => {\n  _Service__WEBPACK_IMPORTED_MODULE_2__[\"default\"].request(url, function (err, doc) {\n    if (doc) {\n      renderer.importIcons(namespace, doc.documentElement, url);\n    }\n  }, \"xml\");\n};\n\nlet zoom_to_fit = renderer => {\n  renderer.fitZoom();\n};\n\nlet make_draggable = function make_draggable(renderer, dragger) {\n  dragger.applyToElement(renderer._canvas);\n  dragger.addTouchZoomControls(renderer, renderer._canvas, this[interactive_symb]);\n\n  renderer._canvas.addEventListener('panned', () => {\n    let evObj = new Event('pandone', {\n      bubbles: true,\n      cancelable: true\n    });\n    this.dispatchEvent(evObj);\n  });\n\n  _Dragger__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addScrollZoomControls.call(this[interactive_symb], renderer, renderer._canvas, 0.1);\n};\n\nlet wire_renderer_sequence_change = function wire_renderer_sequence_change(renderer) {\n  var dragger = new ComponentDragger(this);\n\n  let seq_change_func = () => {\n    try_import_symbols(renderer, \"ui\", \"https://glycodomain.glycomics.ku.dk/icons.svg\");\n    try_import_symbols(renderer, \"sugar\", \"https://glycodomain.glycomics.ku.dk/sugars.svg\");\n    zoom_to_fit(renderer);\n    make_draggable.call(this, renderer, dragger);\n    populate_tracks.call(this);\n    setup_renderer(renderer);\n    renderer.navigation.show();\n    renderer.refresh();\n  };\n\n  renderer.bind('sequenceChange', seq_change_func);\n};\n\nlet populate_tracks = function populate_tracks() {\n  for (let track of this.querySelectorAll('x-gatortrack')) {\n    this.createTrack(track);\n  }\n};\n\nlet wire_selection_change = function wire_selection_change(renderer) {\n  renderer.bind('selection', selections => {\n    let positions = selections.get(renderer);\n\n    if (!positions[0] && !positions[1]) {\n      this.removeAttribute('selected');\n    } else {\n      this.setAttribute('selected', \"\".concat(positions[0], \":\").concat(positions[1]));\n    }\n\n    for (let track of this.querySelectorAll('x-gatortrack')) {\n      let positions = selections.get(track.layer);\n\n      if (!positions[0] && !positions[1]) {\n        track.removeAttribute('selected');\n      } else {\n        track.setAttribute('selected', \"\".concat(positions[0], \":\").concat(positions[1]));\n      }\n    }\n  });\n};\n\nclass GatorComponent extends WrapHTML {\n  static get observedAttributes() {\n    return [];\n  }\n\n  constructor() {\n    super();\n  }\n\n  attributeChangedCallback(name) {}\n\n  connectedCallback() {\n    if (window.ShadyCSS) {\n      ShadyCSS.styleElement(this);\n    }\n\n    let shadowRoot = this.attachShadow({\n      mode: 'open'\n    });\n    shadowRoot.appendChild(tmpl.content.cloneNode(true));\n    this[interactive_symb] = new InteractiveState(this);\n    this.renderer = create_renderer.call(this, shadowRoot.getElementById('container'));\n    this.renderer.grow_container = true;\n\n    if (window.getComputedStyle(this).height && window.getComputedStyle(this).height !== '0px' && window.getComputedStyle(this).height !== 'auto') {\n      this.renderer.grow_container = false;\n\n      if (window.getComputedStyle(this).getPropertyValue('--fill-viewer')) {\n        this.renderer.fixed_size = true;\n      }\n    }\n\n    wire_selection_change.call(this, this.renderer);\n  }\n\n  fitToZoom() {\n    zoom_to_fit(this.renderer);\n  }\n\n  createTrack(track) {\n    _MASCP__WEBPACK_IMPORTED_MODULE_3__[\"default\"].registerLayer(track.name, {}, [this.renderer]);\n    this.renderer.trackOrder = this.renderer.trackOrder.concat([track.name]);\n    this.renderer.showLayer(track.name);\n    this.renderer.refresh();\n  }\n\n  refreshTracks() {\n    populate_tracks.call(this);\n  }\n\n  get selecting() {\n    return this.hasAttribute('selecting');\n  }\n\n  set selecting(toggle) {\n    if (toggle) {\n      this.setAttribute('selecting', '');\n    } else {\n      this.removeAttribute('selecting');\n    }\n  }\n\n  get interactive() {\n    return this.hasAttribute('interactive');\n  }\n\n  set interactive(toggle) {\n    if (toggle) {\n      this.setAttribute('interactive', '');\n    } else {\n      this.removeAttribute('interactive');\n    }\n  }\n\n}\n\ncustomElements.define('x-protviewer', GatorComponent);\n/* harmony default export */ __webpack_exports__[\"default\"] = (GatorComponent);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vZ2F0b3IvanMvbGliL0dhdG9yQ29tcG9uZW50LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL2dhdG9yL2pzL2xpYi9HYXRvckNvbXBvbmVudC5qcz8yZDk0Il0sInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IERyYWdnZXIgZnJvbSAnLi9EcmFnZ2VyJztcbmltcG9ydCBDb25kZW5zZWRTZXF1ZW5jZVJlbmRlcmVyIGZyb20gJy4vQ29uZGVuc2VkU2VxdWVuY2VSZW5kZXJlcic7XG5pbXBvcnQgU2VydmljZSBmcm9tICcuL1NlcnZpY2UnO1xuaW1wb3J0IE1BU0NQIGZyb20gJy4vTUFTQ1AnO1xuXG5jb25zdCBjb21wb25lbnRfc3ltYm9sID0gU3ltYm9sKCdjb21wb25lbnQnKTtcblxuY2xhc3MgRHJhZ2dhYmxlUmVuZGVyZXIgZXh0ZW5kcyBDb25kZW5zZWRTZXF1ZW5jZVJlbmRlcmVyIHtcbiAgY29uc3RydWN0b3IoY29udGFpbmVyLGNvbXBvbmVudCkge1xuICAgIHN1cGVyKGNvbnRhaW5lcik7XG4gICAgdGhpc1tjb21wb25lbnRfc3ltYm9sXSA9IGNvbXBvbmVudDtcbiAgfVxuICBnZXRWaXNpYmxlTGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLnJpZ2h0VmlzaWJsZVJlc2lkdWUoKSAtIHRoaXMubGVmdFZpc2libGVSZXNpZHVlKCk7XG4gIH1cbiAgZ2V0VG90YWxMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VxdWVuY2UubGVuZ3RoO1xuICB9XG4gIGdldExlZnRQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5sZWZ0VmlzaWJsZVJlc2lkdWUoKTtcbiAgfVxuICBzZXRMZWZ0UG9zaXRpb24ocG9zKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0TGVmdFZpc2libGVSZXNpZHVlKHBvcyk7XG4gIH1cblxuICBnZXQgc2VsZWN0aW5nKCkge1xuICAgIHJldHVybiB0aGlzW2NvbXBvbmVudF9zeW1ib2xdLnNlbGVjdGluZztcbiAgfVxufVxuXG5jb25zdCB0bXBsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcblxudG1wbC5pbm5lckhUTUwgPSBgXG48c3R5bGU+XG4gIDpob3N0IHtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIH1cbiAgOmhvc3QoW3Jlc2l6ZWFibGVdKSB7XG4gICAgcmVzaXplOiBib3RoO1xuICAgIG92ZXJmbG93OiBhdXRvO1xuICAgIHBhZGRpbmctcmlnaHQ6IDVweDtcbiAgICBwYWRkaW5nLWJvdHRvbTogNXB4O1xuICB9XG4gICNjb250YWluZXIsIC53aWRnZXRfY29udGVudHMge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcbiAgfVxuICAjY29udGFpbmVyIHtcbiAgfVxuPC9zdHlsZT5cbjxkaXYgY2xhc3M9XCJ3aWRnZXRfY29udGVudHNcIiA+XG4gIDxkaXYgaWQ9XCJjb250YWluZXJcIj5cbiAgPC9kaXY+XG48L2Rpdj5cbjxzbG90Pjwvc2xvdD5cbmA7XG5cbmNvbnN0IGludGVyYWN0aXZlX3N5bWIgPSBTeW1ib2woJ2ludGVyYWN0aXZlJyk7XG5cbmNsYXNzIEludGVyYWN0aXZlU3RhdGUge1xuICBjb25zdHJ1Y3Rvcihjb21wb25lbnQpIHtcbiAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgfVxuICBnZXQgZW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wb25lbnQuaW50ZXJhY3RpdmUgJiYgISB0aGlzLmNvbXBvbmVudC5zZWxlY3Rpbmc7XG4gIH1cbiAgc2V0IGVuYWJsZWQodG9nZ2xlKSB7XG4gICAgdGhpcy5jb21wb25lbnQuaW50ZXJhY3RpdmUgPSB0b2dnbGU7XG4gIH1cbn1cblxuY2xhc3MgQ29tcG9uZW50RHJhZ2dlciBleHRlbmRzIERyYWdnZXIge1xuICBjb25zdHJ1Y3Rvcihjb21wb25lbnQpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICB9XG4gIGdldCBlbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmNvbXBvbmVudC5pbnRlcmFjdGl2ZSAmJiAhIHRoaXMuY29tcG9uZW50LnNlbGVjdGluZztcbiAgfVxuICBzZXQgZW5hYmxlZCh0b2dnbGUpIHtcbiAgICB0aGlzLmNvbXBvbmVudC5pbnRlcmFjdGl2ZSA9IHRvZ2dsZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBXcmFwSFRNTCgpIHsgcmV0dXJuIFJlZmxlY3QuY29uc3RydWN0KEhUTUxFbGVtZW50LCBbXSwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTsgfVxuT2JqZWN0LnNldFByb3RvdHlwZU9mKFdyYXBIVE1MLnByb3RvdHlwZSwgSFRNTEVsZW1lbnQucHJvdG90eXBlKTtcbk9iamVjdC5zZXRQcm90b3R5cGVPZihXcmFwSFRNTCwgSFRNTEVsZW1lbnQpO1xuXG5pZiAod2luZG93LlNoYWR5Q1NTKSB7XG4gIFNoYWR5Q1NTLnByZXBhcmVUZW1wbGF0ZSh0bXBsLCAneC1wcm90dmlld2VyJyk7XG59XG5cbmxldCBzZXR1cF9yZW5kZXJlciA9IGZ1bmN0aW9uKHJlbmRlcmVyKSB7XG4gIHJlbmRlcmVyLmZvbnRfb3JkZXIgPSAnSGVsdmV0aWNhLCBBcmlhbCwgc2Fucy1zZXJpZic7XG4gIHJlbmRlcmVyLnpvb20gPSAwLjgxO1xuICByZW5kZXJlci5wYWRkaW5nID0gMTA7XG4gIHJlbmRlcmVyLnRyYWNrT3JkZXIgPSBbXTtcbiAgcmVuZGVyZXIucmVzZXQoKTtcbiAgcmVuZGVyZXIudHJhY2tHYXAgPSA2O1xuICByZW5kZXJlci50cmFja0hlaWdodCA9IDU7XG4gIHJlbmRlcmVyLmZpeGVkRm9udFNjYWxlID0gMTtcbn07XG5cbmxldCBjcmVhdGVfcmVuZGVyZXIgPSBmdW5jdGlvbihjb250YWluZXIpe1xuICBsZXQgcmVuZGVyZXIgPSBuZXcgRHJhZ2dhYmxlUmVuZGVyZXIoY29udGFpbmVyLHRoaXMpO1xuICBzZXR1cF9yZW5kZXJlcihyZW5kZXJlcik7XG4gIHdpcmVfcmVuZGVyZXJfc2VxdWVuY2VfY2hhbmdlLmNhbGwodGhpcyxyZW5kZXJlcik7XG4gIHJldHVybiByZW5kZXJlcjtcbn07XG5cbmxldCB0cnlfaW1wb3J0X3N5bWJvbHMgPSAocmVuZGVyZXIsbmFtZXNwYWNlLHVybCkgPT4ge1xuICBTZXJ2aWNlLnJlcXVlc3QodXJsLGZ1bmN0aW9uKGVycixkb2MpIHtcbiAgICBpZiAoZG9jKSB7XG4gICAgICByZW5kZXJlci5pbXBvcnRJY29ucyhuYW1lc3BhY2UsZG9jLmRvY3VtZW50RWxlbWVudCx1cmwpO1xuICAgIH1cbiAgfSxcInhtbFwiKTtcbn07XG5cbmxldCB6b29tX3RvX2ZpdCA9IChyZW5kZXJlcikgPT4ge1xuICByZW5kZXJlci5maXRab29tKCk7XG59O1xuXG5sZXQgbWFrZV9kcmFnZ2FibGUgPSBmdW5jdGlvbihyZW5kZXJlcixkcmFnZ2VyKSB7XG4gIGRyYWdnZXIuYXBwbHlUb0VsZW1lbnQocmVuZGVyZXIuX2NhbnZhcyk7XG4gIGRyYWdnZXIuYWRkVG91Y2hab29tQ29udHJvbHMocmVuZGVyZXIsIHJlbmRlcmVyLl9jYW52YXMsdGhpc1tpbnRlcmFjdGl2ZV9zeW1iXSk7XG4gIHJlbmRlcmVyLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigncGFubmVkJywgKCkgPT4ge1xuICAgIGxldCBldk9iaiA9IG5ldyBFdmVudCgncGFuZG9uZScsIHtidWJibGVzOiB0cnVlLCBjYW5jZWxhYmxlOiB0cnVlfSk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2T2JqKTtcbiAgfSk7XG4gIERyYWdnZXIuYWRkU2Nyb2xsWm9vbUNvbnRyb2xzLmNhbGwodGhpc1tpbnRlcmFjdGl2ZV9zeW1iXSxyZW5kZXJlciwgcmVuZGVyZXIuX2NhbnZhcywwLjEpO1xufTtcblxubGV0IHdpcmVfcmVuZGVyZXJfc2VxdWVuY2VfY2hhbmdlID0gZnVuY3Rpb24ocmVuZGVyZXIpIHtcbiAgdmFyIGRyYWdnZXIgPSBuZXcgQ29tcG9uZW50RHJhZ2dlcih0aGlzKTtcbiAgbGV0IHNlcV9jaGFuZ2VfZnVuYyA9ICgpID0+IHtcbiAgICB0cnlfaW1wb3J0X3N5bWJvbHMocmVuZGVyZXIsIFwidWlcIiwgXCJodHRwczovL2dseWNvZG9tYWluLmdseWNvbWljcy5rdS5kay9pY29ucy5zdmdcIik7XG4gICAgdHJ5X2ltcG9ydF9zeW1ib2xzKHJlbmRlcmVyLCBcInN1Z2FyXCIsIFwiaHR0cHM6Ly9nbHljb2RvbWFpbi5nbHljb21pY3Mua3UuZGsvc3VnYXJzLnN2Z1wiKTtcbiAgICB6b29tX3RvX2ZpdChyZW5kZXJlcik7XG4gICAgbWFrZV9kcmFnZ2FibGUuY2FsbCh0aGlzLHJlbmRlcmVyLGRyYWdnZXIpO1xuICAgIHBvcHVsYXRlX3RyYWNrcy5jYWxsKHRoaXMpO1xuICAgIHNldHVwX3JlbmRlcmVyKHJlbmRlcmVyKTtcbiAgICByZW5kZXJlci5uYXZpZ2F0aW9uLnNob3coKTtcbiAgICByZW5kZXJlci5yZWZyZXNoKCk7XG4gIH07XG4gIHJlbmRlcmVyLmJpbmQoJ3NlcXVlbmNlQ2hhbmdlJywgc2VxX2NoYW5nZV9mdW5jKTtcbn07XG5cbmxldCBwb3B1bGF0ZV90cmFja3MgPSBmdW5jdGlvbigpIHtcbiAgZm9yIChsZXQgdHJhY2sgb2YgdGhpcy5xdWVyeVNlbGVjdG9yQWxsKCd4LWdhdG9ydHJhY2snKSkge1xuICAgIHRoaXMuY3JlYXRlVHJhY2sodHJhY2spO1xuICB9XG59XG5cbmxldCB3aXJlX3NlbGVjdGlvbl9jaGFuZ2UgPSBmdW5jdGlvbihyZW5kZXJlcikge1xuICByZW5kZXJlci5iaW5kKCdzZWxlY3Rpb24nLCAoc2VsZWN0aW9ucykgPT4ge1xuICAgIGxldCBwb3NpdGlvbnMgPSBzZWxlY3Rpb25zLmdldChyZW5kZXJlcik7XG4gICAgaWYgKCAhIHBvc2l0aW9uc1swXSAmJiAhIHBvc2l0aW9uc1sxXSApIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdzZWxlY3RlZCcpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdzZWxlY3RlZCcsYCR7cG9zaXRpb25zWzBdfToke3Bvc2l0aW9uc1sxXX1gKTtcbiAgICB9XG4gICAgZm9yIChsZXQgdHJhY2sgb2YgdGhpcy5xdWVyeVNlbGVjdG9yQWxsKCd4LWdhdG9ydHJhY2snKSkge1xuICAgICAgbGV0IHBvc2l0aW9ucyA9IHNlbGVjdGlvbnMuZ2V0KHRyYWNrLmxheWVyKTtcbiAgICAgIGlmICggISBwb3NpdGlvbnNbMF0gJiYgISBwb3NpdGlvbnNbMV0gKSB7XG4gICAgICAgIHRyYWNrLnJlbW92ZUF0dHJpYnV0ZSgnc2VsZWN0ZWQnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhY2suc2V0QXR0cmlidXRlKCdzZWxlY3RlZCcsYCR7cG9zaXRpb25zWzBdfToke3Bvc2l0aW9uc1sxXX1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5cbmNsYXNzIEdhdG9yQ29tcG9uZW50IGV4dGVuZHMgV3JhcEhUTUwge1xuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lKSB7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAod2luZG93LlNoYWR5Q1NTKSB7XG4gICAgICBTaGFkeUNTUy5zdHlsZUVsZW1lbnQodGhpcyk7XG4gICAgfVxuICAgIGxldCBzaGFkb3dSb290ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgIHNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQodG1wbC5jb250ZW50LmNsb25lTm9kZSh0cnVlKSk7XG4gICAgdGhpc1tpbnRlcmFjdGl2ZV9zeW1iXSA9IG5ldyBJbnRlcmFjdGl2ZVN0YXRlKHRoaXMpO1xuICAgIHRoaXMucmVuZGVyZXIgPSBjcmVhdGVfcmVuZGVyZXIuY2FsbCh0aGlzLHNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRhaW5lcicpKTtcbiAgICB0aGlzLnJlbmRlcmVyLmdyb3dfY29udGFpbmVyID0gdHJ1ZTtcbiAgICBpZiAoIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMpLmhlaWdodCAmJiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzKS5oZWlnaHQgIT09ICcwcHgnICYmIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMpLmhlaWdodCAhPT0gJ2F1dG8nICkge1xuICAgICAgdGhpcy5yZW5kZXJlci5ncm93X2NvbnRhaW5lciA9IGZhbHNlO1xuICAgICAgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMpLmdldFByb3BlcnR5VmFsdWUoJy0tZmlsbC12aWV3ZXInKSkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmZpeGVkX3NpemUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICB3aXJlX3NlbGVjdGlvbl9jaGFuZ2UuY2FsbCh0aGlzLHRoaXMucmVuZGVyZXIpO1xuICB9XG5cbiAgZml0VG9ab29tKCkge1xuICAgIHpvb21fdG9fZml0KHRoaXMucmVuZGVyZXIpO1xuICB9XG5cbiAgY3JlYXRlVHJhY2sodHJhY2spIHtcbiAgICBNQVNDUC5yZWdpc3RlckxheWVyKHRyYWNrLm5hbWUse30sW3RoaXMucmVuZGVyZXJdKTtcbiAgICB0aGlzLnJlbmRlcmVyLnRyYWNrT3JkZXIgPSB0aGlzLnJlbmRlcmVyLnRyYWNrT3JkZXIuY29uY2F0KFt0cmFjay5uYW1lXSk7XG4gICAgdGhpcy5yZW5kZXJlci5zaG93TGF5ZXIodHJhY2submFtZSk7XG4gICAgdGhpcy5yZW5kZXJlci5yZWZyZXNoKCk7XG4gIH1cblxuICByZWZyZXNoVHJhY2tzKCkge1xuICAgIHBvcHVsYXRlX3RyYWNrcy5jYWxsKHRoaXMpO1xuICB9XG5cbiAgZ2V0IHNlbGVjdGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ3NlbGVjdGluZycpO1xuICB9XG5cbiAgc2V0IHNlbGVjdGluZyh0b2dnbGUpIHtcbiAgICBpZiAodG9nZ2xlKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnc2VsZWN0aW5nJywnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdzZWxlY3RpbmcnKTtcbiAgICB9XG4gIH1cblxuXG4gIGdldCBpbnRlcmFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2ludGVyYWN0aXZlJyk7XG4gIH1cblxuICBzZXQgaW50ZXJhY3RpdmUodG9nZ2xlKSB7XG4gICAgaWYgKHRvZ2dsZSkge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2ludGVyYWN0aXZlJywnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdpbnRlcmFjdGl2ZScpO1xuICAgIH1cbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ3gtcHJvdHZpZXdlcicsR2F0b3JDb21wb25lbnQpO1xuXG5leHBvcnQgZGVmYXVsdCBHYXRvckNvbXBvbmVudDsiXSwibWFwcGluZ3MiOiJBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBckJBO0FBQ0E7QUFzQkE7QUFFQTtBQTBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQVhBO0FBQ0E7QUFZQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXZFQTtBQUNBO0FBd0VBO0FBRUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../gator/js/lib/GatorComponent.js\n")},"../gator/js/lib/GatorDataReader.js":
/*!******************************************!*\
  !*** ../gator/js/lib/GatorDataReader.js ***!
  \******************************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Service */ \"../gator/js/lib/Service.js\");\n/* harmony import */ var _MASCP__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MASCP */ \"../gator/js/lib/MASCP.js\");\n/* harmony import */ var _ClustalRunner__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ClustalRunner */ \"../gator/js/lib/ClustalRunner.js\");\n/* harmony import */ var _UniprotReader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./UniprotReader */ \"../gator/js/lib/UniprotReader.js\");\n/* harmony import */ var _bean__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../bean */ \"../gator/js/bean.js\");\n/**\n * @fileOverview    Retrieve data from the Gator web service\n */\n\n\n\n\n\nvar localhosts = ['localhost', '10.0.2.2'];\nvar url_base = localhosts.indexOf(window.location.hostname) >= 0 ? 'https://test.glycocode.com/api' : '/api';\nvar cloudfront_host = '';\n\nconst set_reducer = (data_by_mime, set) => {\n  var mimetype = set.metadata.mimetype;\n\n  if (!mimetype) {\n    return;\n  }\n\n  if (!data_by_mime['samples']) {\n    data_by_mime['samples'] = {};\n  }\n\n  set.data.forEach(dat => {\n    dat.dataset = set.dataset;\n    dat.acc = set.acc;\n\n    if (set.metadata.sample) {\n      dat.species = set.metadata.sample.species;\n    }\n  });\n  data_by_mime['samples'][set.dataset] = set.metadata.sample;\n  data_by_mime[mimetype] = (data_by_mime[mimetype] || []).concat(set.data);\n};\n\nvar data_parser = function data_parser(data) {\n  var doc = this.datasetname || (data || {}).datasetname || 'combined';\n\n  if (!data || !data.data) {\n    return this;\n  }\n\n  var actual_data = data.data.filter(function (set) {\n    return set.dataset.indexOf(doc) >= 0;\n  })[0] || {\n    'data': []\n  };\n\n  if (doc.split(',').length > 1) {\n    doc = doc.split(',');\n    var data_by_mime = {};\n    data.data.filter(set => doc.indexOf(set.dataset) >= 0).forEach(set_reducer.bind(null, data_by_mime));\n    actual_data = {\n      'data': data_by_mime\n    };\n  }\n\n  if (doc == 'glycodomain') {\n    actual_data = data.data.filter(function (set) {\n      return set.metadata.mimetype == 'application/json+glycodomain';\n    })[0] || {\n      'data': []\n    };\n    console.log(actual_data);\n  }\n\n  if (doc == 'combined' || doc == 'homology' || doc == 'predictions') {\n    var data_by_mime = {};\n    data.data.forEach(set_reducer.bind(null, data_by_mime));\n    actual_data = {\n      'data': data_by_mime\n    };\n  }\n\n  if (doc == 'homology') {\n    actual_data.alignments = data.data.filter(function (set) {\n      return set.dataset == 'homology_alignment';\n    })[0].data;\n  }\n\n  this._raw_data = actual_data;\n  return this;\n};\n/** Default class constructor\n */\n\n\nconst GatorDataReader = _Service__WEBPACK_IMPORTED_MODULE_0__[\"default\"].buildService(data_parser);\n\nGatorDataReader.prototype.requestData = function () {\n  var reader_conf = {\n    type: \"GET\",\n    dataType: \"json\",\n    data: {}\n  };\n  var acc = (this._requestset || 'combined') + '/' + (this.agi || this.acc).toLowerCase();\n  var gatorURL = (this._endpointURL || GatorDataReader.server).slice(-1) == '/' ? this._endpointURL + acc : this._endpointURL + '/' + acc;\n  reader_conf.auth = _MASCP__WEBPACK_IMPORTED_MODULE_1__[\"default\"].GATOR_AUTH_TOKEN;\n  reader_conf.api_key = _MASCP__WEBPACK_IMPORTED_MODULE_1__[\"default\"].GATOR_CLIENT_ID;\n  reader_conf.session_cache = true;\n  reader_conf.url = gatorURL;\n  return reader_conf;\n};\n\nvar id_token;\nObject.defineProperty(GatorDataReader, 'server', {\n  get: function get() {\n    return url_base.replace('/api', '');\n  },\n  set: function set(url) {\n    url_base = url.replace('/$', '') + '/api';\n  }\n});\nObject.defineProperty(GatorDataReader, 'ID_TOKEN', {\n  get: function get() {\n    return id_token;\n  },\n  set: function set(token) {\n    id_token = token;\n    authenticating_promise = null;\n    _bean__WEBPACK_IMPORTED_MODULE_4__[\"default\"].fire(GatorDataReader, 'idtoken');\n  }\n});\nvar is_anonymous;\nObject.defineProperty(GatorDataReader, 'anonymous', {\n  get: function get() {\n    return is_anonymous;\n  },\n  set: function set(anon) {\n    is_anonymous = anon;\n    id_token = null;\n    authenticating_promise = null;\n  }\n});\nvar authenticating_promise;\n\nvar anonymous_login = function anonymous_login() {\n  return new Promise(function (resolve, reject) {\n    _Service__WEBPACK_IMPORTED_MODULE_0__[\"default\"].request({\n      'url': url_base + '/login?cachebuster=' + new Date().getTime(),\n      'type': 'GET'\n    }, function (err, token) {\n      if (err) {\n        reject(err);\n      } else {\n        var auth_token = JSON.parse(token);\n\n        if (typeof auth_token == 'string') {\n          auth_token = {\n            id_token: auth_token\n          };\n        }\n\n        GatorDataReader.ID_TOKEN = auth_token.id_token;\n        resolve(url_base);\n      }\n    }, true);\n  });\n};\n\nvar reading_was_ok = true;\n\nvar reauth_reader = function reauth_reader(reader_class) {\n  var current_retrieve = reader_class.prototype.retrieve;\n\n  reader_class.prototype.retrieve = function () {\n    console.log('Retrieve with auth retry');\n    var current_arguments = [].slice.call(arguments);\n    var self = this;\n    this.bind('error', function (err) {\n      if (err.status == 401 || err.status == 403) {\n        if (!self.tried_auth) {\n          self.unbind('error');\n          self.tried_auth = true;\n\n          if (reading_was_ok) {\n            delete _MASCP__WEBPACK_IMPORTED_MODULE_1__[\"default\"].GATOR_AUTH_TOKEN;\n            GatorDataReader.ID_TOKEN = null;\n            authenticating_promise = null;\n            _bean__WEBPACK_IMPORTED_MODULE_4__[\"default\"].fire(GatorDataReader, 'unauthorized');\n            reading_was_ok = false;\n          }\n\n          authenticate_gator().catch(function (err) {\n            console.log(\"Error after auth\", err);\n            throw err;\n          }).then(function () {\n            reading_was_ok = true;\n            self.retrieve.apply(self, current_arguments);\n          }).catch(function (err) {\n            console.log(\"Died on doing the reauth\", err);\n          });\n        }\n      }\n    });\n    current_retrieve.apply(self, current_arguments);\n  };\n};\n\nreauth_reader(GatorDataReader);\nwindow.addEventListener(\"unhandledrejection\", function (err, promise) {\n  if (err.reason && err.reason.message == 'Unauthorized' && !err.reason.handled) {\n    err.reason.handled = true;\n    _bean__WEBPACK_IMPORTED_MODULE_4__[\"default\"].fire(GatorDataReader, 'unauthorized');\n    return;\n  }\n\n  console.log(err);\n});\n\nvar authenticate_gator = function authenticate_gator() {\n  if (authenticating_promise) {\n    return authenticating_promise;\n  } // Need to put this somewhere for the moment\n  // Temporary code until we move to a single host\n\n\n  _ClustalRunner__WEBPACK_IMPORTED_MODULE_2__[\"default\"].SERVICE_URL = url_base + '/tools/clustal';\n  _UniprotReader__WEBPACK_IMPORTED_MODULE_3__[\"default\"].SERVICE_URL = url_base + '/data/latest/uniprot';\n\n  if (!_UniprotReader__WEBPACK_IMPORTED_MODULE_3__[\"default\"].reauthed) {\n    reauth_reader(_UniprotReader__WEBPACK_IMPORTED_MODULE_3__[\"default\"]);\n  }\n\n  _UniprotReader__WEBPACK_IMPORTED_MODULE_3__[\"default\"].reauthed = true;\n\n  if (!GatorDataReader.ID_TOKEN && GatorDataReader.anonymous) {\n    console.log(\"Doing an anonymous login\");\n    authenticating_promise = anonymous_login().then(function () {\n      authenticating_promise = null;\n    }).then(authenticate_gator);\n    return authenticating_promise;\n  }\n\n  if (!GatorDataReader.ID_TOKEN && !GatorDataReader.anonymous) {\n    console.log(\"We cannot log in without an ID TOKEN, waiting for token\");\n    authenticating_promise = new Promise(function (resolve, reject) {\n      var resolver = function resolver() {\n        console.log(\"Got a new ID token\");\n        _bean__WEBPACK_IMPORTED_MODULE_4__[\"default\"].remove(GatorDataReader, 'idtoken', resolver);\n        _MASCP__WEBPACK_IMPORTED_MODULE_1__[\"default\"].GATOR_AUTH_TOKEN = GatorDataReader.ID_TOKEN;\n        resolve(url_base);\n      };\n\n      _bean__WEBPACK_IMPORTED_MODULE_4__[\"default\"].add(GatorDataReader, 'idtoken', resolver);\n      setTimeout(function () {\n        console.log(\"Timed out logging in\");\n        reject(new Error('Timed out'));\n      }, 5000);\n    });\n    return authenticating_promise;\n  }\n\n  authenticating_promise = new Promise(function (resolve, reject) {\n    setTimeout(function () {\n      _MASCP__WEBPACK_IMPORTED_MODULE_1__[\"default\"].GATOR_AUTH_TOKEN = GatorDataReader.ID_TOKEN;\n      _bean__WEBPACK_IMPORTED_MODULE_4__[\"default\"].fire(GatorDataReader, 'auth', [url_base]);\n      resolve(url_base);\n    }, 0);\n  });\n  return authenticating_promise;\n};\n\nGatorDataReader.prototype.setupSequenceRenderer = function (renderer) {\n  var self = this;\n\n  if (this.datasetname !== 'homology') {\n    return;\n  }\n\n  renderer.forceTrackAccs = true;\n  renderer.addAxisScale('homology', function (pos, accession, inverse) {\n    if (!self.result || self.agi === accession.name || self.acc === accession.name) {\n      return pos;\n    }\n\n    if (inverse) {\n      return self.result.calculateSequencePositionFromPosition(self.agi || self.acc, accession.name.toLowerCase(), pos);\n    }\n\n    return self.result.calculatePositionForSequence(self.agi || self.acc, accession.name.toLowerCase(), pos);\n  });\n};\n\n(function () {\n  var normalise_insertions = function normalise_insertions(inserts) {\n    var pos;\n    var positions = [];\n    var result_data = {};\n\n    for (pos in inserts) {\n      if (inserts.hasOwnProperty(pos) && parseInt(pos) >= -1) {\n        positions.push(parseInt(pos));\n      }\n    }\n\n    positions = positions.sort(function sortfunction(a, b) {\n      return a - b;\n    }); // From highest to lowest position, loop through and\n    // subtract the lengths of previous subtratctions from\n    // the final position value.\n\n    for (var i = positions.length - 1; i >= 0; i--) {\n      var j = i - 1;\n      pos = parseInt(positions[i]);\n      var value = inserts[pos];\n\n      while (j >= 0) {\n        pos -= inserts[positions[j]].length;\n        j--;\n      }\n\n      if (!value.match(/^\\s+$/)) {\n        result_data[pos + 1] = value + (result_data[pos + 1] || '');\n      }\n    } //    delete result_data[0];\n\n\n    return result_data;\n  };\n\n  var splice_char = function splice_char(seqs, index, insertions) {\n    for (var i = 0; i < seqs.length; i++) {\n      var seq = seqs[i].toString();\n\n      if (seq.charAt(index) != '-') {\n        if (!insertions[i]) {\n          insertions[i] = {};\n          insertions[i][-1] = '';\n        }\n\n        insertions[i][index - 1] = seq.charAt(index);\n\n        if (insertions[i][index] && insertions[i][index].match(/\\w/)) {\n          insertions[i][index - 1] += insertions[i][index];\n          delete insertions[i][index];\n        }\n      } else {\n        if (insertions[i]) {\n          insertions[i][index - 1] = ' ';\n\n          if ((insertions[i][index] || '').match(/^\\s+$/)) {\n            insertions[i][index - 1] += insertions[i][index];\n            delete insertions[i][index];\n          }\n        }\n      }\n\n      seqs[i] = seq.slice(0, index) + seq.slice(index + 1);\n    }\n  };\n\n  GatorDataReader.Result.prototype.makeSequences = function (ref_acc, alignments) {\n    var seqs = [];\n    var insertions = [];\n    var accs = [];\n    var ref_cigar = '';\n    alignments.forEach(function (align) {\n      if (!align.cigar && align.cigar_line) {\n        align.cigar = align.cigar_line;\n        delete align.cigar_line;\n      } // If the cigar line hasn't already been revivified\n\n\n      if (!align.cigar.match(/^[\\-\\.]*$/)) {\n        // Expand out the cigar line replacing M with . and D with -\n        align.cigar = align.cigar.match(/\\d*[MD]/g).map(function (bit) {\n          return new Array((parseInt(bit.slice(0, -1)) || 1) + 1).join(bit.slice(-1) == 'M' ? '.' : '-');\n        }).join('');\n      }\n\n      if (align.uniprot !== ref_acc.toUpperCase()) {\n        accs.push(align.uniprot);\n        seqs.push(align.cigar);\n      } else {\n        ref_cigar = align.cigar;\n      }\n    });\n    var aligning_seq = ref_cigar,\n        i = aligning_seq.length - 1;\n\n    for (i; i >= 0; i--) {\n      if (aligning_seq.charAt(i) == '-') {\n        splice_char(seqs, i, insertions);\n      }\n    }\n\n    for (i = 0; i < seqs.length; i++) {\n      if (insertions[i]) {\n        insertions[i] = normalise_insertions(insertions[i]);\n        var seq = seqs[i];\n        seqs[i] = {\n          'sequence': seq,\n          'insertions': insertions[i]\n        };\n\n        seqs[i].toString = function () {\n          return this.sequence;\n        };\n      }\n    }\n\n    var result = {};\n    accs.forEach(function (acc, idx) {\n      result[acc.toLowerCase()] = seqs[idx];\n    });\n    result[ref_acc.toLowerCase()] = ref_cigar.replace('-', '');\n    return result;\n  };\n})();\n\nGatorDataReader.Result.prototype.calculatePositionForSequence = function (ref_acc, idx, pos) {\n  if (ref_acc.toLowerCase() === idx.toLowerCase()) {\n    return pos;\n  }\n\n  if (!this.sequences) {\n    this.sequences = this.makeSequences(ref_acc, this._raw_data.alignments);\n  }\n\n  var inserts = this.sequences[idx.toLowerCase()].insertions || {};\n  var result = pos;\n  var actual_position = 0;\n  var seq = this.sequences[idx.toLowerCase()].toString();\n\n  for (var i = 0; i < seq.length; i++) {\n    if (inserts[i]) {\n      actual_position += inserts[i].length;\n    }\n\n    actual_position += 1;\n\n    if (seq.charAt(i) == '-') {\n      actual_position -= 1;\n    }\n\n    if (pos <= actual_position) {\n      if (pos == actual_position) {\n        return i + 1;\n      } else {\n        if (i == 0) {\n          i = 1;\n        }\n\n        return -1 * i;\n      }\n    }\n  }\n\n  return -1 * seq.length;\n};\n\nGatorDataReader.Result.prototype.calculateSequencePositionFromPosition = function (ref_acc, idx, pos) {\n  if (ref_acc.toLowerCase() === idx.toLowerCase()) {\n    return pos;\n  }\n\n  if (!this.sequences) {\n    this.sequences = this.makeSequences(ref_acc, this._raw_data.alignments);\n  }\n\n  var inserts = this.sequences[idx.toLowerCase()].insertions || {};\n  var result = pos;\n  var actual_position = 0;\n  var seq = this.sequences[idx.toLowerCase()].toString();\n\n  for (var i = 0; i < pos; i++) {\n    if (inserts[i]) {\n      actual_position += inserts[i].length;\n    }\n\n    actual_position += 1;\n\n    if (seq.charAt(i) == '-') {\n      actual_position -= 1;\n    }\n  }\n\n  if (actual_position == 0) {\n    actual_position += 1;\n  }\n\n  return actual_position;\n};\n\nvar default_result = GatorDataReader.Result;\nObject.defineProperty(GatorDataReader.prototype, 'datasetname', {\n  get: function get() {\n    return this._datasetname;\n  },\n  set: function set(value) {\n    this._datasetname = value;\n    this._requestset = value === 'homology' ? 'homology' : 'combined';\n    let alt_result = class extends default_result {\n      constructor(data) {\n        data.datasetname = value;\n        super(data);\n        return this;\n      }\n\n    };\n    this.Result = alt_result;\n  }\n});\n\nGatorDataReader.authenticate = function () {\n  return authenticate_gator();\n};\n\nvar running_promises = {};\n\nvar new_retrieve = function new_retrieve(acc) {\n  var self = this;\n  var orig_arguments = [].slice.call(arguments);\n\n  if (running_promises[acc + '-' + this._requestset]) {\n    running_promises[acc + '-' + this._requestset].then(function (result) {\n      GatorDataReader.prototype.retrieve.apply(self, orig_arguments);\n    }).catch(function (err) {\n      authenticate_gator().then(function () {\n        new_retrieve.apply(self, orig_arguments);\n      });\n    });\n\n    return;\n  }\n\n  running_promises[acc + '-' + this._requestset] = new Promise(function (resolve, reject) {\n    self.bind('resultReceived', resolve);\n    self.once('error', reject);\n  });\n\n  running_promises[acc + '-' + this._requestset].catch(function (err) {\n    authenticate_gator().then(function () {\n      running_promises[acc + '-' + self._requestset] = null;\n    });\n  });\n\n  GatorDataReader.prototype.retrieve.apply(self, orig_arguments);\n};\n\nGatorDataReader.createReader = function (doc) {\n  // Do the auth dance here\n  var reader = new GatorDataReader(null, url_base + '/data/latest/');\n  console.log(doc);\n  reader.datasetname = doc; // MASCP.Service.CacheService(reader);\n\n  authenticate_gator().then(function () {\n    reader.retrieve = new_retrieve;\n    _bean__WEBPACK_IMPORTED_MODULE_4__[\"default\"].fire(reader, 'ready');\n  });\n  return reader;\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (GatorDataReader);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vZ2F0b3IvanMvbGliL0dhdG9yRGF0YVJlYWRlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9nYXRvci9qcy9saWIvR2F0b3JEYXRhUmVhZGVyLmpzP2I4M2QiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZU92ZXJ2aWV3ICAgIFJldHJpZXZlIGRhdGEgZnJvbSB0aGUgR2F0b3Igd2ViIHNlcnZpY2VcbiAqL1xuXG5pbXBvcnQgU2VydmljZSBmcm9tICcuL1NlcnZpY2UnO1xuaW1wb3J0IE1BU0NQIGZyb20gJy4vTUFTQ1AnO1xuaW1wb3J0IENsdXN0YWxSdW5uZXIgZnJvbSAnLi9DbHVzdGFsUnVubmVyJztcbmltcG9ydCBVbmlwcm90UmVhZGVyIGZyb20gJy4vVW5pcHJvdFJlYWRlcic7XG5pbXBvcnQgYmVhbiBmcm9tICcuLi9iZWFuJztcblxuXG52YXIgbG9jYWxob3N0cyA9IFsnbG9jYWxob3N0JywnMTAuMC4yLjInXTtcbnZhciB1cmxfYmFzZSA9IGxvY2FsaG9zdHMuaW5kZXhPZih3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUpID49IDAgPyAnaHR0cHM6Ly90ZXN0LmdseWNvY29kZS5jb20vYXBpJyA6ICcvYXBpJztcbnZhciBjbG91ZGZyb250X2hvc3QgPSAnJztcblxuY29uc3Qgc2V0X3JlZHVjZXIgPSAoZGF0YV9ieV9taW1lLHNldCkgPT4ge1xuICB2YXIgbWltZXR5cGUgPSBzZXQubWV0YWRhdGEubWltZXR5cGU7XG4gIGlmICggISBtaW1ldHlwZSApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCAhIGRhdGFfYnlfbWltZVsnc2FtcGxlcyddICkge1xuICAgIGRhdGFfYnlfbWltZVsnc2FtcGxlcyddID0ge307XG4gIH1cbiAgc2V0LmRhdGEuZm9yRWFjaChkYXQgPT4ge1xuICAgICAgZGF0LmRhdGFzZXQgPSBzZXQuZGF0YXNldDtcbiAgICAgIGRhdC5hY2MgPSBzZXQuYWNjO1xuICAgICAgaWYgKHNldC5tZXRhZGF0YS5zYW1wbGUpIHtcbiAgICAgICAgZGF0LnNwZWNpZXMgPSBzZXQubWV0YWRhdGEuc2FtcGxlLnNwZWNpZXM7XG4gICAgICB9XG4gIH0pO1xuICBkYXRhX2J5X21pbWVbJ3NhbXBsZXMnXVtzZXQuZGF0YXNldF0gPSBzZXQubWV0YWRhdGEuc2FtcGxlO1xuXG4gIGRhdGFfYnlfbWltZVttaW1ldHlwZV0gPSAoZGF0YV9ieV9taW1lW21pbWV0eXBlXSB8fCBbXSkuY29uY2F0KHNldC5kYXRhKTtcbn07XG5cbnZhciBkYXRhX3BhcnNlciA9ICAgZnVuY3Rpb24oZGF0YSkge1xuICB2YXIgZG9jID0gdGhpcy5kYXRhc2V0bmFtZSB8fCAoZGF0YSB8fCB7fSkuZGF0YXNldG5hbWUgfHwgJ2NvbWJpbmVkJztcbiAgaWYgKCAhIGRhdGEgfHwgISBkYXRhLmRhdGEgKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdmFyIGFjdHVhbF9kYXRhID0gZGF0YS5kYXRhLmZpbHRlcihmdW5jdGlvbihzZXQpIHtcbiAgICByZXR1cm4gc2V0LmRhdGFzZXQuaW5kZXhPZihkb2MpID49IDA7XG4gIH0pWzBdIHx8IHsnZGF0YScgOiBbXSB9O1xuXG4gIGlmIChkb2Muc3BsaXQoJywnKS5sZW5ndGggPiAxKSB7XG4gICAgZG9jID0gZG9jLnNwbGl0KCcsJyk7XG4gICAgdmFyIGRhdGFfYnlfbWltZSA9IHt9O1xuICAgIGRhdGEuZGF0YVxuICAgICAgICAuZmlsdGVyKHNldCA9PiBkb2MuaW5kZXhPZihzZXQuZGF0YXNldCkgPj0gMClcbiAgICAgICAgLmZvckVhY2goc2V0X3JlZHVjZXIuYmluZChudWxsLGRhdGFfYnlfbWltZSkpO1xuICAgIGFjdHVhbF9kYXRhID0geyAnZGF0YScgOiBkYXRhX2J5X21pbWUgfTtcbiAgfVxuXG4gIGlmIChkb2MgPT0gJ2dseWNvZG9tYWluJykge1xuICAgICAgYWN0dWFsX2RhdGEgPSBkYXRhLmRhdGEuZmlsdGVyKGZ1bmN0aW9uKHNldCkge1xuICAgICAgICAgIHJldHVybiBzZXQubWV0YWRhdGEubWltZXR5cGUgPT0gJ2FwcGxpY2F0aW9uL2pzb24rZ2x5Y29kb21haW4nO1xuICAgICAgfSlbMF0gfHwgeydkYXRhJyA6IFtdIH07XG4gICAgICBjb25zb2xlLmxvZyhhY3R1YWxfZGF0YSk7XG4gIH1cbiAgaWYgKGRvYyA9PSAnY29tYmluZWQnIHx8IGRvYyA9PSAnaG9tb2xvZ3knIHx8IGRvYyA9PSAncHJlZGljdGlvbnMnKSB7XG4gICAgICB2YXIgZGF0YV9ieV9taW1lID0ge307XG4gICAgICBkYXRhLmRhdGEuZm9yRWFjaChzZXRfcmVkdWNlci5iaW5kKG51bGwsZGF0YV9ieV9taW1lKSk7XG4gICAgICBhY3R1YWxfZGF0YSA9IHsgJ2RhdGEnIDogZGF0YV9ieV9taW1lIH07XG4gIH1cbiAgaWYgKGRvYyA9PSAnaG9tb2xvZ3knKSB7XG4gICAgYWN0dWFsX2RhdGEuYWxpZ25tZW50cyA9IGRhdGEuZGF0YS5maWx0ZXIoZnVuY3Rpb24oc2V0KSB7IHJldHVybiBzZXQuZGF0YXNldCA9PSAnaG9tb2xvZ3lfYWxpZ25tZW50JzsgfSlbMF0uZGF0YTtcbiAgfVxuICB0aGlzLl9yYXdfZGF0YSA9IGFjdHVhbF9kYXRhO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKiBEZWZhdWx0IGNsYXNzIGNvbnN0cnVjdG9yXG4gKi9cbmNvbnN0IEdhdG9yRGF0YVJlYWRlciA9IFNlcnZpY2UuYnVpbGRTZXJ2aWNlKGRhdGFfcGFyc2VyKTtcblxuR2F0b3JEYXRhUmVhZGVyLnByb3RvdHlwZS5yZXF1ZXN0RGF0YSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVhZGVyX2NvbmYgPSB7XG4gICAgICAgICAgdHlwZTogXCJHRVRcIixcbiAgICAgICAgICBkYXRhVHlwZTogXCJqc29uXCIsXG4gICAgICAgICAgZGF0YTogeyB9XG4gICAgICB9O1xuICB2YXIgYWNjID0gKCB0aGlzLl9yZXF1ZXN0c2V0IHx8ICdjb21iaW5lZCcgKSArICcvJyArICh0aGlzLmFnaSB8fCB0aGlzLmFjYykudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGdhdG9yVVJMID0gKHRoaXMuX2VuZHBvaW50VVJMIHx8IEdhdG9yRGF0YVJlYWRlci5zZXJ2ZXIpLnNsaWNlKC0xKSA9PSAnLycgPyB0aGlzLl9lbmRwb2ludFVSTCsgYWNjIDogdGhpcy5fZW5kcG9pbnRVUkwrJy8nK2FjYztcbiAgcmVhZGVyX2NvbmYuYXV0aCA9IE1BU0NQLkdBVE9SX0FVVEhfVE9LRU47XG4gIHJlYWRlcl9jb25mLmFwaV9rZXkgPSBNQVNDUC5HQVRPUl9DTElFTlRfSUQ7XG4gIHJlYWRlcl9jb25mLnNlc3Npb25fY2FjaGUgPSB0cnVlO1xuICByZWFkZXJfY29uZi51cmwgPSBnYXRvclVSTDtcbiAgcmV0dXJuIHJlYWRlcl9jb25mO1xufTtcblxudmFyIGlkX3Rva2VuO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoR2F0b3JEYXRhUmVhZGVyLCAnc2VydmVyJywge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB1cmxfYmFzZS5yZXBsYWNlKCcvYXBpJywnJyk7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24odXJsKSB7XG4gICAgdXJsX2Jhc2UgPSB1cmwucmVwbGFjZSgnLyQnLCcnKSArICcvYXBpJztcbiAgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShHYXRvckRhdGFSZWFkZXIsICdJRF9UT0tFTicsIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaWRfdG9rZW47XG4gIH0sXG4gIHNldDogZnVuY3Rpb24odG9rZW4pIHtcbiAgICBpZF90b2tlbiA9IHRva2VuO1xuICAgIGF1dGhlbnRpY2F0aW5nX3Byb21pc2UgPSBudWxsO1xuICAgIGJlYW4uZmlyZShHYXRvckRhdGFSZWFkZXIsJ2lkdG9rZW4nKTtcbiAgfVxufSk7XG5cbnZhciBpc19hbm9ueW1vdXM7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShHYXRvckRhdGFSZWFkZXIsICdhbm9ueW1vdXMnLCB7XG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGlzX2Fub255bW91cztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihhbm9uKSB7XG4gICAgaXNfYW5vbnltb3VzID0gYW5vbjtcbiAgICBpZF90b2tlbiA9IG51bGw7XG4gICAgYXV0aGVudGljYXRpbmdfcHJvbWlzZSA9IG51bGw7XG4gIH1cbn0pO1xuXG52YXIgYXV0aGVudGljYXRpbmdfcHJvbWlzZTtcblxudmFyIGFub255bW91c19sb2dpbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSxyZWplY3QpIHtcbiAgICAgIFNlcnZpY2UucmVxdWVzdCh7J3VybCcgOiB1cmxfYmFzZSArICcvbG9naW4/Y2FjaGVidXN0ZXI9JysobmV3IERhdGUoKSkuZ2V0VGltZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndHlwZScgOiAnR0VUJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sZnVuY3Rpb24oZXJyLHRva2VuKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYXV0aF90b2tlbiA9IEpTT04ucGFyc2UodG9rZW4pO1xuICAgICAgICAgIGlmICh0eXBlb2YgYXV0aF90b2tlbiA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYXV0aF90b2tlbiA9IHsgaWRfdG9rZW46IGF1dGhfdG9rZW4gfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgR2F0b3JEYXRhUmVhZGVyLklEX1RPS0VOID0gYXV0aF90b2tlbi5pZF90b2tlbjtcbiAgICAgICAgICByZXNvbHZlKHVybF9iYXNlKTtcbiAgICAgICAgfVxuICAgICAgfSx0cnVlKTtcbiAgICB9KTtcbn07XG5cbnZhciByZWFkaW5nX3dhc19vayA9IHRydWU7XG5cbnZhciByZWF1dGhfcmVhZGVyID0gZnVuY3Rpb24ocmVhZGVyX2NsYXNzKSB7XG4gIHZhciBjdXJyZW50X3JldHJpZXZlID0gcmVhZGVyX2NsYXNzLnByb3RvdHlwZS5yZXRyaWV2ZTtcbiAgcmVhZGVyX2NsYXNzLnByb3RvdHlwZS5yZXRyaWV2ZSA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnNvbGUubG9nKCdSZXRyaWV2ZSB3aXRoIGF1dGggcmV0cnknKTtcbiAgICB2YXIgY3VycmVudF9hcmd1bWVudHMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuYmluZCgnZXJyb3InLGZ1bmN0aW9uKGVycikge1xuICAgICAgaWYgKGVyci5zdGF0dXMgPT0gNDAxIHx8IGVyci5zdGF0dXMgPT0gNDAzKSB7XG4gICAgICAgIGlmICggISBzZWxmLnRyaWVkX2F1dGggKSB7XG4gICAgICAgICAgc2VsZi51bmJpbmQoJ2Vycm9yJyk7XG4gICAgICAgICAgc2VsZi50cmllZF9hdXRoID0gdHJ1ZTtcbiAgICAgICAgICBpZiAocmVhZGluZ193YXNfb2spIHtcbiAgICAgICAgICAgIGRlbGV0ZSBNQVNDUC5HQVRPUl9BVVRIX1RPS0VOO1xuICAgICAgICAgICAgR2F0b3JEYXRhUmVhZGVyLklEX1RPS0VOID0gbnVsbDtcbiAgICAgICAgICAgIGF1dGhlbnRpY2F0aW5nX3Byb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgYmVhbi5maXJlKEdhdG9yRGF0YVJlYWRlciwndW5hdXRob3JpemVkJyk7XG4gICAgICAgICAgICByZWFkaW5nX3dhc19vayA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhdXRoZW50aWNhdGVfZ2F0b3IoKS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3IgYWZ0ZXIgYXV0aFwiLGVycik7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJlYWRpbmdfd2FzX29rID0gdHJ1ZTtcbiAgICAgICAgICAgIHNlbGYucmV0cmlldmUuYXBwbHkoc2VsZixjdXJyZW50X2FyZ3VtZW50cyk7XG4gICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkRpZWQgb24gZG9pbmcgdGhlIHJlYXV0aFwiLGVycik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBjdXJyZW50X3JldHJpZXZlLmFwcGx5KHNlbGYsY3VycmVudF9hcmd1bWVudHMpO1xuICB9O1xufTtcblxucmVhdXRoX3JlYWRlcihHYXRvckRhdGFSZWFkZXIpO1xuXG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidW5oYW5kbGVkcmVqZWN0aW9uXCIsIGZ1bmN0aW9uKGVyciwgcHJvbWlzZSkge1xuICBpZiAoZXJyLnJlYXNvbiAmJiBlcnIucmVhc29uLm1lc3NhZ2UgPT0gJ1VuYXV0aG9yaXplZCcgJiYgISBlcnIucmVhc29uLmhhbmRsZWQpIHtcbiAgICBlcnIucmVhc29uLmhhbmRsZWQgPSB0cnVlO1xuICAgIGJlYW4uZmlyZShHYXRvckRhdGFSZWFkZXIsJ3VuYXV0aG9yaXplZCcpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zb2xlLmxvZyhlcnIpO1xufSk7XG5cbnZhciBhdXRoZW50aWNhdGVfZ2F0b3IgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoYXV0aGVudGljYXRpbmdfcHJvbWlzZSkge1xuICAgICAgcmV0dXJuIGF1dGhlbnRpY2F0aW5nX3Byb21pc2U7XG4gICAgfVxuICAgIC8vIE5lZWQgdG8gcHV0IHRoaXMgc29tZXdoZXJlIGZvciB0aGUgbW9tZW50XG4gICAgLy8gVGVtcG9yYXJ5IGNvZGUgdW50aWwgd2UgbW92ZSB0byBhIHNpbmdsZSBob3N0XG4gICAgQ2x1c3RhbFJ1bm5lci5TRVJWSUNFX1VSTCA9IHVybF9iYXNlICsgJy90b29scy9jbHVzdGFsJztcbiAgICBVbmlwcm90UmVhZGVyLlNFUlZJQ0VfVVJMID0gdXJsX2Jhc2UgKyAnL2RhdGEvbGF0ZXN0L3VuaXByb3QnO1xuICAgIGlmICggISBVbmlwcm90UmVhZGVyLnJlYXV0aGVkICkge1xuICAgICAgcmVhdXRoX3JlYWRlcihVbmlwcm90UmVhZGVyKTtcbiAgICB9XG4gICAgVW5pcHJvdFJlYWRlci5yZWF1dGhlZCA9IHRydWU7XG5cbiAgICBpZiAoICEgR2F0b3JEYXRhUmVhZGVyLklEX1RPS0VOICYmIEdhdG9yRGF0YVJlYWRlci5hbm9ueW1vdXMgKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkRvaW5nIGFuIGFub255bW91cyBsb2dpblwiKTtcbiAgICAgIGF1dGhlbnRpY2F0aW5nX3Byb21pc2UgPSBhbm9ueW1vdXNfbG9naW4oKS50aGVuKGZ1bmN0aW9uKCkgeyBhdXRoZW50aWNhdGluZ19wcm9taXNlID0gbnVsbDsgfSkudGhlbihhdXRoZW50aWNhdGVfZ2F0b3IpO1xuICAgICAgcmV0dXJuIGF1dGhlbnRpY2F0aW5nX3Byb21pc2U7XG4gICAgfVxuXG4gICAgaWYgKCAhIEdhdG9yRGF0YVJlYWRlci5JRF9UT0tFTiAmJiAhIEdhdG9yRGF0YVJlYWRlci5hbm9ueW1vdXMgKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIldlIGNhbm5vdCBsb2cgaW4gd2l0aG91dCBhbiBJRCBUT0tFTiwgd2FpdGluZyBmb3IgdG9rZW5cIik7XG5cbiAgICAgIGF1dGhlbnRpY2F0aW5nX3Byb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLHJlamVjdCkge1xuICAgICAgICB2YXIgcmVzb2x2ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIkdvdCBhIG5ldyBJRCB0b2tlblwiKTtcbiAgICAgICAgICBiZWFuLnJlbW92ZShHYXRvckRhdGFSZWFkZXIsJ2lkdG9rZW4nLHJlc29sdmVyKTtcbiAgICAgICAgICBNQVNDUC5HQVRPUl9BVVRIX1RPS0VOID0gR2F0b3JEYXRhUmVhZGVyLklEX1RPS0VOO1xuICAgICAgICAgIHJlc29sdmUodXJsX2Jhc2UpO1xuICAgICAgICB9O1xuICAgICAgICBiZWFuLmFkZChHYXRvckRhdGFSZWFkZXIsJ2lkdG9rZW4nLHJlc29sdmVyKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlRpbWVkIG91dCBsb2dnaW5nIGluXCIpO1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1RpbWVkIG91dCcpKTtcbiAgICAgICAgfSw1MDAwKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGF1dGhlbnRpY2F0aW5nX3Byb21pc2U7XG4gICAgfVxuXG4gICAgYXV0aGVudGljYXRpbmdfcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUscmVqZWN0KSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBNQVNDUC5HQVRPUl9BVVRIX1RPS0VOID0gR2F0b3JEYXRhUmVhZGVyLklEX1RPS0VOO1xuICAgICAgICBiZWFuLmZpcmUoR2F0b3JEYXRhUmVhZGVyLCdhdXRoJyxbdXJsX2Jhc2VdKTtcbiAgICAgICAgcmVzb2x2ZSh1cmxfYmFzZSk7XG4gICAgICB9LDApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGF1dGhlbnRpY2F0aW5nX3Byb21pc2U7XG59O1xuXG5HYXRvckRhdGFSZWFkZXIucHJvdG90eXBlLnNldHVwU2VxdWVuY2VSZW5kZXJlciA9IGZ1bmN0aW9uKHJlbmRlcmVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICh0aGlzLmRhdGFzZXRuYW1lICE9PSAnaG9tb2xvZ3knKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlbmRlcmVyLmZvcmNlVHJhY2tBY2NzID0gdHJ1ZTtcbiAgICByZW5kZXJlci5hZGRBeGlzU2NhbGUoJ2hvbW9sb2d5JyxmdW5jdGlvbihwb3MsYWNjZXNzaW9uLGludmVyc2UpIHtcbiAgICAgICAgaWYgKCAhIHNlbGYucmVzdWx0IHx8IHNlbGYuYWdpID09PSBhY2Nlc3Npb24ubmFtZSB8fCBzZWxmLmFjYyA9PT0gYWNjZXNzaW9uLm5hbWUgKSB7XG4gICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIGludmVyc2UgKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5yZXN1bHQuY2FsY3VsYXRlU2VxdWVuY2VQb3NpdGlvbkZyb21Qb3NpdGlvbihzZWxmLmFnaSB8fCBzZWxmLmFjYyxhY2Nlc3Npb24ubmFtZS50b0xvd2VyQ2FzZSgpLHBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGYucmVzdWx0LmNhbGN1bGF0ZVBvc2l0aW9uRm9yU2VxdWVuY2Uoc2VsZi5hZ2kgfHwgc2VsZi5hY2MsYWNjZXNzaW9uLm5hbWUudG9Mb3dlckNhc2UoKSxwb3MpO1xuICAgIH0pO1xufTtcblxuXG4oZnVuY3Rpb24oKSB7XG52YXIgbm9ybWFsaXNlX2luc2VydGlvbnMgPSBmdW5jdGlvbihpbnNlcnRzKSB7XG4gICAgdmFyIHBvcztcbiAgICB2YXIgcG9zaXRpb25zID0gW107XG4gICAgdmFyIHJlc3VsdF9kYXRhID0ge307XG4gICAgZm9yIChwb3MgaW4gaW5zZXJ0cykge1xuICAgICAgICBpZiAoaW5zZXJ0cy5oYXNPd25Qcm9wZXJ0eShwb3MpICYmIHBhcnNlSW50KHBvcykgPj0gLTEpIHtcbiAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKHBhcnNlSW50KHBvcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBvc2l0aW9ucyA9IHBvc2l0aW9ucy5zb3J0KGZ1bmN0aW9uIHNvcnRmdW5jdGlvbihhLCBiKXtcbiAgICAgICAgcmV0dXJuIChhIC0gYik7XG4gICAgfSk7XG5cbiAgICAvLyBGcm9tIGhpZ2hlc3QgdG8gbG93ZXN0IHBvc2l0aW9uLCBsb29wIHRocm91Z2ggYW5kXG4gICAgLy8gc3VidHJhY3QgdGhlIGxlbmd0aHMgb2YgcHJldmlvdXMgc3VidHJhdGN0aW9ucyBmcm9tXG4gICAgLy8gdGhlIGZpbmFsIHBvc2l0aW9uIHZhbHVlLlxuXG4gICAgZm9yICh2YXIgaSA9IHBvc2l0aW9ucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgaiA9IGkgLSAxO1xuICAgICAgICBwb3MgPSBwYXJzZUludChwb3NpdGlvbnNbaV0pO1xuICAgICAgICB2YXIgdmFsdWUgPSBpbnNlcnRzW3Bvc107XG4gICAgICAgIHdoaWxlIChqID49IDApIHtcbiAgICAgICAgICAgIHBvcyAtPSBpbnNlcnRzW3Bvc2l0aW9uc1tqXV0ubGVuZ3RoO1xuICAgICAgICAgICAgai0tO1xuICAgICAgICB9XG4gICAgICAgIGlmICghIHZhbHVlLm1hdGNoKC9eXFxzKyQvKSkge1xuICAgICAgICAgICAgcmVzdWx0X2RhdGFbcG9zKzFdID0gdmFsdWUgKyAocmVzdWx0X2RhdGFbcG9zKzFdIHx8ICcnKTtcbiAgICAgICAgfVxuICAgIH1cbi8vICAgIGRlbGV0ZSByZXN1bHRfZGF0YVswXTtcbiAgICByZXR1cm4gcmVzdWx0X2RhdGE7XG59O1xuXG52YXIgc3BsaWNlX2NoYXIgPSBmdW5jdGlvbihzZXFzLGluZGV4LGluc2VydGlvbnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlcXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNlcSA9IHNlcXNbaV0udG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHNlcS5jaGFyQXQoaW5kZXgpICE9ICctJykge1xuICAgICAgICAgICAgaWYgKCAhIGluc2VydGlvbnNbaV0gKSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0aW9uc1tpXSA9IHt9O1xuICAgICAgICAgICAgICAgIGluc2VydGlvbnNbaV1bLTFdID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnNlcnRpb25zW2ldW2luZGV4IC0gMV0gPSBzZXEuY2hhckF0KGluZGV4KTtcbiAgICAgICAgICAgIGlmIChpbnNlcnRpb25zW2ldW2luZGV4XSAmJiBpbnNlcnRpb25zW2ldW2luZGV4XS5tYXRjaCgvXFx3LykpIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRpb25zW2ldW2luZGV4LTFdICs9IGluc2VydGlvbnNbaV1baW5kZXhdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBpbnNlcnRpb25zW2ldW2luZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICggaW5zZXJ0aW9uc1tpXSApIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRpb25zW2ldW2luZGV4IC0gMV0gPSAnICc7XG4gICAgICAgICAgICAgICAgaWYgKChpbnNlcnRpb25zW2ldW2luZGV4XSB8fCAnJykubWF0Y2goL15cXHMrJC8pKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydGlvbnNbaV1baW5kZXgtMV0gKz0gaW5zZXJ0aW9uc1tpXVtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBpbnNlcnRpb25zW2ldW2luZGV4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2Vxc1tpXSA9IHNlcS5zbGljZSgwLGluZGV4KSArIHNlcS5zbGljZShpbmRleCsxKTtcbiAgICB9XG59O1xuXG5HYXRvckRhdGFSZWFkZXIuUmVzdWx0LnByb3RvdHlwZS5tYWtlU2VxdWVuY2VzID0gZnVuY3Rpb24ocmVmX2FjYyxhbGlnbm1lbnRzKSB7XG4gIHZhciBzZXFzID0gW107XG4gIHZhciBpbnNlcnRpb25zID0gW107XG4gIHZhciBhY2NzID0gW107XG4gIHZhciByZWZfY2lnYXIgPSAnJztcbiAgYWxpZ25tZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGFsaWduKSB7XG4gICAgaWYgKCAhIGFsaWduLmNpZ2FyICYmIGFsaWduLmNpZ2FyX2xpbmUpIHtcbiAgICAgIGFsaWduLmNpZ2FyID0gYWxpZ24uY2lnYXJfbGluZTtcbiAgICAgIGRlbGV0ZSBhbGlnbi5jaWdhcl9saW5lO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgY2lnYXIgbGluZSBoYXNuJ3QgYWxyZWFkeSBiZWVuIHJldml2aWZpZWRcbiAgICBpZiAoISBhbGlnbi5jaWdhci5tYXRjaCgvXltcXC1cXC5dKiQvKSkge1xuICAgICAgLy8gRXhwYW5kIG91dCB0aGUgY2lnYXIgbGluZSByZXBsYWNpbmcgTSB3aXRoIC4gYW5kIEQgd2l0aCAtXG4gICAgICBhbGlnbi5jaWdhciA9IGFsaWduLmNpZ2FyLm1hdGNoKC9cXGQqW01EXS9nKVxuICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oYml0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheSgocGFyc2VJbnQoYml0LnNsaWNlKDAsLTEpKSB8fCAxKSsxKS5qb2luKCBiaXQuc2xpY2UoLTEpID09ICdNJyA/ICcuJyA6ICctJyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmpvaW4oJycpO1xuICAgIH1cbiAgICBpZiAoYWxpZ24udW5pcHJvdCAhPT0gcmVmX2FjYy50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICBhY2NzLnB1c2goYWxpZ24udW5pcHJvdCk7XG4gICAgICBzZXFzLnB1c2goYWxpZ24uY2lnYXIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZl9jaWdhciA9IGFsaWduLmNpZ2FyO1xuICAgIH1cbiAgfSk7XG4gIHZhciBhbGlnbmluZ19zZXEgPSByZWZfY2lnYXIsIGkgPSBhbGlnbmluZ19zZXEubGVuZ3RoIC0gMTtcbiAgZm9yIChpOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKGFsaWduaW5nX3NlcS5jaGFyQXQoaSkgPT0gJy0nKSB7XG4gICAgICAgICAgc3BsaWNlX2NoYXIoc2VxcyxpLGluc2VydGlvbnMpO1xuICAgICAgfVxuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBzZXFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaW5zZXJ0aW9uc1tpXSkge1xuICAgICAgICAgIGluc2VydGlvbnNbaV0gPSBub3JtYWxpc2VfaW5zZXJ0aW9ucyhpbnNlcnRpb25zW2ldKTtcbiAgICAgICAgICB2YXIgc2VxID0gc2Vxc1tpXTtcbiAgICAgICAgICBzZXFzW2ldID0geyAnc2VxdWVuY2UnIDogc2VxLCAnaW5zZXJ0aW9ucycgOiBpbnNlcnRpb25zW2ldIH07XG4gICAgICAgICAgc2Vxc1tpXS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXF1ZW5jZTtcbiAgICAgICAgICB9O1xuICAgICAgfVxuICB9XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgYWNjcy5mb3JFYWNoKGZ1bmN0aW9uKGFjYyxpZHgpIHtcbiAgICByZXN1bHRbYWNjLnRvTG93ZXJDYXNlKCldID0gc2Vxc1tpZHhdO1xuICB9KTtcbiAgcmVzdWx0W3JlZl9hY2MudG9Mb3dlckNhc2UoKV0gPSByZWZfY2lnYXIucmVwbGFjZSgnLScsJycpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbn0pKCk7XG5cblxuR2F0b3JEYXRhUmVhZGVyLlJlc3VsdC5wcm90b3R5cGUuY2FsY3VsYXRlUG9zaXRpb25Gb3JTZXF1ZW5jZSA9IGZ1bmN0aW9uKHJlZl9hY2MsaWR4LHBvcykge1xuICBpZiAocmVmX2FjYy50b0xvd2VyQ2FzZSgpID09PSBpZHgudG9Mb3dlckNhc2UoKSkge1xuICAgIHJldHVybiBwb3M7XG4gIH1cbiAgaWYgKCAhIHRoaXMuc2VxdWVuY2VzICkge1xuICAgIHRoaXMuc2VxdWVuY2VzID0gdGhpcy5tYWtlU2VxdWVuY2VzKHJlZl9hY2MsdGhpcy5fcmF3X2RhdGEuYWxpZ25tZW50cyk7XG4gIH1cblxuICB2YXIgaW5zZXJ0cyA9IHRoaXMuc2VxdWVuY2VzW2lkeC50b0xvd2VyQ2FzZSgpXS5pbnNlcnRpb25zIHx8IHt9O1xuICB2YXIgcmVzdWx0ID0gcG9zO1xuICB2YXIgYWN0dWFsX3Bvc2l0aW9uID0gMDtcbiAgdmFyIHNlcSA9IHRoaXMuc2VxdWVuY2VzW2lkeC50b0xvd2VyQ2FzZSgpXS50b1N0cmluZygpO1xuICBmb3IgKHZhciBpID0gMCA7IGkgPCBzZXEubGVuZ3RoOyBpKysgKSB7XG4gICAgICBpZiAoaW5zZXJ0c1tpXSkge1xuICAgICAgICAgIGFjdHVhbF9wb3NpdGlvbiArPSBpbnNlcnRzW2ldLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGFjdHVhbF9wb3NpdGlvbiArPSAxO1xuICAgICAgaWYgKHNlcS5jaGFyQXQoaSkgPT0gJy0nKSB7XG4gICAgICAgICAgYWN0dWFsX3Bvc2l0aW9uIC09IDE7XG4gICAgICB9XG4gICAgICBpZiAocG9zIDw9IGFjdHVhbF9wb3NpdGlvbikge1xuICAgICAgICAgIGlmIChwb3MgPT0gYWN0dWFsX3Bvc2l0aW9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiAoaSsxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoaSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICBpID0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gLTEgKiBpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgfVxuICByZXR1cm4gLTEgKiBzZXEubGVuZ3RoO1xufTtcblxuR2F0b3JEYXRhUmVhZGVyLlJlc3VsdC5wcm90b3R5cGUuY2FsY3VsYXRlU2VxdWVuY2VQb3NpdGlvbkZyb21Qb3NpdGlvbiA9IGZ1bmN0aW9uKHJlZl9hY2MsaWR4LHBvcykge1xuICBpZiAocmVmX2FjYy50b0xvd2VyQ2FzZSgpID09PSBpZHgudG9Mb3dlckNhc2UoKSkge1xuICAgIHJldHVybiBwb3M7XG4gIH1cbiAgaWYgKCAhIHRoaXMuc2VxdWVuY2VzICkge1xuICAgIHRoaXMuc2VxdWVuY2VzID0gdGhpcy5tYWtlU2VxdWVuY2VzKHJlZl9hY2MsdGhpcy5fcmF3X2RhdGEuYWxpZ25tZW50cyk7XG4gIH1cbiAgdmFyIGluc2VydHMgPSB0aGlzLnNlcXVlbmNlc1tpZHgudG9Mb3dlckNhc2UoKV0uaW5zZXJ0aW9ucyB8fCB7fTtcbiAgdmFyIHJlc3VsdCA9IHBvcztcbiAgdmFyIGFjdHVhbF9wb3NpdGlvbiA9IDA7XG4gIHZhciBzZXEgPSB0aGlzLnNlcXVlbmNlc1tpZHgudG9Mb3dlckNhc2UoKV0udG9TdHJpbmcoKTtcbiAgZm9yICh2YXIgaSA9IDAgOyBpIDwgcG9zOyBpKysgKSB7XG4gICAgICBpZiAoaW5zZXJ0c1tpXSkge1xuICAgICAgICAgIGFjdHVhbF9wb3NpdGlvbiArPSBpbnNlcnRzW2ldLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGFjdHVhbF9wb3NpdGlvbiArPSAxO1xuICAgICAgaWYgKHNlcS5jaGFyQXQoaSkgPT0gJy0nKSB7XG4gICAgICAgICAgYWN0dWFsX3Bvc2l0aW9uIC09IDE7XG4gICAgICB9XG4gIH1cbiAgaWYgKGFjdHVhbF9wb3NpdGlvbiA9PSAwKSB7XG4gICAgICBhY3R1YWxfcG9zaXRpb24gKz0gMTtcbiAgfVxuICByZXR1cm4gYWN0dWFsX3Bvc2l0aW9uO1xufTtcblxuXG5cblxudmFyIGRlZmF1bHRfcmVzdWx0ID0gR2F0b3JEYXRhUmVhZGVyLlJlc3VsdDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEdhdG9yRGF0YVJlYWRlci5wcm90b3R5cGUsICdkYXRhc2V0bmFtZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RhdGFzZXRuYW1lO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdGhpcy5fZGF0YXNldG5hbWUgPSB2YWx1ZTtcbiAgICAgIHRoaXMuX3JlcXVlc3RzZXQgPSAodmFsdWUgPT09ICdob21vbG9neScpID8gJ2hvbW9sb2d5JyA6ICdjb21iaW5lZCc7XG4gICAgICBsZXQgYWx0X3Jlc3VsdCA9IGNsYXNzIGV4dGVuZHMgZGVmYXVsdF9yZXN1bHQge1xuICAgICAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgICAgZGF0YS5kYXRhc2V0bmFtZSA9IHZhbHVlO1xuICAgICAgICAgIHN1cGVyKGRhdGEpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5SZXN1bHQgPSBhbHRfcmVzdWx0O1xuICAgIH1cbn0pO1xuR2F0b3JEYXRhUmVhZGVyLmF1dGhlbnRpY2F0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gYXV0aGVudGljYXRlX2dhdG9yKCk7XG59O1xuXG52YXIgcnVubmluZ19wcm9taXNlcyA9IHt9O1xuXG52YXIgbmV3X3JldHJpZXZlID0gZnVuY3Rpb24oYWNjKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIG9yaWdfYXJndW1lbnRzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICBpZiAocnVubmluZ19wcm9taXNlc1thY2MrJy0nK3RoaXMuX3JlcXVlc3RzZXRdKSB7XG4gICAgcnVubmluZ19wcm9taXNlc1thY2MrJy0nK3RoaXMuX3JlcXVlc3RzZXRdLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICBHYXRvckRhdGFSZWFkZXIucHJvdG90eXBlLnJldHJpZXZlLmFwcGx5KHNlbGYsb3JpZ19hcmd1bWVudHMpO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgYXV0aGVudGljYXRlX2dhdG9yKCkudGhlbihmdW5jdGlvbigpe1xuICAgICAgICBuZXdfcmV0cmlldmUuYXBwbHkoc2VsZixvcmlnX2FyZ3VtZW50cyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cbiAgcnVubmluZ19wcm9taXNlc1thY2MrJy0nK3RoaXMuX3JlcXVlc3RzZXRdID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSxyZWplY3QpIHtcbiAgICBzZWxmLmJpbmQoJ3Jlc3VsdFJlY2VpdmVkJyxyZXNvbHZlKTtcbiAgICBzZWxmLm9uY2UoJ2Vycm9yJyxyZWplY3QpO1xuICB9KTtcblxuICBydW5uaW5nX3Byb21pc2VzW2FjYysnLScrdGhpcy5fcmVxdWVzdHNldF0uY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgYXV0aGVudGljYXRlX2dhdG9yKCkudGhlbihmdW5jdGlvbigpeyBydW5uaW5nX3Byb21pc2VzW2FjYysnLScrc2VsZi5fcmVxdWVzdHNldF0gPSBudWxsIH0pO1xuICB9KTtcblxuICBHYXRvckRhdGFSZWFkZXIucHJvdG90eXBlLnJldHJpZXZlLmFwcGx5KHNlbGYsb3JpZ19hcmd1bWVudHMpO1xufTtcblxuR2F0b3JEYXRhUmVhZGVyLmNyZWF0ZVJlYWRlciA9IGZ1bmN0aW9uKGRvYykge1xuICAgIC8vIERvIHRoZSBhdXRoIGRhbmNlIGhlcmVcblxuICAgIHZhciByZWFkZXIgPSBuZXcgR2F0b3JEYXRhUmVhZGVyKG51bGwsdXJsX2Jhc2UrJy9kYXRhL2xhdGVzdC8nKTtcbiAgICBjb25zb2xlLmxvZyhkb2MpO1xuICAgIHJlYWRlci5kYXRhc2V0bmFtZSA9IGRvYztcbiAgICAvLyBNQVNDUC5TZXJ2aWNlLkNhY2hlU2VydmljZShyZWFkZXIpO1xuXG4gICAgYXV0aGVudGljYXRlX2dhdG9yKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIHJlYWRlci5yZXRyaWV2ZSA9IG5ld19yZXRyaWV2ZTtcbiAgICAgIGJlYW4uZmlyZShyZWFkZXIsJ3JlYWR5Jyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVhZGVyO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgR2F0b3JEYXRhUmVhZGVyOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQU9BO0FBQ0E7QUFmQTtBQUNBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../gator/js/lib/GatorDataReader.js\n")},"../gator/js/lib/GeneComponent.js":
/*!****************************************!*\
  !*** ../gator/js/lib/GeneComponent.js ***!
  \****************************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _GenomeReader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GenomeReader */ \"../gator/js/lib/GenomeReader.js\");\n/* harmony import */ var _GatorComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GatorComponent */ \"../gator/js/lib/GatorComponent.js\");\n\n\nconst last_retrieved_gene = Symbol('last_retrieved_gene');\n\nclass GeneComponent extends _GatorComponent__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n  static get observedAttributes() {\n    return ['geneid'];\n  }\n\n  constructor() {\n    super();\n  }\n\n  connectedCallback() {\n    super.connectedCallback();\n    setup_renderer.call(this);\n\n    if (this.geneid) {\n      retrieve_data.call(this);\n    }\n  }\n\n  attributeChangedCallback(name, old, newval) {\n    if (name === 'geneid' && this.renderer) {\n      retrieve_data.call(this);\n      return;\n    }\n  }\n\n  get geneid() {\n    return this.getAttribute('geneid');\n  }\n\n  set geneid(id) {\n    this.setAttribute('geneid', id);\n  }\n\n}\n\nlet reader_has_data = function reader_has_data() {\n  if (!this.geneid) {\n    return;\n  }\n\n  if (this[last_retrieved_gene] === this.geneid) {\n    return;\n  }\n\n  this[last_retrieved_gene] = this.geneid;\n  console.log('Getting data for ', this.geneid);\n  var reader = new _GenomeReader__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n  reader.geneid = this.geneid;\n\n  if (this.hasAttribute('reviewed')) {\n    reader.reviewed = true;\n  } // reader.uniprot = 'Q10472';\n\n\n  reader.exon_margin = 300; //..this.exonmargin || 300;\n\n  if (this.nt_mapping) {\n    reader.nt_mapping = this.nt_mapping;\n  }\n\n  if (!this.ready) {\n    reader.registerSequenceRenderer(this.renderer);\n    reader.bind('requestComplete', () => {\n      this.renderer.hideAxis();\n      this.renderer.fitZoom();\n    });\n    this.ready = new Promise(resolve => {\n      reader.bind('requestComplete', () => {\n        this.uniprots = Object.keys(reader.result._raw_data.data).map(up => up.toUpperCase());\n\n        if (reader.reviewed) {\n          this.uniprots = this.uniprots.filter(up => up === reader.swissprot.toUpperCase());\n        }\n\n        this.refreshTracks();\n        resolve();\n        delete this.ready;\n        var event = new Event('ready', {\n          bubbles: true\n        });\n        this.dispatchEvent(event);\n      });\n    });\n  }\n\n  reader.retrieve(this.accession || \"\" + this.geneid);\n};\n\nlet setup_renderer = function setup_renderer() {\n  this.renderer.trackOrder = [];\n  this.renderer.reset();\n};\n\nlet retrieve_data = function retrieve_data() {\n  this.renderer.bind('sequenceChange', reader_has_data.bind(this));\n  this.renderer.setSequence('M');\n};\n\ncustomElements.define('x-geneviewer', GeneComponent);\n/* harmony default export */ __webpack_exports__[\"default\"] = (GeneComponent);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vZ2F0b3IvanMvbGliL0dlbmVDb21wb25lbnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vZ2F0b3IvanMvbGliL0dlbmVDb21wb25lbnQuanM/NDFiNCJdLCJzb3VyY2VzQ29udGVudCI6WyIgXG5pbXBvcnQgR2Vub21lUmVhZGVyIGZyb20gJy4vR2Vub21lUmVhZGVyJztcbmltcG9ydCBHYXRvckNvbXBvbmVudCBmcm9tICcuL0dhdG9yQ29tcG9uZW50JztcblxuY29uc3QgbGFzdF9yZXRyaWV2ZWRfZ2VuZSA9IFN5bWJvbCgnbGFzdF9yZXRyaWV2ZWRfZ2VuZScpO1xuXG5jbGFzcyBHZW5lQ29tcG9uZW50IGV4dGVuZHMgR2F0b3JDb21wb25lbnQge1xuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydnZW5laWQnXTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgIHNldHVwX3JlbmRlcmVyLmNhbGwodGhpcyk7XG4gICAgaWYgKHRoaXMuZ2VuZWlkKSB7XG4gICAgICByZXRyaWV2ZV9kYXRhLmNhbGwodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsb2xkLG5ld3ZhbCkge1xuICAgIGlmIChuYW1lID09PSAnZ2VuZWlkJyAmJiB0aGlzLnJlbmRlcmVyKSB7XG4gICAgICByZXRyaWV2ZV9kYXRhLmNhbGwodGhpcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgZ2V0IGdlbmVpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2dlbmVpZCcpO1xuICB9XG4gIHNldCBnZW5laWQoaWQpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnZ2VuZWlkJyxpZCk7XG4gIH1cbn1cblxubGV0IHJlYWRlcl9oYXNfZGF0YSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoICEgdGhpcy5nZW5laWQgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICggdGhpc1tsYXN0X3JldHJpZXZlZF9nZW5lXSA9PT0gdGhpcy5nZW5laWQgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXNbbGFzdF9yZXRyaWV2ZWRfZ2VuZV0gPSB0aGlzLmdlbmVpZDtcblxuICBjb25zb2xlLmxvZygnR2V0dGluZyBkYXRhIGZvciAnLHRoaXMuZ2VuZWlkKTtcbiAgdmFyIHJlYWRlciA9IG5ldyBHZW5vbWVSZWFkZXIoKTtcbiAgcmVhZGVyLmdlbmVpZCA9IHRoaXMuZ2VuZWlkO1xuICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ3Jldmlld2VkJykpIHtcbiAgICByZWFkZXIucmV2aWV3ZWQgPSB0cnVlO1xuICB9XG4gIC8vIHJlYWRlci51bmlwcm90ID0gJ1ExMDQ3Mic7XG4gIHJlYWRlci5leG9uX21hcmdpbiA9IDMwMDsvLy4udGhpcy5leG9ubWFyZ2luIHx8IDMwMDtcbiAgaWYgKHRoaXMubnRfbWFwcGluZykge1xuICAgIHJlYWRlci5udF9tYXBwaW5nID0gdGhpcy5udF9tYXBwaW5nO1xuICB9XG4gIGlmICggISB0aGlzLnJlYWR5ICkge1xuICAgIHJlYWRlci5yZWdpc3RlclNlcXVlbmNlUmVuZGVyZXIodGhpcy5yZW5kZXJlcik7XG4gICAgcmVhZGVyLmJpbmQoJ3JlcXVlc3RDb21wbGV0ZScsKCkgPT4ge1xuICAgICAgdGhpcy5yZW5kZXJlci5oaWRlQXhpcygpO1xuICAgICAgdGhpcy5yZW5kZXJlci5maXRab29tKCk7XG4gICAgfSk7XG4gICAgdGhpcy5yZWFkeSA9IG5ldyBQcm9taXNlKCAocmVzb2x2ZSkgPT4ge1xuICAgICAgcmVhZGVyLmJpbmQoJ3JlcXVlc3RDb21wbGV0ZScsKCkgPT4ge1xuICAgICAgICB0aGlzLnVuaXByb3RzID0gT2JqZWN0LmtleXMocmVhZGVyLnJlc3VsdC5fcmF3X2RhdGEuZGF0YSkubWFwKCB1cCA9PiB1cC50b1VwcGVyQ2FzZSgpICk7XG4gICAgICAgIGlmIChyZWFkZXIucmV2aWV3ZWQpIHtcbiAgICAgICAgICB0aGlzLnVuaXByb3RzID0gdGhpcy51bmlwcm90cy5maWx0ZXIoIHVwID0+IHVwID09PSByZWFkZXIuc3dpc3Nwcm90LnRvVXBwZXJDYXNlKCkgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZnJlc2hUcmFja3MoKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICBkZWxldGUgdGhpcy5yZWFkeTtcbiAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEV2ZW50KCdyZWFkeScse2J1YmJsZXM6IHRydWV9KTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmVhZGVyLnJldHJpZXZlKHRoaXMuYWNjZXNzaW9uIHx8IFwiXCIrdGhpcy5nZW5laWQpO1xuXG59O1xuXG5sZXQgc2V0dXBfcmVuZGVyZXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yZW5kZXJlci50cmFja09yZGVyID0gW107XG4gIHRoaXMucmVuZGVyZXIucmVzZXQoKTtcbn07XG5cbmxldCByZXRyaWV2ZV9kYXRhID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmVuZGVyZXIuYmluZCgnc2VxdWVuY2VDaGFuZ2UnLHJlYWRlcl9oYXNfZGF0YS5iaW5kKHRoaXMpKTtcbiAgdGhpcy5yZW5kZXJlci5zZXRTZXF1ZW5jZSgnTScpO1xufTtcblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCd4LWdlbmV2aWV3ZXInLEdlbmVDb21wb25lbnQpO1xuXG5leHBvcnQgZGVmYXVsdCBHZW5lQ29tcG9uZW50OyJdLCJtYXBwaW5ncyI6IkFBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUE5QkE7QUFDQTtBQStCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../gator/js/lib/GeneComponent.js\n")},"../gator/js/lib/GenomeReader.js":
/*!***************************************!*\
  !*** ../gator/js/lib/GenomeReader.js ***!
  \***************************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _MASCP__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MASCP */ "../gator/js/lib/MASCP.js");\n/* harmony import */ var _Service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Service */ "../gator/js/lib/Service.js");\n/* harmony import */ var _bean__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../bean */ "../gator/js/bean.js");\n/** @fileOverview   Classes for reading data from MyGene.info */\n\n\n\n/** Default class constructor\n *  @class      Service class that will retrieve data from Mygene.info for given sequences\n *  @param      {String} endpointURL    Endpoint URL for this service\n *  @extends    MASCP.Service\n */\n\nconst GenomeReader = _Service__WEBPACK_IMPORTED_MODULE_1__["default"].buildService(function (data) {\n  this._raw_data = data;\n  return this;\n});\nGenomeReader.SERVICE_URL = \'http://mygene.info/v2/query\';\n\nGenomeReader.prototype.requestData = function () {\n  this.acc = this.agi;\n\n  if (!this.geneid) {\n    return {\n      type: "GET",\n      dataType: "json",\n      url: \'https://mygene.info/v2/query\',\n      data: {\n        \'q\': \'uniprot:\' + this.acc.toUpperCase(),\n        \'fields\': \'entrezgene\',\n        \'email\': \'joshi%40sund.ku.dk\'\n      }\n    };\n  } else if (!this.acc) {\n    this.acc = this.agi = "" + this.geneid;\n  }\n\n  if (!this.exons) {\n    return {\n      type: "GET",\n      url: \'https://mygene.info/v3/gene/\' + this.geneid,\n      dataType: "json",\n      data: {\n        \'fields\': \'exons_hg19,uniprot.Swiss-Prot\'\n      }\n    };\n  }\n\n  if (this.tried_isoform) {\n    return _MASCP__WEBPACK_IMPORTED_MODULE_0__["default"].GatorDataReader.authenticate().then(url_base => {\n      this.tried_bare = true;\n      return {\n        type: "GET",\n        dataType: "json",\n        auth: _MASCP__WEBPACK_IMPORTED_MODULE_0__["default"].GATOR_AUTH_TOKEN,\n        api_key: _MASCP__WEBPACK_IMPORTED_MODULE_0__["default"].GATOR_CLIENT_ID,\n        url: url_base + \'/data/latest/combined/\' + this.swissprot.toUpperCase()\n      };\n    });\n  }\n\n  return _MASCP__WEBPACK_IMPORTED_MODULE_0__["default"].GatorDataReader.authenticate().then(url_base => {\n    this.tried_isoform = true;\n    return {\n      type: "GET",\n      dataType: "json",\n      auth: _MASCP__WEBPACK_IMPORTED_MODULE_0__["default"].GATOR_AUTH_TOKEN,\n      api_key: _MASCP__WEBPACK_IMPORTED_MODULE_0__["default"].GATOR_CLIENT_ID,\n      url: url_base + \'/data/latest/combined/\' + this.swissprot.toUpperCase() + \'-1\'\n    };\n  });\n  return {\n    type: "GET",\n    dataType: "txt",\n    url: "https://www.uniprot.org/mapping/",\n    data: {\n      "from": "REFSEQ_NT_ID",\n      "to": "ACC",\n      "format": "tab",\n      "query": Object.keys(this.exons).join(\' \')\n    }\n  };\n};\n\nlet update_structure = data => {\n  let result = {};\n\n  for (let transcript of data) {\n    result[transcript.transcript] = transcript;\n    transcript.exons = transcript.position;\n    delete transcript.position;\n  }\n\n  return result;\n};\n\n(function (serv) {\n  var defaultDataReceived = serv.prototype._dataReceived;\n\n  serv.prototype._dataReceived = function (data, status) {\n    var self = this;\n\n    if (data.data && status === "db") {\n      self.sequences = [{\n        "agi": "genome"\n      }];\n      Object.keys(data.data).forEach(function (uniprot) {\n        self.sequences.push({\n          "agi": uniprot.toLowerCase()\n        });\n      });\n      return defaultDataReceived.call(this, data, status);\n    }\n\n    if (status < 200 || status >= 400) {\n      return defaultDataReceived.call(this, null, status);\n    }\n\n    if (!this.geneid) {\n      this.geneid = data.hits[0].entrezgene;\n      this.retrieve(this.acc || this.agi);\n      return;\n    }\n\n    if (!this.exons) {\n      this.exons = update_structure(data.exons_hg19 || data.exons);\n      this.swissprot = (data.uniprot || {})[\'Swiss-Prot\'].toLowerCase();\n\n      if (!this.nt_mapping) {\n        this.retrieve(this.acc || this.agi);\n        return;\n      }\n\n      data = this.nt_mapping.map(function (map) {\n        return map.join(\'\\t\');\n      }).join(\'\\n\');\n    }\n\n    data = data.data.filter(dat => dat.dataset == \'uniprot_refseqnt\');\n\n    if (data.length > 0) {\n      data = data[0].data.map(mapping => [mapping.refseqnt.replace(/\\..*/, \'\'), mapping.uniprot].join(\'\\t\')).join(\'\\n\');\n    } else {\n      if (this.tried_isoform && !this.tried_bare) {\n        this.retrieve(this.acc || this.agi);\n        return;\n      }\n\n      data = "";\n    }\n\n    var mapped = {};\n    self.sequences = [{\n      "agi": "genome"\n    }];\n    (data || "").split(\'\\n\').forEach(function (row) {\n      var bits = row.split(\'\\t\');\n\n      if (!bits[1]) {\n        return;\n      }\n\n      var uniprot = bits[1].toLowerCase().replace(/-\\d+/, \'\');\n      var nuc = bits[0];\n      nuc = nuc.replace(/\\..*$/, \'\');\n\n      if (!self.exons[nuc]) {\n        return;\n      }\n\n      if (!self.agi || !self.acc) {\n        self.acc = uniprot;\n        self.agi = uniprot;\n      }\n\n      if (!mapped[uniprot]) {\n        mapped[uniprot] = [];\n      }\n\n      self.exons[nuc]._id = nuc;\n      mapped[uniprot].push(self.exons[nuc]);\n      self.sequences.push({\n        "agi": uniprot.toLowerCase()\n      });\n    });\n    return defaultDataReceived.call(this, {\n      "data": mapped\n    }, status);\n  };\n})(GenomeReader);\n\nGenomeReader.Result.prototype.getSequences = function () {\n  var results = [];\n  var cds_data = this._raw_data.data;\n  var uniprots = Object.keys(cds_data);\n  let min, max;\n  min = max = null;\n  uniprots.forEach(function (uniprot) {\n    var ends = cds_data[uniprot].map(function (cd) {\n      if (Array.isArray(cd)) {\n        cd = cd.filter(function (c) {\n          return c.chr.match(/^[\\dXx]+$/);\n        })[0];\n      }\n\n      return [cd.txstart, cd.txend];\n    });\n    ends.forEach(function (cd) {\n      if (!min || cd[0] < min) {\n        min = cd[0];\n      }\n\n      if (!max || cd[1] > max) {\n        max = cd[1];\n      }\n    });\n  });\n  results = [Array(Math.floor((max - min) / 3)).join(\'.\')];\n  this.min = min;\n  this.max = max;\n  return results;\n};\n\nGenomeReader.Result.prototype.getIntrons = function (margin) {\n  var self = this;\n  var results = [];\n  var uprots = Object.keys(self._raw_data.data);\n  uprots.forEach(function (up) {\n    var cds = self._raw_data.data[up];\n    cds.forEach(function (target_cds) {\n      if (Array.isArray(target_cds)) {\n        target_cds = target_cds.filter(function (c) {\n          return c.chr.match(/^[\\dXx]+$/);\n        })[0];\n\n        if (!target_cds) {\n          return null;\n        }\n      }\n\n      var exons = target_cds.exons;\n      var target_position;\n\n      for (var i = 0; i < exons.length; i++) {\n        if (i == 0) {\n          results.push([self.min, exons[i][0] - margin]);\n        } else {\n          results.push([exons[i - 1][1] + margin, exons[i][0] - margin]);\n        }\n\n        if (i == exons.length - 1) {\n          results.push([exons[i][1] + margin, self.max]);\n        }\n\n        if (results.slice(-1)[0][0] > results.slice(-1)[0][1]) {\n          results.splice(results.length - 1, 1);\n        }\n      }\n    });\n  });\n  return results;\n};\n\nGenomeReader.prototype.proteinLength = function (target_cds) {\n  var exons = target_cds.exons;\n  var total = 0;\n\n  for (var i = 0; i < exons.length; i++) {\n    if (target_cds.cdsstart > exons[i][1] & target_cds.cdsstart > exons[i][0]) {\n      continue;\n    }\n\n    if (target_cds.cdsend < exons[i][0]) {\n      continue;\n    }\n\n    var start = target_cds.cdsstart > exons[i][0] ? target_cds.cdsstart : exons[i][0];\n    var end = target_cds.cdsend < exons[i][1] ? target_cds.cdsend : exons[i][1];\n    total += end - start;\n  }\n\n  return Math.floor(total / 3) - 1;\n};\n\nGenomeReader.prototype.calculateSequencePositionFromProteinPosition = function (idx, pos) {\n  var self = this;\n  var wanted_identifier = idx;\n\n  var cds = self.result._raw_data.data[wanted_identifier.toLowerCase()];\n\n  if (!cds) {\n    return -1;\n  }\n\n  if (!cds.txstart) {\n    cds = cds.map(function (cd) {\n      if (Array.isArray(cd)) {\n        cd = cd.filter(function (c) {\n          return c.chr.match(/^[\\dXx]+$/);\n        })[0];\n\n        if (!cd) {\n          return null;\n        }\n      }\n\n      return cd;\n    });\n  }\n\n  var target_cds = cds[0] || {};\n  var exons = target_cds.exons || [];\n  var position_genome = Math.floor(pos / 3);\n  var target_position = 0;\n\n  if (pos < target_cds.cdsstart) {\n    target_position = 6;\n\n    if (target_cds.strand == -1) {\n      target_position = 3;\n    }\n  }\n\n  if (pos > target_cds.cdsend) {\n    target_position = self.proteinLength(target_cds) * 3;\n\n    if (target_cds.strand == 1) {\n      target_position += 3;\n    }\n  }\n\n  if (target_position == 0) {\n    for (var i = 0; i < exons.length; i++) {\n      if (target_cds.cdsstart > exons[i][1] & target_cds.cdsstart > exons[i][0]) {\n        continue;\n      }\n\n      var start = target_cds.cdsstart > exons[i][0] ? target_cds.cdsstart : exons[i][0];\n      var end = target_cds.cdsend < exons[i][1] ? target_cds.cdsend : exons[i][1];\n\n      if (pos < start) {\n        break;\n      }\n\n      if (pos <= end && pos >= start) {\n        target_position += pos - start;\n        break;\n      } else {\n        target_position += end - start;\n      }\n    }\n  }\n\n  target_position = Math.floor(target_position / 3) - 1;\n\n  if (target_cds.strand == -1) {\n    target_position = self.proteinLength(target_cds) - target_position;\n  }\n\n  return target_position;\n};\n\nGenomeReader.prototype.calculateProteinPositionForSequence = function (idx, pos) {\n  var self = this;\n  var wanted_identifier = idx;\n\n  var cds = self.result._raw_data.data[wanted_identifier.toLowerCase()];\n\n  if (!cds) {\n    return -1;\n  }\n\n  if (!cds.txstart) {\n    cds = cds.map(function (cd) {\n      if (Array.isArray(cd)) {\n        cd = cd.filter(function (c) {\n          return c.chr.match(/^[\\dXx]+$/);\n        })[0];\n\n        if (!cd) {\n          return null;\n        }\n      }\n\n      return cd;\n    });\n  }\n\n  var target_cds = cds[0] || {};\n  var exons = target_cds.exons || [];\n\n  if (target_cds.strand == -1) {\n    pos = self.proteinLength(target_cds) - pos;\n  }\n\n  var position_genome = pos * 3;\n  var target_position;\n\n  for (var i = 0; i < exons.length; i++) {\n    if (target_cds.cdsstart > exons[i][1] & target_cds.cdsstart > exons[i][0]) {\n      continue;\n    }\n\n    var start = target_cds.cdsstart > exons[i][0] ? target_cds.cdsstart : exons[i][0];\n    var bases = exons[i][1] - start;\n\n    if (bases >= position_genome) {\n      target_position = start + position_genome;\n      break;\n    } else {\n      position_genome -= bases;\n    }\n  }\n\n  return target_position;\n};\n\nGenomeReader.prototype.calculatePositionForSequence = function (idx, pos) {\n  var self = this;\n  var wanted_identifier = self.sequences[idx].agi;\n  var empty_regions = [];\n  var calculated_pos = pos;\n\n  if (wanted_identifier == \'genome\') {// Don\'t change the genome identifier\n  } else {\n    calculated_pos = self.calculateProteinPositionForSequence(idx, pos);\n  }\n\n  for (var i = 0; i < empty_regions.length; i++) {\n    if (pos > empty_regions[i][1]) {\n      calculated_pos -= empty_regions[i][1] - empty_regions[i][0];\n    }\n\n    if (pos < empty_regions[i][1] && pos > empty_regions[i][0]) {\n      calculated_pos = -1;\n    }\n  }\n\n  return calculated_pos;\n};\n\n(function (serv) {\n  var get_exon_boxes = function get_exon_boxes(result, uniprot) {\n    var cds_data = result._raw_data.data;\n\n    if (uniprot) {\n      console.log(\'Filtering exons so we only show\', uniprot);\n    }\n\n    var uniprots = Object.keys(cds_data);\n    var max = result.max;\n    var min = result.min;\n    var return_data = [];\n    var base_offset = 0;\n    uniprots.filter(up => uniprot ? up === (uniprot || \'\').toLowerCase() : true).forEach(function (uniprot) {\n      var ends = cds_data[uniprot].map(function (cd, idx) {\n        if (Array.isArray(cd)) {\n          cd = cd.filter(function (c) {\n            return c.chr.match(/^[\\dXx]+$/);\n          })[0];\n\n          if (!cd) {\n            return;\n          }\n        }\n\n        var exons = cd.exons;\n        var color = idx == 0 ? \'#999\' : \'#f99\';\n        exons.forEach(function (exon) {\n          return_data.push({\n            "aa": 1 + exon[0],\n            "type": "box",\n            "width": exon[1] - exon[0],\n            "options": {\n              "offset": base_offset,\n              "height_scale": 1,\n              "fill": color,\n              "merge": false\n            }\n          });\n\n          if (cd.strand > 0) {\n            return_data.push({\n              "aa": exon[1] - 1,\n              "type": "marker",\n              "options": {\n                "height": 4,\n                "content": {\n                  "type": "right_triangle",\n                  "fill": \'#aaa\'\n                },\n                "offset": base_offset + 2,\n                "bare_element": true\n              }\n            });\n          } else {\n            return_data.push({\n              "aa": exon[0] + 1,\n              "type": "marker",\n              "options": {\n                "height": 4,\n                "content": {\n                  "type": "left_triangle",\n                  "fill": \'#aaa\'\n                },\n                "offset": base_offset + 2,\n                "bare_element": true\n              }\n            });\n          }\n        });\n        return_data.push({\n          "aa": cd.cdsstart,\n          "type": "box",\n          "width": 1,\n          "options": {\n            "fill": "#0000ff",\n            "height_scale": 2,\n            "offset": base_offset - 2,\n            "merge": false\n          }\n        });\n        return_data.push({\n          "aa": cd.cdsend,\n          "type": "box",\n          "width": 1,\n          "options": {\n            "fill": "#0000ff",\n            "height_scale": 2,\n            "offset": base_offset - 2,\n            "merge": false\n          }\n        });\n        base_offset += 1;\n      });\n      base_offset += 2;\n    });\n    return return_data;\n  };\n\n  var get_removed_labels = function get_removed_labels(result) {\n    var removed = result.removed_regions || [];\n    var results = [];\n    var max = result.max;\n    var min = result.min;\n    var cds_data = result._raw_data.data;\n    var uniprots = Object.keys(cds_data);\n    var total = uniprots.reduce(function (prev, up) {\n      return prev + cds_data[up].length;\n    }, 0);\n    removed.forEach(function (vals) {\n      var start = vals[0];\n      var end = vals[1];\n      var start_txt = Math.floor(start % 1e6 / 1000) + "kb";\n      var end_txt = Math.floor(end % 1e6 / 1000) + "kb";\n      results.push({\n        "aa": start - 1,\n        "type": "box",\n        width: end - start + 3,\n        "options": {\n          "fill": "#999",\n          "height_scale": total * 3,\n          "offset": -1 * total\n        }\n      });\n      results.push({\n        "aa": start - 3,\n        "type": "text",\n        "options": {\n          "txt": start_txt,\n          "fill": "#000",\n          "height": 4,\n          "offset": -4,\n          "align": "right"\n        }\n      });\n      results.push({\n        "aa": end + 3,\n        "type": "text",\n        "options": {\n          "txt": end_txt,\n          "fill": "#000",\n          "height": 4,\n          "offset": 4,\n          "align": "left"\n        }\n      });\n    });\n    return results;\n  };\n\n  var calculate_removed_regions = function calculate_removed_regions(result, margin) {\n    var introns = result.getIntrons(margin);\n    var intervals = [{\n      "index": result.min - 2,\n      "start": true,\n      "idx": -1\n    }, {\n      "index": result.min,\n      "start": false,\n      "idx": -1\n    }];\n    introns.forEach(function (intron, idx) {\n      intervals.push({\n        "index": intron[0],\n        "start": true,\n        "idx": idx\n      });\n      intervals.push({\n        "index": intron[1],\n        "start": false,\n        "idx": idx\n      });\n    });\n    intervals.sort(function (a, b) {\n      if (a.index < b.index) {\n        return -1;\n      }\n\n      if (a.index > b.index) {\n        return 1;\n      }\n\n      if (a.index == b.index) {\n        return a.start ? -1 : 1;\n      }\n    });\n    var results = [];\n    intervals.forEach(function (intr, idx) {\n      if (intr.start && intervals[idx + 1] && intervals[idx + 1].start == false) {\n        if (intr.index != intervals[idx + 1].index && intervals[idx + 1].index != result.min) {\n          results.push([intr.index, intervals[idx + 1].index]);\n        }\n      }\n    });\n    result.removed_regions = results;\n  };\n\n  var generate_scaler_function = function generate_scaler_function(reader) {\n    return function (in_pos, layer, inverse) {\n      var pos = in_pos;\n\n      if (!reader.result) {\n        return inverse ? pos * 3 : Math.floor(pos / 3);\n      }\n\n      var introns = reader.result.removed_regions || [];\n\n      if (inverse) {\n        pos = in_pos * 3;\n        calculated_pos = pos;\n\n        for (var i = 0; i < introns.length && pos > 0; i++) {\n          var left_exon = i > 0 ? introns[i - 1] : [null, reader.result.min];\n          var right_exon = introns[i] || [reader.result.max, null];\n          pos -= right_exon[0] - left_exon[1];\n\n          if (pos > 0) {\n            calculated_pos += introns[i][1] - introns[i][0];\n          }\n        }\n\n        return calculated_pos + reader.result.min;\n      }\n\n      var calculated_pos = pos - reader.result.min;\n\n      for (var i = 0; i < introns.length; i++) {\n        if (pos > introns[i][1]) {\n          calculated_pos -= introns[i][1] - introns[i][0];\n        }\n\n        if (pos < introns[i][1] && pos > introns[i][0]) {\n          calculated_pos = introns[i][1] - reader.result.min;\n        }\n      }\n\n      if (calculated_pos < 3) {\n        calculated_pos = 3;\n      }\n\n      return Math.floor(calculated_pos / 3);\n    };\n  };\n\n  Object.defineProperty(serv.prototype, \'exon_margin\', {\n    set: function set(val) {\n      this._exon_margin = val;\n\n      if (this.result) {\n        calculate_removed_regions(this.result, val);\n        this.redrawIntrons();\n      }\n    },\n    get: function get() {\n      return this._exon_margin;\n    }\n  });\n\n  var redrawIntrons = function redrawIntrons(renderer, controller_name, scaler_function) {\n    var labs = [];\n\n    var zoomCheck = function zoomCheck() {\n      if (labs.length < 1 || !labs[0].parentNode) {\n        return;\n      }\n\n      var hidden = false;\n\n      for (var i = 0; !hidden && i < labs.length - 3; i += 3) {\n        if (labs[i].hasAttribute(\'display\')) {\n          hidden = true;\n          continue;\n        }\n\n        if (labs[i].getBoundingClientRect().right > labs[i + 3].getBoundingClientRect().left) {\n          hidden = true;\n        }\n      }\n\n      labs.forEach(function (lab) {\n        if (lab.nodeName == \'rect\') {\n          return;\n        }\n\n        if (hidden) {\n          lab.setAttribute(\'display\', \'none\');\n        } else {\n          lab.removeAttribute(\'display\');\n        }\n      });\n    };\n\n    renderer.bind(\'zoomChange\', zoomCheck);\n    return function () {\n      var result = this.result;\n      renderer.sequence = Array(scaler_function(result.max)).join(\'.\');\n\n      if (labs.length > 0) {\n        labs.forEach(function (lab) {\n          renderer.remove(controller_name, lab);\n        });\n        labs = [];\n      }\n\n      var proxy_reader = {\n        agi: controller_name,\n        gotResult: function gotResult() {\n          labs = renderer.renderObjects(controller_name, get_removed_labels(result));\n          renderer.refresh();\n          zoomCheck();\n        }\n      };\n      _Service__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.registerSequenceRenderer.call(proxy_reader, renderer);\n      proxy_reader.gotResult();\n    };\n  };\n\n  serv.prototype.setupSequenceRenderer = function (renderer) {\n    var self = this;\n    renderer.addAxisScale(\'genome\', function (pos, layer, inverse) {\n      if (layer && layer.scales.has(\'genomic\')) {\n        return pos;\n      }\n\n      let all_scales = Object.keys(self.result._raw_data.data);\n      let identifier = layer.name;\n\n      for (let scale of all_scales) {\n        if (layer.scales.has(scale.toUpperCase()) || layer.scales.has(scale.toLowerCase())) {\n          identifier = scale;\n        }\n      }\n\n      if (inverse) {\n        return self.calculateSequencePositionFromProteinPosition(identifier, pos);\n      }\n\n      return self.calculateProteinPositionForSequence(identifier, pos);\n    });\n    var controller_name = \'cds\';\n\n    var redraw_alignments = function redraw_alignments(sequence_index) {\n      if (!sequence_index) {\n        sequence_index = 0;\n      }\n\n      _MASCP__WEBPACK_IMPORTED_MODULE_0__["default"].registerLayer(controller_name, {\n        \'fullname\': \'Exons\',\n        \'color\': \'#000000\'\n      });\n      _MASCP__WEBPACK_IMPORTED_MODULE_0__["default"].getLayer(controller_name).scales.add(\'genomic\');\n\n      if (renderer.trackOrder.indexOf(controller_name) < 0) {\n        renderer.trackOrder.push(controller_name);\n      }\n\n      renderer.showLayer(controller_name);\n      var result = this.result;\n      var aligned = result.getSequences();\n      var scaler_function = generate_scaler_function(self);\n      renderer.addAxisScale(\'removeIntrons\', scaler_function);\n      calculate_removed_regions(self.result, self.exon_margin || 300);\n\n      if (!renderer.sequence) {\n        // Not sure what to do with this bit here\n        renderer.setSequence(Array(scaler_function(result.max)).join(\'.\'))(function () {\n          redraw_alignments(sequence_index);\n        });\n        return;\n      } else {\n        renderer.sequence = Array(scaler_function(result.max)).join(\'.\');\n        renderer.redrawAxis();\n      }\n\n      var proxy_reader = {\n        agi: controller_name,\n        gotResult: function gotResult() {\n          renderer.renderObjects(controller_name, get_exon_boxes(result, self.reviewed ? self.swissprot : self.uniprot));\n        }\n      };\n      _Service__WEBPACK_IMPORTED_MODULE_1__["default"].prototype.registerSequenceRenderer.call(proxy_reader, renderer);\n      proxy_reader.gotResult();\n      self.redrawIntrons = redrawIntrons(renderer, controller_name, scaler_function);\n      self.redrawIntrons();\n    };\n\n    this.bind(\'resultReceived\', redraw_alignments);\n  };\n})(GenomeReader);\n\n/* harmony default export */ __webpack_exports__["default"] = (GenomeReader);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vZ2F0b3IvanMvbGliL0dlbm9tZVJlYWRlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9nYXRvci9qcy9saWIvR2Vub21lUmVhZGVyLmpzPzY1ZDAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBmaWxlT3ZlcnZpZXcgICBDbGFzc2VzIGZvciByZWFkaW5nIGRhdGEgZnJvbSBNeUdlbmUuaW5mbyAqL1xuXG5pbXBvcnQgTUFTQ1AgZnJvbSAnLi9NQVNDUCc7XG5pbXBvcnQgU2VydmljZSBmcm9tICcuL1NlcnZpY2UnO1xuaW1wb3J0IGJlYW4gZnJvbSAnLi4vYmVhbic7XG5cblxuLyoqIERlZmF1bHQgY2xhc3MgY29uc3RydWN0b3JcbiAqICBAY2xhc3MgICAgICBTZXJ2aWNlIGNsYXNzIHRoYXQgd2lsbCByZXRyaWV2ZSBkYXRhIGZyb20gTXlnZW5lLmluZm8gZm9yIGdpdmVuIHNlcXVlbmNlc1xuICogIEBwYXJhbSAgICAgIHtTdHJpbmd9IGVuZHBvaW50VVJMICAgIEVuZHBvaW50IFVSTCBmb3IgdGhpcyBzZXJ2aWNlXG4gKiAgQGV4dGVuZHMgICAgTUFTQ1AuU2VydmljZVxuICovXG5jb25zdCBHZW5vbWVSZWFkZXIgPSBTZXJ2aWNlLmJ1aWxkU2VydmljZShmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yYXdfZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbkdlbm9tZVJlYWRlci5TRVJWSUNFX1VSTCA9ICdodHRwOi8vbXlnZW5lLmluZm8vdjIvcXVlcnknO1xuR2Vub21lUmVhZGVyLnByb3RvdHlwZS5yZXF1ZXN0RGF0YSA9IGZ1bmN0aW9uKClcbntcbiAgICB0aGlzLmFjYyA9IHRoaXMuYWdpO1xuXG4gICAgaWYgKCEgdGhpcy5nZW5laWQgKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIkdFVFwiLFxuICAgICAgICAgICAgZGF0YVR5cGU6IFwianNvblwiLFxuICAgICAgICAgICAgdXJsIDogJ2h0dHBzOi8vbXlnZW5lLmluZm8vdjIvcXVlcnknLFxuICAgICAgICAgICAgZGF0YTogeyAncScgOiAndW5pcHJvdDonK3RoaXMuYWNjLnRvVXBwZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgICAgICdmaWVsZHMnICAgOiAnZW50cmV6Z2VuZScsXG4gICAgICAgICAgICAgICAgICAgICdlbWFpbCcgICAgOiAnam9zaGklNDBzdW5kLmt1LmRrJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoICEgdGhpcy5hY2MgKSB7XG4gICAgICAgIHRoaXMuYWNjID0gdGhpcy5hZ2kgPSBcIlwiK3RoaXMuZ2VuZWlkO1xuICAgIH1cblxuICAgIGlmICghIHRoaXMuZXhvbnMgKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIkdFVFwiLFxuICAgICAgICAgICAgdXJsIDogJ2h0dHBzOi8vbXlnZW5lLmluZm8vdjMvZ2VuZS8nK3RoaXMuZ2VuZWlkLFxuICAgICAgICAgICAgZGF0YVR5cGU6IFwianNvblwiLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICdmaWVsZHMnIDogJ2V4b25zX2hnMTksdW5pcHJvdC5Td2lzcy1Qcm90J1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRyaWVkX2lzb2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuIE1BU0NQLkdhdG9yRGF0YVJlYWRlci5hdXRoZW50aWNhdGUoKS50aGVuKCh1cmxfYmFzZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy50cmllZF9iYXJlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJHRVRcIixcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogXCJqc29uXCIsXG4gICAgICAgICAgICAgICAgYXV0aDogTUFTQ1AuR0FUT1JfQVVUSF9UT0tFTixcbiAgICAgICAgICAgICAgICBhcGlfa2V5OiBNQVNDUC5HQVRPUl9DTElFTlRfSUQsXG4gICAgICAgICAgICAgICAgdXJsOiB1cmxfYmFzZSsnL2RhdGEvbGF0ZXN0L2NvbWJpbmVkLycrKHRoaXMuc3dpc3Nwcm90KS50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gTUFTQ1AuR2F0b3JEYXRhUmVhZGVyLmF1dGhlbnRpY2F0ZSgpLnRoZW4oKHVybF9iYXNlKSA9PiB7XG4gICAgICAgIHRoaXMudHJpZWRfaXNvZm9ybSA9IHRydWU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIkdFVFwiLFxuICAgICAgICAgICAgZGF0YVR5cGU6IFwianNvblwiLFxuICAgICAgICAgICAgYXV0aDogTUFTQ1AuR0FUT1JfQVVUSF9UT0tFTixcbiAgICAgICAgICAgIGFwaV9rZXk6IE1BU0NQLkdBVE9SX0NMSUVOVF9JRCxcbiAgICAgICAgICAgIHVybDogdXJsX2Jhc2UrJy9kYXRhL2xhdGVzdC9jb21iaW5lZC8nKyh0aGlzLnN3aXNzcHJvdCkudG9VcHBlckNhc2UoKSsnLTEnXG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIkdFVFwiLFxuICAgICAgICBkYXRhVHlwZTogXCJ0eHRcIixcbiAgICAgICAgdXJsOiBcImh0dHBzOi8vd3d3LnVuaXByb3Qub3JnL21hcHBpbmcvXCIsXG4gICAgICAgIGRhdGEgOiB7XG4gICAgICAgICAgICBcImZyb21cIiA6IFwiUkVGU0VRX05UX0lEXCIsXG4gICAgICAgICAgICBcInRvXCIgOiBcIkFDQ1wiLFxuICAgICAgICAgICAgXCJmb3JtYXRcIiA6IFwidGFiXCIsXG4gICAgICAgICAgICBcInF1ZXJ5XCIgOiBPYmplY3Qua2V5cyh0aGlzLmV4b25zKS5qb2luKCcgJylcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5sZXQgdXBkYXRlX3N0cnVjdHVyZSA9IChkYXRhKSA9PiB7XG4gICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAobGV0IHRyYW5zY3JpcHQgb2YgZGF0YSkge1xuICAgICAgICByZXN1bHRbdHJhbnNjcmlwdC50cmFuc2NyaXB0XSA9IHRyYW5zY3JpcHQ7XG4gICAgICAgIHRyYW5zY3JpcHQuZXhvbnMgPSB0cmFuc2NyaXB0LnBvc2l0aW9uO1xuICAgICAgICBkZWxldGUgdHJhbnNjcmlwdC5wb3NpdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbihmdW5jdGlvbihzZXJ2KSB7XG4gICAgdmFyIGRlZmF1bHREYXRhUmVjZWl2ZWQgPSBzZXJ2LnByb3RvdHlwZS5fZGF0YVJlY2VpdmVkO1xuXG4gICAgc2Vydi5wcm90b3R5cGUuX2RhdGFSZWNlaXZlZCA9IGZ1bmN0aW9uKGRhdGEsc3RhdHVzKVxuICAgIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoZGF0YS5kYXRhICYmIHN0YXR1cyA9PT0gXCJkYlwiKSB7XG4gICAgICAgICAgICBzZWxmLnNlcXVlbmNlcyA9IFt7IFwiYWdpXCIgOiBcImdlbm9tZVwiIH1dO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZGF0YS5kYXRhKS5mb3JFYWNoKGZ1bmN0aW9uKHVuaXByb3QpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNlcXVlbmNlcy5wdXNoKHsgXCJhZ2lcIiA6IHVuaXByb3QudG9Mb3dlckNhc2UoKSB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhUmVjZWl2ZWQuY2FsbCh0aGlzLGRhdGEsc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHVzIDwgMjAwIHx8IHN0YXR1cyA+PSA0MDApIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0RGF0YVJlY2VpdmVkLmNhbGwodGhpcyxudWxsLHN0YXR1cyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoICEgdGhpcy5nZW5laWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ2VuZWlkID0gZGF0YS5oaXRzWzBdLmVudHJlemdlbmU7XG4gICAgICAgICAgICB0aGlzLnJldHJpZXZlKHRoaXMuYWNjIHx8IHRoaXMuYWdpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoICEgdGhpcy5leG9ucyApIHtcbiAgICAgICAgICAgIHRoaXMuZXhvbnMgPSB1cGRhdGVfc3RydWN0dXJlKGRhdGEuZXhvbnNfaGcxOSB8fCBkYXRhLmV4b25zKTtcbiAgICAgICAgICAgIHRoaXMuc3dpc3Nwcm90ID0gKGRhdGEudW5pcHJvdCB8fCB7fSlbJ1N3aXNzLVByb3QnXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKCAhIHRoaXMubnRfbWFwcGluZyApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJldHJpZXZlKHRoaXMuYWNjIHx8IHRoaXMuYWdpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhID0gdGhpcy5udF9tYXBwaW5nLm1hcChmdW5jdGlvbihtYXApIHsgcmV0dXJuIG1hcC5qb2luKCdcXHQnKTsgfSApLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEgPSBkYXRhLmRhdGEuZmlsdGVyKCBkYXQgPT4gZGF0LmRhdGFzZXQgPT0gJ3VuaXByb3RfcmVmc2VxbnQnICk7XG5cbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZGF0YSA9IGRhdGFbMF0uZGF0YS5tYXAoIG1hcHBpbmcgPT4gW21hcHBpbmcucmVmc2VxbnQucmVwbGFjZSgvXFwuLiovLCcnKSxtYXBwaW5nLnVuaXByb3RdLmpvaW4oJ1xcdCcpICkuam9pbignXFxuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIHRoaXMudHJpZWRfaXNvZm9ybSAmJiAhIHRoaXMudHJpZWRfYmFyZSApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJldHJpZXZlKHRoaXMuYWNjIHx8IHRoaXMuYWdpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhID0gXCJcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtYXBwZWQgPSB7fTtcbiAgICAgICAgc2VsZi5zZXF1ZW5jZXMgPSBbeyBcImFnaVwiIDogXCJnZW5vbWVcIiB9XTtcbiAgICAgICAgKGRhdGEgfHwgXCJcIikuc3BsaXQoJ1xcbicpLmZvckVhY2goZnVuY3Rpb24ocm93KSB7XG4gICAgICAgICAgICB2YXIgYml0cyA9IHJvdy5zcGxpdCgnXFx0Jyk7XG4gICAgICAgICAgICBpZiAoICEgYml0c1sxXSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB1bmlwcm90ID0gYml0c1sxXS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLy1cXGQrLywnJyk7XG4gICAgICAgICAgICB2YXIgbnVjID0gYml0c1swXTtcbiAgICAgICAgICAgIG51YyA9IG51Yy5yZXBsYWNlKC9cXC4uKiQvLCcnKTtcbiAgICAgICAgICAgIGlmICghIHNlbGYuZXhvbnNbbnVjXSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghIHNlbGYuYWdpIHx8ICEgc2VsZi5hY2MpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmFjYyA9IHVuaXByb3Q7XG4gICAgICAgICAgICAgICAgc2VsZi5hZ2kgPSB1bmlwcm90O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoICEgbWFwcGVkW3VuaXByb3RdICkge1xuICAgICAgICAgICAgICAgIG1hcHBlZFt1bmlwcm90XSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5leG9uc1tudWNdLl9pZCA9IG51YztcbiAgICAgICAgICAgIG1hcHBlZFt1bmlwcm90XS5wdXNoKHNlbGYuZXhvbnNbbnVjXSk7XG4gICAgICAgICAgICBzZWxmLnNlcXVlbmNlcy5wdXNoKHsgXCJhZ2lcIiA6IHVuaXByb3QudG9Mb3dlckNhc2UoKSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkZWZhdWx0RGF0YVJlY2VpdmVkLmNhbGwodGhpcyx7XCJkYXRhXCI6bWFwcGVkfSxzdGF0dXMpO1xuICAgIH07XG59KShHZW5vbWVSZWFkZXIpO1xuXG5cbkdlbm9tZVJlYWRlci5SZXN1bHQucHJvdG90eXBlLmdldFNlcXVlbmNlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgdmFyIGNkc19kYXRhID0gdGhpcy5fcmF3X2RhdGEuZGF0YTtcbiAgICB2YXIgdW5pcHJvdHMgPSBPYmplY3Qua2V5cyhjZHNfZGF0YSk7XG4gICAgbGV0IG1pbiwgbWF4O1xuICAgIG1pbiA9IG1heCA9IG51bGw7XG4gICAgdW5pcHJvdHMuZm9yRWFjaChmdW5jdGlvbih1bmlwcm90KSB7XG4gICAgICAgIHZhciBlbmRzID0gY2RzX2RhdGFbdW5pcHJvdF0ubWFwKGZ1bmN0aW9uKGNkKSB7XG4gICAgICAgICAgICBpZiAoIEFycmF5LmlzQXJyYXkoY2QpICkge1xuICAgICAgICAgICAgICAgIGNkID0gY2QuZmlsdGVyKGZ1bmN0aW9uKGMpIHsgcmV0dXJuIGMuY2hyLm1hdGNoKC9eW1xcZFh4XSskLyApOyB9KVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbIGNkLnR4c3RhcnQsIGNkLnR4ZW5kIF07XG4gICAgICAgIH0pO1xuICAgICAgICBlbmRzLmZvckVhY2goZnVuY3Rpb24oY2QpIHtcbiAgICAgICAgICAgIGlmICghIG1pbiB8fCBjZFswXSA8IG1pbikge1xuICAgICAgICAgICAgICAgIG1pbiA9IGNkWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEgbWF4IHx8IGNkWzFdID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gY2RbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJlc3VsdHMgPSBbIEFycmF5KCBNYXRoLmZsb29yKCAobWF4IC0gbWluKSAvIDMgKSApLmpvaW4oJy4nKSBdO1xuICAgIHRoaXMubWluID0gbWluO1xuICAgIHRoaXMubWF4ID0gbWF4O1xuICAgIHJldHVybiByZXN1bHRzO1xufTtcblxuR2Vub21lUmVhZGVyLlJlc3VsdC5wcm90b3R5cGUuZ2V0SW50cm9ucyA9IGZ1bmN0aW9uKG1hcmdpbikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHZhciB1cHJvdHMgPSBPYmplY3Qua2V5cyhzZWxmLl9yYXdfZGF0YS5kYXRhKTtcbiAgICB1cHJvdHMuZm9yRWFjaChmdW5jdGlvbih1cCkge1xuICAgICAgICB2YXIgY2RzID0gc2VsZi5fcmF3X2RhdGEuZGF0YVt1cF07XG4gICAgICAgIGNkcy5mb3JFYWNoKGZ1bmN0aW9uKHRhcmdldF9jZHMpIHtcbiAgICAgICAgICAgIGlmICggQXJyYXkuaXNBcnJheSh0YXJnZXRfY2RzKSApIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRfY2RzID0gdGFyZ2V0X2Nkcy5maWx0ZXIoZnVuY3Rpb24oYykgeyByZXR1cm4gYy5jaHIubWF0Y2goL15bXFxkWHhdKyQvICk7IH0pWzBdO1xuICAgICAgICAgICAgICAgIGlmICggISB0YXJnZXRfY2RzICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBleG9ucyA9IHRhcmdldF9jZHMuZXhvbnM7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0X3Bvc2l0aW9uO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4b25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goWyBzZWxmLm1pbiwgZXhvbnNbaV1bMF0gLSBtYXJnaW4gXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKFsgZXhvbnNbaS0xXVsxXSArIG1hcmdpbiwgZXhvbnNbaV1bMF0gLSBtYXJnaW5dKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gKGV4b25zLmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChbIGV4b25zW2ldWzFdICsgbWFyZ2luLCBzZWxmLm1heCBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdHMuc2xpY2UoLTEpWzBdWzBdID4gcmVzdWx0cy5zbGljZSgtMSlbMF1bMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5zcGxpY2UocmVzdWx0cy5sZW5ndGggLSAxLDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG5HZW5vbWVSZWFkZXIucHJvdG90eXBlLnByb3RlaW5MZW5ndGggPSBmdW5jdGlvbih0YXJnZXRfY2RzKSB7XG4gICAgdmFyIGV4b25zID0gdGFyZ2V0X2Nkcy5leG9ucztcbiAgICB2YXIgdG90YWwgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRhcmdldF9jZHMuY2Rzc3RhcnQgPiBleG9uc1tpXVsxXSAmIHRhcmdldF9jZHMuY2Rzc3RhcnQgPiBleG9uc1tpXVswXSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldF9jZHMuY2RzZW5kIDwgZXhvbnNbaV1bMF0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YXJ0ID0gdGFyZ2V0X2Nkcy5jZHNzdGFydCA+IGV4b25zW2ldWzBdID8gdGFyZ2V0X2Nkcy5jZHNzdGFydCA6IGV4b25zW2ldWzBdO1xuICAgICAgICB2YXIgZW5kID0gdGFyZ2V0X2Nkcy5jZHNlbmQgPCBleG9uc1tpXVsxXSA/IHRhcmdldF9jZHMuY2RzZW5kIDogZXhvbnNbaV1bMV07XG4gICAgICAgIHRvdGFsICs9IChlbmQgLSBzdGFydCk7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLmZsb29yKHRvdGFsLzMpLTE7XG59O1xuXG5HZW5vbWVSZWFkZXIucHJvdG90eXBlLmNhbGN1bGF0ZVNlcXVlbmNlUG9zaXRpb25Gcm9tUHJvdGVpblBvc2l0aW9uID0gZnVuY3Rpb24oaWR4LHBvcykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgd2FudGVkX2lkZW50aWZpZXIgPSBpZHg7XG4gICAgdmFyIGNkcyA9IHNlbGYucmVzdWx0Ll9yYXdfZGF0YS5kYXRhW3dhbnRlZF9pZGVudGlmaWVyLnRvTG93ZXJDYXNlKCldO1xuICAgIGlmICghIGNkcyApIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIGlmICghIGNkcy50eHN0YXJ0ICkge1xuICAgICAgICBjZHMgPSBjZHMubWFwKCBmdW5jdGlvbihjZCkge1xuICAgICAgICAgICAgaWYgKCBBcnJheS5pc0FycmF5KGNkKSApIHtcbiAgICAgICAgICAgICAgICBjZCA9IGNkLmZpbHRlcihmdW5jdGlvbihjKSB7IHJldHVybiBjLmNoci5tYXRjaCgvXltcXGRYeF0rJC8gKTsgfSlbMF07XG4gICAgICAgICAgICAgICAgaWYgKCAhIGNkICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2Q7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXRfY2RzID0gY2RzWzBdIHx8IHt9O1xuICAgIHZhciBleG9ucyA9IHRhcmdldF9jZHMuZXhvbnMgfHwgW107XG5cbiAgICB2YXIgcG9zaXRpb25fZ2Vub21lID0gTWF0aC5mbG9vcihwb3MgLyAzKTtcblxuXG4gICAgdmFyIHRhcmdldF9wb3NpdGlvbiA9IDA7XG5cbiAgICBpZiAocG9zIDwgdGFyZ2V0X2Nkcy5jZHNzdGFydCkge1xuICAgICAgICB0YXJnZXRfcG9zaXRpb24gPSA2O1xuICAgICAgICBpZiAodGFyZ2V0X2Nkcy5zdHJhbmQgPT0gLTEpIHtcbiAgICAgICAgICAgIHRhcmdldF9wb3NpdGlvbiA9IDM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zID4gdGFyZ2V0X2Nkcy5jZHNlbmQpIHtcbiAgICAgICAgdGFyZ2V0X3Bvc2l0aW9uID0gc2VsZi5wcm90ZWluTGVuZ3RoKHRhcmdldF9jZHMpICogMztcbiAgICAgICAgaWYgKHRhcmdldF9jZHMuc3RyYW5kID09IDEpIHtcbiAgICAgICAgICAgIHRhcmdldF9wb3NpdGlvbiArPSAzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICggdGFyZ2V0X3Bvc2l0aW9uID09IDApIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleG9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRhcmdldF9jZHMuY2Rzc3RhcnQgPiBleG9uc1tpXVsxXSAmIHRhcmdldF9jZHMuY2Rzc3RhcnQgPiBleG9uc1tpXVswXSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdGFyZ2V0X2Nkcy5jZHNzdGFydCA+IGV4b25zW2ldWzBdID8gdGFyZ2V0X2Nkcy5jZHNzdGFydCA6IGV4b25zW2ldWzBdO1xuICAgICAgICAgICAgdmFyIGVuZCA9IHRhcmdldF9jZHMuY2RzZW5kIDwgZXhvbnNbaV1bMV0gPyB0YXJnZXRfY2RzLmNkc2VuZDogZXhvbnNbaV1bMV07XG5cbiAgICAgICAgICAgIGlmIChwb3MgPCBzdGFydCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocG9zIDw9IGVuZCAmJiBwb3MgPj0gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRfcG9zaXRpb24gKz0gKHBvcyAtIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0X3Bvc2l0aW9uICs9IGVuZCAtIHN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRhcmdldF9wb3NpdGlvbiA9IE1hdGguZmxvb3IodGFyZ2V0X3Bvc2l0aW9uIC8gMykgLSAxO1xuXG4gICAgaWYgKHRhcmdldF9jZHMuc3RyYW5kID09IC0xKSB7XG4gICAgICAgIHRhcmdldF9wb3NpdGlvbiA9IHNlbGYucHJvdGVpbkxlbmd0aCh0YXJnZXRfY2RzKSAtIHRhcmdldF9wb3NpdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0X3Bvc2l0aW9uO1xufTtcblxuR2Vub21lUmVhZGVyLnByb3RvdHlwZS5jYWxjdWxhdGVQcm90ZWluUG9zaXRpb25Gb3JTZXF1ZW5jZSA9IGZ1bmN0aW9uKGlkeCxwb3MpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHdhbnRlZF9pZGVudGlmaWVyID0gaWR4O1xuICAgIHZhciBjZHMgPSBzZWxmLnJlc3VsdC5fcmF3X2RhdGEuZGF0YVt3YW50ZWRfaWRlbnRpZmllci50b0xvd2VyQ2FzZSgpXTtcbiAgICBpZiAoISBjZHMgKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICBpZiAoISBjZHMudHhzdGFydCApIHtcbiAgICAgICAgY2RzID0gY2RzLm1hcCggZnVuY3Rpb24oY2QpIHtcbiAgICAgICAgICAgIGlmICggQXJyYXkuaXNBcnJheShjZCkgKSB7XG4gICAgICAgICAgICAgICAgY2QgPSBjZC5maWx0ZXIoZnVuY3Rpb24oYykgeyByZXR1cm4gYy5jaHIubWF0Y2goL15bXFxkWHhdKyQvICk7IH0pWzBdO1xuICAgICAgICAgICAgICAgIGlmICggISBjZCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNkO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0X2NkcyA9IGNkc1swXSB8fCB7fTtcbiAgICB2YXIgZXhvbnMgPSB0YXJnZXRfY2RzLmV4b25zIHx8IFtdO1xuXG4gICAgaWYgKHRhcmdldF9jZHMuc3RyYW5kID09IC0xKSB7XG4gICAgICAgIHBvcyA9IHNlbGYucHJvdGVpbkxlbmd0aCh0YXJnZXRfY2RzKSAtIHBvcztcbiAgICB9XG4gICAgdmFyIHBvc2l0aW9uX2dlbm9tZSA9IHBvcyAqIDM7XG5cblxuICAgIHZhciB0YXJnZXRfcG9zaXRpb247XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4b25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0YXJnZXRfY2RzLmNkc3N0YXJ0ID4gZXhvbnNbaV1bMV0gJiB0YXJnZXRfY2RzLmNkc3N0YXJ0ID4gZXhvbnNbaV1bMF0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGFydCA9IHRhcmdldF9jZHMuY2Rzc3RhcnQgPiBleG9uc1tpXVswXSA/IHRhcmdldF9jZHMuY2Rzc3RhcnQgOiBleG9uc1tpXVswXTtcbiAgICAgICAgdmFyIGJhc2VzID0gKGV4b25zW2ldWzFdIC0gc3RhcnQpO1xuICAgICAgICBpZiAoYmFzZXMgPj0gcG9zaXRpb25fZ2Vub21lKSB7XG4gICAgICAgICAgICB0YXJnZXRfcG9zaXRpb24gPSBzdGFydCArIHBvc2l0aW9uX2dlbm9tZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9zaXRpb25fZ2Vub21lIC09IGJhc2VzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXRfcG9zaXRpb247XG59O1xuXG5HZW5vbWVSZWFkZXIucHJvdG90eXBlLmNhbGN1bGF0ZVBvc2l0aW9uRm9yU2VxdWVuY2UgPSBmdW5jdGlvbihpZHgscG9zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB3YW50ZWRfaWRlbnRpZmllciA9IHNlbGYuc2VxdWVuY2VzW2lkeF0uYWdpO1xuICAgIHZhciBlbXB0eV9yZWdpb25zID0gIFtdO1xuICAgIHZhciBjYWxjdWxhdGVkX3BvcyA9IHBvcztcblxuICAgIGlmICh3YW50ZWRfaWRlbnRpZmllciA9PSAnZ2Vub21lJykge1xuICAgIC8vIERvbid0IGNoYW5nZSB0aGUgZ2Vub21lIGlkZW50aWZpZXJcbiAgICB9IGVsc2Uge1xuICAgICAgICBjYWxjdWxhdGVkX3BvcyA9IHNlbGYuY2FsY3VsYXRlUHJvdGVpblBvc2l0aW9uRm9yU2VxdWVuY2UoaWR4LHBvcyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbXB0eV9yZWdpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChwb3MgPiBlbXB0eV9yZWdpb25zW2ldWzFdKSB7XG4gICAgICAgICAgICBjYWxjdWxhdGVkX3BvcyAtPSAoZW1wdHlfcmVnaW9uc1tpXVsxXSAtIGVtcHR5X3JlZ2lvbnNbaV1bMF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPCBlbXB0eV9yZWdpb25zW2ldWzFdICYmIHBvcyA+IGVtcHR5X3JlZ2lvbnNbaV1bMF0pIHtcbiAgICAgICAgICAgIGNhbGN1bGF0ZWRfcG9zID0gLTE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKGNhbGN1bGF0ZWRfcG9zKTtcbn07XG5cbihmdW5jdGlvbihzZXJ2KSB7XG4gICAgdmFyIGdldF9leG9uX2JveGVzID0gZnVuY3Rpb24ocmVzdWx0LHVuaXByb3QpIHtcbiAgICAgICAgdmFyIGNkc19kYXRhID0gcmVzdWx0Ll9yYXdfZGF0YS5kYXRhO1xuICAgICAgICBpZiAodW5pcHJvdCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZpbHRlcmluZyBleG9ucyBzbyB3ZSBvbmx5IHNob3cnLHVuaXByb3QpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1bmlwcm90cyA9IE9iamVjdC5rZXlzKGNkc19kYXRhKTtcbiAgICAgICAgdmFyIG1heCA9IHJlc3VsdC5tYXg7XG4gICAgICAgIHZhciBtaW4gPSByZXN1bHQubWluO1xuICAgICAgICB2YXIgcmV0dXJuX2RhdGEgPSBbXTtcbiAgICAgICAgdmFyIGJhc2Vfb2Zmc2V0ID0gMDtcbiAgICAgICAgdW5pcHJvdHMuZmlsdGVyKCB1cCA9PiB1bmlwcm90ID8gdXAgPT09ICh1bmlwcm90IHx8ICcnKS50b0xvd2VyQ2FzZSgpIDogdHJ1ZSApLmZvckVhY2goZnVuY3Rpb24odW5pcHJvdCkge1xuICAgICAgICAgICAgdmFyIGVuZHMgPSBjZHNfZGF0YVt1bmlwcm90XS5tYXAoZnVuY3Rpb24oY2QsaWR4KSB7XG4gICAgICAgICAgICAgICAgaWYgKCBBcnJheS5pc0FycmF5KGNkKSApIHtcbiAgICAgICAgICAgICAgICAgICAgY2QgPSBjZC5maWx0ZXIoZnVuY3Rpb24oYykgeyByZXR1cm4gYy5jaHIubWF0Y2goL15bXFxkWHhdKyQvICk7IH0pWzBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoICEgY2QgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZXhvbnMgPSBjZC5leG9ucztcbiAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSAoaWR4ID09IDApID8gJyM5OTknIDogJyNmOTknO1xuICAgICAgICAgICAgICAgIGV4b25zLmZvckVhY2goZnVuY3Rpb24oZXhvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5fZGF0YS5wdXNoKHsgXCJhYVwiOiAxK2V4b25bMF0sIFwidHlwZVwiIDogXCJib3hcIiAsIFwid2lkdGhcIiA6IGV4b25bMV0gLSBleG9uWzBdLCBcIm9wdGlvbnNcIiA6IHsgXCJvZmZzZXRcIiA6IGJhc2Vfb2Zmc2V0LCBcImhlaWdodF9zY2FsZVwiIDogMSwgXCJmaWxsXCIgOiBjb2xvciwgXCJtZXJnZVwiIDogZmFsc2UgIH19KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNkLnN0cmFuZCAgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5fZGF0YS5wdXNoKHsgXCJhYVwiOiBleG9uWzFdIC0gMSwgXCJ0eXBlXCIgOiBcIm1hcmtlclwiLCBcIm9wdGlvbnNcIiA6IHsgXCJoZWlnaHRcIiA6IDQsIFwiY29udGVudFwiIDoge1widHlwZVwiIDogXCJyaWdodF90cmlhbmdsZVwiLCBcImZpbGxcIiA6ICcjYWFhJyB9LCBcIm9mZnNldFwiIDogYmFzZV9vZmZzZXQrMiwgXCJiYXJlX2VsZW1lbnRcIiA6IHRydWUgfX0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuX2RhdGEucHVzaCh7IFwiYWFcIjogZXhvblswXSArIDEsIFwidHlwZVwiIDogXCJtYXJrZXJcIiwgXCJvcHRpb25zXCIgOiB7IFwiaGVpZ2h0XCIgOiA0LCBcImNvbnRlbnRcIiA6IHtcInR5cGVcIiA6IFwibGVmdF90cmlhbmdsZVwiLCBcImZpbGxcIiA6ICcjYWFhJyB9LCBcIm9mZnNldFwiIDogYmFzZV9vZmZzZXQrMiwgXCJiYXJlX2VsZW1lbnRcIiA6IHRydWUgfX0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuX2RhdGEucHVzaCh7XCJhYVwiIDogY2QuY2Rzc3RhcnQsIFwidHlwZVwiIDogXCJib3hcIiAsIFwid2lkdGhcIiA6IDEsIFwib3B0aW9uc1wiIDogeyBcImZpbGxcIiA6IFwiIzAwMDBmZlwiLCBcImhlaWdodF9zY2FsZVwiIDogMiwgXCJvZmZzZXRcIiA6IGJhc2Vfb2Zmc2V0IC0gMiAsIFwibWVyZ2VcIiA6IGZhbHNlIH0gfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuX2RhdGEucHVzaCh7XCJhYVwiIDogY2QuY2RzZW5kLCBcInR5cGVcIiA6IFwiYm94XCIgLCBcIndpZHRoXCIgOiAxLCBcIm9wdGlvbnNcIiA6IHsgXCJmaWxsXCIgOiBcIiMwMDAwZmZcIiwgXCJoZWlnaHRfc2NhbGVcIiA6IDIsIFwib2Zmc2V0XCIgOiBiYXNlX29mZnNldCAgLSAyLCBcIm1lcmdlXCIgOiBmYWxzZSB9IH0pO1xuICAgICAgICAgICAgICAgIGJhc2Vfb2Zmc2V0ICs9IDE7XG5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYmFzZV9vZmZzZXQgKz0gMjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXR1cm5fZGF0YTtcbiAgICB9O1xuXG4gICAgdmFyIGdldF9yZW1vdmVkX2xhYmVscyA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IHJlc3VsdC5yZW1vdmVkX3JlZ2lvbnMgfHwgW107XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIHZhciBtYXggPSByZXN1bHQubWF4O1xuICAgICAgICB2YXIgbWluID0gcmVzdWx0Lm1pbjtcbiAgICAgICAgdmFyIGNkc19kYXRhID0gcmVzdWx0Ll9yYXdfZGF0YS5kYXRhO1xuICAgICAgICB2YXIgdW5pcHJvdHMgPSBPYmplY3Qua2V5cyhjZHNfZGF0YSk7XG4gICAgICAgIHZhciB0b3RhbCA9IHVuaXByb3RzLnJlZHVjZShmdW5jdGlvbihwcmV2LHVwKSB7IHJldHVybiBwcmV2ICsgY2RzX2RhdGFbdXBdLmxlbmd0aDsgIH0sMCk7XG4gICAgICAgIHJlbW92ZWQuZm9yRWFjaChmdW5jdGlvbih2YWxzKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSB2YWxzWzBdO1xuICAgICAgICAgICAgdmFyIGVuZCA9IHZhbHNbMV07XG4gICAgICAgICAgICB2YXIgc3RhcnRfdHh0ID0gTWF0aC5mbG9vciAoIChzdGFydCAlIDFlNiApIC8gMTAwMCkrXCJrYlwiO1xuICAgICAgICAgICAgdmFyIGVuZF90eHQgPSBNYXRoLmZsb29yICggKGVuZCAlIDFlNiApIC8gMTAwMCkrXCJrYlwiO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtcImFhXCIgOiBzdGFydCAtIDEsIFwidHlwZVwiIDogXCJib3hcIiwgd2lkdGggOiAoZW5kIC0gc3RhcnQpICsgMywgXCJvcHRpb25zXCIgOiB7XCJmaWxsXCIgOiBcIiM5OTlcIiwgXCJoZWlnaHRfc2NhbGVcIiA6IHRvdGFsKjMsIFwib2Zmc2V0XCIgOiAtMSp0b3RhbCB9IH0pO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtcImFhXCIgOiBzdGFydCAtIDMsIFwidHlwZVwiIDogXCJ0ZXh0XCIsIFwib3B0aW9uc1wiIDoge1widHh0XCIgOiBzdGFydF90eHQsIFwiZmlsbFwiIDogXCIjMDAwXCIsIFwiaGVpZ2h0XCIgOiA0LCBcIm9mZnNldFwiIDogLTQsIFwiYWxpZ25cIiA6IFwicmlnaHRcIiB9IH0pO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtcImFhXCIgOiBlbmQgKyAzLCBcInR5cGVcIiA6IFwidGV4dFwiLCBcIm9wdGlvbnNcIiA6IHtcInR4dFwiIDogZW5kX3R4dCwgXCJmaWxsXCIgOiBcIiMwMDBcIiwgXCJoZWlnaHRcIiA6IDQsIFwib2Zmc2V0XCIgOiA0LCBcImFsaWduXCIgOiBcImxlZnRcIiB9IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcblxuICAgIHZhciBjYWxjdWxhdGVfcmVtb3ZlZF9yZWdpb25zID0gZnVuY3Rpb24ocmVzdWx0LG1hcmdpbikge1xuICAgICAgICB2YXIgaW50cm9ucyA9ICByZXN1bHQuZ2V0SW50cm9ucyhtYXJnaW4pO1xuXG4gICAgICAgIHZhciBpbnRlcnZhbHMgPSBbeyBcImluZGV4XCIgOiByZXN1bHQubWluIC0gMiwgXCJzdGFydFwiIDogdHJ1ZSwgXCJpZHhcIiA6IC0xIH0gLCB7XCJpbmRleFwiIDogcmVzdWx0Lm1pbiwgXCJzdGFydFwiIDogZmFsc2UsIFwiaWR4XCIgOiAtMSB9XTtcbiAgICAgICAgaW50cm9ucy5mb3JFYWNoKGZ1bmN0aW9uKGludHJvbixpZHgpIHtcbiAgICAgICAgICAgIGludGVydmFscy5wdXNoKHsgXCJpbmRleFwiIDogaW50cm9uWzBdLCBcInN0YXJ0XCIgOiB0cnVlLCAgXCJpZHhcIiA6IGlkeCB9KTtcbiAgICAgICAgICAgIGludGVydmFscy5wdXNoKHsgXCJpbmRleFwiIDogaW50cm9uWzFdLCBcInN0YXJ0XCIgOiBmYWxzZSAsIFwiaWR4XCIgOiBpZHggfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGludGVydmFscy5zb3J0KGZ1bmN0aW9uKGEsYikge1xuICAgICAgICAgICAgaWYgKGEuaW5kZXggPCBiLmluZGV4ICkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhLmluZGV4ID4gYi5pbmRleCApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhLmluZGV4ID09IGIuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5zdGFydCA/IC0xIDogMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGludGVydmFscy5mb3JFYWNoKGZ1bmN0aW9uKGludHIsaWR4KSB7XG4gICAgICAgICAgICBpZiAoaW50ci5zdGFydCAmJiBpbnRlcnZhbHNbaWR4KzFdICYmIGludGVydmFsc1tpZHgrMV0uc3RhcnQgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW50ci5pbmRleCAhPSBpbnRlcnZhbHNbaWR4KzFdLmluZGV4ICYmIGludGVydmFsc1tpZHgrMV0uaW5kZXggIT0gcmVzdWx0Lm1pbikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goIFtpbnRyLmluZGV4ICwgaW50ZXJ2YWxzW2lkeCsxXS5pbmRleCBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXN1bHQucmVtb3ZlZF9yZWdpb25zID0gcmVzdWx0cztcbiAgICB9O1xuICAgIHZhciBnZW5lcmF0ZV9zY2FsZXJfZnVuY3Rpb24gPSBmdW5jdGlvbihyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGluX3BvcyxsYXllcixpbnZlcnNlKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gaW5fcG9zO1xuXG4gICAgICAgICAgICBpZiAoICEgcmVhZGVyLnJlc3VsdCApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW52ZXJzZSA/IChwb3MgKiAzKSA6IE1hdGguZmxvb3IocG9zIC8gMyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbnRyb25zID0gcmVhZGVyLnJlc3VsdC5yZW1vdmVkX3JlZ2lvbnMgfHwgW107XG5cbiAgICAgICAgICAgIGlmIChpbnZlcnNlKSB7XG4gICAgICAgICAgICAgICAgcG9zID0gKGluX3BvcyAqIDMpO1xuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRfcG9zID0gcG9zO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW50cm9ucy5sZW5ndGggJiYgcG9zID4gMDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZWZ0X2V4b24gPSBpID4gMCA/IGludHJvbnNbaS0xXSA6IFtudWxsLHJlYWRlci5yZXN1bHQubWluXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJpZ2h0X2V4b24gPSBpbnRyb25zW2ldIHx8IFtyZWFkZXIucmVzdWx0Lm1heCxudWxsXTtcbiAgICAgICAgICAgICAgICAgICAgcG9zIC09IChyaWdodF9leG9uWzBdIC0gbGVmdF9leG9uWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRfcG9zICs9IGludHJvbnNbaV1bMV0gLSBpbnRyb25zW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxjdWxhdGVkX3BvcyArIHJlYWRlci5yZXN1bHQubWluO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY2FsY3VsYXRlZF9wb3MgPSBwb3MgLSByZWFkZXIucmVzdWx0Lm1pbjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW50cm9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPiBpbnRyb25zW2ldWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRfcG9zIC09IChpbnRyb25zW2ldWzFdIC0gaW50cm9uc1tpXVswXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb3MgPCBpbnRyb25zW2ldWzFdICYmIHBvcyA+IGludHJvbnNbaV1bMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRlZF9wb3MgPSAoaW50cm9uc1tpXVsxXSAtIHJlYWRlci5yZXN1bHQubWluKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsY3VsYXRlZF9wb3MgPCAzKSB7XG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlZF9wb3MgPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChNYXRoLmZsb29yKGNhbGN1bGF0ZWRfcG9zIC8gMykpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlcnYucHJvdG90eXBlLCAnZXhvbl9tYXJnaW4nLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9leG9uX21hcmdpbiA9IHZhbDtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZV9yZW1vdmVkX3JlZ2lvbnModGhpcy5yZXN1bHQsdmFsKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZHJhd0ludHJvbnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX2V4b25fbWFyZ2luOyB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVkcmF3SW50cm9ucyA9IGZ1bmN0aW9uKHJlbmRlcmVyLGNvbnRyb2xsZXJfbmFtZSxzY2FsZXJfZnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIGxhYnMgPSBbXTtcbiAgICAgICAgdmFyIHpvb21DaGVjayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGxhYnMubGVuZ3RoIDwgMSB8fCAhIGxhYnNbMF0ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBoaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwIDsgISBoaWRkZW4gJiYgaSA8IChsYWJzLmxlbmd0aCAtIDMpOyBpICs9IDMpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFic1tpXS5oYXNBdHRyaWJ1dGUoJ2Rpc3BsYXknKSkge1xuICAgICAgICAgICAgICAgICAgICBoaWRkZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICAgIGlmIChsYWJzW2ldLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnJpZ2h0ID4gbGFic1tpKzNdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYWJzLmZvckVhY2goZnVuY3Rpb24obGFiKSB7IGlmKGxhYi5ub2RlTmFtZSA9PSAncmVjdCcpIHsgcmV0dXJuOyB9IGlmIChoaWRkZW4pIHsgbGFiLnNldEF0dHJpYnV0ZSgnZGlzcGxheScsJ25vbmUnKSB9IGVsc2UgeyBsYWIucmVtb3ZlQXR0cmlidXRlKCdkaXNwbGF5JykgfSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVuZGVyZXIuYmluZCgnem9vbUNoYW5nZScsem9vbUNoZWNrKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZXN1bHQ7XG4gICAgICAgICAgICByZW5kZXJlci5zZXF1ZW5jZSA9IEFycmF5KCBzY2FsZXJfZnVuY3Rpb24ocmVzdWx0Lm1heCkpLmpvaW4oJy4nKTtcblxuICAgICAgICAgICAgaWYgKGxhYnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxhYnMuZm9yRWFjaChmdW5jdGlvbihsYWIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXIucmVtb3ZlKGNvbnRyb2xsZXJfbmFtZSxsYWIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGxhYnMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcm94eV9yZWFkZXIgPSB7XG4gICAgICAgICAgICAgICAgYWdpOiBjb250cm9sbGVyX25hbWUsXG4gICAgICAgICAgICAgICAgZ290UmVzdWx0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFicyA9IHJlbmRlcmVyLnJlbmRlck9iamVjdHMoY29udHJvbGxlcl9uYW1lLGdldF9yZW1vdmVkX2xhYmVscyhyZXN1bHQpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXIucmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgICAgICB6b29tQ2hlY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgU2VydmljZS5wcm90b3R5cGUucmVnaXN0ZXJTZXF1ZW5jZVJlbmRlcmVyLmNhbGwocHJveHlfcmVhZGVyLHJlbmRlcmVyKTtcbiAgICAgICAgICAgIHByb3h5X3JlYWRlci5nb3RSZXN1bHQoKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgc2Vydi5wcm90b3R5cGUuc2V0dXBTZXF1ZW5jZVJlbmRlcmVyID0gZnVuY3Rpb24ocmVuZGVyZXIpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICByZW5kZXJlci5hZGRBeGlzU2NhbGUoJ2dlbm9tZScsZnVuY3Rpb24ocG9zLGxheWVyLGludmVyc2UpIHtcbiAgICAgICAgICAgIGlmIChsYXllciAmJiBsYXllci5zY2FsZXMuaGFzKCdnZW5vbWljJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGFsbF9zY2FsZXMgPSBPYmplY3Qua2V5cyhzZWxmLnJlc3VsdC5fcmF3X2RhdGEuZGF0YSk7XG4gICAgICAgICAgICBsZXQgaWRlbnRpZmllciA9IGxheWVyLm5hbWU7XG4gICAgICAgICAgICBmb3IgKGxldCBzY2FsZSBvZiBhbGxfc2NhbGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxheWVyLnNjYWxlcy5oYXMoc2NhbGUudG9VcHBlckNhc2UoKSkgfHwgbGF5ZXIuc2NhbGVzLmhhcyhzY2FsZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyID0gc2NhbGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGludmVyc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jYWxjdWxhdGVTZXF1ZW5jZVBvc2l0aW9uRnJvbVByb3RlaW5Qb3NpdGlvbihpZGVudGlmaWVyLHBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5jYWxjdWxhdGVQcm90ZWluUG9zaXRpb25Gb3JTZXF1ZW5jZShpZGVudGlmaWVyLHBvcyk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY29udHJvbGxlcl9uYW1lID0gJ2Nkcyc7XG4gICAgICAgIHZhciByZWRyYXdfYWxpZ25tZW50cyA9IGZ1bmN0aW9uKHNlcXVlbmNlX2luZGV4KSB7XG4gICAgICAgICAgICBpZiAoICEgc2VxdWVuY2VfaW5kZXggKSB7XG4gICAgICAgICAgICAgICAgc2VxdWVuY2VfaW5kZXggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgTUFTQ1AucmVnaXN0ZXJMYXllcihjb250cm9sbGVyX25hbWUsIHsgJ2Z1bGxuYW1lJyA6ICdFeG9ucycsICdjb2xvcicgOiAnIzAwMDAwMCcgfSk7XG4gICAgICAgICAgICBNQVNDUC5nZXRMYXllcihjb250cm9sbGVyX25hbWUpLnNjYWxlcy5hZGQoJ2dlbm9taWMnKTtcblxuICAgICAgICAgICAgaWYgKHJlbmRlcmVyLnRyYWNrT3JkZXIuaW5kZXhPZihjb250cm9sbGVyX25hbWUpIDwgMCkge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnRyYWNrT3JkZXIucHVzaChjb250cm9sbGVyX25hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVuZGVyZXIuc2hvd0xheWVyKGNvbnRyb2xsZXJfbmFtZSk7XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnJlc3VsdDtcblxuICAgICAgICAgICAgdmFyIGFsaWduZWQgPSByZXN1bHQuZ2V0U2VxdWVuY2VzKCk7XG4gICAgICAgICAgICB2YXIgc2NhbGVyX2Z1bmN0aW9uID0gZ2VuZXJhdGVfc2NhbGVyX2Z1bmN0aW9uKHNlbGYpO1xuXG4gICAgICAgICAgICByZW5kZXJlci5hZGRBeGlzU2NhbGUoJ3JlbW92ZUludHJvbnMnLHNjYWxlcl9mdW5jdGlvbik7XG5cbiAgICAgICAgICAgIGNhbGN1bGF0ZV9yZW1vdmVkX3JlZ2lvbnMoc2VsZi5yZXN1bHQsc2VsZi5leG9uX21hcmdpbiB8fCAzMDApO1xuXG4gICAgICAgICAgICBpZiAoICEgcmVuZGVyZXIuc2VxdWVuY2UgKSB7XG4gICAgICAgICAgICAgICAgLy8gTm90IHN1cmUgd2hhdCB0byBkbyB3aXRoIHRoaXMgYml0IGhlcmVcblxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnNldFNlcXVlbmNlKEFycmF5KCBzY2FsZXJfZnVuY3Rpb24ocmVzdWx0Lm1heCkgKS5qb2luKCcuJykpKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZWRyYXdfYWxpZ25tZW50cyhzZXF1ZW5jZV9pbmRleCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlci5zZXF1ZW5jZSA9IEFycmF5KCBzY2FsZXJfZnVuY3Rpb24ocmVzdWx0Lm1heCkpLmpvaW4oJy4nKTtcbiAgICAgICAgICAgICAgICByZW5kZXJlci5yZWRyYXdBeGlzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJveHlfcmVhZGVyID0ge1xuICAgICAgICAgICAgICAgIGFnaTogY29udHJvbGxlcl9uYW1lLFxuICAgICAgICAgICAgICAgIGdvdFJlc3VsdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyLnJlbmRlck9iamVjdHMoY29udHJvbGxlcl9uYW1lLGdldF9leG9uX2JveGVzKHJlc3VsdCwgc2VsZi5yZXZpZXdlZCA/IHNlbGYuc3dpc3Nwcm90IDogc2VsZi51bmlwcm90KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFNlcnZpY2UucHJvdG90eXBlLnJlZ2lzdGVyU2VxdWVuY2VSZW5kZXJlci5jYWxsKHByb3h5X3JlYWRlcixyZW5kZXJlcik7XG4gICAgICAgICAgICBwcm94eV9yZWFkZXIuZ290UmVzdWx0KCk7XG5cbiAgICAgICAgICAgIHNlbGYucmVkcmF3SW50cm9ucyA9IHJlZHJhd0ludHJvbnMocmVuZGVyZXIsY29udHJvbGxlcl9uYW1lLHNjYWxlcl9mdW5jdGlvbik7XG4gICAgICAgICAgICBzZWxmLnJlZHJhd0ludHJvbnMoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmJpbmQoJ3Jlc3VsdFJlY2VpdmVkJyxyZWRyYXdfYWxpZ25tZW50cyk7XG5cbiAgICB9O1xuXG59KShHZW5vbWVSZWFkZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBHZW5vbWVSZWFkZXI7XG5cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUdBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFGQTtBQUpBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBSkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBSkE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFSQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../gator/js/lib/GenomeReader.js\n')},"../gator/js/lib/MASCP.js":
/*!********************************!*\
  !*** ../gator/js/lib/MASCP.js ***!
  \********************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _bean__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../bean */ "../gator/js/bean.js");\n\n/**\n *  @namespace MASCP namespace\n */\n\nconst MASCP = {};\n/**\n *  @fileOverview   Basic classes and defitions for the MASCP services\n */\n\nif (Object.defineProperty && !MASCP.IE8) {\n  (function () {\n    var ready_callbacks = [];\n    var is_ready = false;\n    Object.defineProperty(MASCP, "ready", {\n      get: function get() {\n        if (ready_callbacks.length === 0 && !is_ready) {\n          return false;\n        }\n\n        return function () {\n          ready_callbacks.forEach(function (cb) {\n            cb.call();\n          });\n        };\n      },\n      set: function set(cb) {\n        if (cb === false || cb === true) {\n          ready_callbacks = [];\n\n          if (cb) {\n            is_ready = true;\n          }\n\n          return is_ready;\n        } else {\n          if (is_ready) {\n            cb.call();\n            return;\n          }\n\n          ready_callbacks.push(cb);\n        }\n      }\n    });\n  })();\n}\n/**\n *  @lends MASCP.Group.prototype\n *  @property   {String}        name                        Name for this group to be used as an identifier\n *  @property   {String}        fullname                    The full (long) name for this group, that can be used in UI widgets for labelling\n *  @property   {String}        color                       Color string to apply to this group\n *  @property   {Boolean}       hide_member_controllers     For controllers for this group, do not show the layer controllers for this group\n *  @property   {Boolean}       hide_group_controller       For controllers for this group do not show the parent group controller\n */\n\n/**\n * Register a group with metadata for all sequence renderers.\n * @static\n * @param {String} groupName    Name to give to this group\n * @param {Hash} options        Options to apply to this group - see MASCP.Group for all the fields\n * @returns New group object\n * @type MASCP.Group\n * @see MASCP.event:groupRegistered\n * @see MASCP.Group\n */\n\n\nMASCP.registerGroup = function (groupName, options) {\n  if (!this.groups) {\n    this.groups = {};\n  }\n\n  if (this.groups[groupName]) {\n    return;\n  }\n\n  var group = new MASCP.Group();\n  group.name = groupName;\n  options = options || {};\n\n  if (options.hide_member_controllers) {\n    group.hide_member_controllers = true;\n  }\n\n  if (options.hide_group_controller) {\n    group.hide_group_controller = true;\n  }\n\n  if (options.fullname) {\n    group.fullname = options.fullname;\n  }\n\n  if (options.color) {\n    group.color = options.color;\n  }\n\n  if (options.group) {\n    group.group = this.getGroup(options.group);\n\n    if (!group.group) {\n      throw "Cannot register this layer with the given group - the group has not been registered yet";\n    }\n\n    group.group._layers.push(group);\n  }\n\n  group._layers = [];\n  group.group_id = new Date().getMilliseconds();\n  this.groups[groupName] = group;\n  _bean__WEBPACK_IMPORTED_MODULE_0__["default"].fire(MASCP, \'groupRegistered\', [group]);\n  return group;\n};\n/**\n *  @lends MASCP.Layer.prototype\n *  @property   {String}        name        Name for this layer to be used as an identifier\n *  @property   {String}        fullname    The full (long) name for this layer, that can be used in UI widgets for labelling\n *  @property   {String}        color       Color string to apply to this layer\n *  @property   {MASCP.Group}   group       Group that this layer is part of. Either a group object, or the name for the group.\n *  @property   {String}        css         CSS block for this layer. Active and inactive layers are children of the .active and .inactive classes respectively. To target a track-based rendering, use the .tracks class first, and to target overlays, use the .overlay class last\n *  @property   {Object}        data        Data for this layer\n */\n\n/**\n * Register a layer with metadata for all sequence renderers.\n * @static\n * @param {String} layerName    Name to give to this layer\n * @param {Hash} options        Options to set field values for this layer - see the fields for MASCP.Layer.\n * @returns New layer object\n * @type MASCP.Layer\n * @see MASCP.Layer\n * @see MASCP.event:layerRegistered\n */\n\n\nMASCP.registerLayer = function (layerName, options, renderers) {\n  if (!this.layers) {\n    this.layers = {};\n  }\n\n  if (!renderers) {\n    renderers = [];\n  }\n\n  var layer;\n\n  if (this.layers[layerName]) {\n    if (this.layers[layerName].disabled || renderers.length > 0) {\n      this.layers[layerName].disabled = false;\n      _bean__WEBPACK_IMPORTED_MODULE_0__["default"].fire(MASCP, \'layerRegistered\', [this.layers[layerName]].concat(renderers));\n    }\n\n    layer = this.layers[layerName];\n  }\n\n  if (layer && options.group) {\n    if (layer.group !== this.getGroup(options.group)) {\n      layer.group = this.getGroup(options.group);\n\n      layer.group._layers.push(layer);\n    }\n\n    if (!layer.group) {\n      throw "Cannot register this layer with the given group - the group has not been registered yet";\n    }\n  }\n\n  if (layer) {\n    return layer;\n  }\n\n  layer = new MASCP.Layer();\n  layer.name = layerName;\n  options = options || {};\n\n  if (options.fullname) {\n    layer.fullname = options.fullname;\n  }\n\n  if (options.color) {\n    layer.color = options.color;\n  }\n\n  if (options.data) {\n    layer.data = options.data;\n  }\n\n  if (layer && options.group) {\n    layer.group = this.getGroup(options.group);\n\n    if (!layer.group) {\n      throw "Cannot register this layer with the given group - the group has not been registered yet";\n    }\n\n    layer.group._layers.push(layer);\n  }\n\n  this.layers[layerName] = layer;\n\n  if (options.css) {\n    console.log("options.css is deprecated");\n  }\n\n  layer.layer_id = new Date().getMilliseconds();\n  _bean__WEBPACK_IMPORTED_MODULE_0__["default"].fire(MASCP, \'layerRegistered\', [layer].concat(renderers));\n  return layer;\n};\n/**\n * @class\n * Metadata for a group of layers to be rendered\n */\n\n\nMASCP.Group = function () {\n  return;\n};\n/**\n * Describe what this method does\n * @private\n * @param {String|Object|Array|Boolean|Number} paramName Describe this parameter\n * @returns Describe what it returns\n * @type String|Object|Array|Boolean|Number\n */\n\n\nMASCP.Group.prototype.size = function () {\n  var counter = 0;\n\n  for (var i = 0; i < this._layers.length; i++) {\n    if (!this._layers[i].disabled) {\n      counter += 1;\n    }\n  }\n\n  return counter;\n};\n\nMASCP.Group.prototype.eachLayer = function (func) {\n  for (var i = 0; i < this._layers.length; i++) {\n    if (!this._layers[i].disabled) {\n      func.call(this._layers[i], this._layers[i]);\n    }\n  }\n};\n/**\n * @class\n * Metadata for a single layer to be rendered\n */\n\n\nMASCP.Layer = function () {\n  this.scales = new Set();\n  return;\n};\n/**\n * Retrieve a layer object from the layer registry. If a layer object is passed to this method, the same layer is returned.\n * @param {String} layer    Layer name\n * @returns Layer object\n * @type Object\n * @see MASCP.Layer\n */\n\n\nMASCP.getLayer = function (layer) {\n  if (!MASCP.layers) {\n    return;\n  }\n\n  return typeof layer == \'string\' ? MASCP.layers[layer] : layer;\n};\n/**\n * Retrieve a group object from the group registry. If a grop object is passed to this method, the same group is returned.\n * @param {String} group    Group name\n * @returns Group object\n * @type Object\n * @see MASCP.Group\n */\n\n\nMASCP.getGroup = function (group) {\n  if (typeof group == \'undefined\') {\n    return;\n  }\n\n  if (!MASCP.groups) {\n    return;\n  }\n\n  if (typeof group == \'string\') {\n    return MASCP.groups[group];\n  }\n\n  return group == MASCP.groups[group.name] ? group : null;\n};\n\n/* harmony default export */ __webpack_exports__["default"] = (MASCP);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vZ2F0b3IvanMvbGliL01BU0NQLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL2dhdG9yL2pzL2xpYi9NQVNDUC5qcz83NDU1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBiZWFuIGZyb20gJy4uL2JlYW4nO1xuXG4vKipcbiAqICBAbmFtZXNwYWNlIE1BU0NQIG5hbWVzcGFjZVxuICovXG5jb25zdCBNQVNDUCA9IHt9O1xuXG4vKipcbiAqICBAZmlsZU92ZXJ2aWV3ICAgQmFzaWMgY2xhc3NlcyBhbmQgZGVmaXRpb25zIGZvciB0aGUgTUFTQ1Agc2VydmljZXNcbiAqL1xuXG5pZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmICEgTUFTQ1AuSUU4ICkge1xuICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlYWR5X2NhbGxiYWNrcyA9IFtdO1xuICAgICAgICB2YXIgaXNfcmVhZHkgPSBmYWxzZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1BU0NQLFwicmVhZHlcIiwge1xuICAgICAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKChyZWFkeV9jYWxsYmFja3MubGVuZ3RoID09PSAwKSAmJiAoISBpc19yZWFkeSApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZWFkeV9jYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbihjYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2IuY2FsbCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCA6IGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNiID09PSBmYWxzZSB8fCBjYiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZWFkeV9jYWxsYmFja3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc19yZWFkeSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzX3JlYWR5O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc19yZWFkeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2IuY2FsbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlYWR5X2NhbGxiYWNrcy5wdXNoKGNiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pKCk7XG59XG5cblxuLyoqXG4gKiAgQGxlbmRzIE1BU0NQLkdyb3VwLnByb3RvdHlwZVxuICogIEBwcm9wZXJ0eSAgIHtTdHJpbmd9ICAgICAgICBuYW1lICAgICAgICAgICAgICAgICAgICAgICAgTmFtZSBmb3IgdGhpcyBncm91cCB0byBiZSB1c2VkIGFzIGFuIGlkZW50aWZpZXJcbiAqICBAcHJvcGVydHkgICB7U3RyaW5nfSAgICAgICAgZnVsbG5hbWUgICAgICAgICAgICAgICAgICAgIFRoZSBmdWxsIChsb25nKSBuYW1lIGZvciB0aGlzIGdyb3VwLCB0aGF0IGNhbiBiZSB1c2VkIGluIFVJIHdpZGdldHMgZm9yIGxhYmVsbGluZ1xuICogIEBwcm9wZXJ0eSAgIHtTdHJpbmd9ICAgICAgICBjb2xvciAgICAgICAgICAgICAgICAgICAgICAgQ29sb3Igc3RyaW5nIHRvIGFwcGx5IHRvIHRoaXMgZ3JvdXBcbiAqICBAcHJvcGVydHkgICB7Qm9vbGVhbn0gICAgICAgaGlkZV9tZW1iZXJfY29udHJvbGxlcnMgICAgIEZvciBjb250cm9sbGVycyBmb3IgdGhpcyBncm91cCwgZG8gbm90IHNob3cgdGhlIGxheWVyIGNvbnRyb2xsZXJzIGZvciB0aGlzIGdyb3VwXG4gKiAgQHByb3BlcnR5ICAge0Jvb2xlYW59ICAgICAgIGhpZGVfZ3JvdXBfY29udHJvbGxlciAgICAgICBGb3IgY29udHJvbGxlcnMgZm9yIHRoaXMgZ3JvdXAgZG8gbm90IHNob3cgdGhlIHBhcmVudCBncm91cCBjb250cm9sbGVyXG4gKi9cblxuLyoqXG4gKiBSZWdpc3RlciBhIGdyb3VwIHdpdGggbWV0YWRhdGEgZm9yIGFsbCBzZXF1ZW5jZSByZW5kZXJlcnMuXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge1N0cmluZ30gZ3JvdXBOYW1lICAgIE5hbWUgdG8gZ2l2ZSB0byB0aGlzIGdyb3VwXG4gKiBAcGFyYW0ge0hhc2h9IG9wdGlvbnMgICAgICAgIE9wdGlvbnMgdG8gYXBwbHkgdG8gdGhpcyBncm91cCAtIHNlZSBNQVNDUC5Hcm91cCBmb3IgYWxsIHRoZSBmaWVsZHNcbiAqIEByZXR1cm5zIE5ldyBncm91cCBvYmplY3RcbiAqIEB0eXBlIE1BU0NQLkdyb3VwXG4gKiBAc2VlIE1BU0NQLmV2ZW50Omdyb3VwUmVnaXN0ZXJlZFxuICogQHNlZSBNQVNDUC5Hcm91cFxuICovXG5NQVNDUC5yZWdpc3Rlckdyb3VwID0gZnVuY3Rpb24oZ3JvdXBOYW1lLCBvcHRpb25zKVxue1xuICAgIGlmICggISB0aGlzLmdyb3VwcyApIHtcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ3JvdXBzW2dyb3VwTmFtZV0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICB2YXIgZ3JvdXAgPSBuZXcgTUFTQ1AuR3JvdXAoKTtcbiAgICBcbiAgICBncm91cC5uYW1lID0gZ3JvdXBOYW1lO1xuICAgIFxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIFxuICAgIGlmIChvcHRpb25zLmhpZGVfbWVtYmVyX2NvbnRyb2xsZXJzKSB7XG4gICAgICAgIGdyb3VwLmhpZGVfbWVtYmVyX2NvbnRyb2xsZXJzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5oaWRlX2dyb3VwX2NvbnRyb2xsZXIpIHtcbiAgICAgICAgZ3JvdXAuaGlkZV9ncm91cF9jb250cm9sbGVyID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5mdWxsbmFtZSkge1xuICAgICAgICBncm91cC5mdWxsbmFtZSA9IG9wdGlvbnMuZnVsbG5hbWU7XG4gICAgfVxuICAgIFxuICAgIGlmIChvcHRpb25zLmNvbG9yKSB7XG4gICAgICAgIGdyb3VwLmNvbG9yID0gb3B0aW9ucy5jb2xvcjtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5ncm91cCkge1xuICAgICAgICBncm91cC5ncm91cCA9IHRoaXMuZ2V0R3JvdXAob3B0aW9ucy5ncm91cCk7XG4gICAgICAgIGlmICggISBncm91cC5ncm91cCApIHtcbiAgICAgICAgICAgIHRocm93IFwiQ2Fubm90IHJlZ2lzdGVyIHRoaXMgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gZ3JvdXAgLSB0aGUgZ3JvdXAgaGFzIG5vdCBiZWVuIHJlZ2lzdGVyZWQgeWV0XCI7XG4gICAgICAgIH1cbiAgICAgICAgZ3JvdXAuZ3JvdXAuX2xheWVycy5wdXNoKGdyb3VwKTtcbiAgICB9XG5cbiAgICBncm91cC5fbGF5ZXJzID0gW107XG5cbiAgICBncm91cC5ncm91cF9pZCA9IG5ldyBEYXRlKCkuZ2V0TWlsbGlzZWNvbmRzKCk7XG4gICAgXG4gICAgdGhpcy5ncm91cHNbZ3JvdXBOYW1lXSA9IGdyb3VwO1xuICAgIFxuICAgIGJlYW4uZmlyZShNQVNDUCwnZ3JvdXBSZWdpc3RlcmVkJyxbZ3JvdXBdKTtcbiAgICBcbiAgICByZXR1cm4gZ3JvdXA7XG59O1xuXG4vKipcbiAqICBAbGVuZHMgTUFTQ1AuTGF5ZXIucHJvdG90eXBlXG4gKiAgQHByb3BlcnR5ICAge1N0cmluZ30gICAgICAgIG5hbWUgICAgICAgIE5hbWUgZm9yIHRoaXMgbGF5ZXIgdG8gYmUgdXNlZCBhcyBhbiBpZGVudGlmaWVyXG4gKiAgQHByb3BlcnR5ICAge1N0cmluZ30gICAgICAgIGZ1bGxuYW1lICAgIFRoZSBmdWxsIChsb25nKSBuYW1lIGZvciB0aGlzIGxheWVyLCB0aGF0IGNhbiBiZSB1c2VkIGluIFVJIHdpZGdldHMgZm9yIGxhYmVsbGluZ1xuICogIEBwcm9wZXJ0eSAgIHtTdHJpbmd9ICAgICAgICBjb2xvciAgICAgICBDb2xvciBzdHJpbmcgdG8gYXBwbHkgdG8gdGhpcyBsYXllclxuICogIEBwcm9wZXJ0eSAgIHtNQVNDUC5Hcm91cH0gICBncm91cCAgICAgICBHcm91cCB0aGF0IHRoaXMgbGF5ZXIgaXMgcGFydCBvZi4gRWl0aGVyIGEgZ3JvdXAgb2JqZWN0LCBvciB0aGUgbmFtZSBmb3IgdGhlIGdyb3VwLlxuICogIEBwcm9wZXJ0eSAgIHtTdHJpbmd9ICAgICAgICBjc3MgICAgICAgICBDU1MgYmxvY2sgZm9yIHRoaXMgbGF5ZXIuIEFjdGl2ZSBhbmQgaW5hY3RpdmUgbGF5ZXJzIGFyZSBjaGlsZHJlbiBvZiB0aGUgLmFjdGl2ZSBhbmQgLmluYWN0aXZlIGNsYXNzZXMgcmVzcGVjdGl2ZWx5LiBUbyB0YXJnZXQgYSB0cmFjay1iYXNlZCByZW5kZXJpbmcsIHVzZSB0aGUgLnRyYWNrcyBjbGFzcyBmaXJzdCwgYW5kIHRvIHRhcmdldCBvdmVybGF5cywgdXNlIHRoZSAub3ZlcmxheSBjbGFzcyBsYXN0XG4gKiAgQHByb3BlcnR5ICAge09iamVjdH0gICAgICAgIGRhdGEgICAgICAgIERhdGEgZm9yIHRoaXMgbGF5ZXJcbiAqL1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgbGF5ZXIgd2l0aCBtZXRhZGF0YSBmb3IgYWxsIHNlcXVlbmNlIHJlbmRlcmVycy5cbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7U3RyaW5nfSBsYXllck5hbWUgICAgTmFtZSB0byBnaXZlIHRvIHRoaXMgbGF5ZXJcbiAqIEBwYXJhbSB7SGFzaH0gb3B0aW9ucyAgICAgICAgT3B0aW9ucyB0byBzZXQgZmllbGQgdmFsdWVzIGZvciB0aGlzIGxheWVyIC0gc2VlIHRoZSBmaWVsZHMgZm9yIE1BU0NQLkxheWVyLlxuICogQHJldHVybnMgTmV3IGxheWVyIG9iamVjdFxuICogQHR5cGUgTUFTQ1AuTGF5ZXJcbiAqIEBzZWUgTUFTQ1AuTGF5ZXJcbiAqIEBzZWUgTUFTQ1AuZXZlbnQ6bGF5ZXJSZWdpc3RlcmVkXG4gKi9cbk1BU0NQLnJlZ2lzdGVyTGF5ZXIgPSBmdW5jdGlvbihsYXllck5hbWUsIG9wdGlvbnMsIHJlbmRlcmVycylcbntcbiAgICBpZiAoICEgdGhpcy5sYXllcnMgKSB7XG4gICAgICAgIHRoaXMubGF5ZXJzID0ge307XG4gICAgfVxuICAgIGlmICggISByZW5kZXJlcnMgKSB7XG4gICAgICAgIHJlbmRlcmVycyA9IFtdO1xuICAgIH1cbiAgICB2YXIgbGF5ZXI7XG4gICAgaWYgKHRoaXMubGF5ZXJzW2xheWVyTmFtZV0pIHtcbiAgICAgICAgaWYgKHRoaXMubGF5ZXJzW2xheWVyTmFtZV0uZGlzYWJsZWQgfHwgcmVuZGVyZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMubGF5ZXJzW2xheWVyTmFtZV0uZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGJlYW4uZmlyZShNQVNDUCwnbGF5ZXJSZWdpc3RlcmVkJyxbdGhpcy5sYXllcnNbbGF5ZXJOYW1lXV0uY29uY2F0KHJlbmRlcmVycykpO1xuICAgICAgICB9XG4gICAgICAgIGxheWVyID0gdGhpcy5sYXllcnNbbGF5ZXJOYW1lXTtcbiAgICB9XG5cbiAgICBpZiAobGF5ZXIgJiYgb3B0aW9ucy5ncm91cCkge1xuICAgICAgICBpZiAobGF5ZXIuZ3JvdXAgIT09IHRoaXMuZ2V0R3JvdXAob3B0aW9ucy5ncm91cCkpIHtcbiAgICAgICAgICAgIGxheWVyLmdyb3VwID0gdGhpcy5nZXRHcm91cChvcHRpb25zLmdyb3VwKTtcbiAgICAgICAgICAgIGxheWVyLmdyb3VwLl9sYXllcnMucHVzaChsYXllcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCAhIGxheWVyLmdyb3VwICkge1xuICAgICAgICAgICAgdGhyb3cgXCJDYW5ub3QgcmVnaXN0ZXIgdGhpcyBsYXllciB3aXRoIHRoZSBnaXZlbiBncm91cCAtIHRoZSBncm91cCBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZCB5ZXRcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBpZiAobGF5ZXIpIHtcbiAgICAgICAgcmV0dXJuIGxheWVyO1xuICAgIH1cblxuICAgIGxheWVyID0gbmV3IE1BU0NQLkxheWVyKCk7XG4gICAgXG4gICAgbGF5ZXIubmFtZSA9IGxheWVyTmFtZTtcbiAgICBcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBcbiAgICBpZiAob3B0aW9ucy5mdWxsbmFtZSkge1xuICAgICAgICBsYXllci5mdWxsbmFtZSA9IG9wdGlvbnMuZnVsbG5hbWU7XG4gICAgfVxuICAgIFxuICAgIGlmIChvcHRpb25zLmNvbG9yKSB7XG4gICAgICAgIGxheWVyLmNvbG9yID0gb3B0aW9ucy5jb2xvcjtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5kYXRhKSB7XG4gICAgICAgIGxheWVyLmRhdGEgPSBvcHRpb25zLmRhdGE7XG4gICAgfVxuICAgIFxuICAgIGlmIChsYXllciAmJiBvcHRpb25zLmdyb3VwKSB7XG4gICAgICAgIGxheWVyLmdyb3VwID0gdGhpcy5nZXRHcm91cChvcHRpb25zLmdyb3VwKTtcbiAgICAgICAgaWYgKCAhIGxheWVyLmdyb3VwICkge1xuICAgICAgICAgICAgdGhyb3cgXCJDYW5ub3QgcmVnaXN0ZXIgdGhpcyBsYXllciB3aXRoIHRoZSBnaXZlbiBncm91cCAtIHRoZSBncm91cCBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZCB5ZXRcIjtcbiAgICAgICAgfVxuICAgICAgICBsYXllci5ncm91cC5fbGF5ZXJzLnB1c2gobGF5ZXIpO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLmxheWVyc1tsYXllck5hbWVdID0gbGF5ZXI7XG4gICAgXG4gICAgaWYgKG9wdGlvbnMuY3NzKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwib3B0aW9ucy5jc3MgaXMgZGVwcmVjYXRlZFwiKTtcbiAgICB9XG4gICAgbGF5ZXIubGF5ZXJfaWQgPSBuZXcgRGF0ZSgpLmdldE1pbGxpc2Vjb25kcygpO1xuICAgIGJlYW4uZmlyZShNQVNDUCwnbGF5ZXJSZWdpc3RlcmVkJyxbbGF5ZXJdLmNvbmNhdChyZW5kZXJlcnMpKTtcbiAgICBcbiAgICByZXR1cm4gbGF5ZXI7XG59O1xuXG4vKipcbiAqIEBjbGFzc1xuICogTWV0YWRhdGEgZm9yIGEgZ3JvdXAgb2YgbGF5ZXJzIHRvIGJlIHJlbmRlcmVkXG4gKi9cbk1BU0NQLkdyb3VwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuO1xufTtcblxuLyoqXG4gKiBEZXNjcmliZSB3aGF0IHRoaXMgbWV0aG9kIGRvZXNcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8QXJyYXl8Qm9vbGVhbnxOdW1iZXJ9IHBhcmFtTmFtZSBEZXNjcmliZSB0aGlzIHBhcmFtZXRlclxuICogQHJldHVybnMgRGVzY3JpYmUgd2hhdCBpdCByZXR1cm5zXG4gKiBAdHlwZSBTdHJpbmd8T2JqZWN0fEFycmF5fEJvb2xlYW58TnVtYmVyXG4gKi9cbk1BU0NQLkdyb3VwLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgaWYgKCEgdGhpcy5fbGF5ZXJzW2ldLmRpc2FibGVkKSB7XG4gICAgICAgICAgICBjb3VudGVyICs9IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvdW50ZXI7XG59O1xuXG5NQVNDUC5Hcm91cC5wcm90b3R5cGUuZWFjaExheWVyID0gZnVuY3Rpb24oZnVuYykge1xuICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgaWYgKCEgdGhpcy5fbGF5ZXJzW2ldLmRpc2FibGVkKSB7XG4gICAgICAgICAgICBmdW5jLmNhbGwodGhpcy5fbGF5ZXJzW2ldLHRoaXMuX2xheWVyc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIEBjbGFzc1xuICogTWV0YWRhdGEgZm9yIGEgc2luZ2xlIGxheWVyIHRvIGJlIHJlbmRlcmVkXG4gKi9cbk1BU0NQLkxheWVyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zY2FsZXMgPSBuZXcgU2V0KCk7XG4gICAgcmV0dXJuO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSBhIGxheWVyIG9iamVjdCBmcm9tIHRoZSBsYXllciByZWdpc3RyeS4gSWYgYSBsYXllciBvYmplY3QgaXMgcGFzc2VkIHRvIHRoaXMgbWV0aG9kLCB0aGUgc2FtZSBsYXllciBpcyByZXR1cm5lZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBsYXllciAgICBMYXllciBuYW1lXG4gKiBAcmV0dXJucyBMYXllciBvYmplY3RcbiAqIEB0eXBlIE9iamVjdFxuICogQHNlZSBNQVNDUC5MYXllclxuICovXG5NQVNDUC5nZXRMYXllciA9IGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgaWYgKCAhIE1BU0NQLmxheWVycyApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gKHR5cGVvZiBsYXllciA9PSAnc3RyaW5nJykgPyBNQVNDUC5sYXllcnNbbGF5ZXJdIDogbGF5ZXI7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIGEgZ3JvdXAgb2JqZWN0IGZyb20gdGhlIGdyb3VwIHJlZ2lzdHJ5LiBJZiBhIGdyb3Agb2JqZWN0IGlzIHBhc3NlZCB0byB0aGlzIG1ldGhvZCwgdGhlIHNhbWUgZ3JvdXAgaXMgcmV0dXJuZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gZ3JvdXAgICAgR3JvdXAgbmFtZVxuICogQHJldHVybnMgR3JvdXAgb2JqZWN0XG4gKiBAdHlwZSBPYmplY3RcbiAqIEBzZWUgTUFTQ1AuR3JvdXBcbiAqL1xuTUFTQ1AuZ2V0R3JvdXAgPSBmdW5jdGlvbihncm91cCkge1xuICAgIGlmICh0eXBlb2YgZ3JvdXAgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoICEgTUFTQ1AuZ3JvdXBzICkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZ3JvdXAgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIE1BU0NQLmdyb3Vwc1tncm91cF07XG4gICAgfVxuICAgIHJldHVybiAoZ3JvdXAgPT0gTUFTQ1AuZ3JvdXBzW2dyb3VwLm5hbWVdKSA/IGdyb3VwIDogbnVsbDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE1BU0NQO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFFQTs7OztBQUdBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQXpCQTtBQTJCQTtBQUNBO0FBR0E7Ozs7Ozs7OztBQVNBOzs7Ozs7Ozs7Ozs7QUFVQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFFQTs7Ozs7Ozs7OztBQVVBOzs7Ozs7Ozs7Ozs7QUFVQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../gator/js/lib/MASCP.js\n')},"../gator/js/lib/SVGCanvas.js":
/*!************************************!*\
  !*** ../gator/js/lib/SVGCanvas.js ***!
  \************************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _bean__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../bean */ \"../gator/js/bean.js\");\n\n\nconst SVGCanvas = function () {\n  var extended_elements = [];\n  var DEFAULT_RS = 1;\n  var svgns = 'http://www.w3.org/2000/svg';\n\n  function extend_array(an_array, RS) {\n    var curr_x, curr_y, curr_transform, targ_disp, a_disp;\n\n    an_array.visibility = function () {\n      var curr_disp = 'hidden';\n\n      for (var i = 0; i < an_array.length; i++) {\n        if (Array.isArray(an_array[i])) {\n          continue;\n        }\n\n        a_disp = an_array[i].getAttribute('visibility');\n\n        if (a_disp && a_disp != 'hidden') {\n          curr_disp = a_disp;\n          break;\n        }\n      }\n\n      return curr_disp;\n    };\n\n    an_array.currenty = function () {\n      var a_y;\n      var filtered = an_array.filter(function (el) {\n        return el && !Array.isArray(el);\n      });\n\n      if (filtered[0] && filtered[0].getAttribute('transform')) {\n        a_y = /translate\\((-?\\d+\\.?\\d*)\\s*,?\\s*(-?\\d+\\.?\\d*)\\)/.exec(filtered[0].getAttribute('transform'));\n\n        if (a_y !== null && typeof a_y !== 'undefined') {\n          a_y = a_y[2];\n        }\n      }\n\n      return filtered[0] ? parseInt(a_y || filtered[0].getAttribute('y') || 0, 10) : 0;\n    };\n\n    an_array.animate = function (hsh) {\n      if (typeof hsh.y == 'undefined') {\n        attr(hsh);\n        return;\n      }\n\n      if (an_array.length === 0) {\n        return;\n      }\n\n      var hash = {};\n      var key;\n\n      for (key in hsh) {\n        if (hsh.hasOwnProperty(key)) {\n          hash[key] = hsh[key];\n        }\n      }\n\n      setup_anim_clocks();\n\n      if (an_array.animating) {\n        for (var i = 0; i < (anim_clock_funcs || []).length; i++) {\n          if (anim_clock_funcs[i].target_set != an_array) {\n            continue;\n          }\n\n          an_array.animating = false;\n          anim_clock_funcs.splice(i, 1);\n        }\n      }\n\n      var curr_disp = an_array.visibility();\n      var target_disp = hash.visibility;\n\n      if (curr_disp == target_disp && target_disp == 'hidden') {\n        attr(hsh);\n        return;\n      }\n\n      var curr_y = an_array.currenty();\n\n      if (isNaN(parseInt(curr_y, 10))) {\n        console.log(\"Have a NaN y value, skipping\");\n        return;\n      }\n\n      var target_y = parseInt(hash.y, 10);\n      delete hash.y;\n\n      if (curr_disp == target_disp && target_disp == 'visible') {\n        delete hash.visibility;\n        target_disp = null;\n        attr({\n          'visibility': 'visible'\n        });\n      }\n\n      if (hash.visibility == 'hidden') {\n        delete hash.visibility;\n      }\n\n      attr(hash);\n      var counter = 0;\n\n      if (target_y != curr_y) {\n        var anim_steps = 1 * (Math.abs(parseInt((target_y - curr_y) / (50 * RS), 10) / rate) + 1);\n        var diff = (target_y - curr_y) / anim_steps;\n        hash.y = curr_y || 0;\n        var orig_func = an_array.animate;\n        an_array.animating = true;\n        hash.y = curr_y + diff * 1;\n\n        let step_func = function step_func(step) {\n          if (diff < 0 && hash.y < target_y) {\n            hash.y = target_y;\n          }\n\n          if (diff > 0 && hash.y > target_y) {\n            hash.y = target_y;\n          }\n\n          attr(hash);\n          counter += step || 1;\n\n          if (hash.y != target_y) {\n            hash.y = curr_y + diff * (counter + 1);\n            return;\n          }\n\n          an_array.animating = false;\n\n          if (target_disp) {\n            attr({\n              'visibility': target_disp\n            });\n          }\n\n          anim_clock_funcs.splice(anim_clock_funcs.indexOf(step_func), 1);\n        };\n\n        anim_clock_funcs.push(step_func);\n        anim_clock_funcs[anim_clock_funcs.length - 1].target_set = an_array;\n      }\n\n      return;\n    };\n\n    an_array.attr = function (hsh) {\n      if (in_anim) {\n        return this.animate(hsh);\n      }\n\n      return attr(hsh);\n    };\n\n    var attr = function attr(hsh) {\n      var hash = {};\n      var key;\n\n      for (key in hsh) {\n        if (hsh.hasOwnProperty(key)) {\n          hash[key] = hsh[key];\n        }\n      }\n\n      var curr_disp = an_array.visibility();\n      var targ_y = parseInt(hash.y, 10);\n      targ_disp = hash.visibility;\n\n      for (key in hash) {\n        if (hash.hasOwnProperty(key)) {\n          for (var i = 0; i < an_array.length; i++) {\n            if (!an_array[i]) {\n              continue;\n            }\n\n            if (Array.isArray(an_array[i])) {\n              continue;\n            }\n\n            if (an_array[i].style.display == 'none') {\n              continue;\n            }\n\n            var value = hash[key];\n\n            if (key == 'style' && an_array[i].hasAttribute('style')) {\n              var curr_style = an_array[i].getAttribute('style');\n              curr_style += '; ' + hash[key];\n              value = curr_style;\n            }\n\n            var has_translate = an_array[i].hasAttribute('transform') && an_array[i].getAttribute('transform').indexOf('translate') >= 0;\n\n            if (key == 'height' && an_array[i].setHeight) {\n              //hasAttribute('transform') && ! an_array[i].no_scale) {\n              an_array[i].setHeight(hash[key]);\n            } else if (!(has_translate && (key == 'y' || key == 'x'))) {\n              an_array[i].setAttribute(key, value);\n            }\n\n            if (key == 'y' && an_array[i].hasAttribute('d')) {\n              var curr_path = an_array[i].getAttribute('d');\n              var re = /M\\s*([\\d\\.]+) ([\\d\\.]+)/;\n              curr_path = curr_path.replace(re, '');\n\n              if (isNaN(parseInt(value, 10))) {\n                throw \"Error \" + key + \" is \" + hash[key];\n              }\n\n              an_array[i].setAttribute('d', 'M0 ' + parseInt(value, 10) + ' ' + curr_path);\n            }\n\n            if (key == 'y' && an_array[i].hasAttribute('cy')) {\n              an_array[i].setAttribute('cy', hash[key]);\n            }\n\n            if (key == 'y' && an_array[i].hasAttribute('transform')) {\n              curr_transform = an_array[i].getAttribute('transform');\n              curr_x = /translate\\((-?\\d+\\.?\\d*)\\s*,?\\s*(-?\\d+\\.?\\d*)?\\)/.exec(an_array[i].getAttribute('transform'));\n\n              if (curr_x === null) {\n                continue;\n              }\n\n              curr_x = curr_x[1];\n              curr_transform = curr_transform.replace(/translate\\((-?\\d+\\.?\\d*)\\s*,?\\s*(-?\\d+\\.?\\d*)?\\)/, 'translate(' + curr_x + ',' + value + ')');\n              an_array[i].setAttribute('transform', curr_transform);\n            }\n\n            if (key == 'x' && an_array[i].hasAttribute('transform')) {\n              curr_transform = an_array[i].getAttribute('transform');\n              curr_y = /translate\\((-?\\d+\\.?\\d*)\\s*,?\\s*(-?\\d+\\.?\\d*)\\)/.exec(an_array[i].getAttribute('transform'));\n\n              if (curr_y === null) {\n                continue;\n              }\n\n              curr_y = curr_y[2];\n              curr_transform = curr_transform.replace(/translate\\((-?\\d+\\.?\\d*)\\s*,?\\s*(-?\\d+\\.?\\d*)\\)/, 'translate(' + value + ',' + curr_y + ')');\n              an_array[i].setAttribute('transform', curr_transform);\n            }\n\n            if (key == 'text-anchor' && an_array[i].hasAttribute('style')) {\n              an_array[i].style.textAnchor = hash[key];\n            }\n\n            ;\n          }\n        }\n      }\n    };\n\n    an_array.hide = function () {\n      this.attr({\n        'visibility': 'hidden'\n      });\n    };\n\n    an_array.show = function () {\n      this.attr({\n        'visibility': 'visible'\n      });\n    };\n\n    an_array.refresh_zoom = function () {\n      for (var i = 0; i < an_array.length; i++) {\n        if (Array.isArray(an_array[i])) {\n          continue;\n        }\n\n        if (an_array[i].zoom_level && an_array[i].zoom_level == 'text') {\n          if (an_array[i].ownerSVGElement && an_array[i].ownerSVGElement.zoom > 3.5) {\n            an_array[i].setAttribute('display', 'inline');\n            an_array[i].setAttribute('opacity', 1);\n          } else {\n            an_array[i].setAttribute('display', 'none');\n          }\n        }\n\n        if (an_array[i].zoom_level && an_array[i].zoom_level == 'summary') {\n          if (an_array[i].ownerSVGElement && an_array[i].ownerSVGElement.zoom <= 3.5) {\n            an_array[i].setAttribute('display', 'inline');\n            an_array[i].setAttribute('opacity', 1);\n          } else {\n            an_array[i].setAttribute('display', 'none');\n          }\n        }\n      }\n    };\n\n    return an_array;\n  }\n\n  var anim_clock_funcs = null,\n      in_anim = false;\n  var anim_clock = null;\n  var rate = 75;\n  var new_rate = null;\n\n  var setup_anim_clocks = function setup_anim_clocks() {\n    if (anim_clock_funcs === null) {\n      anim_clock_funcs = [];\n    } else {\n      anim_clock_funcs.forEach(function (func) {\n        func._last_step = null;\n      });\n      clearInterval(anim_clock);\n    }\n\n    if (!in_anim) {\n      extended_elements.forEach(function (canv) {\n        _bean__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fire(canv, '_anim_begin');\n      });\n      in_anim = true;\n    }\n\n    var start = null;\n    anim_clock = setInterval(function () {\n      if (!anim_clock_funcs || anim_clock_funcs.length === 0) {\n        clearInterval(anim_clock);\n        anim_clock = null;\n        anim_clock_funcs = null;\n        in_anim = false;\n        extended_elements.forEach(function (canv) {\n          _bean__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fire(canv, '_anim_end');\n        });\n        return;\n      }\n\n      var suspended_ids = [];\n      extended_elements.forEach(function (canv) {\n        suspended_ids.push(canv.suspendRedraw(5000));\n      });\n      var tic = new Date().getTime();\n\n      if (!start) {\n        start = new Date().getTime();\n      }\n\n      for (var i = 0; i < (anim_clock_funcs || []).length; i++) {\n        var end = new Date().getTime();\n        var step_id = parseInt((end - start) / rate, 10);\n\n        if (new_rate === null && step_id - anim_clock_funcs[i]._last_step > 2) {\n          new_rate = Math.round(1.6 * rate);\n        }\n\n        anim_clock_funcs[i].apply(null, [step_id - (anim_clock_funcs[i]._last_step || step_id)]);\n\n        if (anim_clock_funcs && anim_clock_funcs[i]) {\n          anim_clock_funcs[i]._last_step = step_id;\n        }\n      }\n\n      var toc = new Date().getTime();\n      extended_elements.forEach(function (canv) {\n        canv.unsuspendRedraw(suspended_ids.shift());\n      });\n      var actual_speed = toc - tic;\n\n      if (actual_speed < rate && new_rate === null && actual_speed >= 1) {\n        rate = Math.round(1.5 * (toc - tic));\n        setup_anim_clocks();\n      } else if (new_rate !== null && new_rate != rate) {\n        rate = new_rate;\n        setup_anim_clocks();\n      }\n    }, rate);\n  };\n\n  var scale_re = /scale\\((-?\\d+\\.?\\d*)\\)/;\n\n  var setHeight = function setHeight(height) {\n    var curr_transform = this.getAttribute('transform').toString();\n    var curr_scale = scale_re.exec(curr_transform);\n    var curr_height = parseFloat(this.getAttribute('height') || 1);\n    var new_scale = 1;\n\n    if (curr_scale === null) {\n      curr_transform += ' scale(1) ';\n      curr_scale = 1;\n    } else {\n      curr_scale = parseFloat(curr_scale[1]);\n    }\n\n    new_scale = parseFloat(height) / curr_height * curr_scale;\n    curr_transform = curr_transform.replace(scale_re, 'scale(' + new_scale + ')');\n    this.setAttribute('transform', curr_transform);\n    this.setAttribute('height', height);\n    return new_scale;\n  };\n\n  return function (canvas) {\n    var RS = canvas.RS || DEFAULT_RS;\n    canvas.RS = RS;\n    canvas.font_order = 'Helvetica, Verdana, Arial, Sans-serif';\n    extended_elements.push(canvas);\n\n    canvas.makeEl = function (name, attributes) {\n      var result = canvas.ownerDocument.createElementNS(svgns, name);\n\n      for (var attribute in attributes) {\n        if (attributes.hasOwnProperty(attribute)) {\n          result.setAttribute(attribute, attributes[attribute]);\n        }\n      }\n\n      return result;\n    };\n\n    canvas.make_gradient = function (id, x2, y2, stops, opacities) {\n      var gradient = this.makeEl('linearGradient', {\n        'id': id,\n        'x1': '0%',\n        'x2': x2,\n        'y1': '0%',\n        'y2': y2\n      });\n      var total_stops = stops.length;\n\n      while (stops.length > 0) {\n        var stop_id = Math.round((total_stops - stops.length) / total_stops * 100);\n        var stop = stops.shift();\n        var opacity = opacities.shift();\n        gradient.appendChild(this.makeEl('stop', {\n          'offset': stop_id + '%',\n          'style': 'stop-color:' + stop + ';stop-opacity:' + opacity\n        }));\n      }\n\n      return gradient;\n    };\n\n    canvas.path = function (pathdesc) {\n      var a_path = document.createElementNS(svgns, 'path');\n      a_path.setAttribute('d', pathdesc);\n      a_path.setAttribute('stroke', '#000000');\n      a_path.setAttribute('stroke-width', '1');\n      this.appendChild(a_path);\n      return a_path;\n    };\n\n    canvas.poly = function (points) {\n      var a_poly = document.createElementNS(svgns, 'polygon');\n      a_poly.setAttribute('points', points);\n      this.appendChild(a_poly);\n      return a_poly;\n    };\n\n    canvas.circle = function (x, y, radius) {\n      var a_circle = document.createElementNS(svgns, 'circle');\n      a_circle.setAttribute('cx', typeof x == 'string' ? x : x * RS);\n      a_circle.setAttribute('cy', typeof y == 'string' ? y : y * RS);\n      a_circle.setAttribute('r', typeof radius == 'string' ? radius : radius * RS);\n\n      a_circle.move = function (new_x) {\n        a_circle.setAttribute('cx', new_x * RS);\n      };\n\n      this.appendChild(a_circle);\n      return a_circle;\n    };\n\n    canvas.group = function () {\n      var a_g = document.createElementNS(svgns, 'g');\n      this.appendChild(a_g);\n\n      a_g.push = function (new_el) {\n        a_g.appendChild(new_el);\n      };\n\n      return a_g;\n    };\n\n    canvas.clipPath = function () {\n      var el = document.createElementNS(svgns, 'clipPath');\n      this.appendChild(el);\n\n      el.push = function (new_el) {\n        el.appendChild(new_el);\n      };\n\n      return el;\n    };\n\n    canvas.line = function (x, y, x2, y2) {\n      var a_line = document.createElementNS(svgns, 'line');\n      a_line.setAttribute('x1', typeof x == 'string' ? x : x * RS);\n      a_line.setAttribute('y1', typeof y == 'string' ? y : y * RS);\n      a_line.setAttribute('x2', typeof x2 == 'string' ? x2 : x2 * RS);\n      a_line.setAttribute('y2', typeof y2 == 'string' ? y2 : y2 * RS);\n      this.appendChild(a_line);\n      return a_line;\n    };\n\n    canvas.rect = function (x, y, width, height, opts) {\n      if (!opts) {\n        opts = {};\n      }\n\n      var a_rect = document.createElementNS(svgns, 'rect');\n      a_rect.setAttribute('x', typeof x == 'string' ? x : x * RS);\n      a_rect.setAttribute('y', typeof y == 'string' ? y : y * RS);\n      a_rect.setAttribute('width', typeof width == 'string' ? width : width * RS);\n      a_rect.setAttribute('height', typeof height == 'string' ? height : height * RS);\n      a_rect.setAttribute('stroke', '#000000');\n      this.appendChild(a_rect);\n\n      if (typeof opts.offset !== \"undefined\") {\n        a_rect.offset = opts.offset;\n        a_rect.setAttribute('transform', 'translate(' + a_rect.getAttribute('x') + ',' + a_rect.getAttribute('y') + ')');\n        a_rect.setAttribute('x', '0');\n        a_rect.setAttribute('y', a_rect.offset * RS);\n      }\n\n      a_rect.move = function (new_x, new_width) {\n        if (typeof this.offset !== \"undefined\" && this.getAttribute('transform')) {\n          var transform_attr = this.getAttribute('transform');\n          var matches = /translate\\(.*[,\\s](.*)\\)/.exec(transform_attr);\n\n          if (matches[1]) {\n            this.setAttribute('transform', 'translate(' + new_x * RS + ',' + matches[1] + ')');\n          }\n\n          this.setAttribute('width', new_width * RS);\n        } else {\n          this.setAttribute('x', new_x * RS);\n          this.setAttribute('width', new_width * RS);\n        }\n      };\n\n      return a_rect;\n    };\n\n    canvas.roundRect = function (x, y, width, height, r, opts) {\n      var a_rect = this.rect(x, y, width, height, opts);\n\n      if (typeof r != 'object' || !r.x) {\n        r = {\n          'x': r,\n          'y': r\n        };\n      }\n\n      a_rect.setAttribute('rx', r.x * RS);\n      a_rect.setAttribute('ry', r.y * RS);\n      return a_rect;\n    };\n\n    canvas.ellipticalRect = function (x, y, width, height) {\n      return this.roundRect(x, y, width, height, {\n        'x': 0.25 * width,\n        'y': 0.5 * height\n      });\n    };\n\n    canvas.pentagon = function (x, y, width, height, rotate) {\n      return this.nagon(x, y, width, height, 5, rotate);\n    };\n\n    canvas.hexagon = function (x, y, width, height, rotate) {\n      return this.nagon(x, y, width, height, 6, rotate);\n    };\n\n    var shape_set_attribute = function shape_set_attribute(attr, val) {\n      this.constructor.prototype.setAttribute.call(this, attr, val);\n\n      if (attr == 'height' || attr == 'width' || attr == 'x' || attr == 'y') {\n        this.redraw(Math.floor(parseFloat(this.getAttribute('height'))));\n      }\n    };\n\n    canvas.nagon = function (x, y, width, height, n, rotate) {\n      var shape = this.poly(\"\"); // shape.setAttribute('transform','translate('+(x*RS)+','+(RS*y)+')');\n\n      shape.setAttribute('x', x * RS);\n      shape.setAttribute('y', y * RS);\n      shape.setAttribute('width', width * RS);\n\n      shape.redraw = function (hght) {\n        if (hght) {\n          this.last_height = hght;\n        } else {\n          hght = this.last_height;\n        }\n\n        var a = 0.5 * Math.floor(parseFloat(shape.getAttribute('width')));\n        var b = 0.5 * hght;\n        var points = [];\n        var min_x = null;\n        var max_x = null;\n\n        for (var i = 0; i < n; i++) {\n          var angle = rotate / 360 * 2 * Math.PI + 2 / n * Math.PI * i;\n          var a_x = parseInt(a + a * Math.cos(angle));\n          var a_y = parseInt(b + b * Math.sin(angle));\n          points.push([a_x, a_y]);\n\n          if (min_x === null || a_x < min_x) {\n            min_x = a_x;\n          }\n\n          if (max_x === null || a_x > max_x) {\n            max_x = a_x;\n          }\n        }\n\n        var x_pos = Math.floor(parseFloat(shape.getAttribute('x')));\n        var y_pos = Math.floor(parseFloat(shape.getAttribute('y')));\n        points.map(function (points) {\n          if (points[0] == min_x) {\n            points[0] = 0;\n          }\n\n          if (points[0] == max_x) {\n            points[0] = a * 2;\n          }\n\n          points[0] += x_pos;\n          points[1] = y_pos + 0.5 * hght * (points[1] / b);\n          return points.join(\",\");\n        });\n        this.setAttribute('points', points.join(\" \"));\n      };\n\n      shape.setHeight = shape.redraw;\n\n      shape.move = function (new_x, new_width) {\n        var curr_y = /translate\\((-?\\d+\\.?\\d*)\\s*,?\\s*(-?\\d+\\.?\\d*)\\)/.exec(this.getAttribute('transform'));\n\n        if (curr_y === null) {\n          return;\n        }\n\n        curr_y = curr_y[2];\n        var curr_transform = this.getAttribute('transform').replace(/translate\\((-?\\d+\\.?\\d*)\\s*,?\\s*(-?\\d+\\.?\\d*)\\)/, 'translate(' + new_x * RS + ',' + curr_y + ')');\n        this.setAttribute('transform', curr_transform);\n        a = 0.5 * new_width * RS;\n      };\n\n      shape.setAttribute = shape_set_attribute;\n      shape.redraw(height * RS);\n      return shape;\n    };\n\n    canvas.use = function (ref, x, y, width, height) {\n      var a_use = document.createElementNS(svgns, 'use');\n      a_use.setAttribute('x', typeof x == 'string' ? x : x * RS);\n      a_use.setAttribute('y', typeof y == 'string' ? y : y * RS);\n      a_use.setAttribute('width', typeof width == 'string' ? width : width * RS);\n      a_use.setAttribute('height', typeof height == 'string' ? height : height * RS);\n      a_use.setAttributeNS('http://www.w3.org/1999/xlink', 'href', ref);\n      this.appendChild(a_use);\n      return a_use;\n    };\n\n    canvas.a = function (href) {\n      var a_anchor = document.createElementNS(svgns, 'a');\n      a_anchor.setAttribute('target', '_new');\n      a_anchor.setAttributeNS('http://www.w3.org/1999/xlink', 'href', href);\n      this.appendChild(a_anchor);\n      return a_anchor;\n    };\n\n    canvas.button = function (x, y, width, height, text) {\n      var fo = document.createElementNS(svgns, 'foreignObject');\n      fo.setAttribute('x', x);\n      fo.setAttribute('y', y);\n      fo.setAttribute('width', x + width);\n      fo.setAttribute('height', y + height);\n\n      if (!fo.style) {\n        fo.setAttribute('style', 'position: absolute;');\n      } else {\n        fo.style.position = 'absolute';\n      }\n\n      this.appendChild(fo);\n      var button = document.createElement('button');\n      button.style.display = 'block';\n      button.textContent = text;\n      fo.appendChild(button);\n      return button;\n    };\n\n    canvas.svgbutton = function (x, y, width, height, txt) {\n      var button = this.group();\n      var back = this.rect(x, y, width, height);\n      back.setAttribute('rx', '10');\n      back.setAttribute('ry', '10');\n      back.setAttribute('stroke', '#ffffff');\n      back.setAttribute('stroke-width', '2');\n      back.setAttribute('fill', 'url(#simple_gradient)');\n      x = back.x.baseVal.value;\n      y = back.y.baseVal.value;\n      width = back.width.baseVal.value;\n      height = back.height.baseVal.value;\n      var text = this.text(x + width / 2, y + height / 3, txt);\n      text.setAttribute('text-anchor', 'middle');\n      text.firstChild.setAttribute('dy', '1.5ex');\n      text.setAttribute('font-size', 0.5 * height);\n      text.setAttribute('fill', '#ffffff');\n      button.push(back);\n      button.push(text);\n      button.background_element = back;\n      button.text_element = text;\n      button.setAttribute('cursor', 'pointer');\n\n      var button_trigger = function button_trigger() {\n        back.setAttribute('fill', '#999999');\n        back.setAttribute('stroke', '#000000');\n      };\n\n      button.addEventListener('mousedown', button_trigger, false);\n      button.addEventListener('touchstart', button_trigger, false);\n\n      var button_reset = function button_reset() {\n        back.setAttribute('stroke', '#ffffff');\n        back.setAttribute('fill', 'url(#simple_gradient)');\n      };\n\n      button.addEventListener('mouseup', button_reset, false);\n      button.addEventListener('mouseout', button_reset, false);\n      button.addEventListener('touchend', button_reset, false);\n      return button;\n    };\n\n    canvas.callout = function (x, y, content, opts) {\n      var callout = this.group();\n      var back = this.roundRect(-0.5 * (opts.width + 4), 20, opts.width + 4, opts.height + 4, 4);\n      back.setAttribute('fill', '#000000');\n      var pres_box = this.roundRect(-0.5 * (opts.width + 1), 22, opts.width + 1, opts.height, 4);\n      pres_box.setAttribute('fill', '#eeeeee');\n      callout.push(back);\n      callout.push(pres_box);\n      var poly = this.poly('0,500 500,1000 -500,1000');\n      poly.setAttribute('fill', '#000000');\n      callout.push(poly);\n      var fo = document.createElementNS(svgns, 'foreignObject');\n      fo.setAttribute('x', -0.5 * (opts.width + 1) * RS);\n      fo.setAttribute('y', 22 * RS);\n      fo.setAttribute('width', opts.width * RS);\n      fo.setAttribute('height', opts.height * RS);\n      callout.push(fo);\n      var html = document.createElementNS('http://www.w3.org/1999/xhtml', 'html');\n      html.setAttribute('xmlns', 'http://www.w3.org/1999/xhtml');\n      var body = document.createElementNS('http://www.w3.org/1999/xhtml', 'body');\n      body.style.fontSize = (opts['font-size'] || 15) * RS + 'px';\n      body.style.margin = 5 * RS + 'px';\n      body.style.height = opts.height * RS * 10 + 'px';\n      html.appendChild(body);\n      body.appendChild(content);\n      fo.appendChild(html);\n      var scale = opts.height / 15;\n      callout.setAttribute('transform', 'translate(' + x * RS + ',' + (y + 20) * RS + ') scale(' + scale + ')');\n      callout.setHeight = setHeight;\n\n      if (!opts.align) {\n        var currVbox = parseFloat(this.getAttribute('viewBox').split(/\\s+/)[2]);\n\n        if ((x + 10 + 0.5 * opts.width) * RS > currVbox) {\n          opts.align = 'right';\n        }\n\n        if ((x - 0.5 * opts.width) * RS < 0) {\n          opts.align = 'left';\n        }\n      }\n\n      if (opts.align) {\n        var shifter = opts.align == \"right\" ? -0.5 : 0.5;\n        back.setAttribute('transform', 'translate(' + shifter * opts.width * RS + ',0)');\n        pres_box.setAttribute('transform', 'translate(' + shifter * opts.width * RS + ',0)');\n        poly.setAttribute('transform', 'translate(' + 0 * shifter * opts.width * RS + ',0)');\n        poly.setAttribute('points', shifter > 0 ? \"0,500 500,1000 0,1000\" : \"0,500 0,1000 -500,1000\");\n        fo.setAttribute('transform', 'translate(' + shifter * opts.width * RS + ',0)');\n      }\n\n      callout.setAttribute('height', opts.height * RS);\n      return callout;\n    };\n\n    canvas.growingMarker = function (x, y, symbol, opts) {\n      var container = document.createElementNS(svgns, 'svg');\n\n      if (!opts.stretch && !(Array.isArray && Array.isArray(opts.content))) {\n        container.setAttribute('viewBox', '-50 -100 200 250');\n        container.setAttribute('preserveAspectRatio', 'xMinYMin meet');\n      } else {\n        container = this.group();\n      }\n\n      container.setAttribute('x', x);\n      container.setAttribute('y', y);\n      var the_marker = this.marker(50 / RS, 50 / RS, 50 / RS, symbol, opts);\n      container.appendChild(the_marker);\n      container.contentElement = the_marker.contentElement;\n      var result = this.group();\n      var positioning_group = this.group();\n      result.appendChild(positioning_group);\n      positioning_group.appendChild(container);\n\n      if (!opts.stretch && !(Array.isArray && Array.isArray(opts.content))) {\n        container.setAttribute('width', '200');\n        container.setAttribute('height', '250');\n      }\n\n      if (opts.angle) {\n        result.angle = opts.angle;\n      } // var rect = document.createElementNS(svgns,'rect');\n      // rect.setAttribute('stroke','#f00');\n      // rect.setAttribute('stroke-width','10');\n      // rect.setAttribute('x','-50');\n      // rect.setAttribute('y','-100');\n      // rect.setAttribute('width','100%');\n      // rect.setAttribute('height','100%');\n      // rect.setAttribute('fill','none');\n      // container.appendChild(rect);\n      // var rect = document.createElementNS(svgns,'rect');\n      // rect.setAttribute('stroke','#0f0');\n      // rect.setAttribute('stroke-width','10');\n      // rect.setAttribute('x','50');\n      // rect.setAttribute('y','25');\n      // rect.setAttribute('width','50%');\n      // rect.setAttribute('height','50%');\n      // rect.setAttribute('fill','none');\n      // container.appendChild(rect);\n\n\n      result.setAttribute('height', '250');\n      result.setAttribute('transform', 'scale(1)');\n\n      result.setHeight = function (height) {\n        // this.setAttribute('height',height);\n        var scale_val = setHeight.call(this, height);\n        this.setAttribute('height', height);\n        var top_offset = this.offset || 0;\n\n        if (!this.angle) {\n          this.angle = 0;\n        }\n\n        this.firstChild.setAttribute('transform', 'translate(-100,' + top_offset * RS + ') rotate(' + this.angle + ',100,0)');\n      };\n\n      result.container = container;\n      return result;\n    };\n\n    canvas.marker = function (cx, cy, r, symbol, opts) {\n      var units = 0;\n\n      if (typeof cx == 'string') {\n        var parts = new RegExp(/(\\d+)(.*)/g).exec(cx);\n        units = parts[2];\n        cx = parseFloat(parts[1]);\n        parts = new RegExp(/(\\d+)(.*)/g).exec(cy);\n        cy = parseFloat(parts[1]);\n        parts = new RegExp(/(\\d+)(.*)/g).exec(r);\n        r = parseFloat(parts[1]);\n      }\n\n      var dim = {\n        CX: cx + units,\n        CY: cy + units,\n        R: r + units,\n        MIN_X: cx - r + units,\n        MAX_X: cx + r + units,\n        MIN_Y: cy - r + units,\n        MAX_Y: cy + r + units,\n        MID_X1: cx - r / 2 + units,\n        MID_X2: cx + r / 2 + units,\n        MID_Y1: cy - r / 2 + units,\n        MID_Y2: cy + r / 2 + units\n      };\n      var marker = this.group();\n\n      if (!opts) {\n        opts = {};\n      }\n\n      var fill_color = opts && opts.border ? opts.border : 'rgb(0,0,0)';\n\n      if (!opts.bare_element) {\n        if (opts.width) {\n          marker.push(this.roundRect(-0.5 * opts.width - 1, -0.5, opts.width + 2, 3, 1.5));\n          marker.lastChild.setAttribute('fill', fill_color);\n        } else {\n          marker.push(this.circle(0, -0.5 * r, r));\n          marker.lastChild.setAttribute('fill', fill_color);\n          marker.lastChild.setAttribute('border', 'true');\n          marker.push(this.circle(0, 1.5 * r, r));\n          marker.lastChild.setAttribute('fill', fill_color);\n          marker.lastChild.setAttribute('border', 'true');\n          var arrow = this.poly(-0.9 * r * RS + ',' + 0 * r * RS + ' 0,' + -2.5 * r * RS + ' ' + 0.9 * r * RS + ',' + 0 * r * RS);\n          arrow.setAttribute('fill', fill_color);\n          arrow.setAttribute('stroke-width', '0');\n          marker.push(arrow);\n          marker.lastChild.setAttribute('border', 'true');\n        }\n      }\n\n      marker.setAttribute('transform', 'translate(' + cx * RS + ',' + 0.5 * cy * RS + ') scale(1)');\n      marker.setHeight = setHeight;\n      marker.setAttribute('height', dim.R * RS);\n\n      if (typeof symbol == 'string') {\n        if (symbol.match(/^(:?https?:)?\\/?.*#/)) {\n          marker.contentElement = this.use(symbol, -r, 0, 2 * r, 2 * r);\n          marker.contentElement.setAttribute('content', 'true');\n        } else {\n          marker.contentElement = this.text_circle(0, 0, 2 * r, symbol, opts);\n          marker.contentElement.firstChild.setAttribute('content', 'true');\n        }\n\n        marker.push(marker.contentElement);\n      } else if (Array.isArray && Array.isArray(symbol)) {\n        marker.contentElement = this.group();\n        var phase = Math.PI / symbol.length; // phase -= (Math.PI / 2);\n\n        var needs_stretch = opts.stretch;\n        var nrow = 2;\n        symbol.forEach(function (symb, i) {\n          var x_pos = i % nrow;\n          var y_pos = 2 + Math.floor(i / nrow);\n          x_pos *= 2 * r;\n          y_pos *= 2 * r;\n          x_pos -= 0.5 * r;\n          var rotate_amount = 180 * i / symbol.length;\n          rotate_amount -= 0 * 90;\n          rotate_amount = 0;\n\n          if (needs_stretch) {\n            if (rotate_amount >= -90 && rotate_amount <= 90) {\n              opts.stretch = 'right';\n            } else {\n              opts.stretch = 'left';\n            }\n\n            if (rotate_amount % 90 == 0 && rotate_amount != 90 && rotate_amount != -90) {\n              if (rotate_amount == 0) {\n                opts.stretch = 'right';\n              }\n\n              if (symbol.length == 1) {\n                opts.stretch = true;\n              }\n            }\n          }\n\n          if (rotate_amount > 90 && rotate_amount < 270) {\n            rotate_amount = 180 + rotate_amount;\n          }\n\n          let new_el = null;\n\n          if (symb.match(/^(:?https?:)?\\/?.*#/)) {\n            new_el = canvas.use(symb, (x_pos - 0.5) * r, (y_pos - 0.5) * r, 2 * r, 2 * r);\n            new_el.setAttribute('pointer-events', 'none');\n            new_el.setAttribute('content', 'true');\n          } else {\n            var opts_copy = JSON.parse(JSON.stringify(opts));\n            opts_copy.no_tracer = true;\n            delete opts_copy.offset;\n            delete opts_copy.height;\n            new_el = canvas.text_circle(x_pos * r, y_pos * r, 1.75 * r, symb, opts_copy);\n            new_el.firstChild.setAttribute('content', 'true');\n          }\n\n          var curr_transform = new_el.getAttribute('transform') || '';\n          curr_transform = curr_transform + ' rotate(' + rotate_amount + ',' + 0 * r * RS + ',' + y_pos * r * RS + ')';\n          new_el.setAttribute('transform', curr_transform);\n          marker.contentElement.push(new_el);\n        });\n        marker.push(marker.contentElement);\n      } else {\n        marker.contentElement = this.group();\n\n        if (!opts.bare_element) {\n          marker.contentElement.push(this.text_circle(0, 0.5 * r, 1.75 * r, \"\", opts));\n          marker.contentElement.lastChild.firstChild.setAttribute('content', 'true');\n        }\n\n        if (symbol) {\n          if (!opts.bare_element) {\n            symbol.setAttribute('transform', 'translate(0,' + 0.5 * r * RS + ')');\n          }\n\n          symbol.setAttribute('content', 'true');\n          marker.contentElement.push(symbol);\n        }\n\n        marker.push(marker.contentElement);\n      }\n\n      marker.setAttribute('marker', 'true');\n      return marker;\n    };\n\n    canvas.text_circle = function (cx, cy, r, txt, opts) {\n      if (!opts) {\n        opts = {};\n      }\n\n      var units = 0;\n\n      if (typeof cx == 'string') {\n        var parts = new RegExp(/(\\d+)(.*)/g).exec(cx);\n        units = parts[2];\n        cx = parseFloat(parts[1]);\n        parts = new RegExp(/(\\d+)(.*)/g).exec(cy);\n        cy = parseFloat(parts[1]);\n        parts = new RegExp(/(\\d+)(.*)/g).exec(r);\n        r = parseFloat(parts[1]);\n      }\n\n      var dim = {\n        CX: cx + units,\n        CY: cy + units,\n        R: r + units,\n        MIN_X: cx - r + units,\n        MAX_X: cx + r + units,\n        MIN_Y: cy - r + units,\n        MAX_Y: cy + r + units,\n        MID_X1: cx - r / 2 + units,\n        MID_X2: cx + r / 2 + units,\n        MID_Y1: cy - r / 2 + units,\n        MID_Y2: cy + r / 2 + units\n      };\n      var marker_group = this.group();\n      var text = this.text(0, dim.CY, txt);\n      text.setAttribute('font-size', 10 * RS);\n      text.setAttribute('font-weight', opts.weight || 'bolder');\n      text.setAttribute('fill', opts.text_fill || '#ffffff');\n      text.setAttribute('style', 'font-family: sans-serif; text-anchor: middle;');\n      text.firstChild.setAttribute('dy', '0.35em');\n      text.setAttribute('text-anchor', 'middle');\n      var back;\n\n      if (!opts.stretch) {\n        back = this.circle(0, dim.CY, 9 / 10 * dim.R);\n      } else {\n        var text_width = 1.2 * (opts.font_size || r) * text.getBBox().width / (10 * RS);\n        var text_height = 3 / 2 * dim.R;\n        var left_pos = -0.5 * text_width;\n\n        if (text_width > 3 * dim.R) {\n          left_pos = -0.5 * text_width;\n\n          if (opts.stretch == 'right') {\n            left_pos = -0.1 * text_width;\n          }\n\n          if (opts.stretch == 'left') {\n            left_pos = -0.9 * text_width;\n          }\n        } else {\n          text_width = 3 * dim.R;\n          left_pos = -0.5 * text_width;\n        }\n\n        text.setAttribute('x', (0.5 * text_width + left_pos) * RS);\n        back = this.roundRect(left_pos, dim.CY - 0.5 * text_height, text_width, text_height, {\n          'x': 0.5 * dim.R,\n          'y': 0.5 * text_height\n        }, {});\n      }\n\n      text.setAttribute('font-size', (opts.font_size || r) * RS);\n      back.setAttribute('fill', opts.fill || 'url(#simple_gradient)');\n      window.matchMedia('print').addListener(function (match) {\n        back.setAttribute('fill', match.matches ? '#aaaaaa' : opts.fill || 'url(#simple_gradient)');\n      });\n      back.setAttribute('stroke', opts.border || '#000000');\n      back.setAttribute('stroke-width', r / 10 * RS);\n      marker_group.push(back);\n      marker_group.push(text);\n      marker_group.setAttribute('transform', 'translate(' + dim.CX * RS + ', 1) scale(1)');\n      marker_group.setAttribute('height', dim.R / 2 * RS);\n      marker_group.setHeight = setHeight;\n      return marker_group;\n    };\n\n    canvas.crossed_circle = function (cx, cy, r) {\n      var units = 0;\n\n      if (typeof cx == 'string') {\n        var parts = new RegExp(/(\\d+)(.*)/g).exec(cx);\n        units = parts[2];\n        cx = parseFloat(parts[1]);\n        parts = new RegExp(/(\\d+)(.*)/g).exec(cy);\n        cy = parseFloat(parts[1]);\n        parts = new RegExp(/(\\d+)(.*)/g).exec(r);\n        r = parseFloat(parts[1]);\n      }\n\n      var dim = {\n        CX: cx + units,\n        CY: cy + units,\n        R: r + units,\n        MIN_X: cx - r + units,\n        MAX_X: cx + r + units,\n        MIN_Y: cy - r + units,\n        MAX_Y: cy + r + units,\n        MID_X1: cx - r / 2 + units,\n        MID_X2: cx + r / 2 + units,\n        MID_Y1: cy - r / 2 + units,\n        MID_Y2: cy + r / 2 + units\n      };\n      var close_group = this.group();\n      var close_button = this.circle(dim.CX, dim.CY, dim.R);\n      close_button.setAttribute('fill', '#000000');\n      close_button.setAttribute('stroke', '#ffffff');\n      close_button.setAttribute('stroke-width', '2');\n      close_group._button = close_button;\n      close_group.push(close_button);\n      var a_line = this.line(dim.MID_X1, dim.MID_Y1, dim.MID_X2, dim.MID_Y2);\n      a_line.setAttribute('stroke', '#ffffff');\n      a_line.setAttribute('stroke-width', '2');\n      close_group.push(a_line);\n      var first_line = a_line;\n      var a_line = this.line(dim.MID_X1, dim.MID_Y2, dim.MID_X2, dim.MID_Y1);\n      a_line.setAttribute('stroke', '#ffffff');\n      a_line.setAttribute('stroke-width', '2');\n      close_group.push(a_line);\n\n      close_group.move = function (cx, cy) {\n        close_button.setAttribute('cx', cx);\n        dim.MID_X1 = cx - r / 2;\n        dim.MID_X2 = cx + r / 2;\n        dim.MID_Y1 = cy - r / 2;\n        dim.MID_Y2 = cy + r / 2;\n        first_line.setAttribute('x1', dim.MID_X1);\n        first_line.setAttribute('y1', dim.MID_Y1);\n        first_line.setAttribute('x2', dim.MID_X2);\n        first_line.setAttribute('y2', dim.MID_Y2);\n        a_line.setAttribute('x1', dim.MID_X1);\n        a_line.setAttribute('y1', dim.MID_Y2);\n        a_line.setAttribute('x2', dim.MID_X2);\n        a_line.setAttribute('y2', dim.MID_Y1);\n      };\n\n      return close_group;\n    };\n\n    canvas.text = function (x, y, text) {\n      var a_text = document.createElementNS(svgns, 'text');\n      var a_tspan = document.createElementNS(svgns, 'tspan');\n\n      if (typeof text != 'string') {\n        a_text.appendChild(text);\n      } else {\n        a_text.appendChild(a_tspan);\n        a_tspan.textContent = text;\n        a_tspan.setAttribute('dy', '0');\n      }\n\n      a_text.style.fontFamily = this.font_order || 'Helvetica, Verdana, Arial, Sans-serif';\n      a_text.setAttribute('x', typeof x == 'string' ? x : x * RS);\n      a_text.setAttribute('y', typeof y == 'string' ? y : y * RS);\n\n      a_text.move = function (new_x, new_width) {\n        if (typeof this.offset !== \"undefined\" && this.getAttribute('transform')) {\n          var transform_attr = this.getAttribute('transform');\n          var matches = /translate\\(.*[,\\s](.*)\\)/.exec(transform_attr);\n\n          if (matches[1]) {\n            this.setAttribute('transform', 'translate(' + new_x * RS + ',' + matches[1] + ')');\n          }\n        } else {\n          this.setAttribute('x', new_x * RS);\n        }\n      };\n\n      this.appendChild(a_text);\n      return a_text;\n    };\n\n    canvas.plus = function (x, y, height) {\n      var g = this.group();\n      g.appendChild(this.makeEl('rect', {\n        'x': Math.round(0.4 * height * RS).toString(),\n        'y': Math.round(0.1 * height * RS).toString(),\n        'stroke-width': '1',\n        'width': Math.round(0.2 * height * RS).toString(),\n        'height': Math.round(0.8 * height * RS).toString(),\n        'stroke': '#ffffff',\n        'fill': '#ffffff'\n      }));\n      g.appendChild(this.makeEl('rect', {\n        'x': Math.round(0.1 * height * RS).toString(),\n        'y': Math.round(0.4 * height * RS).toString(),\n        'stroke-width': '1',\n        'width': Math.round(0.8 * height * RS).toString(),\n        'height': Math.round(0.2 * height * RS).toString(),\n        'stroke': '#ffffff',\n        'fill': '#ffffff'\n      }));\n      g.setAttribute('transform', 'translate(' + x * RS + ',' + y * RS + ')');\n      return g;\n    };\n\n    canvas.minus = function (x, y, height) {\n      var g = this.group();\n      g.appendChild(this.makeEl('rect', {\n        'x': Math.round(0.1 * height * RS).toString(),\n        'y': Math.round(0.4 * height * RS).toString(),\n        'stroke-width': '1',\n        'width': Math.round(0.8 * height * RS).toString(),\n        'height': Math.round(0.2 * height * RS).toString(),\n        'stroke': '#ffffff',\n        'fill': '#ffffff'\n      }));\n      g.setAttribute('transform', 'translate(' + x * RS + ',' + y * RS + ')');\n      return g;\n    }; // Calculate the bounding box of an element with respect to its parent element\n    // Thanks to http://stackoverflow.com/questions/10623809/get-bounding-box-of-element-accounting-for-its-transform\n\n\n    canvas.transformedBoundingBox = function (el) {\n      var bb = el.getBBox(),\n          svg = el.ownerSVGElement,\n          m = el.parentNode.getScreenCTM().inverse().multiply(el.getScreenCTM()).inverse(); // Create an array of all four points for the original bounding box\n\n      var pts = [svg.createSVGPoint(), svg.createSVGPoint(), svg.createSVGPoint(), svg.createSVGPoint()];\n      pts[0].x = bb.x;\n      pts[0].y = bb.y;\n      pts[1].x = bb.x + bb.width;\n      pts[1].y = bb.y;\n      pts[2].x = bb.x + bb.width;\n      pts[2].y = bb.y + bb.height;\n      pts[3].x = bb.x;\n      pts[3].y = bb.y + bb.height; // Transform each into the space of the parent,\n      // and calculate the min/max points from that.\n\n      var xMin = Infinity,\n          xMax = -Infinity,\n          yMin = Infinity,\n          yMax = -Infinity;\n      pts.forEach(function (pt) {\n        pt = pt.matrixTransform(m);\n        xMin = Math.min(xMin, pt.x);\n        xMax = Math.max(xMax, pt.x);\n        yMin = Math.min(yMin, pt.y);\n        yMax = Math.max(yMax, pt.y);\n      }); // Update the bounding box with the new values\n\n      try {\n        bb.x = xMin;\n        bb.width = xMax - xMin;\n        bb.y = yMin;\n        bb.height = yMax - yMin;\n      } catch (e) {\n        bb = {\n          'x': xMin,\n          'y': yMin,\n          'width': xMax - xMin,\n          'height': yMax - yMin\n        };\n      }\n\n      return bb;\n    };\n\n    canvas.set = function () {\n      var an_array = [];\n      extend_array(an_array, RS);\n      return an_array;\n    };\n\n    canvas.hide = function () {\n      this.setAttribute('display', 'none');\n    };\n\n    canvas.show = function () {\n      this.setAttribute('display', 'inline');\n    };\n  };\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (SVGCanvas);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vZ2F0b3IvanMvbGliL1NWR0NhbnZhcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9nYXRvci9qcy9saWIvU1ZHQ2FudmFzLmpzP2ZiZjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGJlYW4gZnJvbSAnLi4vYmVhbic7XG5cbmNvbnN0IFNWR0NhbnZhcyA9IChmdW5jdGlvbigpIHtcbiAgICBcbiAgICB2YXIgZXh0ZW5kZWRfZWxlbWVudHMgPSBbXTtcbiAgICB2YXIgREVGQVVMVF9SUyA9IDE7XG4gICAgdmFyIHN2Z25zID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbiAgICBcbiAgICBmdW5jdGlvbiBleHRlbmRfYXJyYXkoYW5fYXJyYXksUlMpIHtcbiAgICAgICAgdmFyIGN1cnJfeCwgY3Vycl95LCBjdXJyX3RyYW5zZm9ybSwgdGFyZ19kaXNwLCBhX2Rpc3A7XG4gICAgICAgIFxuICAgICAgICBhbl9hcnJheS52aXNpYmlsaXR5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY3Vycl9kaXNwID0gJ2hpZGRlbic7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IGFuX2FycmF5Lmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFuX2FycmF5W2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhX2Rpc3AgPSBhbl9hcnJheVtpXS5nZXRBdHRyaWJ1dGUoJ3Zpc2liaWxpdHknKTtcbiAgICAgICAgICAgICAgICBpZiAoYV9kaXNwICYmIGFfZGlzcCAhPSAnaGlkZGVuJykge1xuICAgICAgICAgICAgICAgICAgICBjdXJyX2Rpc3AgPSBhX2Rpc3A7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjdXJyX2Rpc3A7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBhbl9hcnJheS5jdXJyZW50eSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGFfeTtcbiAgICAgICAgICAgIHZhciBmaWx0ZXJlZCA9IGFuX2FycmF5LmZpbHRlcihmdW5jdGlvbihlbCkgeyByZXR1cm4gZWwgJiYgISBBcnJheS5pc0FycmF5KGVsKTsgfSk7XG4gICAgICAgICAgICBpZiAoZmlsdGVyZWRbMF0gJiYgZmlsdGVyZWRbMF0uZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKSkge1xuICAgICAgICAgICAgICAgIGFfeSA9IC90cmFuc2xhdGVcXCgoLT9cXGQrXFwuP1xcZCopXFxzKiw/XFxzKigtP1xcZCtcXC4/XFxkKilcXCkvLmV4ZWMoZmlsdGVyZWRbMF0uZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKSk7XG4gICAgICAgICAgICAgICAgaWYgKGFfeSAhPT0gbnVsbCAmJiAodHlwZW9mKGFfeSkgIT09ICd1bmRlZmluZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICBhX3kgPSBhX3lbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcmVkWzBdID8gcGFyc2VJbnQoIGFfeSB8fCBmaWx0ZXJlZFswXS5nZXRBdHRyaWJ1dGUoJ3knKSB8fCAwLDEwKSA6IDA7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBhbl9hcnJheS5hbmltYXRlID0gZnVuY3Rpb24oaHNoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGhzaC55ID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgYXR0cihoc2gpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbl9hcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBoYXNoID0ge307XG4gICAgICAgICAgICB2YXIga2V5O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKGtleSBpbiBoc2gpIHtcbiAgICAgICAgICAgICAgICBpZiAoaHNoLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzaFtrZXldID0gaHNoW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBzZXR1cF9hbmltX2Nsb2NrcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoYW5fYXJyYXkuYW5pbWF0aW5nKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAoYW5pbV9jbG9ja19mdW5jcyB8fCBbXSkubGVuZ3RoOyBpKysgKSB7ICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFuaW1fY2xvY2tfZnVuY3NbaV0udGFyZ2V0X3NldCAhPSBhbl9hcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYW5fYXJyYXkuYW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1fY2xvY2tfZnVuY3Muc3BsaWNlKGksMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGN1cnJfZGlzcCA9IGFuX2FycmF5LnZpc2liaWxpdHkoKTtcblxuICAgICAgICAgICAgdmFyIHRhcmdldF9kaXNwID0gaGFzaC52aXNpYmlsaXR5O1xuICAgICAgICAgICAgaWYgKGN1cnJfZGlzcCA9PSB0YXJnZXRfZGlzcCAmJiB0YXJnZXRfZGlzcCA9PSAnaGlkZGVuJykge1xuICAgICAgICAgICAgICAgIGF0dHIoaHNoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjdXJyX3kgPSBhbl9hcnJheS5jdXJyZW50eSgpO1xuXG4gICAgICAgICAgICBpZiAoaXNOYU4ocGFyc2VJbnQoY3Vycl95LDEwKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkhhdmUgYSBOYU4geSB2YWx1ZSwgc2tpcHBpbmdcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdGFyZ2V0X3kgPSBwYXJzZUludChoYXNoLnksMTApO1xuXG4gICAgICAgICAgICBkZWxldGUgaGFzaC55O1xuXG4gICAgICAgICAgICBpZiAoY3Vycl9kaXNwID09IHRhcmdldF9kaXNwICYmIHRhcmdldF9kaXNwID09ICd2aXNpYmxlJyApIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgaGFzaC52aXNpYmlsaXR5O1xuICAgICAgICAgICAgICAgIHRhcmdldF9kaXNwID0gbnVsbDsgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGF0dHIoeyd2aXNpYmlsaXR5JyA6ICd2aXNpYmxlJ30pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaGFzaC52aXNpYmlsaXR5ID09ICdoaWRkZW4nKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGhhc2gudmlzaWJpbGl0eTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXR0cihoYXNoKTtcbiAgICAgICAgICAgIHZhciBjb3VudGVyID0gMDtcblxuICAgICAgICAgICAgaWYgKHRhcmdldF95ICE9IGN1cnJfeSkge1xuICAgICAgICAgICAgICAgIHZhciBhbmltX3N0ZXBzID0gMSAqIChNYXRoLmFicyhwYXJzZUludCgoKHRhcmdldF95IC0gY3Vycl95KS8oNTAqUlMpKSwxMCkvcmF0ZSkgKyAxKTtcbiAgICAgICAgICAgICAgICB2YXIgZGlmZiA9ICh0YXJnZXRfeSAtIGN1cnJfeSkgLyBhbmltX3N0ZXBzO1xuICAgICAgICAgICAgICAgIGhhc2gueSA9IGN1cnJfeSB8fCAwO1xuICAgICAgICAgICAgICAgIHZhciBvcmlnX2Z1bmMgPSBhbl9hcnJheS5hbmltYXRlO1xuICAgICAgICAgICAgICAgIGFuX2FycmF5LmFuaW1hdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaGFzaC55ID0gY3Vycl95ICsgZGlmZioxO1xuXG4gICAgICAgICAgICAgICAgbGV0IHN0ZXBfZnVuYyA9IGZ1bmN0aW9uKHN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpZmYgPCAwICYmIChoYXNoLnkgPCB0YXJnZXRfeSkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNoLnkgPSB0YXJnZXRfeTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlmZiA+IDAgJiYgKGhhc2gueSA+IHRhcmdldF95KSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc2gueSA9IHRhcmdldF95O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGF0dHIoaGFzaCk7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXIgKz0gKHN0ZXAgfHwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNoLnkgIT0gdGFyZ2V0X3kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc2gueSA9IGN1cnJfeSArIGRpZmYqKGNvdW50ZXIrMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYW5fYXJyYXkuYW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRfZGlzcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cih7J3Zpc2liaWxpdHknIDogdGFyZ2V0X2Rpc3B9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhbmltX2Nsb2NrX2Z1bmNzLnNwbGljZShhbmltX2Nsb2NrX2Z1bmNzLmluZGV4T2Yoc3RlcF9mdW5jKSwxKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhbmltX2Nsb2NrX2Z1bmNzLnB1c2goc3RlcF9mdW5jKTtcbiAgICAgICAgICAgICAgICBhbmltX2Nsb2NrX2Z1bmNzW2FuaW1fY2xvY2tfZnVuY3MubGVuZ3RoIC0gMV0udGFyZ2V0X3NldCA9IGFuX2FycmF5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgYW5fYXJyYXkuYXR0ciA9IGZ1bmN0aW9uKGhzaCkge1xuICAgICAgICAgICAgaWYgKGluX2FuaW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRlKGhzaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXR0cihoc2gpO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgdmFyIGF0dHIgPSBmdW5jdGlvbihoc2gpIHtcbiAgICAgICAgICAgIHZhciBoYXNoID0ge307XG4gICAgICAgICAgICB2YXIga2V5O1xuICAgICAgICAgICAgZm9yIChrZXkgaW4gaHNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhzaC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc2hba2V5XSA9IGhzaFtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGN1cnJfZGlzcCA9IGFuX2FycmF5LnZpc2liaWxpdHkoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHRhcmdfeSA9IHBhcnNlSW50KGhhc2gueSwxMCk7XG4gICAgICAgICAgICB0YXJnX2Rpc3AgPSBoYXNoLnZpc2liaWxpdHk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZvciAoa2V5IGluIGhhc2gpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzaC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5fYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggISBhbl9hcnJheVtpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYW5fYXJyYXlbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGFuX2FycmF5W2ldLnN0eWxlLmRpc3BsYXkgPT0gJ25vbmUnICl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBoYXNoW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09ICdzdHlsZScgJiYgYW5fYXJyYXlbaV0uaGFzQXR0cmlidXRlKCdzdHlsZScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJfc3R5bGUgPSBhbl9hcnJheVtpXS5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vycl9zdHlsZSArPSAnOyAnK2hhc2hba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGN1cnJfc3R5bGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFzX3RyYW5zbGF0ZSA9IGFuX2FycmF5W2ldLmhhc0F0dHJpYnV0ZSgndHJhbnNmb3JtJykgJiYgKGFuX2FycmF5W2ldLmdldEF0dHJpYnV0ZSgndHJhbnNmb3JtJykuaW5kZXhPZigndHJhbnNsYXRlJykgPj0gMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT0gJ2hlaWdodCcgJiYgYW5fYXJyYXlbaV0uc2V0SGVpZ2h0ICkgeyAvL2hhc0F0dHJpYnV0ZSgndHJhbnNmb3JtJykgJiYgISBhbl9hcnJheVtpXS5ub19zY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuX2FycmF5W2ldLnNldEhlaWdodChoYXNoW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICAoISAoaGFzX3RyYW5zbGF0ZSAmJiAoa2V5ID09ICd5JyB8fCBrZXkgPT0gJ3gnKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbl9hcnJheVtpXS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7ICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09ICd5JyAmJiBhbl9hcnJheVtpXS5oYXNBdHRyaWJ1dGUoJ2QnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyX3BhdGggPSBhbl9hcnJheVtpXS5nZXRBdHRyaWJ1dGUoJ2QnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmUgPSAvTVxccyooW1xcZFxcLl0rKSAoW1xcZFxcLl0rKS87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vycl9wYXRoID0gY3Vycl9wYXRoLnJlcGxhY2UocmUsJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihwYXJzZUludCh2YWx1ZSwxMCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFwiRXJyb3IgXCIra2V5K1wiIGlzIFwiK2hhc2hba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5fYXJyYXlbaV0uc2V0QXR0cmlidXRlKCdkJywgJ00wICcrcGFyc2VJbnQodmFsdWUsMTApKycgJytjdXJyX3BhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PSAneScgJiYgYW5fYXJyYXlbaV0uaGFzQXR0cmlidXRlKCdjeScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5fYXJyYXlbaV0uc2V0QXR0cmlidXRlKCdjeScsIGhhc2hba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT0gJ3knICYmIGFuX2FycmF5W2ldLmhhc0F0dHJpYnV0ZSgndHJhbnNmb3JtJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyX3RyYW5zZm9ybSA9IGFuX2FycmF5W2ldLmdldEF0dHJpYnV0ZSgndHJhbnNmb3JtJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyX3ggPSAvdHJhbnNsYXRlXFwoKC0/XFxkK1xcLj9cXGQqKVxccyosP1xccyooLT9cXGQrXFwuP1xcZCopP1xcKS8uZXhlYyhhbl9hcnJheVtpXS5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3Vycl94ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyX3ggPSBjdXJyX3hbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vycl90cmFuc2Zvcm0gPSBjdXJyX3RyYW5zZm9ybS5yZXBsYWNlKC90cmFuc2xhdGVcXCgoLT9cXGQrXFwuP1xcZCopXFxzKiw/XFxzKigtP1xcZCtcXC4/XFxkKik/XFwpLywndHJhbnNsYXRlKCcrY3Vycl94KycsJyt2YWx1ZSsnKScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuX2FycmF5W2ldLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJyxjdXJyX3RyYW5zZm9ybSk7ICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09ICd4JyAmJiBhbl9hcnJheVtpXS5oYXNBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vycl90cmFuc2Zvcm0gPSBhbl9hcnJheVtpXS5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vycl95ID0gL3RyYW5zbGF0ZVxcKCgtP1xcZCtcXC4/XFxkKilcXHMqLD9cXHMqKC0/XFxkK1xcLj9cXGQqKVxcKS8uZXhlYyhhbl9hcnJheVtpXS5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3Vycl95ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyX3kgPSBjdXJyX3lbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vycl90cmFuc2Zvcm0gPSBjdXJyX3RyYW5zZm9ybS5yZXBsYWNlKC90cmFuc2xhdGVcXCgoLT9cXGQrXFwuP1xcZCopXFxzKiw/XFxzKigtP1xcZCtcXC4/XFxkKilcXCkvLCd0cmFuc2xhdGUoJyt2YWx1ZSsnLCcrY3Vycl95KycpJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5fYXJyYXlbaV0uc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLGN1cnJfdHJhbnNmb3JtKTsgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT0gJ3RleHQtYW5jaG9yJyAmJiBhbl9hcnJheVtpXS5oYXNBdHRyaWJ1dGUoJ3N0eWxlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbl9hcnJheVtpXS5zdHlsZS50ZXh0QW5jaG9yID0gaGFzaFtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgYW5fYXJyYXkuaGlkZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5hdHRyKHsgJ3Zpc2liaWxpdHknIDogJ2hpZGRlbid9KTtcbiAgICAgICAgfTtcbiAgICAgICAgYW5fYXJyYXkuc2hvdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5hdHRyKHsgJ3Zpc2liaWxpdHknIDogJ3Zpc2libGUnfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgYW5fYXJyYXkucmVmcmVzaF96b29tID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuX2FycmF5Lmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFuX2FycmF5W2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYW5fYXJyYXlbaV0uem9vbV9sZXZlbCAmJiBhbl9hcnJheVtpXS56b29tX2xldmVsID09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYW5fYXJyYXlbaV0ub3duZXJTVkdFbGVtZW50ICYmIGFuX2FycmF5W2ldLm93bmVyU1ZHRWxlbWVudC56b29tID4gMy41KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbl9hcnJheVtpXS5zZXRBdHRyaWJ1dGUoJ2Rpc3BsYXknLCAnaW5saW5lJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbl9hcnJheVtpXS5zZXRBdHRyaWJ1dGUoJ29wYWNpdHknLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuX2FycmF5W2ldLnNldEF0dHJpYnV0ZSgnZGlzcGxheScsICdub25lJyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKGFuX2FycmF5W2ldLnpvb21fbGV2ZWwgJiYgYW5fYXJyYXlbaV0uem9vbV9sZXZlbCA9PSAnc3VtbWFyeScpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFuX2FycmF5W2ldLm93bmVyU1ZHRWxlbWVudCAmJiBhbl9hcnJheVtpXS5vd25lclNWR0VsZW1lbnQuem9vbSA8PSAzLjUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuX2FycmF5W2ldLnNldEF0dHJpYnV0ZSgnZGlzcGxheScsICdpbmxpbmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuX2FycmF5W2ldLnNldEF0dHJpYnV0ZSgnb3BhY2l0eScsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5fYXJyYXlbaV0uc2V0QXR0cmlidXRlKCdkaXNwbGF5JywgJ25vbmUnKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gYW5fYXJyYXk7XG4gICAgfVxuXG4gICAgdmFyIGFuaW1fY2xvY2tfZnVuY3MgPSBudWxsLCBpbl9hbmltID0gZmFsc2U7XG4gICAgdmFyIGFuaW1fY2xvY2sgPSBudWxsO1xuICAgIHZhciByYXRlID0gNzU7XG4gICAgdmFyIG5ld19yYXRlID0gbnVsbDtcbiAgICBcbiAgICB2YXIgc2V0dXBfYW5pbV9jbG9ja3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGFuaW1fY2xvY2tfZnVuY3MgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGFuaW1fY2xvY2tfZnVuY3MgPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFuaW1fY2xvY2tfZnVuY3MuZm9yRWFjaChmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgICAgICAgICAgZnVuYy5fbGFzdF9zdGVwID0gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChhbmltX2Nsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoICEgaW5fYW5pbSApIHtcbiAgICAgICAgICAgIGV4dGVuZGVkX2VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oY2Fudikge1xuICAgICAgICAgICAgICAgIGJlYW4uZmlyZShjYW52LCdfYW5pbV9iZWdpbicpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpbl9hbmltID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhcnQgPSBudWxsO1xuICAgICAgICBhbmltX2Nsb2NrID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoICEgYW5pbV9jbG9ja19mdW5jcyB8fCBhbmltX2Nsb2NrX2Z1bmNzLmxlbmd0aCA9PT0gMCApIHtcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGFuaW1fY2xvY2spO1xuICAgICAgICAgICAgICAgIGFuaW1fY2xvY2sgPSBudWxsO1xuICAgICAgICAgICAgICAgIGFuaW1fY2xvY2tfZnVuY3MgPSBudWxsO1xuICAgICAgICAgICAgICAgIGluX2FuaW0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBleHRlbmRlZF9lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGNhbnYpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVhbi5maXJlKGNhbnYsJ19hbmltX2VuZCcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHN1c3BlbmRlZF9pZHMgPSBbXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXh0ZW5kZWRfZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihjYW52KSB7XG4gICAgICAgICAgICAgICAgc3VzcGVuZGVkX2lkcy5wdXNoKGNhbnYuc3VzcGVuZFJlZHJhdyg1MDAwKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciB0aWMgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoISBzdGFydCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAoYW5pbV9jbG9ja19mdW5jcyB8fCBbXSkubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgdmFyIHN0ZXBfaWQgPSBwYXJzZUludCgoZW5kIC0gc3RhcnQpL3JhdGUsMTApO1xuICAgICAgICAgICAgICAgIGlmICggbmV3X3JhdGUgPT09IG51bGwgJiYgKHN0ZXBfaWQgLSBhbmltX2Nsb2NrX2Z1bmNzW2ldLl9sYXN0X3N0ZXApID4gMikge1xuICAgICAgICAgICAgICAgICAgICBuZXdfcmF0ZSA9IE1hdGgucm91bmQoMS42KnJhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhbmltX2Nsb2NrX2Z1bmNzW2ldLmFwcGx5KG51bGwsW3N0ZXBfaWQgLSAoYW5pbV9jbG9ja19mdW5jc1tpXS5fbGFzdF9zdGVwIHx8IHN0ZXBfaWQpXSk7XG4gICAgICAgICAgICAgICAgaWYgKGFuaW1fY2xvY2tfZnVuY3MgJiYgYW5pbV9jbG9ja19mdW5jc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICBhbmltX2Nsb2NrX2Z1bmNzW2ldLl9sYXN0X3N0ZXAgPSBzdGVwX2lkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0b2MgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXG4gICAgICAgICAgICBleHRlbmRlZF9lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGNhbnYpIHtcbiAgICAgICAgICAgICAgICBjYW52LnVuc3VzcGVuZFJlZHJhdyhzdXNwZW5kZWRfaWRzLnNoaWZ0KCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBhY3R1YWxfc3BlZWQgPSAodG9jIC0gdGljKTtcbiAgICAgICAgICAgIGlmICgoIGFjdHVhbF9zcGVlZCA8IHJhdGUpICYmIChuZXdfcmF0ZSA9PT0gbnVsbCkgJiYgYWN0dWFsX3NwZWVkID49IDEgKSB7XG4gICAgICAgICAgICAgICAgcmF0ZSA9IE1hdGgucm91bmQoMS41Kih0b2MgLSB0aWMpKTtcbiAgICAgICAgICAgICAgICBzZXR1cF9hbmltX2Nsb2NrcygpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuZXdfcmF0ZSAhPT0gbnVsbCAmJiBuZXdfcmF0ZSAhPSByYXRlKSB7XG4gICAgICAgICAgICAgICAgcmF0ZSA9IG5ld19yYXRlO1xuICAgICAgICAgICAgICAgIHNldHVwX2FuaW1fY2xvY2tzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICB9LHJhdGUpO1xuICAgIH07XG4gICAgdmFyIHNjYWxlX3JlID0gL3NjYWxlXFwoKC0/XFxkK1xcLj9cXGQqKVxcKS87XG4gICAgdmFyIHNldEhlaWdodCA9IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgICAgICB2YXIgY3Vycl90cmFuc2Zvcm0gPSB0aGlzLmdldEF0dHJpYnV0ZSgndHJhbnNmb3JtJykudG9TdHJpbmcoKTtcblxuICAgICAgICB2YXIgY3Vycl9zY2FsZSA9IHNjYWxlX3JlLmV4ZWMoY3Vycl90cmFuc2Zvcm0pO1xuICAgIFxuICAgICAgICB2YXIgY3Vycl9oZWlnaHQgPSBwYXJzZUZsb2F0KHRoaXMuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSB8fCAxKTtcblxuICAgICAgICB2YXIgbmV3X3NjYWxlID0gMTtcbiAgICAgICAgaWYgKGN1cnJfc2NhbGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGN1cnJfdHJhbnNmb3JtICs9ICcgc2NhbGUoMSkgJztcbiAgICAgICAgICAgIGN1cnJfc2NhbGUgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3Vycl9zY2FsZSA9IHBhcnNlRmxvYXQoY3Vycl9zY2FsZVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3X3NjYWxlID0gKCBwYXJzZUZsb2F0KGhlaWdodCkgLyBjdXJyX2hlaWdodCApICogY3Vycl9zY2FsZTtcblxuICAgICAgICBjdXJyX3RyYW5zZm9ybSA9IGN1cnJfdHJhbnNmb3JtLnJlcGxhY2Uoc2NhbGVfcmUsJ3NjYWxlKCcrbmV3X3NjYWxlKycpJyk7XG5cbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsY3Vycl90cmFuc2Zvcm0pO1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JyxoZWlnaHQpO1xuICAgICAgICByZXR1cm4gbmV3X3NjYWxlO1xuICAgIH07XG5cbiAgICByZXR1cm4gKGZ1bmN0aW9uKGNhbnZhcykge1xuICAgICAgICBcbiAgICAgICAgdmFyIFJTID0gY2FudmFzLlJTIHx8IERFRkFVTFRfUlM7XG4gICAgICAgIGNhbnZhcy5SUyA9IFJTO1xuICAgICAgICBjYW52YXMuZm9udF9vcmRlciA9ICdIZWx2ZXRpY2EsIFZlcmRhbmEsIEFyaWFsLCBTYW5zLXNlcmlmJ1xuICAgICAgICBleHRlbmRlZF9lbGVtZW50cy5wdXNoKGNhbnZhcyk7XG4gICAgICAgIFxuICAgICAgICBjYW52YXMubWFrZUVsID0gZnVuY3Rpb24obmFtZSxhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gY2FudmFzLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2Z25zLG5hbWUpO1xuICAgICAgICAgICAgZm9yICh2YXIgYXR0cmlidXRlIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCBhdHRyaWJ1dGVzW2F0dHJpYnV0ZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgY2FudmFzLm1ha2VfZ3JhZGllbnQgPSBmdW5jdGlvbihpZCx4Mix5MixzdG9wcyxvcGFjaXRpZXMpIHtcbiAgICAgICAgICAgIHZhciBncmFkaWVudCA9IHRoaXMubWFrZUVsKCdsaW5lYXJHcmFkaWVudCcse1xuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICd4MSc6JzAlJyxcbiAgICAgICAgICAgICAgICAneDInOiB4MixcbiAgICAgICAgICAgICAgICAneTEnOicwJScsXG4gICAgICAgICAgICAgICAgJ3kyJzogeTJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHRvdGFsX3N0b3BzID0gc3RvcHMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUoc3RvcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBzdG9wX2lkID0gTWF0aC5yb3VuZCggKCh0b3RhbF9zdG9wcyAtIHN0b3BzLmxlbmd0aCkgLyB0b3RhbF9zdG9wcykgKiAxMDAgKTtcbiAgICAgICAgICAgICAgICB2YXIgc3RvcCA9IHN0b3BzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgdmFyIG9wYWNpdHkgPSBvcGFjaXRpZXMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBncmFkaWVudC5hcHBlbmRDaGlsZCh0aGlzLm1ha2VFbCgnc3RvcCcse1xuICAgICAgICAgICAgICAgICAgICAnb2Zmc2V0Jzogc3RvcF9pZCsnJScsXG4gICAgICAgICAgICAgICAgICAgICdzdHlsZSc6J3N0b3AtY29sb3I6JytzdG9wKyc7c3RvcC1vcGFjaXR5Oicrb3BhY2l0eVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBncmFkaWVudDtcbiAgICAgICAgfTtcblxuXG4gICAgICAgIGNhbnZhcy5wYXRoID0gZnVuY3Rpb24ocGF0aGRlc2MpIHtcbiAgICAgICAgICAgIHZhciBhX3BhdGggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnbnMsJ3BhdGgnKTtcbiAgICAgICAgICAgIGFfcGF0aC5zZXRBdHRyaWJ1dGUoJ2QnLCBwYXRoZGVzYyk7XG4gICAgICAgICAgICBhX3BhdGguc2V0QXR0cmlidXRlKCdzdHJva2UnLCcjMDAwMDAwJyk7XG4gICAgICAgICAgICBhX3BhdGguc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCcxJyk7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGFfcGF0aCk7XG4gICAgICAgICAgICByZXR1cm4gYV9wYXRoO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNhbnZhcy5wb2x5ID0gZnVuY3Rpb24ocG9pbnRzKSB7XG4gICAgICAgICAgICB2YXIgYV9wb2x5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2Z25zLCdwb2x5Z29uJyk7XG4gICAgICAgICAgICBhX3BvbHkuc2V0QXR0cmlidXRlKCdwb2ludHMnLHBvaW50cyk7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGFfcG9seSk7XG4gICAgICAgICAgICByZXR1cm4gYV9wb2x5O1xuICAgICAgICB9O1xuXG4gICAgICAgIGNhbnZhcy5jaXJjbGUgPSBmdW5jdGlvbih4LHkscmFkaXVzKSB7XG4gICAgICAgICAgICB2YXIgYV9jaXJjbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnbnMsJ2NpcmNsZScpO1xuICAgICAgICAgICAgYV9jaXJjbGUuc2V0QXR0cmlidXRlKCdjeCcsIHR5cGVvZiB4ID09ICdzdHJpbmcnID8geCA6IHggKiBSUyk7XG4gICAgICAgICAgICBhX2NpcmNsZS5zZXRBdHRyaWJ1dGUoJ2N5JywgdHlwZW9mIHkgPT0gJ3N0cmluZycgPyB5IDogeSAqIFJTKTtcbiAgICAgICAgICAgIGFfY2lyY2xlLnNldEF0dHJpYnV0ZSgncicsIHR5cGVvZiByYWRpdXMgPT0gJ3N0cmluZycgPyByYWRpdXMgOiByYWRpdXMgKiBSUyk7XG4gICAgICAgICAgICBhX2NpcmNsZS5tb3ZlID0gZnVuY3Rpb24obmV3X3gpIHtcbiAgICAgICAgICAgICAgICBhX2NpcmNsZS5zZXRBdHRyaWJ1dGUoJ2N4JyxuZXdfeCpSUyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChhX2NpcmNsZSk7XG4gICAgICAgICAgICByZXR1cm4gYV9jaXJjbGU7XG4gICAgICAgIH07XG5cbiAgICAgICAgY2FudmFzLmdyb3VwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYV9nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2Z25zLCdnJyk7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGFfZyk7XG4gICAgICAgICAgICBhX2cucHVzaCA9IGZ1bmN0aW9uKG5ld19lbCkge1xuICAgICAgICAgICAgICAgIGFfZy5hcHBlbmRDaGlsZChuZXdfZWwpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIGFfZztcbiAgICAgICAgfTtcblxuICAgICAgICBjYW52YXMuY2xpcFBhdGggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzdmducywnY2xpcFBhdGgnKTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICAgICAgZWwucHVzaCA9IGZ1bmN0aW9uKG5ld19lbCkge1xuICAgICAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKG5ld19lbCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgY2FudmFzLmxpbmUgPSBmdW5jdGlvbih4LHkseDIseTIpIHtcbiAgICAgICAgICAgIHZhciBhX2xpbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnbnMsJ2xpbmUnKTtcbiAgICAgICAgICAgIGFfbGluZS5zZXRBdHRyaWJ1dGUoJ3gxJywgdHlwZW9mIHggPT0gJ3N0cmluZycgPyB4IDogeCAqIFJTKTtcbiAgICAgICAgICAgIGFfbGluZS5zZXRBdHRyaWJ1dGUoJ3kxJywgdHlwZW9mIHkgPT0gJ3N0cmluZycgPyB5IDogeSAqIFJTKTtcbiAgICAgICAgICAgIGFfbGluZS5zZXRBdHRyaWJ1dGUoJ3gyJywgdHlwZW9mIHgyID09ICdzdHJpbmcnID8geDIgOiB4MiAqIFJTKTtcbiAgICAgICAgICAgIGFfbGluZS5zZXRBdHRyaWJ1dGUoJ3kyJywgdHlwZW9mIHkyID09ICdzdHJpbmcnID8geTIgOiB5MiAqIFJTKTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoYV9saW5lKTtcbiAgICAgICAgICAgIHJldHVybiBhX2xpbmU7ICAgICAgICBcbiAgICAgICAgfTtcblxuICAgICAgICBjYW52YXMucmVjdCA9IGZ1bmN0aW9uKHgseSx3aWR0aCxoZWlnaHQsb3B0cykge1xuICAgICAgICAgICAgaWYgKCAhIG9wdHMgKSB7XG4gICAgICAgICAgICAgICAgb3B0cyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFfcmVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzdmducywncmVjdCcpO1xuICAgICAgICAgICAgYV9yZWN0LnNldEF0dHJpYnV0ZSgneCcsIHR5cGVvZiB4ID09ICdzdHJpbmcnID8geCA6IHggKiBSUyk7XG4gICAgICAgICAgICBhX3JlY3Quc2V0QXR0cmlidXRlKCd5JywgdHlwZW9mIHkgPT0gJ3N0cmluZycgPyB5IDogeSAqIFJTKTtcbiAgICAgICAgICAgIGFfcmVjdC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdHlwZW9mIHdpZHRoID09ICdzdHJpbmcnID8gd2lkdGggOiB3aWR0aCAqIFJTKTtcbiAgICAgICAgICAgIGFfcmVjdC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHR5cGVvZiBoZWlnaHQgPT0gJ3N0cmluZycgPyBoZWlnaHQgOiBoZWlnaHQgKiBSUyk7XG4gICAgICAgICAgICBhX3JlY3Quc2V0QXR0cmlidXRlKCdzdHJva2UnLCcjMDAwMDAwJyk7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGFfcmVjdCk7XG4gICAgICAgICAgICBpZiAoIHR5cGVvZihvcHRzLm9mZnNldCkgIT09IFwidW5kZWZpbmVkXCIgKSB7XG4gICAgICAgICAgICAgICAgYV9yZWN0Lm9mZnNldCA9IG9wdHMub2Zmc2V0O1xuICAgICAgICAgICAgICAgIGFfcmVjdC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsJ3RyYW5zbGF0ZSgnK2FfcmVjdC5nZXRBdHRyaWJ1dGUoJ3gnKSsnLCcrYV9yZWN0LmdldEF0dHJpYnV0ZSgneScpKycpJyk7XG4gICAgICAgICAgICAgICAgYV9yZWN0LnNldEF0dHJpYnV0ZSgneCcsJzAnKTtcbiAgICAgICAgICAgICAgICBhX3JlY3Quc2V0QXR0cmlidXRlKCd5JyxhX3JlY3Qub2Zmc2V0KlJTKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYV9yZWN0Lm1vdmUgPSBmdW5jdGlvbihuZXdfeCxuZXdfd2lkdGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHR5cGVvZih0aGlzLm9mZnNldCkgIT09IFwidW5kZWZpbmVkXCIpICYmIHRoaXMuZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtX2F0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgndHJhbnNmb3JtJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0gL3RyYW5zbGF0ZVxcKC4qWyxcXHNdKC4qKVxcKS8uZXhlYyh0cmFuc2Zvcm1fYXR0cik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsJ3RyYW5zbGF0ZSgnKyhuZXdfeCpSUykrJywnK21hdGNoZXNbMV0rJyknKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLG5ld193aWR0aCpSUyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3gnLG5ld194KlJTKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJyxuZXdfd2lkdGgqUlMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gYV9yZWN0O1xuICAgICAgICB9O1xuXG4gICAgICAgIGNhbnZhcy5yb3VuZFJlY3QgPSBmdW5jdGlvbih4LHksd2lkdGgsaGVpZ2h0LHIsb3B0cykge1xuICAgICAgICAgICAgdmFyIGFfcmVjdCA9IHRoaXMucmVjdCh4LHksd2lkdGgsaGVpZ2h0LG9wdHMpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByICE9ICdvYmplY3QnIHx8ICEgci54ICkge1xuICAgICAgICAgICAgICAgIHIgPSB7ICd4JyA6IHIsICd5JyA6IHIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFfcmVjdC5zZXRBdHRyaWJ1dGUoJ3J4JyxyLngqUlMpO1xuICAgICAgICAgICAgYV9yZWN0LnNldEF0dHJpYnV0ZSgncnknLHIueSpSUyk7XG4gICAgICAgICAgICByZXR1cm4gYV9yZWN0O1xuICAgICAgICB9O1xuXG4gICAgICAgIGNhbnZhcy5lbGxpcHRpY2FsUmVjdCA9IGZ1bmN0aW9uKHgseSx3aWR0aCxoZWlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvdW5kUmVjdCh4LHksd2lkdGgsaGVpZ2h0LHsneCcgOiAwLjI1KndpZHRoLCAneScgOiAwLjUqaGVpZ2h0fSk7XG4gICAgICAgIH07XG4gICAgICAgIGNhbnZhcy5wZW50YWdvbiA9IGZ1bmN0aW9uKHgseSx3aWR0aCxoZWlnaHQscm90YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uYWdvbih4LHksd2lkdGgsaGVpZ2h0LDUscm90YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBjYW52YXMuaGV4YWdvbiA9IGZ1bmN0aW9uKHgseSx3aWR0aCxoZWlnaHQscm90YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uYWdvbih4LHksd2lkdGgsaGVpZ2h0LDYscm90YXRlKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgc2hhcGVfc2V0X2F0dHJpYnV0ZSA9IGZ1bmN0aW9uKGF0dHIsdmFsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5zZXRBdHRyaWJ1dGUuY2FsbCh0aGlzLGF0dHIsdmFsKTtcbiAgICAgICAgICAgIGlmIChhdHRyID09ICdoZWlnaHQnIHx8IGF0dHIgPT0gJ3dpZHRoJyB8fCBhdHRyID09ICd4JyB8fCBhdHRyID09ICd5Jykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVkcmF3KE1hdGguZmxvb3IocGFyc2VGbG9hdCh0aGlzLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY2FudmFzLm5hZ29uID0gZnVuY3Rpb24oeCx5LHdpZHRoLGhlaWdodCxuLHJvdGF0ZSkge1xuICAgICAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5wb2x5KFwiXCIpO1xuICAgICAgICAgICAgLy8gc2hhcGUuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCd0cmFuc2xhdGUoJysoeCpSUykrJywnKyhSUyp5KSsnKScpO1xuICAgICAgICAgICAgc2hhcGUuc2V0QXR0cmlidXRlKCd4Jyx4KlJTKTtcbiAgICAgICAgICAgIHNoYXBlLnNldEF0dHJpYnV0ZSgneScseSpSUyk7XG4gICAgICAgICAgICBzaGFwZS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJyx3aWR0aCpSUyk7XG4gICAgICAgICAgICBzaGFwZS5yZWRyYXcgPSBmdW5jdGlvbihoZ2h0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGhnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0X2hlaWdodCA9IGhnaHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGdodCA9IHRoaXMubGFzdF9oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBhID0gMC41Kk1hdGguZmxvb3IocGFyc2VGbG9hdChzaGFwZS5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykpKTtcbiAgICAgICAgICAgICAgICB2YXIgYiA9IDAuNSpoZ2h0O1xuICAgICAgICAgICAgICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgbWluX3ggPSBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBtYXhfeCA9IG51bGw7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmdsZSA9IChyb3RhdGUvMzYwICogMipNYXRoLlBJKSArIDIvbipNYXRoLlBJKmk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhX3ggPSBwYXJzZUludChhK2EqTWF0aC5jb3MoYW5nbGUpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFfeSA9IHBhcnNlSW50KGIrYipNYXRoLnNpbihhbmdsZSkpO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaCggW2FfeCwgYV95XSApO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWluX3ggPT09IG51bGwgfHwgYV94IDwgbWluX3ggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5feCA9IGFfeDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobWF4X3ggPT09IG51bGwgfHwgYV94ID4gbWF4X3gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heF94ID0gYV94O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB4X3BvcyA9IE1hdGguZmxvb3IocGFyc2VGbG9hdChzaGFwZS5nZXRBdHRyaWJ1dGUoJ3gnKSkpO1xuICAgICAgICAgICAgICAgIHZhciB5X3BvcyA9IE1hdGguZmxvb3IocGFyc2VGbG9hdChzaGFwZS5nZXRBdHRyaWJ1dGUoJ3knKSkpO1xuICAgICAgICAgICAgICAgIHBvaW50cy5tYXAoZnVuY3Rpb24ocG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb2ludHNbMF0gPT0gbWluX3gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50c1swXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50c1swXSA9PSBtYXhfeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzWzBdID0gYSoyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBvaW50c1swXSArPSB4X3BvcztcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzWzFdID0geV9wb3MgKyAwLjUqaGdodCoocG9pbnRzWzFdIC8gYik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb2ludHMuam9pbihcIixcIik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3BvaW50cycscG9pbnRzLmpvaW4oXCIgXCIpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzaGFwZS5zZXRIZWlnaHQgPSBzaGFwZS5yZWRyYXc7XG4gICAgICAgICAgICBzaGFwZS5tb3ZlID0gZnVuY3Rpb24obmV3X3gsbmV3X3dpZHRoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJfeSA9IC90cmFuc2xhdGVcXCgoLT9cXGQrXFwuP1xcZCopXFxzKiw/XFxzKigtP1xcZCtcXC4/XFxkKilcXCkvLmV4ZWModGhpcy5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpKTtcbiAgICAgICAgICAgICAgICBpZiAoY3Vycl95ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3Vycl95ID0gY3Vycl95WzJdO1xuICAgICAgICAgICAgICAgIHZhciBjdXJyX3RyYW5zZm9ybSA9IHRoaXMuZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKS5yZXBsYWNlKC90cmFuc2xhdGVcXCgoLT9cXGQrXFwuP1xcZCopXFxzKiw/XFxzKigtP1xcZCtcXC4/XFxkKilcXCkvLCd0cmFuc2xhdGUoJysobmV3X3gqUlMpKycsJytjdXJyX3krJyknKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJyxjdXJyX3RyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgYSA9IDAuNSpuZXdfd2lkdGgqUlM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2hhcGUuc2V0QXR0cmlidXRlID0gc2hhcGVfc2V0X2F0dHJpYnV0ZTtcbiAgICAgICAgICAgIHNoYXBlLnJlZHJhdyhoZWlnaHQqUlMpO1xuICAgICAgICAgICAgcmV0dXJuIHNoYXBlO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNhbnZhcy51c2UgPSBmdW5jdGlvbihyZWYseCx5LHdpZHRoLGhlaWdodCkge1xuICAgICAgICAgICAgdmFyIGFfdXNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2Z25zLCd1c2UnKTtcbiAgICAgICAgICAgIGFfdXNlLnNldEF0dHJpYnV0ZSgneCcsIHR5cGVvZiB4ID09ICdzdHJpbmcnID8geCA6IHggKiBSUyk7XG4gICAgICAgICAgICBhX3VzZS5zZXRBdHRyaWJ1dGUoJ3knLCB0eXBlb2YgeSA9PSAnc3RyaW5nJyA/IHkgOiB5ICogUlMpO1xuICAgICAgICAgICAgYV91c2Uuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHR5cGVvZiB3aWR0aCA9PSAnc3RyaW5nJyA/IHdpZHRoIDogd2lkdGggKiBSUyk7XG4gICAgICAgICAgICBhX3VzZS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHR5cGVvZiBoZWlnaHQgPT0gJ3N0cmluZycgPyBoZWlnaHQgOiBoZWlnaHQgKiBSUyk7XG4gICAgICAgICAgICBhX3VzZS5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsJ2hyZWYnLHJlZik7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGFfdXNlKTtcblxuICAgICAgICAgICAgcmV0dXJuIGFfdXNlOyAgICAgICAgXG4gICAgICAgIH07XG5cbiAgICAgICAgY2FudmFzLmEgPSBmdW5jdGlvbihocmVmKSB7XG4gICAgICAgICAgICB2YXIgYV9hbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnbnMsJ2EnKTtcbiAgICAgICAgICAgIGFfYW5jaG9yLnNldEF0dHJpYnV0ZSgndGFyZ2V0JywnX25ldycpOyAgICAgICAgXG4gICAgICAgICAgICBhX2FuY2hvci5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsJ2hyZWYnLGhyZWYpO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChhX2FuY2hvcik7XG4gICAgICAgICAgICByZXR1cm4gYV9hbmNob3I7XG4gICAgICAgIH07XG5cbiAgICAgICAgY2FudmFzLmJ1dHRvbiA9IGZ1bmN0aW9uKHgseSx3aWR0aCxoZWlnaHQsdGV4dCkge1xuICAgICAgICAgICAgdmFyIGZvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2Z25zLCdmb3JlaWduT2JqZWN0Jyk7XG4gICAgICAgICAgICBmby5zZXRBdHRyaWJ1dGUoJ3gnLHgpO1xuICAgICAgICAgICAgZm8uc2V0QXR0cmlidXRlKCd5Jyx5KTtcbiAgICAgICAgICAgIGZvLnNldEF0dHJpYnV0ZSgnd2lkdGgnLHgrd2lkdGgpO1xuICAgICAgICAgICAgZm8uc2V0QXR0cmlidXRlKCdoZWlnaHQnLHkraGVpZ2h0KTtcbiAgICAgICAgICAgIGlmICggISBmby5zdHlsZSApIHtcbiAgICAgICAgICAgICAgICBmby5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywncG9zaXRpb246IGFic29sdXRlOycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmby5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGZvKTtcbiAgICAgICAgICAgIHZhciBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgICAgIGJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgIGJ1dHRvbi50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgICAgICAgICBmby5hcHBlbmRDaGlsZChidXR0b24pO1xuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbjtcbiAgICAgICAgfTtcblxuICAgICAgICBjYW52YXMuc3ZnYnV0dG9uID0gZnVuY3Rpb24oeCx5LHdpZHRoLGhlaWdodCx0eHQpIHtcbiAgICAgICAgICAgIHZhciBidXR0b24gPSB0aGlzLmdyb3VwKCk7XG4gICAgICAgICAgICB2YXIgYmFjayA9IHRoaXMucmVjdCh4LHksd2lkdGgsaGVpZ2h0KTtcbiAgICAgICAgICAgIGJhY2suc2V0QXR0cmlidXRlKCdyeCcsJzEwJyk7XG4gICAgICAgICAgICBiYWNrLnNldEF0dHJpYnV0ZSgncnknLCcxMCcpO1xuICAgICAgICAgICAgYmFjay5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsJyNmZmZmZmYnKTtcbiAgICAgICAgICAgIGJhY2suc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCcyJyk7XG4gICAgICAgICAgICBiYWNrLnNldEF0dHJpYnV0ZSgnZmlsbCcsJ3VybCgjc2ltcGxlX2dyYWRpZW50KScpO1xuICAgICAgICAgICAgeCA9IGJhY2sueC5iYXNlVmFsLnZhbHVlO1xuICAgICAgICAgICAgeSA9IGJhY2sueS5iYXNlVmFsLnZhbHVlO1xuICAgICAgICAgICAgd2lkdGggPSBiYWNrLndpZHRoLmJhc2VWYWwudmFsdWU7XG4gICAgICAgICAgICBoZWlnaHQgPSBiYWNrLmhlaWdodC5iYXNlVmFsLnZhbHVlO1xuXG4gICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMudGV4dCh4K3dpZHRoLzIseSsoaGVpZ2h0LzMpLHR4dCk7ICAgICAgICBcbiAgICAgICAgICAgIHRleHQuc2V0QXR0cmlidXRlKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKTtcbiAgICAgICAgICAgIHRleHQuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoJ2R5JywgJzEuNWV4Jyk7XG4gICAgICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZSgnZm9udC1zaXplJywwLjUqaGVpZ2h0KTtcbiAgICAgICAgICAgIHRleHQuc2V0QXR0cmlidXRlKCdmaWxsJywnI2ZmZmZmZicpO1xuICAgICAgICAgICAgYnV0dG9uLnB1c2goYmFjayk7XG4gICAgICAgICAgICBidXR0b24ucHVzaCh0ZXh0KTtcbiAgICAgICAgICAgIGJ1dHRvbi5iYWNrZ3JvdW5kX2VsZW1lbnQgPSBiYWNrO1xuICAgICAgICAgICAgYnV0dG9uLnRleHRfZWxlbWVudCA9IHRleHQ7XG5cbiAgICAgICAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2N1cnNvcicsJ3BvaW50ZXInKTtcbiAgICAgICAgICAgIHZhciBidXR0b25fdHJpZ2dlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGJhY2suc2V0QXR0cmlidXRlKCdmaWxsJywnIzk5OTk5OScpO1xuICAgICAgICAgICAgICAgIGJhY2suc2V0QXR0cmlidXRlKCdzdHJva2UnLCcjMDAwMDAwJyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsYnV0dG9uX3RyaWdnZXIsZmFsc2UpO1xuICAgICAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLGJ1dHRvbl90cmlnZ2VyLGZhbHNlKTtcbiAgICAgICAgICAgIHZhciBidXR0b25fcmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBiYWNrLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywnI2ZmZmZmZicpO1xuICAgICAgICAgICAgICAgIGJhY2suc2V0QXR0cmlidXRlKCdmaWxsJywndXJsKCNzaW1wbGVfZ3JhZGllbnQpJyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLGJ1dHRvbl9yZXNldCxmYWxzZSk7XG4gICAgICAgICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLGJ1dHRvbl9yZXNldCxmYWxzZSk7XG4gICAgICAgICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLGJ1dHRvbl9yZXNldCxmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gYnV0dG9uO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNhbnZhcy5jYWxsb3V0ID0gZnVuY3Rpb24oeCx5LGNvbnRlbnQsb3B0cykge1xuICAgICAgICAgICAgdmFyIGNhbGxvdXQgPSB0aGlzLmdyb3VwKCk7XG4gICAgICAgICAgICB2YXIgYmFjayA9IHRoaXMucm91bmRSZWN0KC0wLjUqKG9wdHMud2lkdGgrNCksMjAsb3B0cy53aWR0aCs0LG9wdHMuaGVpZ2h0KzQsNCk7XG4gICAgICAgICAgICBiYWNrLnNldEF0dHJpYnV0ZSgnZmlsbCcsJyMwMDAwMDAnKTtcbiAgICAgICAgICAgIHZhciBwcmVzX2JveCA9IHRoaXMucm91bmRSZWN0KC0wLjUqKG9wdHMud2lkdGgrMSksMjIsb3B0cy53aWR0aCsxLG9wdHMuaGVpZ2h0LDQpO1xuICAgICAgICAgICAgcHJlc19ib3guc2V0QXR0cmlidXRlKCdmaWxsJywnI2VlZWVlZScpO1xuICAgICAgICAgICAgY2FsbG91dC5wdXNoKGJhY2spO1xuICAgICAgICAgICAgY2FsbG91dC5wdXNoKHByZXNfYm94KTtcbiAgICAgICAgICAgIHZhciBwb2x5ID0gdGhpcy5wb2x5KCcwLDUwMCA1MDAsMTAwMCAtNTAwLDEwMDAnKTtcbiAgICAgICAgICAgIHBvbHkuc2V0QXR0cmlidXRlKCdmaWxsJywnIzAwMDAwMCcpO1xuICAgICAgICAgICAgY2FsbG91dC5wdXNoKHBvbHkpO1xuICAgICAgICAgICAgdmFyIGZvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2Z25zLCdmb3JlaWduT2JqZWN0Jyk7XG4gICAgICAgICAgICBmby5zZXRBdHRyaWJ1dGUoJ3gnLC0wLjUqKG9wdHMud2lkdGgrMSkqUlMpO1xuICAgICAgICAgICAgZm8uc2V0QXR0cmlidXRlKCd5JywyMipSUyk7XG4gICAgICAgICAgICBmby5zZXRBdHRyaWJ1dGUoJ3dpZHRoJyxvcHRzLndpZHRoKlJTKTtcbiAgICAgICAgICAgIGZvLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JyxvcHRzLmhlaWdodCpSUyk7XG4gICAgICAgICAgICBjYWxsb3V0LnB1c2goZm8pO1xuICAgICAgICAgICAgdmFyIGh0bWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnLCdodG1sJyk7XG4gICAgICAgICAgICBodG1sLnNldEF0dHJpYnV0ZSgneG1sbnMnLCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJyk7XG4gICAgICAgICAgICB2YXIgYm9keSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsJ2JvZHknKTtcbiAgICAgICAgICAgIGJvZHkuc3R5bGUuZm9udFNpemUgPSAoKG9wdHNbJ2ZvbnQtc2l6ZSddIHx8IDE1KSpSUykgKydweCc7XG4gICAgICAgICAgICBib2R5LnN0eWxlLm1hcmdpbiA9ICg1KlJTKSsncHgnO1xuICAgICAgICAgICAgYm9keS5zdHlsZS5oZWlnaHQgPSBvcHRzLmhlaWdodCpSUyoxMCsncHgnO1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChib2R5KTtcbiAgICAgICAgICAgIGJvZHkuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgICAgICAgICBmby5hcHBlbmRDaGlsZChodG1sKTtcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IG9wdHMuaGVpZ2h0LzE1O1xuICAgICAgICAgICAgY2FsbG91dC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsJ3RyYW5zbGF0ZSgnKyh4KlJTKSsnLCcrKCh5KzIwKSpSUykrJykgc2NhbGUoJytzY2FsZSsnKScpO1xuICAgICAgICAgICAgY2FsbG91dC5zZXRIZWlnaHQgPSBzZXRIZWlnaHQ7XG4gICAgICAgICAgICBpZiAoICEgb3B0cy5hbGlnbiApIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VyclZib3ggPSBwYXJzZUZsb2F0KHRoaXMuZ2V0QXR0cmlidXRlKCd2aWV3Qm94Jykuc3BsaXQoL1xccysvKVsyXSk7XG4gICAgICAgICAgICAgICAgaWYgKCgoeCArIDEwKSArIDAuNSpvcHRzLndpZHRoKSpSUyA+IGN1cnJWYm94ICkge1xuICAgICAgICAgICAgICAgICAgICBvcHRzLmFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCh4IC0gMC41Km9wdHMud2lkdGgpKlJTIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRzLmFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRzLmFsaWduKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNoaWZ0ZXIgPSBvcHRzLmFsaWduID09IFwicmlnaHRcIiA/IC0wLjUgOiAwLjU7XG4gICAgICAgICAgICAgICAgYmFjay5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJysoc2hpZnRlcipvcHRzLndpZHRoKlJTKSsnLDApJyk7XG4gICAgICAgICAgICAgICAgcHJlc19ib3guc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcrKHNoaWZ0ZXIqb3B0cy53aWR0aCpSUykrJywwKScpO1xuICAgICAgICAgICAgICAgIHBvbHkuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcrKDAqc2hpZnRlcipvcHRzLndpZHRoKlJTKSsnLDApJyk7XG4gICAgICAgICAgICAgICAgcG9seS5zZXRBdHRyaWJ1dGUoJ3BvaW50cycsIHNoaWZ0ZXIgPiAwID8gXCIwLDUwMCA1MDAsMTAwMCAwLDEwMDBcIiA6IFwiMCw1MDAgMCwxMDAwIC01MDAsMTAwMFwiKTtcbiAgICAgICAgICAgICAgICBmby5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJysoc2hpZnRlcipvcHRzLndpZHRoKlJTKSsnLDApJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsb3V0LnNldEF0dHJpYnV0ZSgnaGVpZ2h0Jywob3B0cy5oZWlnaHQpKlJTKTtcbiAgICAgICAgICAgIHJldHVybiBjYWxsb3V0O1xuICAgICAgICB9O1xuXG4gICAgICAgIGNhbnZhcy5ncm93aW5nTWFya2VyID0gZnVuY3Rpb24oeCx5LHN5bWJvbCxvcHRzKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2Z25zLCdzdmcnKTtcbiAgICAgICAgICAgIGlmICggISBvcHRzLnN0cmV0Y2ggJiYgISAoQXJyYXkuaXNBcnJheSAmJiBBcnJheS5pc0FycmF5KG9wdHMuY29udGVudCkpICkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCAnLTUwIC0xMDAgMjAwIDI1MCcpO1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLCAneE1pbllNaW4gbWVldCcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSB0aGlzLmdyb3VwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKCd4Jyx4KTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3knLHkpO1xuICAgICAgICAgICAgdmFyIHRoZV9tYXJrZXIgPSB0aGlzLm1hcmtlcig1MC9SUywoNTApL1JTLDUwL1JTLHN5bWJvbCxvcHRzKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGVfbWFya2VyKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5jb250ZW50RWxlbWVudCA9IHRoZV9tYXJrZXIuY29udGVudEVsZW1lbnQ7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5ncm91cCgpO1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uaW5nX2dyb3VwID0gdGhpcy5ncm91cCgpO1xuICAgICAgICAgICAgcmVzdWx0LmFwcGVuZENoaWxkKHBvc2l0aW9uaW5nX2dyb3VwKTtcbiAgICAgICAgICAgIHBvc2l0aW9uaW5nX2dyb3VwLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgICAgICBpZiAoICEgb3B0cy5zdHJldGNoICYmICEgKEFycmF5LmlzQXJyYXkgJiYgQXJyYXkuaXNBcnJheShvcHRzLmNvbnRlbnQpKSApIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKCd3aWR0aCcsJzIwMCcpO1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsJzI1MCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdHMuYW5nbGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuYW5nbGUgPSBvcHRzLmFuZ2xlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdmFyIHJlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnbnMsJ3JlY3QnKTtcbiAgICAgICAgICAgIC8vIHJlY3Quc2V0QXR0cmlidXRlKCdzdHJva2UnLCcjZjAwJyk7XG4gICAgICAgICAgICAvLyByZWN0LnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywnMTAnKTtcbiAgICAgICAgICAgIC8vIHJlY3Quc2V0QXR0cmlidXRlKCd4JywnLTUwJyk7XG4gICAgICAgICAgICAvLyByZWN0LnNldEF0dHJpYnV0ZSgneScsJy0xMDAnKTtcbiAgICAgICAgICAgIC8vIHJlY3Quc2V0QXR0cmlidXRlKCd3aWR0aCcsJzEwMCUnKTtcbiAgICAgICAgICAgIC8vIHJlY3Quc2V0QXR0cmlidXRlKCdoZWlnaHQnLCcxMDAlJyk7XG4gICAgICAgICAgICAvLyByZWN0LnNldEF0dHJpYnV0ZSgnZmlsbCcsJ25vbmUnKTtcbiAgICAgICAgICAgIC8vIGNvbnRhaW5lci5hcHBlbmRDaGlsZChyZWN0KTtcblxuICAgICAgICAgICAgLy8gdmFyIHJlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnbnMsJ3JlY3QnKTtcbiAgICAgICAgICAgIC8vIHJlY3Quc2V0QXR0cmlidXRlKCdzdHJva2UnLCcjMGYwJyk7XG4gICAgICAgICAgICAvLyByZWN0LnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywnMTAnKTtcbiAgICAgICAgICAgIC8vIHJlY3Quc2V0QXR0cmlidXRlKCd4JywnNTAnKTtcbiAgICAgICAgICAgIC8vIHJlY3Quc2V0QXR0cmlidXRlKCd5JywnMjUnKTtcbiAgICAgICAgICAgIC8vIHJlY3Quc2V0QXR0cmlidXRlKCd3aWR0aCcsJzUwJScpO1xuICAgICAgICAgICAgLy8gcmVjdC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsJzUwJScpO1xuICAgICAgICAgICAgLy8gcmVjdC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCdub25lJyk7XG5cbiAgICAgICAgICAgIC8vIGNvbnRhaW5lci5hcHBlbmRDaGlsZChyZWN0KTtcblxuICAgICAgICAgICAgcmVzdWx0LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywnMjUwJyk7XG4gICAgICAgICAgICByZXN1bHQuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCdzY2FsZSgxKScpO1xuICAgICAgICAgICAgcmVzdWx0LnNldEhlaWdodCA9IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLGhlaWdodCk7XG4gICAgICAgICAgICAgICAgdmFyIHNjYWxlX3ZhbCA9IHNldEhlaWdodC5jYWxsKHRoaXMsaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JyxoZWlnaHQpO1xuICAgICAgICAgICAgICAgIHZhciB0b3Bfb2Zmc2V0ID0gdGhpcy5vZmZzZXQgfHwgMDtcbiAgICAgICAgICAgICAgICBpZiAoICEgdGhpcy5hbmdsZSApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmdsZSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsJ3RyYW5zbGF0ZSgtMTAwLCcrKHRvcF9vZmZzZXQqUlMpKycpIHJvdGF0ZSgnK3RoaXMuYW5nbGUrJywxMDAsMCknKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXN1bHQuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcblxuICAgICAgICBjYW52YXMubWFya2VyID0gZnVuY3Rpb24oY3gsY3kscixzeW1ib2wsb3B0cykge1xuICAgICAgICAgICAgdmFyIHVuaXRzID0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3ggPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBuZXcgUmVnRXhwKC8oXFxkKykoLiopL2cpLmV4ZWMoY3gpO1xuICAgICAgICAgICAgICAgIHVuaXRzID0gcGFydHNbMl07XG4gICAgICAgICAgICAgICAgY3ggPSBwYXJzZUZsb2F0KHBhcnRzWzFdKTtcblxuICAgICAgICAgICAgICAgIHBhcnRzID0gbmV3IFJlZ0V4cCgvKFxcZCspKC4qKS9nKS5leGVjKGN5KTtcbiAgICAgICAgICAgICAgICBjeSA9IHBhcnNlRmxvYXQocGFydHNbMV0pO1xuXG4gICAgICAgICAgICAgICAgcGFydHMgPSBuZXcgUmVnRXhwKC8oXFxkKykoLiopL2cpLmV4ZWMocik7XG4gICAgICAgICAgICAgICAgciA9IHBhcnNlRmxvYXQocGFydHNbMV0pOyAgICAgICAgXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRpbSA9IHtcbiAgICAgICAgICAgICAgICBDWCAgICAgIDogY3grdW5pdHMsXG4gICAgICAgICAgICAgICAgQ1kgICAgICA6IGN5K3VuaXRzLFxuICAgICAgICAgICAgICAgIFIgICAgICAgOiByK3VuaXRzLFxuICAgICAgICAgICAgICAgIE1JTl9YICAgOiAoY3gtcikrdW5pdHMsXG4gICAgICAgICAgICAgICAgTUFYX1ggICA6IChjeCtyKSt1bml0cyxcbiAgICAgICAgICAgICAgICBNSU5fWSAgIDogKGN5LXIpK3VuaXRzLFxuICAgICAgICAgICAgICAgIE1BWF9ZICAgOiAoY3krcikrdW5pdHMsXG4gICAgICAgICAgICAgICAgTUlEX1gxICA6IChjeC0oci8yKSkrdW5pdHMsXG4gICAgICAgICAgICAgICAgTUlEX1gyICA6IChjeCsoci8yKSkrdW5pdHMsXG4gICAgICAgICAgICAgICAgTUlEX1kxICA6IChjeS0oci8yKSkrdW5pdHMsXG4gICAgICAgICAgICAgICAgTUlEX1kyICA6IChjeSsoci8yKSkrdW5pdHNcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBtYXJrZXIgPSB0aGlzLmdyb3VwKCk7XG4gICAgICAgICAgICBpZiAoISBvcHRzICkge1xuICAgICAgICAgICAgICAgIG9wdHMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmaWxsX2NvbG9yID0gKG9wdHMgJiYgb3B0cy5ib3JkZXIpID8gb3B0cy5ib3JkZXIgOiAncmdiKDAsMCwwKSc7XG4gICAgICAgICAgICBpZiAoICEgb3B0cy5iYXJlX2VsZW1lbnQgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBvcHRzLndpZHRoICkge1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXIucHVzaCh0aGlzLnJvdW5kUmVjdCgtMC41Km9wdHMud2lkdGgtMSwtMC41LG9wdHMud2lkdGgrMiwzLDEuNSkpO1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXIubGFzdENoaWxkLnNldEF0dHJpYnV0ZSgnZmlsbCcsZmlsbF9jb2xvcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyLnB1c2godGhpcy5jaXJjbGUoMCwtMC41KnIscikpO1xuXG4gICAgICAgICAgICAgICAgICAgIG1hcmtlci5sYXN0Q2hpbGQuc2V0QXR0cmlidXRlKCdmaWxsJyxmaWxsX2NvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyLmxhc3RDaGlsZC5zZXRBdHRyaWJ1dGUoJ2JvcmRlcicsJ3RydWUnKTtcblxuICAgICAgICAgICAgICAgICAgICBtYXJrZXIucHVzaCh0aGlzLmNpcmNsZSgwLDEuNSpyLHIpKTtcblxuICAgICAgICAgICAgICAgICAgICBtYXJrZXIubGFzdENoaWxkLnNldEF0dHJpYnV0ZSgnZmlsbCcsZmlsbF9jb2xvcik7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtlci5sYXN0Q2hpbGQuc2V0QXR0cmlidXRlKCdib3JkZXInLCd0cnVlJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnJvdyA9IHRoaXMucG9seSgoLTAuOSpyKlJTKSsnLCcrKDAqcipSUykrJyAwLCcrKC0yLjUqcipSUykrJyAnKygwLjkpKnIqUlMrJywnKygwKnIqUlMpKTtcblxuICAgICAgICAgICAgICAgICAgICBhcnJvdy5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLGZpbGxfY29sb3IpO1xuICAgICAgICAgICAgICAgICAgICBhcnJvdy5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsJzAnKTtcblxuICAgICAgICAgICAgICAgICAgICBtYXJrZXIucHVzaChhcnJvdyk7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtlci5sYXN0Q2hpbGQuc2V0QXR0cmlidXRlKCdib3JkZXInLCd0cnVlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFya2VyLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywndHJhbnNsYXRlKCcrKChjeCkqUlMpKycsJyswLjUqY3kqUlMrJykgc2NhbGUoMSknKTtcbiAgICAgICAgICAgIG1hcmtlci5zZXRIZWlnaHQgPSBzZXRIZWlnaHQ7XG4gICAgICAgICAgICBtYXJrZXIuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBkaW0uUipSUyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN5bWJvbCA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlmIChzeW1ib2wubWF0Y2goL14oOj9odHRwcz86KT9cXC8/LiojLykpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyLmNvbnRlbnRFbGVtZW50ID0gdGhpcy51c2Uoc3ltYm9sLC1yLDAsMipyLDIqcik7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtlci5jb250ZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnLCd0cnVlJyk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXIuY29udGVudEVsZW1lbnQgPSB0aGlzLnRleHRfY2lyY2xlKDAsMCwyKnIsc3ltYm9sLG9wdHMpO1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXIuY29udGVudEVsZW1lbnQuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnLCd0cnVlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hcmtlci5wdXNoKG1hcmtlci5jb250ZW50RWxlbWVudCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkgJiYgQXJyYXkuaXNBcnJheShzeW1ib2wpKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyLmNvbnRlbnRFbGVtZW50ID0gdGhpcy5ncm91cCgpO1xuICAgICAgICAgICAgICAgIHZhciBwaGFzZSA9ICggTWF0aC5QSSAvIHN5bWJvbC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIC8vIHBoYXNlIC09IChNYXRoLlBJIC8gMik7XG4gICAgICAgICAgICAgICAgdmFyIG5lZWRzX3N0cmV0Y2ggPSBvcHRzLnN0cmV0Y2g7XG4gICAgICAgICAgICAgICAgdmFyIG5yb3cgPSAyO1xuICAgICAgICAgICAgICAgIHN5bWJvbC5mb3JFYWNoKGZ1bmN0aW9uKHN5bWIsaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeF9wb3MgPSBpICUgbnJvdztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHlfcG9zID0gMitNYXRoLmZsb29yKGkgLyBucm93KTtcbiAgICAgICAgICAgICAgICAgICAgeF9wb3MgKj0gMipyO1xuICAgICAgICAgICAgICAgICAgICB5X3BvcyAqPSAyKnI7XG4gICAgICAgICAgICAgICAgICAgIHhfcG9zIC09IDAuNSpyO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm90YXRlX2Ftb3VudCA9IDE4MCppL3N5bWJvbC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHJvdGF0ZV9hbW91bnQgLT0gMCo5MDtcbiAgICAgICAgICAgICAgICAgICAgcm90YXRlX2Ftb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZWVkc19zdHJldGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocm90YXRlX2Ftb3VudCA+PSAtOTAgJiYgcm90YXRlX2Ftb3VudCA8PSA5MCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRzLnN0cmV0Y2ggPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRzLnN0cmV0Y2ggPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHJvdGF0ZV9hbW91bnQgJSA5MCkgPT0gMCAmJiByb3RhdGVfYW1vdW50ICE9IDkwICYmIHJvdGF0ZV9hbW91bnQgIT0gLTkwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvdGF0ZV9hbW91bnQgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRzLnN0cmV0Y2ggPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3ltYm9sLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMuc3RyZXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAocm90YXRlX2Ftb3VudCA+IDkwICYmIHJvdGF0ZV9hbW91bnQgPCAyNzApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdGF0ZV9hbW91bnQgPSAxODAgKyByb3RhdGVfYW1vdW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdfZWwgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3ltYi5tYXRjaCgvXig6P2h0dHBzPzopP1xcLz8uKiMvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3X2VsID0gY2FudmFzLnVzZShzeW1iLCh4X3BvcyAtIDAuNSkqciwoeV9wb3MgLSAwLjUpKnIsMipyLDIqcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdfZWwuc2V0QXR0cmlidXRlKCdwb2ludGVyLWV2ZW50cycsJ25vbmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld19lbC5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnLCd0cnVlJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3B0c19jb3B5ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvcHRzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRzX2NvcHkubm9fdHJhY2VyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRzX2NvcHkub2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdHNfY29weS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdfZWwgPSBjYW52YXMudGV4dF9jaXJjbGUoeF9wb3Mqcix5X3BvcypyLDEuNzUqcixzeW1iLG9wdHNfY29weSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdfZWwuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnLCd0cnVlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJfdHJhbnNmb3JtID0gbmV3X2VsLmdldEF0dHJpYnV0ZSgndHJhbnNmb3JtJykgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJfdHJhbnNmb3JtID0gY3Vycl90cmFuc2Zvcm0gKyAnIHJvdGF0ZSgnKyhyb3RhdGVfYW1vdW50KSsnLCcrMCpyKlJTKycsJyt5X3BvcypyKlJTKycpJztcbiAgICAgICAgICAgICAgICAgICAgbmV3X2VsLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJyxjdXJyX3RyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtlci5jb250ZW50RWxlbWVudC5wdXNoKG5ld19lbCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbWFya2VyLnB1c2gobWFya2VyLmNvbnRlbnRFbGVtZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFya2VyLmNvbnRlbnRFbGVtZW50ID0gdGhpcy5ncm91cCgpO1xuICAgICAgICAgICAgICAgIGlmICghIG9wdHMuYmFyZV9lbGVtZW50ICkge1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXIuY29udGVudEVsZW1lbnQucHVzaCh0aGlzLnRleHRfY2lyY2xlKDAsMC41KnIsMS43NSpyLFwiXCIsb3B0cykpO1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXIuY29udGVudEVsZW1lbnQubGFzdENoaWxkLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCdjb250ZW50JywndHJ1ZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggISBvcHRzLmJhcmVfZWxlbWVudCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsJ3RyYW5zbGF0ZSgwLCcrKDAuNSpyKlJTKSsnKScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbC5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnLCd0cnVlJyk7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtlci5jb250ZW50RWxlbWVudC5wdXNoKHN5bWJvbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hcmtlci5wdXNoKG1hcmtlci5jb250ZW50RWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXJrZXIuc2V0QXR0cmlidXRlKCdtYXJrZXInLCd0cnVlJyk7XG4gICAgICAgICAgICByZXR1cm4gbWFya2VyO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNhbnZhcy50ZXh0X2NpcmNsZSA9IGZ1bmN0aW9uKGN4LGN5LHIsdHh0LG9wdHMpIHtcblxuICAgICAgICAgICAgaWYgKCAhIG9wdHMgKSB7XG4gICAgICAgICAgICAgICAgb3B0cyA9IHt9O1xuICAgICAgICAgICAgfSAgICAgICAgXG5cbiAgICAgICAgICAgIHZhciB1bml0cyA9IDA7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3ggPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBuZXcgUmVnRXhwKC8oXFxkKykoLiopL2cpLmV4ZWMoY3gpO1xuICAgICAgICAgICAgICAgIHVuaXRzID0gcGFydHNbMl07XG4gICAgICAgICAgICAgICAgY3ggPSBwYXJzZUZsb2F0KHBhcnRzWzFdKTtcblxuICAgICAgICAgICAgICAgIHBhcnRzID0gbmV3IFJlZ0V4cCgvKFxcZCspKC4qKS9nKS5leGVjKGN5KTtcbiAgICAgICAgICAgICAgICBjeSA9IHBhcnNlRmxvYXQocGFydHNbMV0pO1xuXG4gICAgICAgICAgICAgICAgcGFydHMgPSBuZXcgUmVnRXhwKC8oXFxkKykoLiopL2cpLmV4ZWMocik7XG4gICAgICAgICAgICAgICAgciA9IHBhcnNlRmxvYXQocGFydHNbMV0pOyAgICAgICAgXG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkaW0gPSB7XG4gICAgICAgICAgICAgICAgQ1ggICAgICA6IGN4K3VuaXRzLFxuICAgICAgICAgICAgICAgIENZICAgICAgOiBjeSt1bml0cyxcbiAgICAgICAgICAgICAgICBSICAgICAgIDogcit1bml0cyxcbiAgICAgICAgICAgICAgICBNSU5fWCAgIDogKGN4LXIpK3VuaXRzLFxuICAgICAgICAgICAgICAgIE1BWF9YICAgOiAoY3grcikrdW5pdHMsXG4gICAgICAgICAgICAgICAgTUlOX1kgICA6IChjeS1yKSt1bml0cyxcbiAgICAgICAgICAgICAgICBNQVhfWSAgIDogKGN5K3IpK3VuaXRzLFxuICAgICAgICAgICAgICAgIE1JRF9YMSAgOiAoY3gtKHIvMikpK3VuaXRzLFxuICAgICAgICAgICAgICAgIE1JRF9YMiAgOiAoY3grKHIvMikpK3VuaXRzLFxuICAgICAgICAgICAgICAgIE1JRF9ZMSAgOiAoY3ktKHIvMikpK3VuaXRzLFxuICAgICAgICAgICAgICAgIE1JRF9ZMiAgOiAoY3krKHIvMikpK3VuaXRzXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgbWFya2VyX2dyb3VwID0gdGhpcy5ncm91cCgpO1xuXG5cbiAgICAgICAgICAgIHZhciB0ZXh0ID0gdGhpcy50ZXh0KDAsZGltLkNZLHR4dCk7XG4gICAgICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZSgnZm9udC1zaXplJywxMCpSUyk7XG4gICAgICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZSgnZm9udC13ZWlnaHQnLG9wdHMud2VpZ2h0IHx8ICdib2xkZXInKTtcbiAgICAgICAgICAgIHRleHQuc2V0QXR0cmlidXRlKCdmaWxsJyxvcHRzLnRleHRfZmlsbCB8fCAnI2ZmZmZmZicpO1xuICAgICAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywnZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7IHRleHQtYW5jaG9yOiBtaWRkbGU7Jyk7XG4gICAgICAgICAgICB0ZXh0LmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCdkeScsJzAuMzVlbScpO1xuICAgICAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGUoJ3RleHQtYW5jaG9yJywnbWlkZGxlJyk7XG4gICAgICAgICAgICB2YXIgYmFjaztcblxuICAgICAgICAgICAgaWYgKCAhIG9wdHMuc3RyZXRjaCApIHtcbiAgICAgICAgICAgICAgICBiYWNrID0gdGhpcy5jaXJjbGUoMCxkaW0uQ1ksOS8xMCpkaW0uUik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0X3dpZHRoID0gMS4yICogKG9wdHMuZm9udF9zaXplIHx8IHIpICogdGV4dC5nZXRCQm94KCkud2lkdGggLyAoMTAgKiBSUyk7XG4gICAgICAgICAgICAgICAgdmFyIHRleHRfaGVpZ2h0ID0gMy8yICogZGltLlI7XG4gICAgICAgICAgICAgICAgdmFyIGxlZnRfcG9zID0gLTAuNSp0ZXh0X3dpZHRoO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0X3dpZHRoID4gKDMqZGltLlIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRfcG9zID0gLTAuNSp0ZXh0X3dpZHRoO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRzLnN0cmV0Y2ggPT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdF9wb3MgPSAtMC4xKnRleHRfd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMuc3RyZXRjaCA9PSAnbGVmdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRfcG9zID0gLTAuOSp0ZXh0X3dpZHRoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dF93aWR0aCA9IDMgKiBkaW0uUjtcbiAgICAgICAgICAgICAgICAgICAgbGVmdF9wb3MgPSAtMC41KnRleHRfd2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRleHQuc2V0QXR0cmlidXRlKCd4JywoMC41KnRleHRfd2lkdGggKyBsZWZ0X3BvcykqUlMpO1xuICAgICAgICAgICAgICAgIGJhY2sgPSB0aGlzLnJvdW5kUmVjdChsZWZ0X3BvcyxkaW0uQ1ktMC41KnRleHRfaGVpZ2h0LHRleHRfd2lkdGgsdGV4dF9oZWlnaHQseyd4JyA6IDAuNSpkaW0uUiwgJ3knIDogMC41KnRleHRfaGVpZ2h0IH0se30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGUoJ2ZvbnQtc2l6ZScsKG9wdHMuZm9udF9zaXplIHx8IHIpKlJTKTtcblxuICAgICAgICAgICAgYmFjay5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLG9wdHMuZmlsbCB8fCAndXJsKCNzaW1wbGVfZ3JhZGllbnQpJyk7XG4gICAgICAgICAgICB3aW5kb3cubWF0Y2hNZWRpYSgncHJpbnQnKS5hZGRMaXN0ZW5lcihmdW5jdGlvbihtYXRjaCkge1xuICAgICAgICAgICAgICAgIGJhY2suc2V0QXR0cmlidXRlKCdmaWxsJyxtYXRjaC5tYXRjaGVzID8gJyNhYWFhYWEnOiAob3B0cy5maWxsIHx8ICd1cmwoI3NpbXBsZV9ncmFkaWVudCknKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJhY2suc2V0QXR0cmlidXRlKCdzdHJva2UnLCBvcHRzLmJvcmRlciB8fCAnIzAwMDAwMCcpO1xuICAgICAgICAgICAgYmFjay5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIChyLzEwKSpSUyk7XG5cbiAgICAgICAgICAgIG1hcmtlcl9ncm91cC5wdXNoKGJhY2spO1xuXG4gICAgICAgICAgICBtYXJrZXJfZ3JvdXAucHVzaCh0ZXh0KTtcblxuICAgICAgICAgICAgbWFya2VyX2dyb3VwLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywndHJhbnNsYXRlKCcrZGltLkNYKlJTKycsIDEpIHNjYWxlKDEpJyk7XG4gICAgICAgICAgICBtYXJrZXJfZ3JvdXAuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAoZGltLlIvMikqUlMgKTtcbiAgICAgICAgICAgIG1hcmtlcl9ncm91cC5zZXRIZWlnaHQgPSBzZXRIZWlnaHQ7XG4gICAgICAgICAgICByZXR1cm4gbWFya2VyX2dyb3VwO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNhbnZhcy5jcm9zc2VkX2NpcmNsZSA9IGZ1bmN0aW9uKGN4LGN5LHIpIHtcblxuICAgICAgICAgICAgdmFyIHVuaXRzID0gMDtcblxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGN4ID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gbmV3IFJlZ0V4cCgvKFxcZCspKC4qKS9nKS5leGVjKGN4KTtcbiAgICAgICAgICAgICAgICB1bml0cyA9IHBhcnRzWzJdO1xuICAgICAgICAgICAgICAgIGN4ID0gcGFyc2VGbG9hdChwYXJ0c1sxXSk7XG5cbiAgICAgICAgICAgICAgICBwYXJ0cyA9IG5ldyBSZWdFeHAoLyhcXGQrKSguKikvZykuZXhlYyhjeSk7XG4gICAgICAgICAgICAgICAgY3kgPSBwYXJzZUZsb2F0KHBhcnRzWzFdKTtcblxuICAgICAgICAgICAgICAgIHBhcnRzID0gbmV3IFJlZ0V4cCgvKFxcZCspKC4qKS9nKS5leGVjKHIpO1xuICAgICAgICAgICAgICAgIHIgPSBwYXJzZUZsb2F0KHBhcnRzWzFdKTsgICAgICAgIFxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGltID0ge1xuICAgICAgICAgICAgICAgIENYICAgICAgOiBjeCt1bml0cyxcbiAgICAgICAgICAgICAgICBDWSAgICAgIDogY3krdW5pdHMsXG4gICAgICAgICAgICAgICAgUiAgICAgICA6IHIrdW5pdHMsXG4gICAgICAgICAgICAgICAgTUlOX1ggICA6IChjeC1yKSt1bml0cyxcbiAgICAgICAgICAgICAgICBNQVhfWCAgIDogKGN4K3IpK3VuaXRzLFxuICAgICAgICAgICAgICAgIE1JTl9ZICAgOiAoY3ktcikrdW5pdHMsXG4gICAgICAgICAgICAgICAgTUFYX1kgICA6IChjeStyKSt1bml0cyxcbiAgICAgICAgICAgICAgICBNSURfWDEgIDogKGN4LShyLzIpKSt1bml0cyxcbiAgICAgICAgICAgICAgICBNSURfWDIgIDogKGN4KyhyLzIpKSt1bml0cyxcbiAgICAgICAgICAgICAgICBNSURfWTEgIDogKGN5LShyLzIpKSt1bml0cyxcbiAgICAgICAgICAgICAgICBNSURfWTIgIDogKGN5KyhyLzIpKSt1bml0c1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGNsb3NlX2dyb3VwID0gdGhpcy5ncm91cCgpO1xuXG4gICAgICAgICAgICB2YXIgY2xvc2VfYnV0dG9uID0gdGhpcy5jaXJjbGUoZGltLkNYLGRpbS5DWSxkaW0uUik7XG4gICAgICAgICAgICBjbG9zZV9idXR0b24uc2V0QXR0cmlidXRlKCdmaWxsJywnIzAwMDAwMCcpO1xuICAgICAgICAgICAgY2xvc2VfYnV0dG9uLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgJyNmZmZmZmYnKTtcbiAgICAgICAgICAgIGNsb3NlX2J1dHRvbi5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsICcyJyk7XG5cbiAgICAgICAgICAgIGNsb3NlX2dyb3VwLl9idXR0b24gPSBjbG9zZV9idXR0b247XG5cbiAgICAgICAgICAgIGNsb3NlX2dyb3VwLnB1c2goY2xvc2VfYnV0dG9uKTtcblxuICAgICAgICAgICAgdmFyIGFfbGluZSA9IHRoaXMubGluZShkaW0uTUlEX1gxLGRpbS5NSURfWTEsZGltLk1JRF9YMixkaW0uTUlEX1kyKTtcbiAgICAgICAgICAgIGFfbGluZS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsICcjZmZmZmZmJyk7XG4gICAgICAgICAgICBhX2xpbmUuc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCAnMicpO1xuXG4gICAgICAgICAgICBjbG9zZV9ncm91cC5wdXNoKGFfbGluZSk7XG5cbiAgICAgICAgICAgIHZhciBmaXJzdF9saW5lID0gYV9saW5lO1xuXG4gICAgICAgICAgICB2YXIgYV9saW5lID0gdGhpcy5saW5lKGRpbS5NSURfWDEsZGltLk1JRF9ZMixkaW0uTUlEX1gyLGRpbS5NSURfWTEpO1xuICAgICAgICAgICAgYV9saW5lLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgJyNmZmZmZmYnKTtcbiAgICAgICAgICAgIGFfbGluZS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsICcyJyk7XG5cbiAgICAgICAgICAgIGNsb3NlX2dyb3VwLnB1c2goYV9saW5lKTtcblxuICAgICAgICAgICAgY2xvc2VfZ3JvdXAubW92ZSA9IGZ1bmN0aW9uKGN4LGN5KSB7XG4gICAgICAgICAgICAgICAgY2xvc2VfYnV0dG9uLnNldEF0dHJpYnV0ZSgnY3gnLGN4KTtcbiAgICAgICAgICAgICAgICBkaW0uTUlEX1gxID0gKGN4LShyLzIpKTtcbiAgICAgICAgICAgICAgICBkaW0uTUlEX1gyID0gKGN4KyhyLzIpKTtcbiAgICAgICAgICAgICAgICBkaW0uTUlEX1kxID0gKGN5LShyLzIpKTtcbiAgICAgICAgICAgICAgICBkaW0uTUlEX1kyID0gKGN5KyhyLzIpKTtcbiAgICAgICAgICAgICAgICBmaXJzdF9saW5lLnNldEF0dHJpYnV0ZSgneDEnLGRpbS5NSURfWDEpO1xuICAgICAgICAgICAgICAgIGZpcnN0X2xpbmUuc2V0QXR0cmlidXRlKCd5MScsZGltLk1JRF9ZMSk7XG4gICAgICAgICAgICAgICAgZmlyc3RfbGluZS5zZXRBdHRyaWJ1dGUoJ3gyJyxkaW0uTUlEX1gyKTtcbiAgICAgICAgICAgICAgICBmaXJzdF9saW5lLnNldEF0dHJpYnV0ZSgneTInLGRpbS5NSURfWTIpO1xuICAgICAgICAgICAgICAgIGFfbGluZS5zZXRBdHRyaWJ1dGUoJ3gxJyxkaW0uTUlEX1gxKTtcbiAgICAgICAgICAgICAgICBhX2xpbmUuc2V0QXR0cmlidXRlKCd5MScsZGltLk1JRF9ZMik7XG4gICAgICAgICAgICAgICAgYV9saW5lLnNldEF0dHJpYnV0ZSgneDInLGRpbS5NSURfWDIpO1xuICAgICAgICAgICAgICAgIGFfbGluZS5zZXRBdHRyaWJ1dGUoJ3kyJyxkaW0uTUlEX1kxKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gY2xvc2VfZ3JvdXA7ICAgICAgICBcbiAgICAgICAgfTtcbiAgICAgICAgY2FudmFzLnRleHQgPSBmdW5jdGlvbih4LHksdGV4dCkge1xuICAgICAgICAgICAgdmFyIGFfdGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzdmducywndGV4dCcpO1xuICAgICAgICAgICAgdmFyIGFfdHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnbnMsICd0c3BhbicpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZXh0ICE9ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgYV90ZXh0LmFwcGVuZENoaWxkKHRleHQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhX3RleHQuYXBwZW5kQ2hpbGQoYV90c3Bhbik7XG4gICAgICAgICAgICAgICAgYV90c3Bhbi50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgICAgICAgICAgICAgYV90c3Bhbi5zZXRBdHRyaWJ1dGUoJ2R5JywnMCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYV90ZXh0LnN0eWxlLmZvbnRGYW1pbHkgPSB0aGlzLmZvbnRfb3JkZXIgfHwgJ0hlbHZldGljYSwgVmVyZGFuYSwgQXJpYWwsIFNhbnMtc2VyaWYnO1xuICAgICAgICAgICAgYV90ZXh0LnNldEF0dHJpYnV0ZSgneCcsdHlwZW9mIHggPT0gJ3N0cmluZycgPyB4IDogeCAqIFJTKTtcbiAgICAgICAgICAgIGFfdGV4dC5zZXRBdHRyaWJ1dGUoJ3knLHR5cGVvZiB5ID09ICdzdHJpbmcnID8geSA6IHkgKiBSUyk7ICAgICAgICBcbiAgICAgICAgICAgIGFfdGV4dC5tb3ZlID0gZnVuY3Rpb24obmV3X3gsbmV3X3dpZHRoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCh0eXBlb2YodGhpcy5vZmZzZXQpICE9PSBcInVuZGVmaW5lZFwiKSAmJiB0aGlzLmdldEF0dHJpYnV0ZSgndHJhbnNmb3JtJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybV9hdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IC90cmFuc2xhdGVcXCguKlssXFxzXSguKilcXCkvLmV4ZWModHJhbnNmb3JtX2F0dHIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCd0cmFuc2xhdGUoJysobmV3X3gqUlMpKycsJyttYXRjaGVzWzFdKycpJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgneCcsbmV3X3gqUlMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoYV90ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBhX3RleHQ7XG4gICAgICAgIH07XG4gICAgICAgIGNhbnZhcy5wbHVzID0gZnVuY3Rpb24oeCx5LGhlaWdodCkge1xuICAgICAgICAgICAgdmFyIGcgPSB0aGlzLmdyb3VwKCk7XG4gICAgICAgICAgICBnLmFwcGVuZENoaWxkKHRoaXMubWFrZUVsKCdyZWN0Jywge1xuICAgICAgICAgICAgICAgICd4JyA6IE1hdGgucm91bmQoKDAuNCkqaGVpZ2h0KlJTKS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICd5JyA6IE1hdGgucm91bmQoKDAuMSkqaGVpZ2h0KlJTKS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICdzdHJva2Utd2lkdGgnIDogJzEnLFxuICAgICAgICAgICAgICAgICd3aWR0aCcgOiBNYXRoLnJvdW5kKCgwLjIpKmhlaWdodCpSUykudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAnaGVpZ2h0JzogTWF0aC5yb3VuZCgoMC44KSpoZWlnaHQqUlMpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgJ3N0cm9rZSc6ICcjZmZmZmZmJyxcbiAgICAgICAgICAgICAgICAnZmlsbCcgIDogJyNmZmZmZmYnICAgICAgICAgICAgXG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIGcuYXBwZW5kQ2hpbGQodGhpcy5tYWtlRWwoJ3JlY3QnLCB7XG4gICAgICAgICAgICAgICAgJ3gnIDogTWF0aC5yb3VuZCgoMC4xKSpoZWlnaHQqUlMpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgJ3knIDogTWF0aC5yb3VuZCgoMC40KSpoZWlnaHQqUlMpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCcgOiAnMScsXG4gICAgICAgICAgICAgICAgJ3dpZHRoJyA6IE1hdGgucm91bmQoKDAuOCkqaGVpZ2h0KlJTKS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICdoZWlnaHQnOiBNYXRoLnJvdW5kKCgwLjIpKmhlaWdodCpSUykudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAnc3Ryb2tlJzogJyNmZmZmZmYnLFxuICAgICAgICAgICAgICAgICdmaWxsJyAgOiAnI2ZmZmZmZicgICAgICAgICAgICBcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGcuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCd0cmFuc2xhdGUoJyt4KlJTKycsJyt5KlJTKycpJyk7XG4gICAgICAgICAgICByZXR1cm4gZztcbiAgICAgICAgfTtcbiAgICAgICAgY2FudmFzLm1pbnVzID0gZnVuY3Rpb24oeCx5LGhlaWdodCkge1xuICAgICAgICAgICAgdmFyIGcgPSB0aGlzLmdyb3VwKCk7XG5cbiAgICAgICAgICAgIGcuYXBwZW5kQ2hpbGQodGhpcy5tYWtlRWwoJ3JlY3QnLCB7XG4gICAgICAgICAgICAgICAgJ3gnIDogTWF0aC5yb3VuZCgoMC4xKSpoZWlnaHQqUlMpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgJ3knIDogTWF0aC5yb3VuZCgoMC40KSpoZWlnaHQqUlMpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCcgOiAnMScsXG4gICAgICAgICAgICAgICAgJ3dpZHRoJyA6IE1hdGgucm91bmQoKDAuOCkqaGVpZ2h0KlJTKS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICdoZWlnaHQnOiBNYXRoLnJvdW5kKCgwLjIpKmhlaWdodCpSUykudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAnc3Ryb2tlJzogJyNmZmZmZmYnLFxuICAgICAgICAgICAgICAgICdmaWxsJyAgOiAnI2ZmZmZmZicgICAgICAgICAgICBcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGcuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCd0cmFuc2xhdGUoJyt4KlJTKycsJyt5KlJTKycpJyk7XG4gICAgICAgICAgICByZXR1cm4gZztcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGJvdW5kaW5nIGJveCBvZiBhbiBlbGVtZW50IHdpdGggcmVzcGVjdCB0byBpdHMgcGFyZW50IGVsZW1lbnRcbiAgICAgICAgLy8gVGhhbmtzIHRvIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTA2MjM4MDkvZ2V0LWJvdW5kaW5nLWJveC1vZi1lbGVtZW50LWFjY291bnRpbmctZm9yLWl0cy10cmFuc2Zvcm1cbiAgICAgICAgY2FudmFzLnRyYW5zZm9ybWVkQm91bmRpbmdCb3ggPSBmdW5jdGlvbihlbCl7XG4gICAgICAgICAgICB2YXIgYmIgID0gZWwuZ2V0QkJveCgpLFxuICAgICAgICAgICAgICAgIHN2ZyA9IGVsLm93bmVyU1ZHRWxlbWVudCxcbiAgICAgICAgICAgICAgICBtICAgPSBlbC5wYXJlbnROb2RlLmdldFNjcmVlbkNUTSgpLmludmVyc2UoKS5tdWx0aXBseShlbC5nZXRTY3JlZW5DVE0oKSkuaW52ZXJzZSgpO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGFuIGFycmF5IG9mIGFsbCBmb3VyIHBvaW50cyBmb3IgdGhlIG9yaWdpbmFsIGJvdW5kaW5nIGJveFxuICAgICAgICAgICAgdmFyIHB0cyA9IFtcbiAgICAgICAgICAgICAgICBzdmcuY3JlYXRlU1ZHUG9pbnQoKSwgc3ZnLmNyZWF0ZVNWR1BvaW50KCksXG4gICAgICAgICAgICAgICAgc3ZnLmNyZWF0ZVNWR1BvaW50KCksIHN2Zy5jcmVhdGVTVkdQb2ludCgpXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgcHRzWzBdLng9YmIueDsgICAgICAgICAgcHRzWzBdLnk9YmIueTtcbiAgICAgICAgICAgIHB0c1sxXS54PWJiLngrYmIud2lkdGg7IHB0c1sxXS55PWJiLnk7XG4gICAgICAgICAgICBwdHNbMl0ueD1iYi54K2JiLndpZHRoOyBwdHNbMl0ueT1iYi55K2JiLmhlaWdodDtcbiAgICAgICAgICAgIHB0c1szXS54PWJiLng7ICAgICAgICAgIHB0c1szXS55PWJiLnkrYmIuaGVpZ2h0O1xuXG4gICAgICAgICAgICAvLyBUcmFuc2Zvcm0gZWFjaCBpbnRvIHRoZSBzcGFjZSBvZiB0aGUgcGFyZW50LFxuICAgICAgICAgICAgLy8gYW5kIGNhbGN1bGF0ZSB0aGUgbWluL21heCBwb2ludHMgZnJvbSB0aGF0LlxuICAgICAgICAgICAgdmFyIHhNaW49SW5maW5pdHkseE1heD0tSW5maW5pdHkseU1pbj1JbmZpbml0eSx5TWF4PS1JbmZpbml0eTtcbiAgICAgICAgICAgIHB0cy5mb3JFYWNoKGZ1bmN0aW9uKHB0KXtcbiAgICAgICAgICAgICAgICBwdCA9IHB0Lm1hdHJpeFRyYW5zZm9ybShtKTtcbiAgICAgICAgICAgICAgICB4TWluID0gTWF0aC5taW4oeE1pbixwdC54KTtcbiAgICAgICAgICAgICAgICB4TWF4ID0gTWF0aC5tYXgoeE1heCxwdC54KTtcbiAgICAgICAgICAgICAgICB5TWluID0gTWF0aC5taW4oeU1pbixwdC55KTtcbiAgICAgICAgICAgICAgICB5TWF4ID0gTWF0aC5tYXgoeU1heCxwdC55KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGJvdW5kaW5nIGJveCB3aXRoIHRoZSBuZXcgdmFsdWVzXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGJiLnggPSB4TWluOyBiYi53aWR0aCAgPSB4TWF4LXhNaW47XG4gICAgICAgICAgICAgICAgYmIueSA9IHlNaW47IGJiLmhlaWdodCA9IHlNYXgteU1pbjtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBiYiA9IHsgJ3gnIDogeE1pbiwgJ3knIDogeU1pbiwgJ3dpZHRoJyA6IHhNYXgteE1pbiwgJ2hlaWdodCcgOiB5TWF4LXlNaW4gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiYjtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGNhbnZhcy5zZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhbl9hcnJheSA9IFtdO1xuICAgICAgICAgICAgZXh0ZW5kX2FycmF5KGFuX2FycmF5LFJTKTtcbiAgICAgICAgICAgIHJldHVybiBhbl9hcnJheTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FudmFzLmhpZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdkaXNwbGF5Jywnbm9uZScpO1xuICAgICAgICB9O1xuICAgICAgICBjYW52YXMuc2hvdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2Rpc3BsYXknLCdpbmxpbmUnKTtcbiAgICAgICAgfTtcbiAgICB9KTtcblxufSkoKTtcblxuXG5leHBvcnQgZGVmYXVsdCBTVkdDYW52YXM7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWEE7QUFjQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFYQTtBQWNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWEE7QUFjQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBSUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../gator/js/lib/SVGCanvas.js\n")},"../gator/js/lib/SequenceRenderer.js":
/*!*******************************************!*\
  !*** ../gator/js/lib/SequenceRenderer.js ***!
  \*******************************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _MASCP__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MASCP */ \"../gator/js/lib/MASCP.js\");\n/* harmony import */ var _bean__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../bean */ \"../gator/js/bean.js\");\n/**\n * @fileOverview    Read in sequences to be re-rendered in a block that can be easily annotated.\n */\n\n\n/**\n * @class   Reformatter for sequences in html pages. The object retrieves the amino acid sequence from the \n *          given element, and then reformats the display of the sequence so that rendering layers can be\n *          applied to it. \n * @author  hjjoshi\n * @param   {Element} sequenceContainer Container element that the sequence currently is found in, and also \n *                                      the container that data will be re-inserted into.\n */\n\nconst SequenceRenderer = function () {\n  /**\n   *  @lends SequenceRenderer.prototype\n   *  @property   {Array}     trackOrder  The order of tracks on the renderer, an array of layer/group names.\n   */\n  var setupTrackOrder = function setupTrackOrder(renderer) {\n    var renderer_track_order = [];\n    var accessors = {\n      getTrackOrder: function getTrackOrder() {\n        return renderer_track_order;\n      },\n      setTrackOrder: function setTrackOrder(in_order) {\n        var track_order = [];\n        var order = in_order;\n\n        if (!order instanceof Array) {\n          order = [in_order];\n        }\n\n        for (var i = 0; i < order.length; i++) {\n          var a_track = order[i];\n\n          if (_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLayer(a_track)) {\n            while (track_order.indexOf(a_track) >= 0) {\n              track_order.splice(track_order.indexOf(a_track), 1);\n            }\n\n            track_order.push(a_track);\n          }\n\n          if (_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getGroup(a_track)) {\n            let insert_idx = i + 1;\n            _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getGroup(order[i]).eachLayer(function (grp_lay) {\n              while (track_order.indexOf(grp_lay.name) >= 0) {\n                track_order.splice(track_order.indexOf(grp_lay.name), 1);\n              }\n\n              order.splice(insert_idx, 0, grp_lay.name);\n              insert_idx += 1;\n            });\n          }\n        }\n\n        for (i = (renderer_track_order || []).length - 1; i >= 0; i--) {\n          if (track_order.indexOf(renderer_track_order[i]) < 0) {\n            this.hideLayer(renderer_track_order[i]);\n            this.hideGroup(renderer_track_order[i]);\n\n            if (_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLayer(renderer_track_order[i])) {\n              _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire(_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLayer(renderer_track_order[i]), 'removed', [renderer]);\n            }\n\n            if (_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getGroup(renderer_track_order[i])) {\n              _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire(_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getGroup(renderer_track_order[i]), 'removed', [renderer]);\n            }\n          }\n        }\n\n        renderer_track_order = track_order;\n\n        if (this.refresh) {\n          this.refresh(true);\n        }\n\n        _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire(renderer, 'orderChanged', [track_order]);\n      }\n    };\n\n    if (_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].IE) {\n      renderer.setTrackOrder = accessors.setTrackOrder;\n    }\n\n    if (typeof Object.defineProperty == 'function' && !_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].IE8) {\n      Object.defineProperty(renderer, \"trackOrder\", {\n        get: accessors.getTrackOrder,\n        set: accessors.setTrackOrder\n      });\n    }\n  };\n\n  return function (sequenceContainer) {\n    if (!sequenceContainer) {\n      return this;\n    }\n\n    if (typeof sequenceContainer !== 'undefined') {\n      this._container = sequenceContainer;\n\n      if (!this._container.style.position) {\n        this._container.style.position = 'relative';\n      } //        this._container.style.width = '100%';\n\n\n      _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(this, 'sequenceChange', function (e) {\n        while (sequenceContainer.firstChild) {\n          sequenceContainer.removeChild(sequenceContainer.firstChild);\n        }\n\n        this._sequence_els.forEach(function (el) {\n          sequenceContainer.appendChild(el);\n        });\n\n        var float_clear = document.createElement('div');\n        float_clear.setAttribute('style', 'clear: both; float: none; height: 0px; width: 100%;');\n        sequenceContainer.appendChild(float_clear);\n        sequenceContainer.style.width = this._sequence_els.length + 'em'; //            this.showRowNumbers();            \n      });\n      this.setSequence(sequenceContainer.textContent || '');\n    }\n\n    setupTrackOrder(this);\n    return this;\n  };\n}();\n/**\n * Event fired when a layer is registered with the global layer registry\n * @name    MASCP.layerRegistered\n * @event\n * @param   {Object}    e\n * @param   {Object}    layer Layer just registered\n */\n\n/**\n * Event fired when a group is registered with the global group registry\n * @name    MASCP.groupRegistered\n * @event\n * @param   {Object}    e\n * @param   {Object}    group Group just registered\n */\n\n/**\n * Event fired when the sequence is changed in a sequence renderer\n * @name    SequenceRenderer#sequenceChange\n * @event\n * @param   {Object}    e\n */\n\n/**\n * Event fired when a result is rendered on this renderer\n * @name    SequenceRenderer#resultsRendered\n * @event\n * @param   {Object}    e\n * @param   {MASCP.Service} reader  Reader that rendered the result.\n */\n\n/**\n * @name    MASCP.Group#visibilityChange\n * @event\n * @param   {Object}    e\n * @param   {Object}    renderer\n * @param   {Boolean}   visibility\n */\n\n/**\n * @name    MASCP.Layer#visibilityChange\n * @event\n * @param   {Object}    e\n * @param   {Object}    renderer\n * @param   {Boolean}   visibility\n */\n\n/**\n *  @lends SequenceRenderer.prototype\n *  @property   {String}  sequence  Sequence to mark up.\n */\n\n\nSequenceRenderer.prototype = {\n  sequence: null\n};\n\nif (_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].IE) {\n  SequenceRenderer.prototype.prototype = document.createElement('div');\n}\n/**\n * Set the sequence for this renderer. Fires the sequenceChange event when the sequence is set.\n * @param {String} sequence Sequence to render\n * @see SequenceRenderer#event:sequenceChange\n */\n\n\nSequenceRenderer.prototype.setSequence = function (sequence) {\n  this.sequence = this._cleanSequence(sequence);\n  var sequence_els = [];\n  var renderer = this;\n\n  if (!this.sequence) {\n    return;\n  }\n\n  var seq_chars = this.sequence.split('');\n\n  for (var i = 0; i < seq_chars.length; i++) {\n    var aa = seq_chars[i];\n\n    if (aa.match(/[A-Za-z]/)) {\n      var span_el = document.createElement('span');\n      span_el.textContent = aa;\n      sequence_els.push(span_el);\n    }\n  }\n\n  sequence_els.forEach(function (el, i) {\n    // if ( (i % 10) == 0 && i > 0 && ((i % 50) != 0)) {\n    //     this.style.margin = '0px 0px 0px 1em';\n    // }\n    // if ( (i % 50) == 0 && i > 0 ) {\n    //     if (MASCP.IE7) {\n    //         sequence_els[i-1].style.styleFloat = 'none';\n    //         sequence_els[i-1].style.width = '1em';\n    //     }\n    //     this.style.clear = 'both';\n    // }\n    el._index = i;\n    el.style.display = 'block';\n    el.style.cssFloat = 'left';\n    el.style.styleFloat = 'left';\n    el.style.height = '1.1em';\n    el.style.position = 'relative';\n    el.addToLayer = SequenceRenderer.addElementToLayer;\n    el.addBoxOverlay = SequenceRenderer.addBoxOverlayToElement;\n    el.addToLayerWithLink = SequenceRenderer.addElementToLayerWithLink;\n    el._renderer = renderer;\n  });\n  this._sequence_els = sequence_els;\n  _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire(this, 'sequenceChange');\n};\n/**\n * Color some residues on this residue\n * @param {Array} indexes Indexes to apply the given color to\n * @param {String} color Color to use to highlight the residues\n * @returns ID for the layer that is created\n * @type String\n */\n\n\nSequenceRenderer.prototype.colorResidues = function (indexes, color) {\n  var layer_id = Math.floor(Math.random() * 1000).toString();\n  _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].registerLayer(layer_id, {\n    'color': color || '#ff0000'\n  });\n  var aas = this.getAminoAcidsByPosition(indexes);\n\n  for (var i = 0; i < aas.length; i++) {\n    aas[i].addToLayer(layer_id);\n  }\n\n  return _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLayer(layer_id);\n};\n\nSequenceRenderer.prototype._cleanSequence = function (sequence) {\n  if (!sequence) {\n    return sequence;\n  }\n\n  var cleaned_sequence = sequence;\n  cleaned_sequence = cleaned_sequence.replace(new RegExp(String.fromCharCode(160), \"g\"), '');\n  cleaned_sequence = cleaned_sequence.replace(/[\\n\\t\\s\\d]+/mgi, '');\n  cleaned_sequence = cleaned_sequence.replace(/\\(.*\\)/g, '');\n  return cleaned_sequence;\n};\n/**\n * Retrieve the HTML Elements that contain the amino acids at the given positions. The first amino acid is found at position 1.\n * @param {Array} indexes Indexes to retrieve elements for\n * @returns Elements representing each amino acid at the given positions\n * @type Array\n */\n\n\nSequenceRenderer.prototype.getAminoAcidsByPosition = function (indexes) {\n  var sequence_els = this._sequence_els;\n  return indexes.map(function (index) {\n    if (index < 0) {\n      return null;\n    }\n\n    return sequence_els[index - 1];\n  });\n};\n\nSequenceRenderer.prototype.getAA = function (index) {\n  return this.getAminoAcidsByPosition([index]).shift();\n};\n/**\n * Retrieve the HTML Elements that contain the amino acids contained in the given peptide sequence.\n * @param {String} peptideSequence Peptide sequence used to look up the amino acids\n * @returns Elements representing each amino acid at the given positions\n * @type Array\n */\n\n\nSequenceRenderer.prototype.getAminoAcidsByPeptide = function (peptideSequence) {\n  var start = this.sequence.indexOf(peptideSequence);\n  var results = [];\n\n  if (start < 0) {\n    results.addToLayer = function () {};\n\n    return results;\n  }\n\n  results = results.concat(this._sequence_els.slice(start, start + peptideSequence.length));\n\n  if (results.length) {\n    results.addToLayer = function (layername, fraction, options) {\n      return results[0].addBoxOverlay(layername, results.length, fraction, options);\n    };\n  } else {\n    results.addToLayer = function () {};\n  }\n\n  return results;\n};\n/**\n * Toggle the display of the given layer\n * @param {String|Object} layer Layer name, or layer object\n * @see MASCP.Layer#event:visibilityChange\n */\n\n\nSequenceRenderer.prototype.toggleLayer = function (layer, consumeChange) {\n  var layerName = layer;\n\n  if (typeof layer != 'string') {\n    layerName = layer.name;\n  } else {\n    layer = _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].layers[layer];\n  }\n\n  this._container.classList.toggle(layerName + '_active');\n\n  this._container.classList.toggle(layerName + '_inactive');\n\n  if (!consumeChange) {\n    _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire(layer, 'visibilityChange', [this, this.isLayerActive(layer)]);\n  }\n\n  return this;\n};\n/**\n * Show the given layer\n * @param {String|Object} layer Layer name, or layer object\n * @see MASCP.Layer#event:visibilityChange\n */\n\n\nSequenceRenderer.prototype.showLayer = function (lay, consumeChange) {\n  var layer = _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLayer(lay);\n\n  if (!layer || layer.disabled) {\n    return;\n  }\n\n  this._container.classList.add(layer.name + '_active');\n\n  this._container.classList.add('active_layer');\n\n  this._container.classList.remove(layer.name + '_inactive');\n\n  if (!consumeChange) {\n    _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire(layer, 'visibilityChange', [this, true]);\n  }\n\n  return this;\n};\n/**\n * Hide the given layer\n * @param {String|Object} layer Layer name, or layer object\n * @see MASCP.Layer#event:visibilityChange\n */\n\n\nSequenceRenderer.prototype.hideLayer = function (lay, consumeChange) {\n  var layer = _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLayer(lay);\n\n  if (!layer || layer.disabled) {\n    return;\n  }\n\n  this._container.classList.remove(layer.name + '_active');\n\n  this._container.classList.remove('active_layer');\n\n  this._container.classList.add(layer.name + '_inactive');\n\n  if (!consumeChange) {\n    _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire(layer, 'visibilityChange', [this, false]);\n  }\n\n  return this;\n};\n/**\n * Register a layer with this renderer. Actually is a proxy on to the global registry method\n * @see MASCP#registerLayer\n */\n\n\nSequenceRenderer.prototype.registerLayer = function (layer, options) {\n  return _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].registerLayer(layer, options);\n};\n/**\n * Hide or show a group. Fires an event when this method is called.\n * @param {Object} grp Group to set the visibility for\n * @param {Boolean} visibility True for visible, false for hidden\n * @see MASCP.Group#event:visibilityChange\n */\n\n\nSequenceRenderer.prototype.setGroupVisibility = function (grp, visibility, consumeChange) {\n  var group = _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getGroup(grp);\n\n  if (!group) {\n    return;\n  }\n\n  var groupName = group.name;\n  var renderer = this;\n  group.eachLayer(function (layer) {\n    if (_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getGroup(layer) === layer) {\n      // We can skip explicitly setting the visibility of groups here, since\n      // any sub-groups should have a controller.\n      return;\n    }\n\n    if (this.disabled && visibility) {\n      renderer.hideLayer(layer.name);\n      return;\n    }\n\n    if (visibility === true) {\n      renderer.showLayer(layer.name);\n    } else if (visibility === false) {\n      renderer.hideLayer(layer.name);\n    } else {\n      renderer.toggleLayer(layer.name);\n    }\n  });\n\n  if (visibility !== null && !consumeChange) {\n    _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire(group, 'visibilityChange', [renderer, visibility]);\n  }\n};\n/**\n * Hide a group. Fires an event when this method is called.\n * @param {Object} grp Group to set the visibility for\n * @see MASCP.Group#event:visibilityChange\n */\n\n\nSequenceRenderer.prototype.hideGroup = function (group, consumeChange) {\n  this.setGroupVisibility(group, false, consumeChange);\n};\n/**\n * Show a group. Fires an event when this method is called.\n * @param {Object} grp Group to set the visibility for\n * @see MASCP.Group#event:visibilityChange\n */\n\n\nSequenceRenderer.prototype.showGroup = function (group, consumeChange) {\n  this.setGroupVisibility(group, true, consumeChange);\n};\n/**\n * Toggle the visibility for a group. Fires an event when this method is called.\n * @param {Object} grp Group to set the visibility for\n * @see MASCP.Group#event:visibilityChange\n */\n\n\nSequenceRenderer.prototype.toggleGroup = function (group, consumeChange) {\n  this.setGroupVisibility(group, consumeChange);\n};\n/**\n * Check if the given layer is active\n * @param {String|Object} layer Layer name, or layer object\n * @returns Whether this layer is active on this renderer\n * @type Boolean\n */\n\n\nSequenceRenderer.prototype.isLayerActive = function (layer) {\n  var layerName = layer;\n\n  if (typeof layer != 'string') {\n    layerName = layer.name;\n  }\n\n  return !layer.disabled && this._container.classList.contains(layerName + '_active');\n};\n/**\n * Deprecated until there's a better implementation for the CondensedSequenceRenderer\n * @private\n */\n\n\nSequenceRenderer.prototype._setHighlight = function (layer, isHighlighted) {\n  return;\n};\n/**\n * Create a layer controller for this sequence renderer. Attach the controller to the containing box, and shift the box across 20px.\n */\n\n\nSequenceRenderer.prototype.createLayerController = function () {\n  console.log(\"createLayerController is deprected\");\n  return;\n};\n/**\n * Create a checkbox that is used to control the given layer\n * @param {String|Object} layer Layer name or layer object that a controller should be generated for\n * @param {Object} inputElement Optional input element to bind events to. If no element is given, a new one is created.\n * @returns Checkbox element that when checked will toggle on the layer, and toggle it off when unchecked\n * @type Object\n */\n\n\nSequenceRenderer.prototype.createLayerCheckbox = function (layer, inputElement, exclusive) {\n  console.log(\"createLayerCheckbox is deprecated\");\n  return;\n};\n\nSequenceRenderer.prototype._removeOtherBindings = function (object, inputElement) {\n  var renderer = this;\n\n  for (var i = 0; i < inputElement._current_bindings.length; i++) {\n    if (inputElement._current_bindings[i].renderer != renderer) {\n      continue;\n    }\n\n    var cb = inputElement._current_bindings[i];\n\n    if (cb.layer && cb.layer != object.name) {\n      _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].remove(_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLayer(cb.layer), 'visibilityChange', cb.object_function);\n      _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].remove(inputElement, 'change', cb.input_function);\n    }\n\n    if (cb.group && cb.group != object.name) {\n      _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].remove(_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getGroup(cb.group), 'visibilityChange', cb.object_function);\n      _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].remove(inputElement, 'change', cb.input_function);\n    }\n\n    cb.group = null;\n    cb.layer = null;\n  }\n};\n/**\n * Create a layer based controller for a group. This layer can act as a proxy for the other layers\n * @param {Object} lay Layer to turn into a group controller\n * @param {Object} grp Group to be controlled by this layer.\n */\n\n\nSequenceRenderer.prototype.createGroupController = function (lay, grp) {\n  var layer = _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLayer(lay);\n  var group = _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getGroup(grp);\n  var self = this;\n  _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(layer, 'visibilityChange', function (rend, visible) {\n    if (rend == self) {\n      self.setGroupVisibility(group, visible);\n      self.refresh();\n    }\n  });\n};\n/**\n * Function to be added to Amino acid elements to facilitate adding elements to layers\n * @private\n * @param {String} layerName The layer that this amino acid should be added to\n * @returns Itself\n * @type Element\n */\n\n\nSequenceRenderer.addElementToLayer = function (layerName) {\n  this.addBoxOverlay(layerName, 1);\n  return this;\n};\n/**\n * Function to be added to Amino acid elements to facilitate adding elements to layers with a link\n * @private\n * @param {String} layerName The layer that this amino acid should be added to\n * @param {String} url URL to link to\n * @returns Itself\n * @type Element\n */\n\n\nSequenceRenderer.addElementToLayerWithLink = function (layerName, url, width) {\n  this.classList.add(layerName);\n  var anchor = document.createElement('a');\n  anchor.setAttribute('href', url);\n  anchor.classList.add(layerName + '_overlay');\n  anchor.setAttribute('style', 'display: box; left: 0px; top: 0px; width: 100%; position: absolute; height: 100%;');\n  anchor.textContent = '&nbsp;';\n  this.appendChild(anchor);\n\n  while (width && width > 0) {\n    this._renderer._sequence_els[this._index + width].addToLayerWithLink(layerName, url);\n\n    width -= 1;\n  }\n\n  if (this._z_indexes && this._z_indexes[layerName]) {\n    anchor.style.zIndex = this._z_indexes[layerName];\n  }\n\n  return this;\n};\n/**\n * Function to be added to Amino acid elements to facilitate adding box overlays to elements\n * @private\n * @param {String} layerName The layer that this amino acid should be added to, as well as the fraction opacity to use for this overlay\n * @returns Itself\n * @type Element\n */\n\n\nSequenceRenderer.addBoxOverlayToElement = function (layerName, width, fraction) {\n  if (typeof fraction == 'undefined') {\n    fraction = 1;\n  }\n\n  this.classList.add(layerName);\n  var new_el = document.createElement('div');\n  new_el.classList.add(layerName + '_overlay');\n  new_el.setAttribute('style', 'top: 0px; width: 100%; position: absolute; height: 100%; opacity:' + fraction + ';');\n  this.appendChild(new_el);\n\n  while (width && width > 1) {\n    this._renderer._sequence_els[this._index + width - 1].addBoxOverlay(layerName, 0, fraction);\n\n    width -= 1;\n  }\n\n  if (this._z_indexes && this._z_indexes[layerName]) {\n    new_el.style.zIndex = this._z_indexes[layerName];\n  }\n\n  var event_names = ['mouseover', 'mousedown', 'mousemove', 'mouseout', 'click', 'dblclick', 'mouseup', 'mouseenter', 'mouseleave'];\n\n  for (var i = 0; i < event_names.length; i++) {\n    _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(new_el, event_names[i], function () {\n      return function (e) {\n        _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire(_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLayer(layerName), e.type, [e, 'SequenceRenderer']);\n      };\n    }(i));\n  }\n\n  return this;\n};\n/**\n * Reset this renderer. Hide all groups and layers, disabling them in the registry.\n */\n\n\nSequenceRenderer.prototype.reset = function () {\n  while (this._container.classList.length > 0) {\n    this._container.classList.remove(this._container.classList.item(0));\n  }\n\n  for (var group in _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].groups) {\n    if (_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].groups.hasOwnProperty(group)) {\n      this.hideGroup(group);\n    }\n  }\n\n  for (var layer in _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].layers) {\n    if (_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].layers.hasOwnProperty(layer)) {\n      if (!this.keeptracks) {\n        this.hideLayer(layer, true);\n        _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].layers[layer].disabled = true;\n      }\n    }\n  }\n\n  if (this.resetAnnotations) {\n    this.resetAnnotations();\n  }\n};\n/**\n * Execute the given block of code (in the renderer context) moving the refresh method away so that it is not called\n * @param {Function} func Function that contains operations to run without refreshing the renderer\n */\n\n\nSequenceRenderer.prototype.withoutRefresh = function (func) {\n  var curr_refresh = this.refresh;\n\n  this.refresh = function () {};\n\n  this.refresh.suspended = true;\n  func.apply(this);\n  this.refresh = curr_refresh;\n};\n/**\n * Refresh the display for this sequence renderer\n */\n\n\nSequenceRenderer.prototype.refresh = function () {\n  var z_index = -2;\n\n  if (!this._z_indexes) {\n    this._z_indexes = {};\n  }\n\n  for (var i = 0; i < (this.trackOrder || []).length; i++) {\n    if (!this.isLayerActive(this.trackOrder[i])) {\n      continue;\n    }\n\n    Array.prototype.slice.call(document.querySelectorAll('.' + this.trackOrder[i] + '_overlay')).forEach(function (el) {\n      el.style.zIndex = z_index;\n    });\n    this._z_indexes[this.trackOrder[i]] = z_index;\n    z_index -= 1;\n  }\n};\n/**\n * Bind a function to execute on a particular event for this object\n * @param {String} ev Event name\n * @param {Function} func Function to execute\n */\n\n\nSequenceRenderer.prototype.bind = function (ev, func) {\n  _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(this, ev, func);\n};\n\nSequenceRenderer.prototype.unbind = function (ev, func) {\n  _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].remove(this, ev, func);\n};\n\nSequenceRenderer.prototype.trigger = function (ev, args) {\n  _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire(this, ev, args);\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (SequenceRenderer);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vZ2F0b3IvanMvbGliL1NlcXVlbmNlUmVuZGVyZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vZ2F0b3IvanMvbGliL1NlcXVlbmNlUmVuZGVyZXIuanM/OGZiYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlT3ZlcnZpZXcgICAgUmVhZCBpbiBzZXF1ZW5jZXMgdG8gYmUgcmUtcmVuZGVyZWQgaW4gYSBibG9jayB0aGF0IGNhbiBiZSBlYXNpbHkgYW5ub3RhdGVkLlxuICovXG5cbmltcG9ydCBNQVNDUCBmcm9tICcuL01BU0NQJztcbmltcG9ydCBiZWFuIGZyb20gJy4uL2JlYW4nO1xuXG5cbi8qKlxuICogQGNsYXNzICAgUmVmb3JtYXR0ZXIgZm9yIHNlcXVlbmNlcyBpbiBodG1sIHBhZ2VzLiBUaGUgb2JqZWN0IHJldHJpZXZlcyB0aGUgYW1pbm8gYWNpZCBzZXF1ZW5jZSBmcm9tIHRoZSBcbiAqICAgICAgICAgIGdpdmVuIGVsZW1lbnQsIGFuZCB0aGVuIHJlZm9ybWF0cyB0aGUgZGlzcGxheSBvZiB0aGUgc2VxdWVuY2Ugc28gdGhhdCByZW5kZXJpbmcgbGF5ZXJzIGNhbiBiZVxuICogICAgICAgICAgYXBwbGllZCB0byBpdC4gXG4gKiBAYXV0aG9yICBoampvc2hpXG4gKiBAcGFyYW0gICB7RWxlbWVudH0gc2VxdWVuY2VDb250YWluZXIgQ29udGFpbmVyIGVsZW1lbnQgdGhhdCB0aGUgc2VxdWVuY2UgY3VycmVudGx5IGlzIGZvdW5kIGluLCBhbmQgYWxzbyBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgY29udGFpbmVyIHRoYXQgZGF0YSB3aWxsIGJlIHJlLWluc2VydGVkIGludG8uXG4gKi9cbmNvbnN0IFNlcXVlbmNlUmVuZGVyZXIgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAvKipcbiAgICAgKiAgQGxlbmRzIFNlcXVlbmNlUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogIEBwcm9wZXJ0eSAgIHtBcnJheX0gICAgIHRyYWNrT3JkZXIgIFRoZSBvcmRlciBvZiB0cmFja3Mgb24gdGhlIHJlbmRlcmVyLCBhbiBhcnJheSBvZiBsYXllci9ncm91cCBuYW1lcy5cbiAgICAgKi9cbiAgICB2YXIgc2V0dXBUcmFja09yZGVyID0gZnVuY3Rpb24ocmVuZGVyZXIpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVyX3RyYWNrX29yZGVyID0gW107XG5cbiAgICAgICAgdmFyIGFjY2Vzc29ycyA9IHtcblxuICAgICAgICAgICAgZ2V0VHJhY2tPcmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlcmVyX3RyYWNrX29yZGVyO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0VHJhY2tPcmRlcjogZnVuY3Rpb24oaW5fb3JkZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJhY2tfb3JkZXIgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgb3JkZXIgPSBpbl9vcmRlcjtcbiAgICAgICAgICAgICAgICBpZiAoICEgb3JkZXIgaW5zdGFuY2VvZiBBcnJheSApIHtcbiAgICAgICAgICAgICAgICAgICAgb3JkZXIgPSBbIGluX29yZGVyIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFfdHJhY2sgPSBvcmRlcltpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1BU0NQLmdldExheWVyKGFfdHJhY2spKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAodHJhY2tfb3JkZXIuaW5kZXhPZihhX3RyYWNrKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tfb3JkZXIuc3BsaWNlKHRyYWNrX29yZGVyLmluZGV4T2YoYV90cmFjayksMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFja19vcmRlci5wdXNoKGFfdHJhY2spO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChNQVNDUC5nZXRHcm91cChhX3RyYWNrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGluc2VydF9pZHg9IGkrMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIE1BU0NQLmdldEdyb3VwKG9yZGVyW2ldKS5lYWNoTGF5ZXIoZnVuY3Rpb24oZ3JwX2xheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICh0cmFja19vcmRlci5pbmRleE9mKGdycF9sYXkubmFtZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFja19vcmRlci5zcGxpY2UodHJhY2tfb3JkZXIuaW5kZXhPZihncnBfbGF5Lm5hbWUpLDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmRlci5zcGxpY2UoaW5zZXJ0X2lkeCwwLGdycF9sYXkubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0X2lkeCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChpID0gKChyZW5kZXJlcl90cmFja19vcmRlciB8fCBbXSkubGVuZ3RoIC0gMSk7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFja19vcmRlci5pbmRleE9mKHJlbmRlcmVyX3RyYWNrX29yZGVyW2ldKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZUxheWVyKHJlbmRlcmVyX3RyYWNrX29yZGVyW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZUdyb3VwKHJlbmRlcmVyX3RyYWNrX29yZGVyW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNQVNDUC5nZXRMYXllcihyZW5kZXJlcl90cmFja19vcmRlcltpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWFuLmZpcmUoTUFTQ1AuZ2V0TGF5ZXIocmVuZGVyZXJfdHJhY2tfb3JkZXJbaV0pLCdyZW1vdmVkJyxbcmVuZGVyZXJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNQVNDUC5nZXRHcm91cChyZW5kZXJlcl90cmFja19vcmRlcltpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWFuLmZpcmUoTUFTQ1AuZ2V0R3JvdXAocmVuZGVyZXJfdHJhY2tfb3JkZXJbaV0pLCdyZW1vdmVkJyxbcmVuZGVyZXJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZW5kZXJlcl90cmFja19vcmRlciA9IHRyYWNrX29yZGVyO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVmcmVzaCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2godHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJlYW4uZmlyZShyZW5kZXJlciwnb3JkZXJDaGFuZ2VkJywgWyB0cmFja19vcmRlciBdICk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoTUFTQ1AuSUUpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLnNldFRyYWNrT3JkZXIgPSBhY2Nlc3NvcnMuc2V0VHJhY2tPcmRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgodHlwZW9mIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA9PSAnZnVuY3Rpb24nKSAmJiAhIE1BU0NQLklFOCApIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZW5kZXJlcixcInRyYWNrT3JkZXJcIiwge1xuICAgICAgICAgICAgICAgIGdldCA6IGFjY2Vzc29ycy5nZXRUcmFja09yZGVyLFxuICAgICAgICAgICAgICAgIHNldCA6IGFjY2Vzc29ycy5zZXRUcmFja09yZGVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oc2VxdWVuY2VDb250YWluZXIpIHtcbiAgICAgICAgaWYgKCEgc2VxdWVuY2VDb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2VxdWVuY2VDb250YWluZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLl9jb250YWluZXIgPSBzZXF1ZW5jZUNvbnRhaW5lcjtcbiAgICAgICAgICAgIGlmICggISB0aGlzLl9jb250YWluZXIuc3R5bGUucG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICAgICAgfVxuICAgIC8vICAgICAgICB0aGlzLl9jb250YWluZXIuc3R5bGUud2lkdGggPSAnMTAwJSc7XG5cbiAgICAgICAgICAgIGJlYW4uYWRkKHRoaXMsJ3NlcXVlbmNlQ2hhbmdlJywgZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHNlcXVlbmNlQ29udGFpbmVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VxdWVuY2VDb250YWluZXIucmVtb3ZlQ2hpbGQoc2VxdWVuY2VDb250YWluZXIuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3NlcXVlbmNlX2Vscy5mb3JFYWNoKGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcXVlbmNlQ29udGFpbmVyLmFwcGVuZENoaWxkKGVsKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgZmxvYXRfY2xlYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICBmbG9hdF9jbGVhci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywnY2xlYXI6IGJvdGg7IGZsb2F0OiBub25lOyBoZWlnaHQ6IDBweDsgd2lkdGg6IDEwMCU7Jyk7XG4gICAgICAgICAgICAgICAgc2VxdWVuY2VDb250YWluZXIuYXBwZW5kQ2hpbGQoZmxvYXRfY2xlYXIpO1xuICAgICAgICAgICAgICAgIHNlcXVlbmNlQ29udGFpbmVyLnN0eWxlLndpZHRoID0gKHRoaXMuX3NlcXVlbmNlX2Vscy5sZW5ndGgpKydlbSc7XG4gICAgLy8gICAgICAgICAgICB0aGlzLnNob3dSb3dOdW1iZXJzKCk7ICAgICAgICAgICAgXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5zZXRTZXF1ZW5jZShzZXF1ZW5jZUNvbnRhaW5lci50ZXh0Q29udGVudCB8fCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHNldHVwVHJhY2tPcmRlcih0aGlzKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIEV2ZW50IGZpcmVkIHdoZW4gYSBsYXllciBpcyByZWdpc3RlcmVkIHdpdGggdGhlIGdsb2JhbCBsYXllciByZWdpc3RyeVxuICogQG5hbWUgICAgTUFTQ1AubGF5ZXJSZWdpc3RlcmVkXG4gKiBAZXZlbnRcbiAqIEBwYXJhbSAgIHtPYmplY3R9ICAgIGVcbiAqIEBwYXJhbSAgIHtPYmplY3R9ICAgIGxheWVyIExheWVyIGp1c3QgcmVnaXN0ZXJlZFxuICovXG5cbi8qKlxuICogRXZlbnQgZmlyZWQgd2hlbiBhIGdyb3VwIGlzIHJlZ2lzdGVyZWQgd2l0aCB0aGUgZ2xvYmFsIGdyb3VwIHJlZ2lzdHJ5XG4gKiBAbmFtZSAgICBNQVNDUC5ncm91cFJlZ2lzdGVyZWRcbiAqIEBldmVudFxuICogQHBhcmFtICAge09iamVjdH0gICAgZVxuICogQHBhcmFtICAge09iamVjdH0gICAgZ3JvdXAgR3JvdXAganVzdCByZWdpc3RlcmVkXG4gKi9cblxuLyoqXG4gKiBFdmVudCBmaXJlZCB3aGVuIHRoZSBzZXF1ZW5jZSBpcyBjaGFuZ2VkIGluIGEgc2VxdWVuY2UgcmVuZGVyZXJcbiAqIEBuYW1lICAgIFNlcXVlbmNlUmVuZGVyZXIjc2VxdWVuY2VDaGFuZ2VcbiAqIEBldmVudFxuICogQHBhcmFtICAge09iamVjdH0gICAgZVxuICovXG5cbi8qKlxuICogRXZlbnQgZmlyZWQgd2hlbiBhIHJlc3VsdCBpcyByZW5kZXJlZCBvbiB0aGlzIHJlbmRlcmVyXG4gKiBAbmFtZSAgICBTZXF1ZW5jZVJlbmRlcmVyI3Jlc3VsdHNSZW5kZXJlZFxuICogQGV2ZW50XG4gKiBAcGFyYW0gICB7T2JqZWN0fSAgICBlXG4gKiBAcGFyYW0gICB7TUFTQ1AuU2VydmljZX0gcmVhZGVyICBSZWFkZXIgdGhhdCByZW5kZXJlZCB0aGUgcmVzdWx0LlxuICovXG5cbi8qKlxuICogQG5hbWUgICAgTUFTQ1AuR3JvdXAjdmlzaWJpbGl0eUNoYW5nZVxuICogQGV2ZW50XG4gKiBAcGFyYW0gICB7T2JqZWN0fSAgICBlXG4gKiBAcGFyYW0gICB7T2JqZWN0fSAgICByZW5kZXJlclxuICogQHBhcmFtICAge0Jvb2xlYW59ICAgdmlzaWJpbGl0eVxuICovXG5cbi8qKlxuICogQG5hbWUgICAgTUFTQ1AuTGF5ZXIjdmlzaWJpbGl0eUNoYW5nZVxuICogQGV2ZW50XG4gKiBAcGFyYW0gICB7T2JqZWN0fSAgICBlXG4gKiBAcGFyYW0gICB7T2JqZWN0fSAgICByZW5kZXJlclxuICogQHBhcmFtICAge0Jvb2xlYW59ICAgdmlzaWJpbGl0eVxuICovXG5cblxuXG4vKipcbiAqICBAbGVuZHMgU2VxdWVuY2VSZW5kZXJlci5wcm90b3R5cGVcbiAqICBAcHJvcGVydHkgICB7U3RyaW5nfSAgc2VxdWVuY2UgIFNlcXVlbmNlIHRvIG1hcmsgdXAuXG4gKi9cblNlcXVlbmNlUmVuZGVyZXIucHJvdG90eXBlID0ge1xuICAgIHNlcXVlbmNlOiBudWxsIFxufTtcbiBcbmlmICggTUFTQ1AuSUUgKSB7XG4gICAgU2VxdWVuY2VSZW5kZXJlci5wcm90b3R5cGUucHJvdG90eXBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG59XG5cblxuLyoqXG4gKiBTZXQgdGhlIHNlcXVlbmNlIGZvciB0aGlzIHJlbmRlcmVyLiBGaXJlcyB0aGUgc2VxdWVuY2VDaGFuZ2UgZXZlbnQgd2hlbiB0aGUgc2VxdWVuY2UgaXMgc2V0LlxuICogQHBhcmFtIHtTdHJpbmd9IHNlcXVlbmNlIFNlcXVlbmNlIHRvIHJlbmRlclxuICogQHNlZSBTZXF1ZW5jZVJlbmRlcmVyI2V2ZW50OnNlcXVlbmNlQ2hhbmdlXG4gKi9cblNlcXVlbmNlUmVuZGVyZXIucHJvdG90eXBlLnNldFNlcXVlbmNlID0gZnVuY3Rpb24oc2VxdWVuY2UpXG57XG4gICAgdGhpcy5zZXF1ZW5jZSA9IHRoaXMuX2NsZWFuU2VxdWVuY2Uoc2VxdWVuY2UpO1xuICAgIHZhciBzZXF1ZW5jZV9lbHMgPSBbXTtcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzO1xuICAgIGlmICggISB0aGlzLnNlcXVlbmNlICkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzZXFfY2hhcnMgPSB0aGlzLnNlcXVlbmNlLnNwbGl0KCcnKTtcbiAgICBmb3IgKHZhciBpID0wOyBpIDwgc2VxX2NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBhYSA9IHNlcV9jaGFyc1tpXTtcbiAgICAgICAgaWYgKGFhLm1hdGNoKC9bQS1aYS16XS8pKSB7XG4gICAgICAgICAgICB2YXIgc3Bhbl9lbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIHNwYW5fZWwudGV4dENvbnRlbnQgPSBhYTtcbiAgICAgICAgICAgIHNlcXVlbmNlX2Vscy5wdXNoKHNwYW5fZWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2VxdWVuY2VfZWxzLmZvckVhY2goIGZ1bmN0aW9uKGVsLGkpIHtcbiAgICAgICAgLy8gaWYgKCAoaSAlIDEwKSA9PSAwICYmIGkgPiAwICYmICgoaSAlIDUwKSAhPSAwKSkge1xuICAgICAgICAvLyAgICAgdGhpcy5zdHlsZS5tYXJnaW4gPSAnMHB4IDBweCAwcHggMWVtJztcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBpZiAoIChpICUgNTApID09IDAgJiYgaSA+IDAgKSB7XG4gICAgICAgIC8vICAgICBpZiAoTUFTQ1AuSUU3KSB7XG4gICAgICAgIC8vICAgICAgICAgc2VxdWVuY2VfZWxzW2ktMV0uc3R5bGUuc3R5bGVGbG9hdCA9ICdub25lJztcbiAgICAgICAgLy8gICAgICAgICBzZXF1ZW5jZV9lbHNbaS0xXS5zdHlsZS53aWR0aCA9ICcxZW0nO1xuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyAgICAgdGhpcy5zdHlsZS5jbGVhciA9ICdib3RoJztcbiAgICAgICAgLy8gfVxuICAgICAgICBcbiAgICAgICAgZWwuX2luZGV4ID0gaTtcbiAgICAgICAgXG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICBlbC5zdHlsZS5jc3NGbG9hdCA9ICdsZWZ0JztcbiAgICAgICAgZWwuc3R5bGUuc3R5bGVGbG9hdCA9ICdsZWZ0JztcbiAgICAgICAgZWwuc3R5bGUuaGVpZ2h0ID0gJzEuMWVtJztcbiAgICAgICAgZWwuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuXG4gICAgICAgIGVsLmFkZFRvTGF5ZXIgPSBTZXF1ZW5jZVJlbmRlcmVyLmFkZEVsZW1lbnRUb0xheWVyO1xuICAgICAgICBlbC5hZGRCb3hPdmVybGF5ID0gU2VxdWVuY2VSZW5kZXJlci5hZGRCb3hPdmVybGF5VG9FbGVtZW50O1xuICAgICAgICBlbC5hZGRUb0xheWVyV2l0aExpbmsgPSBTZXF1ZW5jZVJlbmRlcmVyLmFkZEVsZW1lbnRUb0xheWVyV2l0aExpbms7XG4gICAgICAgIGVsLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIH0pO1xuICAgIHRoaXMuX3NlcXVlbmNlX2VscyA9IHNlcXVlbmNlX2VsczsgICBcbiAgICBiZWFuLmZpcmUodGhpcywnc2VxdWVuY2VDaGFuZ2UnKTtcbn07XG5cbi8qKlxuICogQ29sb3Igc29tZSByZXNpZHVlcyBvbiB0aGlzIHJlc2lkdWVcbiAqIEBwYXJhbSB7QXJyYXl9IGluZGV4ZXMgSW5kZXhlcyB0byBhcHBseSB0aGUgZ2l2ZW4gY29sb3IgdG9cbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBDb2xvciB0byB1c2UgdG8gaGlnaGxpZ2h0IHRoZSByZXNpZHVlc1xuICogQHJldHVybnMgSUQgZm9yIHRoZSBsYXllciB0aGF0IGlzIGNyZWF0ZWRcbiAqIEB0eXBlIFN0cmluZ1xuICovXG5TZXF1ZW5jZVJlbmRlcmVyLnByb3RvdHlwZS5jb2xvclJlc2lkdWVzID0gZnVuY3Rpb24oaW5kZXhlcywgY29sb3IpIHtcbiAgICB2YXIgbGF5ZXJfaWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqMTAwMCkudG9TdHJpbmcoKTtcbiAgICBNQVNDUC5yZWdpc3RlckxheWVyKGxheWVyX2lkLCB7ICdjb2xvcicgOiAoY29sb3IgfHwgJyNmZjAwMDAnKSB9KTtcbiAgICB2YXIgYWFzID0gdGhpcy5nZXRBbWlub0FjaWRzQnlQb3NpdGlvbihpbmRleGVzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFhcy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgYWFzW2ldLmFkZFRvTGF5ZXIobGF5ZXJfaWQpO1xuICAgIH1cbiAgICByZXR1cm4gTUFTQ1AuZ2V0TGF5ZXIobGF5ZXJfaWQpO1xufTtcblxuXG5TZXF1ZW5jZVJlbmRlcmVyLnByb3RvdHlwZS5fY2xlYW5TZXF1ZW5jZSA9IGZ1bmN0aW9uKHNlcXVlbmNlKSB7XG4gICAgaWYgKCAhIHNlcXVlbmNlICkge1xuICAgICAgICByZXR1cm4gc2VxdWVuY2U7XG4gICAgfVxuICAgIHZhciBjbGVhbmVkX3NlcXVlbmNlID0gc2VxdWVuY2U7XG4gICAgY2xlYW5lZF9zZXF1ZW5jZSA9IGNsZWFuZWRfc2VxdWVuY2UucmVwbGFjZShuZXcgUmVnRXhwKFN0cmluZy5mcm9tQ2hhckNvZGUoMTYwKSxcImdcIiksJycpO1xuICAgIGNsZWFuZWRfc2VxdWVuY2UgPSBjbGVhbmVkX3NlcXVlbmNlLnJlcGxhY2UoL1tcXG5cXHRcXHNcXGRdKy9tZ2ksJycpO1xuICAgIGNsZWFuZWRfc2VxdWVuY2UgPSBjbGVhbmVkX3NlcXVlbmNlLnJlcGxhY2UoL1xcKC4qXFwpL2csJycpO1xuICAgIHJldHVybiBjbGVhbmVkX3NlcXVlbmNlO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgSFRNTCBFbGVtZW50cyB0aGF0IGNvbnRhaW4gdGhlIGFtaW5vIGFjaWRzIGF0IHRoZSBnaXZlbiBwb3NpdGlvbnMuIFRoZSBmaXJzdCBhbWlubyBhY2lkIGlzIGZvdW5kIGF0IHBvc2l0aW9uIDEuXG4gKiBAcGFyYW0ge0FycmF5fSBpbmRleGVzIEluZGV4ZXMgdG8gcmV0cmlldmUgZWxlbWVudHMgZm9yXG4gKiBAcmV0dXJucyBFbGVtZW50cyByZXByZXNlbnRpbmcgZWFjaCBhbWlubyBhY2lkIGF0IHRoZSBnaXZlbiBwb3NpdGlvbnNcbiAqIEB0eXBlIEFycmF5XG4gKi9cblNlcXVlbmNlUmVuZGVyZXIucHJvdG90eXBlLmdldEFtaW5vQWNpZHNCeVBvc2l0aW9uID0gZnVuY3Rpb24oaW5kZXhlcykge1xuICAgIHZhciBzZXF1ZW5jZV9lbHMgPSB0aGlzLl9zZXF1ZW5jZV9lbHM7XG4gICAgcmV0dXJuIGluZGV4ZXMubWFwKGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXF1ZW5jZV9lbHNbaW5kZXgtMV07XG4gICAgfSk7XG59O1xuXG5TZXF1ZW5jZVJlbmRlcmVyLnByb3RvdHlwZS5nZXRBQSA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QW1pbm9BY2lkc0J5UG9zaXRpb24oW2luZGV4XSkuc2hpZnQoKTtcbn07XG5cblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgSFRNTCBFbGVtZW50cyB0aGF0IGNvbnRhaW4gdGhlIGFtaW5vIGFjaWRzIGNvbnRhaW5lZCBpbiB0aGUgZ2l2ZW4gcGVwdGlkZSBzZXF1ZW5jZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwZXB0aWRlU2VxdWVuY2UgUGVwdGlkZSBzZXF1ZW5jZSB1c2VkIHRvIGxvb2sgdXAgdGhlIGFtaW5vIGFjaWRzXG4gKiBAcmV0dXJucyBFbGVtZW50cyByZXByZXNlbnRpbmcgZWFjaCBhbWlubyBhY2lkIGF0IHRoZSBnaXZlbiBwb3NpdGlvbnNcbiAqIEB0eXBlIEFycmF5XG4gKi9cblNlcXVlbmNlUmVuZGVyZXIucHJvdG90eXBlLmdldEFtaW5vQWNpZHNCeVBlcHRpZGUgPSBmdW5jdGlvbihwZXB0aWRlU2VxdWVuY2UpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnNlcXVlbmNlLmluZGV4T2YocGVwdGlkZVNlcXVlbmNlKTtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICByZXN1bHRzLmFkZFRvTGF5ZXIgPSBmdW5jdGlvbigpIHt9O1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgcmVzdWx0cyA9IHJlc3VsdHMuY29uY2F0KHRoaXMuX3NlcXVlbmNlX2Vscy5zbGljZShzdGFydCxzdGFydCsocGVwdGlkZVNlcXVlbmNlLmxlbmd0aCkpKTtcbiAgICBpZiAocmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0cy5hZGRUb0xheWVyID0gZnVuY3Rpb24obGF5ZXJuYW1lLCBmcmFjdGlvbiwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHNbMF0uYWRkQm94T3ZlcmxheShsYXllcm5hbWUscmVzdWx0cy5sZW5ndGgsZnJhY3Rpb24sb3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0cy5hZGRUb0xheWVyID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gICAgICAgIFxuICAgIHJldHVybiByZXN1bHRzO1xufTtcblxuLyoqXG4gKiBUb2dnbGUgdGhlIGRpc3BsYXkgb2YgdGhlIGdpdmVuIGxheWVyXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGxheWVyIExheWVyIG5hbWUsIG9yIGxheWVyIG9iamVjdFxuICogQHNlZSBNQVNDUC5MYXllciNldmVudDp2aXNpYmlsaXR5Q2hhbmdlXG4gKi9cblNlcXVlbmNlUmVuZGVyZXIucHJvdG90eXBlLnRvZ2dsZUxheWVyID0gZnVuY3Rpb24obGF5ZXIsY29uc3VtZUNoYW5nZSkge1xuICAgIHZhciBsYXllck5hbWUgPSBsYXllcjtcbiAgICBpZiAodHlwZW9mIGxheWVyICE9ICdzdHJpbmcnKSB7XG4gICAgICAgIGxheWVyTmFtZSA9IGxheWVyLm5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGF5ZXIgPSBNQVNDUC5sYXllcnNbbGF5ZXJdO1xuICAgIH1cbiAgICB0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0LnRvZ2dsZShsYXllck5hbWUrJ19hY3RpdmUnKTtcbiAgICB0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0LnRvZ2dsZShsYXllck5hbWUrJ19pbmFjdGl2ZScpO1xuICAgIGlmICggISBjb25zdW1lQ2hhbmdlICkge1xuICAgICAgICBiZWFuLmZpcmUobGF5ZXIsJ3Zpc2liaWxpdHlDaGFuZ2UnLFt0aGlzLHRoaXMuaXNMYXllckFjdGl2ZShsYXllcildKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNob3cgdGhlIGdpdmVuIGxheWVyXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGxheWVyIExheWVyIG5hbWUsIG9yIGxheWVyIG9iamVjdFxuICogQHNlZSBNQVNDUC5MYXllciNldmVudDp2aXNpYmlsaXR5Q2hhbmdlXG4gKi9cblNlcXVlbmNlUmVuZGVyZXIucHJvdG90eXBlLnNob3dMYXllciA9IGZ1bmN0aW9uKGxheSxjb25zdW1lQ2hhbmdlKSB7XG4gICAgdmFyIGxheWVyID0gTUFTQ1AuZ2V0TGF5ZXIobGF5KTtcblxuICAgIGlmICghIGxheWVyIHx8IGxheWVyLmRpc2FibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY29udGFpbmVyLmNsYXNzTGlzdC5hZGQobGF5ZXIubmFtZSsnX2FjdGl2ZScpO1xuICAgIHRoaXMuX2NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdhY3RpdmVfbGF5ZXInKTsgICAgXG4gICAgdGhpcy5fY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUobGF5ZXIubmFtZSsnX2luYWN0aXZlJyk7XG4gICAgaWYgKCAhIGNvbnN1bWVDaGFuZ2UgKSB7XG4gICAgICAgIGJlYW4uZmlyZShsYXllciwndmlzaWJpbGl0eUNoYW5nZScsW3RoaXMsdHJ1ZV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSGlkZSB0aGUgZ2l2ZW4gbGF5ZXJcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gbGF5ZXIgTGF5ZXIgbmFtZSwgb3IgbGF5ZXIgb2JqZWN0XG4gKiBAc2VlIE1BU0NQLkxheWVyI2V2ZW50OnZpc2liaWxpdHlDaGFuZ2VcbiAqL1xuU2VxdWVuY2VSZW5kZXJlci5wcm90b3R5cGUuaGlkZUxheWVyID0gZnVuY3Rpb24obGF5LGNvbnN1bWVDaGFuZ2UpIHtcbiAgICB2YXIgbGF5ZXIgPSBNQVNDUC5nZXRMYXllcihsYXkpO1xuXG4gICAgaWYgKCEgbGF5ZXIgfHwgbGF5ZXIuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAgICAgXG4gICAgdGhpcy5fY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUobGF5ZXIubmFtZSsnX2FjdGl2ZScpO1xuICAgIHRoaXMuX2NvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmVfbGF5ZXInKTtcbiAgICB0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0LmFkZChsYXllci5uYW1lKydfaW5hY3RpdmUnKTtcbiAgICBpZiAoISBjb25zdW1lQ2hhbmdlICkge1xuICAgICAgICBiZWFuLmZpcmUobGF5ZXIsJ3Zpc2liaWxpdHlDaGFuZ2UnLFt0aGlzLGZhbHNlXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIGxheWVyIHdpdGggdGhpcyByZW5kZXJlci4gQWN0dWFsbHkgaXMgYSBwcm94eSBvbiB0byB0aGUgZ2xvYmFsIHJlZ2lzdHJ5IG1ldGhvZFxuICogQHNlZSBNQVNDUCNyZWdpc3RlckxheWVyXG4gKi9cblNlcXVlbmNlUmVuZGVyZXIucHJvdG90eXBlLnJlZ2lzdGVyTGF5ZXIgPSBmdW5jdGlvbihsYXllcixvcHRpb25zKSB7XG4gICAgcmV0dXJuIE1BU0NQLnJlZ2lzdGVyTGF5ZXIobGF5ZXIsb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEhpZGUgb3Igc2hvdyBhIGdyb3VwLiBGaXJlcyBhbiBldmVudCB3aGVuIHRoaXMgbWV0aG9kIGlzIGNhbGxlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBncnAgR3JvdXAgdG8gc2V0IHRoZSB2aXNpYmlsaXR5IGZvclxuICogQHBhcmFtIHtCb29sZWFufSB2aXNpYmlsaXR5IFRydWUgZm9yIHZpc2libGUsIGZhbHNlIGZvciBoaWRkZW5cbiAqIEBzZWUgTUFTQ1AuR3JvdXAjZXZlbnQ6dmlzaWJpbGl0eUNoYW5nZVxuICovXG5TZXF1ZW5jZVJlbmRlcmVyLnByb3RvdHlwZS5zZXRHcm91cFZpc2liaWxpdHkgPSBmdW5jdGlvbihncnAsdmlzaWJpbGl0eSxjb25zdW1lQ2hhbmdlKSB7XG4gICAgdmFyIGdyb3VwID0gTUFTQ1AuZ2V0R3JvdXAoZ3JwKTtcbiAgICBpZiAoICEgZ3JvdXAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGdyb3VwTmFtZSA9IGdyb3VwLm5hbWU7XG4gICAgXG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcztcblxuICAgIGdyb3VwLmVhY2hMYXllcihmdW5jdGlvbihsYXllcikge1xuICAgICAgICBpZiAoTUFTQ1AuZ2V0R3JvdXAobGF5ZXIpID09PSBsYXllcikge1xuICAgICAgICAgICAgLy8gV2UgY2FuIHNraXAgZXhwbGljaXRseSBzZXR0aW5nIHRoZSB2aXNpYmlsaXR5IG9mIGdyb3VwcyBoZXJlLCBzaW5jZVxuICAgICAgICAgICAgLy8gYW55IHN1Yi1ncm91cHMgc2hvdWxkIGhhdmUgYSBjb250cm9sbGVyLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkICYmIHZpc2liaWxpdHkpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLmhpZGVMYXllcihsYXllci5uYW1lKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmlzaWJpbGl0eSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmVuZGVyZXIuc2hvd0xheWVyKGxheWVyLm5hbWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHZpc2liaWxpdHkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZW5kZXJlci5oaWRlTGF5ZXIobGF5ZXIubmFtZSk7ICAgICAgICAgICAgICAgIFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVuZGVyZXIudG9nZ2xlTGF5ZXIobGF5ZXIubmFtZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAodmlzaWJpbGl0eSAhPT0gbnVsbCAmJiAhIGNvbnN1bWVDaGFuZ2UpIHtcbiAgICAgICAgYmVhbi5maXJlKGdyb3VwLCd2aXNpYmlsaXR5Q2hhbmdlJyxbcmVuZGVyZXIsdmlzaWJpbGl0eV0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogSGlkZSBhIGdyb3VwLiBGaXJlcyBhbiBldmVudCB3aGVuIHRoaXMgbWV0aG9kIGlzIGNhbGxlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBncnAgR3JvdXAgdG8gc2V0IHRoZSB2aXNpYmlsaXR5IGZvclxuICogQHNlZSBNQVNDUC5Hcm91cCNldmVudDp2aXNpYmlsaXR5Q2hhbmdlXG4gKi9cblNlcXVlbmNlUmVuZGVyZXIucHJvdG90eXBlLmhpZGVHcm91cCA9IGZ1bmN0aW9uKGdyb3VwLGNvbnN1bWVDaGFuZ2UpIHtcbiAgICB0aGlzLnNldEdyb3VwVmlzaWJpbGl0eShncm91cCxmYWxzZSxjb25zdW1lQ2hhbmdlKTtcbn07XG5cbi8qKlxuICogU2hvdyBhIGdyb3VwLiBGaXJlcyBhbiBldmVudCB3aGVuIHRoaXMgbWV0aG9kIGlzIGNhbGxlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBncnAgR3JvdXAgdG8gc2V0IHRoZSB2aXNpYmlsaXR5IGZvclxuICogQHNlZSBNQVNDUC5Hcm91cCNldmVudDp2aXNpYmlsaXR5Q2hhbmdlXG4gKi9cblNlcXVlbmNlUmVuZGVyZXIucHJvdG90eXBlLnNob3dHcm91cCA9IGZ1bmN0aW9uKGdyb3VwLGNvbnN1bWVDaGFuZ2UpIHtcbiAgICB0aGlzLnNldEdyb3VwVmlzaWJpbGl0eShncm91cCx0cnVlLGNvbnN1bWVDaGFuZ2UpO1xufTtcblxuLyoqXG4gKiBUb2dnbGUgdGhlIHZpc2liaWxpdHkgZm9yIGEgZ3JvdXAuIEZpcmVzIGFuIGV2ZW50IHdoZW4gdGhpcyBtZXRob2QgaXMgY2FsbGVkLlxuICogQHBhcmFtIHtPYmplY3R9IGdycCBHcm91cCB0byBzZXQgdGhlIHZpc2liaWxpdHkgZm9yXG4gKiBAc2VlIE1BU0NQLkdyb3VwI2V2ZW50OnZpc2liaWxpdHlDaGFuZ2VcbiAqL1xuU2VxdWVuY2VSZW5kZXJlci5wcm90b3R5cGUudG9nZ2xlR3JvdXAgPSBmdW5jdGlvbihncm91cCxjb25zdW1lQ2hhbmdlKSB7XG4gICAgdGhpcy5zZXRHcm91cFZpc2liaWxpdHkoZ3JvdXAsY29uc3VtZUNoYW5nZSk7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBsYXllciBpcyBhY3RpdmVcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gbGF5ZXIgTGF5ZXIgbmFtZSwgb3IgbGF5ZXIgb2JqZWN0XG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoaXMgbGF5ZXIgaXMgYWN0aXZlIG9uIHRoaXMgcmVuZGVyZXJcbiAqIEB0eXBlIEJvb2xlYW5cbiAqL1xuU2VxdWVuY2VSZW5kZXJlci5wcm90b3R5cGUuaXNMYXllckFjdGl2ZSA9IGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgdmFyIGxheWVyTmFtZSA9IGxheWVyO1xuICAgIGlmICh0eXBlb2YgbGF5ZXIgIT0gJ3N0cmluZycpIHtcbiAgICAgICAgbGF5ZXJOYW1lID0gbGF5ZXIubmFtZTtcbiAgICB9XG4gICAgcmV0dXJuICghIGxheWVyLmRpc2FibGVkKSAmJiB0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0LmNvbnRhaW5zKGxheWVyTmFtZSsnX2FjdGl2ZScpO1xufTtcblxuLyoqXG4gKiBEZXByZWNhdGVkIHVudGlsIHRoZXJlJ3MgYSBiZXR0ZXIgaW1wbGVtZW50YXRpb24gZm9yIHRoZSBDb25kZW5zZWRTZXF1ZW5jZVJlbmRlcmVyXG4gKiBAcHJpdmF0ZVxuICovXG5cblNlcXVlbmNlUmVuZGVyZXIucHJvdG90eXBlLl9zZXRIaWdobGlnaHQgPSBmdW5jdGlvbihsYXllcixpc0hpZ2hsaWdodGVkKSB7XG4gICAgcmV0dXJuO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBsYXllciBjb250cm9sbGVyIGZvciB0aGlzIHNlcXVlbmNlIHJlbmRlcmVyLiBBdHRhY2ggdGhlIGNvbnRyb2xsZXIgdG8gdGhlIGNvbnRhaW5pbmcgYm94LCBhbmQgc2hpZnQgdGhlIGJveCBhY3Jvc3MgMjBweC5cbiAqL1xuU2VxdWVuY2VSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlTGF5ZXJDb250cm9sbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgY29uc29sZS5sb2coXCJjcmVhdGVMYXllckNvbnRyb2xsZXIgaXMgZGVwcmVjdGVkXCIpO1xuICAgIHJldHVybjtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgY2hlY2tib3ggdGhhdCBpcyB1c2VkIHRvIGNvbnRyb2wgdGhlIGdpdmVuIGxheWVyXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGxheWVyIExheWVyIG5hbWUgb3IgbGF5ZXIgb2JqZWN0IHRoYXQgYSBjb250cm9sbGVyIHNob3VsZCBiZSBnZW5lcmF0ZWQgZm9yXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRFbGVtZW50IE9wdGlvbmFsIGlucHV0IGVsZW1lbnQgdG8gYmluZCBldmVudHMgdG8uIElmIG5vIGVsZW1lbnQgaXMgZ2l2ZW4sIGEgbmV3IG9uZSBpcyBjcmVhdGVkLlxuICogQHJldHVybnMgQ2hlY2tib3ggZWxlbWVudCB0aGF0IHdoZW4gY2hlY2tlZCB3aWxsIHRvZ2dsZSBvbiB0aGUgbGF5ZXIsIGFuZCB0b2dnbGUgaXQgb2ZmIHdoZW4gdW5jaGVja2VkXG4gKiBAdHlwZSBPYmplY3RcbiAqL1xuU2VxdWVuY2VSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlTGF5ZXJDaGVja2JveCA9IGZ1bmN0aW9uKGxheWVyLGlucHV0RWxlbWVudCxleGNsdXNpdmUpIHtcbiAgICBjb25zb2xlLmxvZyhcImNyZWF0ZUxheWVyQ2hlY2tib3ggaXMgZGVwcmVjYXRlZFwiKTtcbiAgICByZXR1cm47XG59O1xuXG5cblNlcXVlbmNlUmVuZGVyZXIucHJvdG90eXBlLl9yZW1vdmVPdGhlckJpbmRpbmdzID0gZnVuY3Rpb24ob2JqZWN0LGlucHV0RWxlbWVudCkge1xuICAgIHZhciByZW5kZXJlciA9IHRoaXM7XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dEVsZW1lbnQuX2N1cnJlbnRfYmluZGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCBpbnB1dEVsZW1lbnQuX2N1cnJlbnRfYmluZGluZ3NbaV0ucmVuZGVyZXIgIT0gcmVuZGVyZXIgKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2IgPSBpbnB1dEVsZW1lbnQuX2N1cnJlbnRfYmluZGluZ3NbaV07XG4gICAgICAgIFxuICAgICAgICBpZiAoIGNiLmxheWVyICYmIGNiLmxheWVyICE9IG9iamVjdC5uYW1lICkge1xuICAgICAgICAgICAgYmVhbi5yZW1vdmUoTUFTQ1AuZ2V0TGF5ZXIoY2IubGF5ZXIpLCd2aXNpYmlsaXR5Q2hhbmdlJyxjYi5vYmplY3RfZnVuY3Rpb24pO1xuICAgICAgICAgICAgYmVhbi5yZW1vdmUoaW5wdXRFbGVtZW50LCdjaGFuZ2UnLGNiLmlucHV0X2Z1bmN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKCBjYi5ncm91cCAmJiBjYi5ncm91cCAhPSBvYmplY3QubmFtZSApIHtcbiAgICAgICAgICAgIGJlYW4ucmVtb3ZlKE1BU0NQLmdldEdyb3VwKGNiLmdyb3VwKSwndmlzaWJpbGl0eUNoYW5nZScsY2Iub2JqZWN0X2Z1bmN0aW9uKTtcbiAgICAgICAgICAgIGJlYW4ucmVtb3ZlKGlucHV0RWxlbWVudCwnY2hhbmdlJyxjYi5pbnB1dF9mdW5jdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgY2IuZ3JvdXAgPSBudWxsO1xuICAgICAgICBjYi5sYXllciA9IG51bGw7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBsYXllciBiYXNlZCBjb250cm9sbGVyIGZvciBhIGdyb3VwLiBUaGlzIGxheWVyIGNhbiBhY3QgYXMgYSBwcm94eSBmb3IgdGhlIG90aGVyIGxheWVyc1xuICogQHBhcmFtIHtPYmplY3R9IGxheSBMYXllciB0byB0dXJuIGludG8gYSBncm91cCBjb250cm9sbGVyXG4gKiBAcGFyYW0ge09iamVjdH0gZ3JwIEdyb3VwIHRvIGJlIGNvbnRyb2xsZWQgYnkgdGhpcyBsYXllci5cbiAqL1xuXG5TZXF1ZW5jZVJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVHcm91cENvbnRyb2xsZXIgPSBmdW5jdGlvbihsYXksZ3JwKSB7XG4gICAgdmFyIGxheWVyID0gTUFTQ1AuZ2V0TGF5ZXIobGF5KTtcbiAgICB2YXIgZ3JvdXAgPSBNQVNDUC5nZXRHcm91cChncnApO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGJlYW4uYWRkKGxheWVyLCd2aXNpYmlsaXR5Q2hhbmdlJyxmdW5jdGlvbihyZW5kLHZpc2libGUpIHtcbiAgICAgICAgaWYgKHJlbmQgPT0gc2VsZikge1xuICAgICAgICAgICAgc2VsZi5zZXRHcm91cFZpc2liaWxpdHkoZ3JvdXAsIHZpc2libGUpO1xuICAgICAgICAgICAgc2VsZi5yZWZyZXNoKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8qKlxuICogRnVuY3Rpb24gdG8gYmUgYWRkZWQgdG8gQW1pbm8gYWNpZCBlbGVtZW50cyB0byBmYWNpbGl0YXRlIGFkZGluZyBlbGVtZW50cyB0byBsYXllcnNcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gbGF5ZXJOYW1lIFRoZSBsYXllciB0aGF0IHRoaXMgYW1pbm8gYWNpZCBzaG91bGQgYmUgYWRkZWQgdG9cbiAqIEByZXR1cm5zIEl0c2VsZlxuICogQHR5cGUgRWxlbWVudFxuICovXG5TZXF1ZW5jZVJlbmRlcmVyLmFkZEVsZW1lbnRUb0xheWVyID0gZnVuY3Rpb24obGF5ZXJOYW1lKVxue1xuICAgIHRoaXMuYWRkQm94T3ZlcmxheShsYXllck5hbWUsMSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEZ1bmN0aW9uIHRvIGJlIGFkZGVkIHRvIEFtaW5vIGFjaWQgZWxlbWVudHMgdG8gZmFjaWxpdGF0ZSBhZGRpbmcgZWxlbWVudHMgdG8gbGF5ZXJzIHdpdGggYSBsaW5rXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IGxheWVyTmFtZSBUaGUgbGF5ZXIgdGhhdCB0aGlzIGFtaW5vIGFjaWQgc2hvdWxkIGJlIGFkZGVkIHRvXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsIFVSTCB0byBsaW5rIHRvXG4gKiBAcmV0dXJucyBJdHNlbGZcbiAqIEB0eXBlIEVsZW1lbnRcbiAqL1xuU2VxdWVuY2VSZW5kZXJlci5hZGRFbGVtZW50VG9MYXllcldpdGhMaW5rID0gZnVuY3Rpb24obGF5ZXJOYW1lLCB1cmwsIHdpZHRoKVxue1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChsYXllck5hbWUpO1xuICAgIHZhciBhbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgYW5jaG9yLnNldEF0dHJpYnV0ZSgnaHJlZicsdXJsKTtcbiAgICBhbmNob3IuY2xhc3NMaXN0LmFkZChsYXllck5hbWUrJ19vdmVybGF5Jyk7XG4gICAgYW5jaG9yLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCdkaXNwbGF5OiBib3g7IGxlZnQ6IDBweDsgdG9wOiAwcHg7IHdpZHRoOiAxMDAlOyBwb3NpdGlvbjogYWJzb2x1dGU7IGhlaWdodDogMTAwJTsnKTtcbiAgICBhbmNob3IudGV4dENvbnRlbnQgPSAnJm5ic3A7JztcbiAgICB0aGlzLmFwcGVuZENoaWxkKGFuY2hvcik7XG4gICAgd2hpbGUgKHdpZHRoICYmIHdpZHRoID4gMCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5fc2VxdWVuY2VfZWxzW3RoaXMuX2luZGV4ICsgd2lkdGhdLmFkZFRvTGF5ZXJXaXRoTGluayhsYXllck5hbWUsdXJsKTtcbiAgICAgICAgd2lkdGggLT0gMTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3pfaW5kZXhlcyAmJiB0aGlzLl96X2luZGV4ZXNbbGF5ZXJOYW1lXSkge1xuICAgICAgICBhbmNob3Iuc3R5bGUuekluZGV4ID0gdGhpcy5fel9pbmRleGVzW2xheWVyTmFtZV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzOyAgICBcbn07XG5cbi8qKlxuICogRnVuY3Rpb24gdG8gYmUgYWRkZWQgdG8gQW1pbm8gYWNpZCBlbGVtZW50cyB0byBmYWNpbGl0YXRlIGFkZGluZyBib3ggb3ZlcmxheXMgdG8gZWxlbWVudHNcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gbGF5ZXJOYW1lIFRoZSBsYXllciB0aGF0IHRoaXMgYW1pbm8gYWNpZCBzaG91bGQgYmUgYWRkZWQgdG8sIGFzIHdlbGwgYXMgdGhlIGZyYWN0aW9uIG9wYWNpdHkgdG8gdXNlIGZvciB0aGlzIG92ZXJsYXlcbiAqIEByZXR1cm5zIEl0c2VsZlxuICogQHR5cGUgRWxlbWVudFxuICovXG5TZXF1ZW5jZVJlbmRlcmVyLmFkZEJveE92ZXJsYXlUb0VsZW1lbnQgPSBmdW5jdGlvbihsYXllck5hbWUsIHdpZHRoLCBmcmFjdGlvbilcbntcbiAgICBpZiAodHlwZW9mIGZyYWN0aW9uID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGZyYWN0aW9uID0gMTtcbiAgICB9XG5cbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQobGF5ZXJOYW1lKTtcbiAgICB2YXIgbmV3X2VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgbmV3X2VsLmNsYXNzTGlzdC5hZGQobGF5ZXJOYW1lKydfb3ZlcmxheScpO1xuICAgIG5ld19lbC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywndG9wOiAwcHg7IHdpZHRoOiAxMDAlOyBwb3NpdGlvbjogYWJzb2x1dGU7IGhlaWdodDogMTAwJTsgb3BhY2l0eTonK2ZyYWN0aW9uKyc7Jyk7XG4gICAgdGhpcy5hcHBlbmRDaGlsZChuZXdfZWwpO1xuICAgIHdoaWxlICh3aWR0aCAmJiB3aWR0aCA+IDEpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuX3NlcXVlbmNlX2Vsc1t0aGlzLl9pbmRleCArIHdpZHRoIC0gMV0uYWRkQm94T3ZlcmxheShsYXllck5hbWUsMCxmcmFjdGlvbik7XG4gICAgICAgIHdpZHRoIC09IDE7XG4gICAgfVxuICAgIGlmICh0aGlzLl96X2luZGV4ZXMgJiYgdGhpcy5fel9pbmRleGVzW2xheWVyTmFtZV0pIHtcbiAgICAgICAgbmV3X2VsLnN0eWxlLnpJbmRleCA9IHRoaXMuX3pfaW5kZXhlc1tsYXllck5hbWVdO1xuICAgIH1cbiAgICB2YXIgZXZlbnRfbmFtZXMgPSBbJ21vdXNlb3ZlcicsJ21vdXNlZG93bicsJ21vdXNlbW92ZScsJ21vdXNlb3V0JywnY2xpY2snLCdkYmxjbGljaycsJ21vdXNldXAnLCdtb3VzZWVudGVyJywnbW91c2VsZWF2ZSddO1xuICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IGV2ZW50X25hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJlYW4uYWRkKG5ld19lbCxldmVudF9uYW1lc1tpXSxmdW5jdGlvbigpIHsgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGJlYW4uZmlyZShNQVNDUC5nZXRMYXllcihsYXllck5hbWUpLGUudHlwZSxbZSwnU2VxdWVuY2VSZW5kZXJlciddKTtcbiAgICAgICAgfTt9KGkpKTtcbiAgICB9ICAgIFxuICAgIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqIFJlc2V0IHRoaXMgcmVuZGVyZXIuIEhpZGUgYWxsIGdyb3VwcyBhbmQgbGF5ZXJzLCBkaXNhYmxpbmcgdGhlbSBpbiB0aGUgcmVnaXN0cnkuXG4gKi9cblNlcXVlbmNlUmVuZGVyZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKVxue1xuICAgIHdoaWxlKHRoaXMuX2NvbnRhaW5lci5jbGFzc0xpc3QubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0Lml0ZW0oMCkpO1xuICAgIH1cbiAgICBmb3IgKCB2YXIgZ3JvdXAgaW4gTUFTQ1AuZ3JvdXBzKSB7XG4gICAgICAgIGlmIChNQVNDUC5ncm91cHMuaGFzT3duUHJvcGVydHkoZ3JvdXApKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGVHcm91cChncm91cCk7XG4gICAgICAgIH1cbiAgICB9ICAgIFxuICAgIGZvciAoIHZhciBsYXllciBpbiBNQVNDUC5sYXllcnMpIHtcbiAgICAgICAgaWYgKE1BU0NQLmxheWVycy5oYXNPd25Qcm9wZXJ0eShsYXllcikpIHtcbiAgICAgICAgICAgIGlmICggISB0aGlzLmtlZXB0cmFja3MgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlTGF5ZXIobGF5ZXIsdHJ1ZSk7XG4gICAgICAgICAgICAgICAgTUFTQ1AubGF5ZXJzW2xheWVyXS5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZXNldEFubm90YXRpb25zKSB7XG4gICAgICAgIHRoaXMucmVzZXRBbm5vdGF0aW9ucygpO1xuICAgIH1cbiAgICBcbn07XG5cbi8qKlxuICogRXhlY3V0ZSB0aGUgZ2l2ZW4gYmxvY2sgb2YgY29kZSAoaW4gdGhlIHJlbmRlcmVyIGNvbnRleHQpIG1vdmluZyB0aGUgcmVmcmVzaCBtZXRob2QgYXdheSBzbyB0aGF0IGl0IGlzIG5vdCBjYWxsZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgRnVuY3Rpb24gdGhhdCBjb250YWlucyBvcGVyYXRpb25zIHRvIHJ1biB3aXRob3V0IHJlZnJlc2hpbmcgdGhlIHJlbmRlcmVyXG4gKi9cblNlcXVlbmNlUmVuZGVyZXIucHJvdG90eXBlLndpdGhvdXRSZWZyZXNoID0gZnVuY3Rpb24oZnVuYylcbntcbiAgICB2YXIgY3Vycl9yZWZyZXNoID0gdGhpcy5yZWZyZXNoO1xuICAgIHRoaXMucmVmcmVzaCA9IGZ1bmN0aW9uKCkge307XG4gICAgdGhpcy5yZWZyZXNoLnN1c3BlbmRlZCA9IHRydWU7XG4gICAgZnVuYy5hcHBseSh0aGlzKTtcbiAgICB0aGlzLnJlZnJlc2ggPSBjdXJyX3JlZnJlc2g7XG59O1xuXG4vKipcbiAqIFJlZnJlc2ggdGhlIGRpc3BsYXkgZm9yIHRoaXMgc2VxdWVuY2UgcmVuZGVyZXJcbiAqL1xuU2VxdWVuY2VSZW5kZXJlci5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uKClcbntcbiAgICB2YXIgel9pbmRleCA9IC0yO1xuICAgIGlmICggISB0aGlzLl96X2luZGV4ZXMpIHtcbiAgICAgICAgdGhpcy5fel9pbmRleGVzID0ge307XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgKHRoaXMudHJhY2tPcmRlciB8fCBbXSkubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgIGlmICghIHRoaXMuaXNMYXllckFjdGl2ZSh0aGlzLnRyYWNrT3JkZXJbaV0pKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuJyt0aGlzLnRyYWNrT3JkZXJbaV0rJ19vdmVybGF5JykpLmZvckVhY2goZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgIGVsLnN0eWxlLnpJbmRleCA9IHpfaW5kZXg7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl96X2luZGV4ZXNbdGhpcy50cmFja09yZGVyW2ldXSA9IHpfaW5kZXg7XG4gICAgICAgIHpfaW5kZXggLT0gMTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEJpbmQgYSBmdW5jdGlvbiB0byBleGVjdXRlIG9uIGEgcGFydGljdWxhciBldmVudCBmb3IgdGhpcyBvYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBldiBFdmVudCBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIEZ1bmN0aW9uIHRvIGV4ZWN1dGVcbiAqL1xuXG5TZXF1ZW5jZVJlbmRlcmVyLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24oZXYsZnVuYylcbntcbiAgICBiZWFuLmFkZCh0aGlzLGV2LGZ1bmMpO1xufTtcblxuU2VxdWVuY2VSZW5kZXJlci5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24oZXYsZnVuYylcbntcbiAgICBiZWFuLnJlbW92ZSh0aGlzLGV2LGZ1bmMpO1xufTtcblxuXG5TZXF1ZW5jZVJlbmRlcmVyLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24oZXYsYXJncylcbntcbiAgICBiZWFuLmZpcmUodGhpcyxldixhcmdzKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFNlcXVlbmNlUmVuZGVyZXI7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUFJQTtBQUNBO0FBR0E7Ozs7Ozs7OztBQVFBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQWxEQTtBQUNBO0FBb0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBUUE7Ozs7Ozs7O0FBUUE7Ozs7Ozs7QUFPQTs7Ozs7Ozs7QUFRQTs7Ozs7Ozs7QUFRQTs7Ozs7Ozs7QUFVQTs7Ozs7O0FBSUE7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFHQTs7Ozs7OztBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBT0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7OztBQVFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFPQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTs7Ozs7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTs7Ozs7O0FBSUE7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBR0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQU1BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../gator/js/lib/SequenceRenderer.js\n")},"../gator/js/lib/Service.js":
/*!**********************************!*\
  !*** ../gator/js/lib/Service.js ***!
  \**********************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _bean__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../bean */ "../gator/js/bean.js");\n/* harmony import */ var _jsandbox__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../jsandbox */ "../gator/js/jsandbox.js");\n/* harmony import */ var _MASCP__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MASCP */ "../gator/js/lib/MASCP.js");\n//"use strict";\n\n\n\n/** Default constructor for Services\n *  @class      Super-class for all MASCP services to retrieve data from\n *              proteomic databases. Sub-classes of this class override methods\n *              to change how requests are built, and how the data is parsed.\n *  @param      {String}    agi             AGI to retrieve data for\n *  @param      {String}    endpointURL     Endpoint for the service\n */\n\nconst Service = function Service(agi, endpointURL) {};\n/** Build a data retrieval class that uses the given function to extract result data.\n *  @static\n *  @param  {Function}  dataExtractor   Function to extract data from the resultant data (passed as an argument\n *                                      to the function), and then populate the result object. The function is\n *                                      bound to a hash to populate data in to. When no data is passed to the\n *                                      function, the hash should be populated with default values.\n */\n\n\nlet resultsymb = Symbol(\'resultclass\');\n\nService.buildService = function (dataExtractor) {\n  let clazz = class extends Service {\n    constructor(agi, endpointURL) {\n      super();\n\n      if (typeof endpointURL != \'undefined\') {\n        this._endpointURL = endpointURL;\n      } else {\n        this._endpointURL = clazz.SERVICE_URL;\n      }\n\n      this.agi = agi;\n      return this;\n    }\n\n    toString() {\n      for (var serv in _MASCP__WEBPACK_IMPORTED_MODULE_2__["default"]) {\n        if (this === _MASCP__WEBPACK_IMPORTED_MODULE_2__["default"][serv]) {\n          return "MASCP." + serv;\n        }\n      }\n    }\n\n    get Result() {\n      return this[resultsymb] || this.constructor.Result;\n    }\n\n    set Result(resultclass) {\n      this[resultsymb] = resultclass;\n    }\n\n  };\n  clazz.Result = class {\n    constructor(data) {\n      dataExtractor.apply(this, [data]);\n      return this;\n    }\n\n  };\n  Object.assign(dataExtractor.apply({}, []), clazz.Result.prototype);\n  return clazz;\n};\n\nService.clone = function (service, name) {\n  var new_service = Service.buildService(function () {\n    return this;\n  });\n  new_service.Result = service.Result;\n  new_service.prototype = new service();\n  _MASCP__WEBPACK_IMPORTED_MODULE_2__["default"][name] = new_service;\n  new_service.prototype[\'__class__\'] = new_service;\n  return new_service;\n};\n/**\n *  @lends Service.prototype\n *  @property   {String}  agi               AGI to retrieve data for\n *  @property   {Service.Result}  result  Result from the query\n *  @property   {Boolean} async             Flag for using asynchronous requests - defaults to true\n */\n\n\nService.prototype = Object.assign({\n  \'agi\': null,\n  \'result\': null,\n  \'async\': true\n}, Service.prototype);\n/*\n * Internal callback for new data coming in from a XHR\n * @private\n */\n\nService.prototype._dataReceived = function (data, status) {\n  if (!data) {\n    return false;\n  }\n\n  var clazz = this.Result;\n\n  if (data && data.error && data.error != \'\' && data.error !== null) {\n    _bean__WEBPACK_IMPORTED_MODULE_0__["default"].fire(this, \'error\', [data.error]);\n    return false;\n  }\n\n  if (Object.prototype.toString.call(data) === \'[object Array]\') {\n    for (var i = 0; i < data.length; i++) {\n      arguments.callee.call(this, data[i], status);\n    }\n\n    if (i === 0) {\n      this.result = new clazz();\n    }\n\n    this.result._raw_data = {\n      \'data\': data\n    };\n  } else if (!this.result) {\n    var result;\n\n    try {\n      result = new clazz(data);\n    } catch (err2) {\n      _bean__WEBPACK_IMPORTED_MODULE_0__["default"].fire(this, \'error\', [err2]);\n      return false;\n    }\n\n    if (!result._raw_data) {\n      result._raw_data = data;\n    }\n\n    this.result = result;\n  } else {\n    // var new_result = {};\n    try {\n      clazz.call(this.result, data);\n    } catch (err3) {\n      _bean__WEBPACK_IMPORTED_MODULE_0__["default"].fire(this, \'error\', [err3]);\n      return false;\n    } // for(var field in new_result) {\n    //     if (true && new_result.hasOwnProperty(field)) {\n    //         this.result[field] = new_result[field];\n    //     }\n    // }\n\n\n    if (!this.result._raw_data) {\n      this.result._raw_data = data;\n    } // this.result._raw_data = data;\n\n  }\n\n  if (data && data.retrieved) {\n    this.result.retrieved = data.retrieved;\n    this.result._raw_data.retrieved = data.retrieved;\n  }\n\n  this.result.agi = this.agi;\n  return true;\n};\n\nService.prototype.gotResult = function () {\n  var self = this;\n\n  var reader_cache = function reader_cache(thing) {\n    if (!thing.readers) {\n      thing.readers = [];\n    }\n\n    thing.readers.push(self.toString());\n  };\n\n  _bean__WEBPACK_IMPORTED_MODULE_0__["default"].add(_MASCP__WEBPACK_IMPORTED_MODULE_2__["default"], \'layerRegistered\', reader_cache);\n  _bean__WEBPACK_IMPORTED_MODULE_0__["default"].add(_MASCP__WEBPACK_IMPORTED_MODULE_2__["default"], \'groupRegistered\', reader_cache);\n  _bean__WEBPACK_IMPORTED_MODULE_0__["default"].fire(self, "resultReceived");\n\n  try {\n    _bean__WEBPACK_IMPORTED_MODULE_0__["default"].remove(_MASCP__WEBPACK_IMPORTED_MODULE_2__["default"], \'layerRegistered\', reader_cache);\n    _bean__WEBPACK_IMPORTED_MODULE_0__["default"].remove(_MASCP__WEBPACK_IMPORTED_MODULE_2__["default"], \'groupRegistered\', reader_cache);\n  } catch (e) {}\n\n  _bean__WEBPACK_IMPORTED_MODULE_0__["default"].fire(Service, "resultReceived");\n};\n\nService.prototype.requestComplete = function () {\n  _bean__WEBPACK_IMPORTED_MODULE_0__["default"].fire(this, \'requestComplete\');\n  _bean__WEBPACK_IMPORTED_MODULE_0__["default"].fire(Service, \'requestComplete\', [this]);\n};\n\nService.prototype.requestIncomplete = function () {\n  _bean__WEBPACK_IMPORTED_MODULE_0__["default"].fire(this, \'requestIncomplete\');\n  _bean__WEBPACK_IMPORTED_MODULE_0__["default"].fire(Service, \'requestIncomplete\', [this]);\n};\n\nService.registeredLayers = function (service) {\n  var result = [];\n\n  for (var layname in _MASCP__WEBPACK_IMPORTED_MODULE_2__["default"].layers) {\n    if (_MASCP__WEBPACK_IMPORTED_MODULE_2__["default"].layers.hasOwnProperty(layname)) {\n      var layer = _MASCP__WEBPACK_IMPORTED_MODULE_2__["default"].layers[layname];\n\n      if (layer.readers && layer.readers.indexOf(service.toString()) >= 0) {\n        result.push(layer);\n      }\n    }\n  }\n\n  return result;\n};\n\nService.registeredGroups = function (service) {\n  var result = [];\n\n  for (var nm in _MASCP__WEBPACK_IMPORTED_MODULE_2__["default"].groups) {\n    if (_MASCP__WEBPACK_IMPORTED_MODULE_2__["default"].groups.hasOwnProperty(nm)) {\n      var group = _MASCP__WEBPACK_IMPORTED_MODULE_2__["default"].groups[nm];\n\n      if (group.readers && group.readers.indexOf(service.toString()) >= 0) {\n        result.push(group);\n      }\n    }\n  }\n\n  return result;\n};\n/**\n *  Binds a handler to one or more events. Returns a reference to self, so this method\n *  can be chained.\n *\n *  @param  {String}    type        Event type to bind\n *  @param  {Function}  function    Handler to execute on event\n */\n\n\nService.prototype.bind = function (type, func) {\n  _bean__WEBPACK_IMPORTED_MODULE_0__["default"].add(this, type, func);\n  return this;\n};\n\nService.prototype.once = function (type, func) {\n  var self = this;\n\n  var wrapped_func = function wrapped_func() {\n    _bean__WEBPACK_IMPORTED_MODULE_0__["default"].remove(self, type, wrapped_func);\n    func.apply(self, [].slice.call(arguments));\n  };\n\n  self.bind(type, wrapped_func);\n};\n/**\n *  Unbinds a handler from one or more events. Returns a reference to self, so this method\n *  can be chained.\n *\n *  @param  {String}    type        Event type to unbind\n *  @param  {Function}  function    Handler to unbind from event\n */\n\n\nService.prototype.unbind = function (type, func) {\n  _bean__WEBPACK_IMPORTED_MODULE_0__["default"].remove(this, type, func);\n  return this;\n};\n/**\n * @name    Service#resultReceived\n * @event\n * @param   {Object}    e\n */\n\n/**\n * @name    Service#error\n * @event\n * @param   {Object}    e\n */\n\n/**\n *  Asynchronously retrieves data from the remote source. When data is received, a \n *  resultReceived.mascp event is triggered upon this service, while an error.mascp\n *  event is triggered when an error occurs. This method returns a reference to self\n *  so it can be chained.\n */\n\n\n(function (base) {\n  var make_params = function make_params(params) {\n    var qpoints = [];\n\n    for (var fieldname in params) {\n      if (params.hasOwnProperty(fieldname)) {\n        qpoints.push(fieldname + \'=\' + params[fieldname]);\n      }\n    }\n\n    return qpoints.join(\'&\');\n  };\n\n  var cached_requests = {};\n\n  var do_request = function do_request(request_data) {\n    request_data.async = true;\n    var datablock = null;\n\n    if (!request_data.url) {\n      request_data.success.call(null, null);\n      return;\n    }\n\n    var request = new XMLHttpRequest();\n\n    if (request_data.type == \'GET\' && request_data.data) {\n      var index_of_quest = request_data.url.indexOf(\'?\');\n\n      if (index_of_quest == request_data.url.length - 1) {\n        request_data.url = request_data.url.slice(0, -1);\n        index_of_quest = -1;\n      }\n\n      var has_question = index_of_quest >= 0 ? \'&\' : \'?\';\n      request_data.url = request_data.url.replace(/\\?$/, \'\') + has_question + make_params(request_data.data);\n    }\n\n    if (request_data.type == \'GET\' && request_data.session_cache) {\n      if (cached_requests[request_data.url]) {\n        cached_requests[request_data.url].then(function (data) {\n          request_data.success.call(null, data);\n        }).catch(function (error_args) {\n          request_data.error.apply(null, [null, request, error_args]);\n        });\n        return;\n      } else {\n        var success_callback = request_data.success;\n        var error_callback = request_data.error;\n        cached_requests[request_data.url] = new Promise(function (resolve, reject) {\n          request_data.success = function (data) {\n            resolve(data);\n          };\n\n          request_data.error = function (message, req, error_obj) {\n            reject([message, req, error_obj]);\n            delete cached_requests[request_data.url];\n          };\n        });\n        cached_requests[request_data.url].catch(function (error_args) {\n          error_callback.apply(null, error_args);\n        }).then(function (data) {\n          success_callback.call(null, data);\n        });\n      }\n    }\n\n    request.open(request_data.type, request_data.url, request_data.async);\n\n    if (request_data.type == \'POST\') {\n      request.setRequestHeader("Content-Type", request_data.content ? request_data.content : "application/x-www-form-urlencoded");\n      datablock = request_data.content ? request_data.data : make_params(request_data.data);\n    }\n\n    if (request.customUA) {\n      request.setRequestHeader(\'User-Agent\', request.customUA);\n    }\n\n    if (request_data.auth) {\n      request.setRequestHeader(\'Authorization\', \'Bearer \' + request_data.auth);\n    }\n\n    if (request_data.api_key) {\n      request.setRequestHeader(\'x-api-key\', request_data.api_key);\n    }\n\n    var redirect_counts = 5;\n\n    request.onreadystatechange = function (evt) {\n      if (request.readyState == 4) {\n        if (request.status >= 300 && request.status < 400 && redirect_counts > 0) {\n          var loc = request.getResponseHeader(\'location\').replace(/location:\\s+/, \'\');\n          redirect_counts = redirect_counts - 1;\n          request.open(\'GET\', loc, request_data.async);\n          request.send();\n          return;\n        }\n\n        if (request.status == 503) {\n          // Let\'s encode an exponential backoff\n          request.last_wait = (request_data.last_wait || 500) * 2;\n          setTimeout(function () {\n            request.open(request_data.type, request_data.url, request_data.async);\n\n            if (request_data.type == \'POST\') {\n              request.setRequestHeader("Content-Type", request_data.content ? request_data.content : "application/x-www-form-urlencoded");\n            }\n\n            if (request.customUA) {\n              request.setRequestHeader(\'User-Agent\', request.customUA);\n            }\n\n            request.send(datablock);\n          }, request_data.last_wait);\n          return;\n        }\n\n        if (request.status == 403) {\n          // Make sure our S3 buckets expose the Server header cross-origin\n          var server = request.getResponseHeader(\'Server\');\n\n          if (server === \'AmazonS3\') {\n            request_data.success.call(null, {\n              "error": "No data"\n            }, 403, request);\n            return;\n          }\n        }\n\n        if (request.status >= 200 && request.status < 300) {\n          var data_block;\n\n          if (request_data.dataType == \'xml\') {\n            data_block = typeof document !== \'undefined\' ? document.implementation.createDocument(null, "nodata", null) : {\n              \'getElementsByTagName\': function getElementsByTagName() {\n                return [];\n              }\n            };\n          } else {\n            data_block = {};\n          }\n\n          try {\n            var text = request.responseText;\n            data_block = request_data.dataType == \'xml\' ? request.responseXML : request_data.dataType == \'txt\' ? request.responseText : JSON.parse(request.responseText);\n          } catch (e) {\n            if (e.type == \'unexpected_eos\') {\n              request_data.success.call(null, {}, request.status, request);\n              return;\n            } else {\n              request_data.error.call(null, request.responseText, request, {\n                \'error\': e.type || e.message,\n                \'stack\': e\n              });\n              return;\n            }\n          }\n\n          if (request.status == 202 && data_block.status == "RUNNING") {\n            setTimeout(function () {\n              request.open(request_data.type, request_data.url, request_data.async);\n\n              if (request_data.type == \'POST\') {\n                request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");\n              }\n\n              if (request.customUA) {\n                request.setRequestHeader(\'User-Agent\', request.customUA);\n              }\n\n              request.send(datablock);\n            }, 5000);\n            return;\n          }\n\n          request_data.success.call(null, data_block, request.status, request);\n          data_block = null;\n        } else {\n          request_data.error.call(null, request.responseText, request, request.status);\n        }\n      }\n    };\n\n    if (_MASCP__WEBPACK_IMPORTED_MODULE_2__["default"].NETWORK_FAIL && _MASCP__WEBPACK_IMPORTED_MODULE_2__["default"].NETWORK_FAIL.enabled) {\n      setTimeout(function () {\n        console.log("Causing network failure");\n        request = {\n          \'onreadystatechange\': request.onreadystatechange\n        };\n        request.readyState = 4;\n        request.status = _MASCP__WEBPACK_IMPORTED_MODULE_2__["default"].NETWORK_FAIL.status || 500;\n        request.responseText = "Intercepted by Network Failure simulator";\n        request.onreadystatechange();\n      }, 1000);\n      return;\n    }\n\n    request.send(datablock);\n  };\n\n  Service.request = function (url, callback, noparse) {\n    var method = _MASCP__WEBPACK_IMPORTED_MODULE_2__["default"].IE ? do_request_ie : do_request;\n\n    if (_MASCP__WEBPACK_IMPORTED_MODULE_2__["default"].IE && !url.match(/^https?\\:/)) {\n      method = do_request;\n    }\n\n    var params;\n\n    if (!url) {\n      callback(null);\n      return;\n    }\n\n    if (typeof url == \'string\') {\n      params = {\n        async: true,\n        url: url,\n        timeout: 5000,\n        type: "GET",\n        error: function error(response, req, status) {\n          callback.call(null, {\n            "status": status\n          });\n        },\n        success: function success(data, status, xhr) {\n          callback.call(null, null, data);\n        }\n      };\n    } else if (url.hasOwnProperty(\'url\')) {\n      params = url;\n\n      params.success = function (data) {\n        callback.call(null, null, data);\n      };\n\n      params.error = function (resp, req, status) {\n        callback.call(null, {\n          "status": status\n        });\n      };\n    }\n\n    if (noparse) {\n      params.dataType = \'txt\';\n\n      if (noparse === "xml") {\n        params.dataType = \'xml\';\n      }\n    }\n\n    method.call(null, params);\n  };\n  /**\n   * Private method for performing a cross-domain request using Internet Explorer 8 and up. Adapts the \n   * parameters passed, and builds an XDR object. There is no support for a locking\n   * synchronous method to do these requests (that is required for Unit testing) so an alert box is used\n   * to provide the locking.\n   * @private\n   * @param {Object} dataHash Hash with the data and settings used to build the query.\n   */\n\n\n  var do_request_ie = function do_request_ie(dataHash) {\n    // Use XDR\n    var xdr = new XDomainRequest();\n    var loaded = false;\n    var counter = 0;\n\n    xdr.onerror = function (ev) {\n      dataHash.error(xdr, xdr, {\n        "message": "XDomainRequest error"\n      });\n    };\n\n    xdr.onprogress = function () {};\n\n    xdr.open("GET", dataHash.url + "?" + make_params(dataHash.data));\n\n    xdr.onload = function () {\n      loaded = true;\n\n      if (dataHash.dataType == \'xml\') {\n        var dom = new ActiveXObject("Microsoft.XMLDOM");\n        dom.async = false;\n        dom.loadXML(xdr.responseText);\n        dataHash.success(dom, \'success\', xdr);\n      } else if (dataHash.dataType == \'json\') {\n        var parsed = null;\n\n        try {\n          parsed = JSON.parse(xdr.responseText);\n        } catch (err) {\n          dataHash.error(xdr, xdr, {\n            "message": "JSON parsing error"\n          });\n        }\n\n        if (parsed) {\n          dataHash.success(parsed, \'success\', xdr);\n        }\n      } else {\n        dataHash.success(xdr.responseText, \'success\', xdr);\n      }\n    }; // We can\'t set the content-type on the parameters here to url-encoded form data.\n\n\n    setTimeout(function () {\n      xdr.send();\n    }, 0);\n\n    while (!dataHash.async && !loaded && counter < 3) {\n      alert("This browser does not support synchronous requests, click OK while we\'re waiting for data");\n      counter += 1;\n    }\n\n    if (!dataHash.async && !loaded) {\n      alert("No data");\n    }\n  };\n\n  let handle_request_success = function handle_request_success(data, status, xhr) {\n    Service._current_reqs -= 1;\n\n    if (xhr && xhr.status !== null && xhr.status === 0) {\n      _bean__WEBPACK_IMPORTED_MODULE_0__["default"].fire(this, "error", [{\n        "error": "Zero return status from request "\n      }]);\n      this.requestComplete();\n      return;\n    }\n\n    var received_flag = this._dataReceived(data, status);\n\n    if (received_flag) {\n      this.gotResult();\n    }\n\n    if (received_flag !== null && typeof received_flag !== \'undefined\') {\n      this.requestComplete();\n    } else {\n      this.requestIncomplete();\n    }\n  };\n\n  let handle_request_error = function handle_request_error(response, req, status) {\n    Service._current_reqs -= 1;\n\n    if (typeof status == \'string\') {\n      status = {\n        \'error\': status,\n        \'request\': req\n      };\n    }\n\n    if (!isNaN(status)) {\n      status = {\n        "error": "Reqeust error",\n        "status": status,\n        \'request\': req\n      };\n    }\n\n    _bean__WEBPACK_IMPORTED_MODULE_0__["default"].fire(this, "error", [status]);\n    _bean__WEBPACK_IMPORTED_MODULE_0__["default"].fire(Service, \'requestComplete\');\n    this.requestComplete();\n  };\n\n  let perform_request = function perform_request(request_data) {\n    if (request_data === false) {\n      return;\n    }\n\n    if (!request_data) {\n      _bean__WEBPACK_IMPORTED_MODULE_0__["default"].fire(this, "error", ["No request data"]);\n      _bean__WEBPACK_IMPORTED_MODULE_0__["default"].fire(Service, "requestComplete", [this]);\n      this.requestComplete();\n      return this;\n    }\n\n    var default_params = {\n      async: this.async,\n      url: request_data.url || this._endpointURL,\n      timeout: 5000,\n      error: handle_request_error.bind(this),\n      success: handle_request_success.bind(this)\n    };\n    default_params = Object.assign(request_data, default_params);\n    do_request(default_params);\n    Service._current_reqs += 1;\n  };\n\n  base.retrieve = function (agi, callback) {\n    var self = this;\n    Service._current_reqs = Service._current_reqs || 0;\n    Service._waiting_reqs = Service._waiting_reqs || 0;\n\n    if (Service.MAX_REQUESTS) {\n      var my_func = arguments.callee;\n\n      if (Service._current_reqs > Service.MAX_REQUESTS) {\n        Service._waiting_reqs += 1;\n        _bean__WEBPACK_IMPORTED_MODULE_0__["default"].add(Service, \'requestComplete\', function () {\n          _bean__WEBPACK_IMPORTED_MODULE_0__["default"].remove(this, \'requestComplete\', arguments.callee);\n          setTimeout(function () {\n            Service._waiting_reqs -= 1;\n            my_func.call(self, agi, callback);\n          }, 0);\n        });\n        return this;\n      }\n    }\n\n    if (agi) {\n      this.agi = agi;\n    }\n\n    if (agi && callback) {\n      this.agi = agi;\n      this.result = null;\n      var done_result = false;\n\n      var done_func = function done_func(err, obj) {\n        _bean__WEBPACK_IMPORTED_MODULE_0__["default"].remove(self, "resultReceived", done_func);\n        _bean__WEBPACK_IMPORTED_MODULE_0__["default"].remove(self, "error", done_func);\n        _bean__WEBPACK_IMPORTED_MODULE_0__["default"].remove(self, "requestComplete", done_func);\n\n        if (!done_result) {\n          if (err) {\n            callback.call(self, err);\n          } else {\n            callback.call(self);\n          }\n        }\n\n        done_result = true;\n      };\n\n      _bean__WEBPACK_IMPORTED_MODULE_0__["default"].add(self, "resultReceived", done_func);\n      _bean__WEBPACK_IMPORTED_MODULE_0__["default"].add(self, "error", done_func);\n      _bean__WEBPACK_IMPORTED_MODULE_0__["default"].add(self, "requestComplete", done_func);\n    }\n\n    var request_data = this.requestData();\n    Promise.resolve(request_data).then(perform_request.bind(this));\n    return this;\n  };\n})(Service.prototype);\n/**\n *  Get the parameters that will be used to build this request. Implementations of services will\n *  override this method, returning the parameters to be used to build the XHR.\n */\n\n\nService.prototype.requestData = function () {};\n\nService.prototype.toString = function () {\n  for (var clazz in _MASCP__WEBPACK_IMPORTED_MODULE_2__["default"]) {\n    if (this.__class__ == _MASCP__WEBPACK_IMPORTED_MODULE_2__["default"][clazz]) {\n      return "MASCP." + clazz;\n    }\n  }\n};\n/**\n * For this service, register a sequence rendering view so that the results can be marked up directly\n * on to a sequence. This method will do nothing if the service does not know how to render the \n * results onto the sequence.\n * @param {MASCP.SequenceRenderer} sequenceRenderer Sequence renderer object to render results upon\n */\n\n\nService.prototype.registerSequenceRenderer = function (sequenceRenderer, options) {\n  if (this.setupSequenceRenderer) {\n    this.renderers = this.renderers || [];\n    this.setupSequenceRenderer(sequenceRenderer, options);\n    this.renderers.push(sequenceRenderer);\n  }\n\n  sequenceRenderer.trigger(\'readerRegistered\', [this]);\n  return this;\n};\n\nService.prototype.resetOnResult = function (sequenceRenderer, rendered, track) {\n  var self = this;\n\n  var result_func = function result_func() {\n    self.unbind(\'resultReceived\', result_func);\n    sequenceRenderer.bind(\'resultsRendered\', clear_func);\n  };\n\n  var clear_func = function clear_func(reader) {\n    if (reader !== self) {\n      return;\n    }\n\n    sequenceRenderer.unbind(\'resultsRendered\', clear_func);\n    rendered.forEach(function (obj) {\n      sequenceRenderer.remove(track, obj);\n    });\n  };\n\n  this.bind(\'resultReceived\', result_func);\n};\n/**\n * For this service, set up a sequence renderer so that the events are connected up with receiving data.\n * This method should be overridden to wire up the sequence renderer to the service.\n * @param {MASCP.SequenceRenderer} sequenceRenderer Sequence renderer object to render results upon\n */\n\n\nService.prototype.setupSequenceRenderer = function (sequenceRenderer) {\n  return this;\n};\n/** Default constructor\n *  @class  Super-class for all results from MASCP services.\n */\n\n\nService.Result = function () {};\n\nService.Result.prototype = {\n  agi: null,\n  reader: null\n};\n\nService.Result.prototype.render = function () {};\n\n/* harmony default export */ __webpack_exports__["default"] = (Service);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vZ2F0b3IvanMvbGliL1NlcnZpY2UuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vZ2F0b3IvanMvbGliL1NlcnZpY2UuanM/Y2MxYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1widXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgYmVhbiBmcm9tICcuLi9iZWFuJztcbmltcG9ydCBKU2FuZGJveCBmcm9tICcuLi9qc2FuZGJveCc7XG5cbmltcG9ydCBNQVNDUCBmcm9tICcuL01BU0NQJztcblxuLyoqIERlZmF1bHQgY29uc3RydWN0b3IgZm9yIFNlcnZpY2VzXG4gKiAgQGNsYXNzICAgICAgU3VwZXItY2xhc3MgZm9yIGFsbCBNQVNDUCBzZXJ2aWNlcyB0byByZXRyaWV2ZSBkYXRhIGZyb21cbiAqICAgICAgICAgICAgICBwcm90ZW9taWMgZGF0YWJhc2VzLiBTdWItY2xhc3NlcyBvZiB0aGlzIGNsYXNzIG92ZXJyaWRlIG1ldGhvZHNcbiAqICAgICAgICAgICAgICB0byBjaGFuZ2UgaG93IHJlcXVlc3RzIGFyZSBidWlsdCwgYW5kIGhvdyB0aGUgZGF0YSBpcyBwYXJzZWQuXG4gKiAgQHBhcmFtICAgICAge1N0cmluZ30gICAgYWdpICAgICAgICAgICAgIEFHSSB0byByZXRyaWV2ZSBkYXRhIGZvclxuICogIEBwYXJhbSAgICAgIHtTdHJpbmd9ICAgIGVuZHBvaW50VVJMICAgICBFbmRwb2ludCBmb3IgdGhlIHNlcnZpY2VcbiAqL1xuY29uc3QgU2VydmljZSA9IGZ1bmN0aW9uKGFnaSxlbmRwb2ludFVSTCkge307XG5cbi8qKiBCdWlsZCBhIGRhdGEgcmV0cmlldmFsIGNsYXNzIHRoYXQgdXNlcyB0aGUgZ2l2ZW4gZnVuY3Rpb24gdG8gZXh0cmFjdCByZXN1bHQgZGF0YS5cbiAqICBAc3RhdGljXG4gKiAgQHBhcmFtICB7RnVuY3Rpb259ICBkYXRhRXh0cmFjdG9yICAgRnVuY3Rpb24gdG8gZXh0cmFjdCBkYXRhIGZyb20gdGhlIHJlc3VsdGFudCBkYXRhIChwYXNzZWQgYXMgYW4gYXJndW1lbnRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byB0aGUgZnVuY3Rpb24pLCBhbmQgdGhlbiBwb3B1bGF0ZSB0aGUgcmVzdWx0IG9iamVjdC4gVGhlIGZ1bmN0aW9uIGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmQgdG8gYSBoYXNoIHRvIHBvcHVsYXRlIGRhdGEgaW4gdG8uIFdoZW4gbm8gZGF0YSBpcyBwYXNzZWQgdG8gdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24sIHRoZSBoYXNoIHNob3VsZCBiZSBwb3B1bGF0ZWQgd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAqL1xuXG5sZXQgcmVzdWx0c3ltYiA9IFN5bWJvbCgncmVzdWx0Y2xhc3MnKTtcblxuU2VydmljZS5idWlsZFNlcnZpY2UgPSBmdW5jdGlvbihkYXRhRXh0cmFjdG9yKVxue1xuXG4gICAgbGV0IGNsYXp6ID0gY2xhc3MgZXh0ZW5kcyBTZXJ2aWNlIHtcbiAgICAgICAgY29uc3RydWN0b3IoYWdpLGVuZHBvaW50VVJMKSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmRwb2ludFVSTCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VuZHBvaW50VVJMID0gZW5kcG9pbnRVUkw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VuZHBvaW50VVJMID0gY2xhenouU0VSVklDRV9VUkw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFnaSA9IGFnaTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBzZXJ2IGluIE1BU0NQKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMgPT09IE1BU0NQW3NlcnZdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIk1BU0NQLlwiK3NlcnY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2V0IFJlc3VsdCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW3Jlc3VsdHN5bWJdIHx8IHRoaXMuY29uc3RydWN0b3IuUmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0IFJlc3VsdChyZXN1bHRjbGFzcykge1xuICAgICAgICAgICAgdGhpc1tyZXN1bHRzeW1iXSA9IHJlc3VsdGNsYXNzO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGNsYXp6LlJlc3VsdCA9IGNsYXNzIHtcbiAgICAgICAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgICAgICAgICAgZGF0YUV4dHJhY3Rvci5hcHBseSh0aGlzLFtkYXRhXSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBPYmplY3QuYXNzaWduKGRhdGFFeHRyYWN0b3IuYXBwbHkoe30sW10pLGNsYXp6LlJlc3VsdC5wcm90b3R5cGUpO1xuXG4gICAgcmV0dXJuIGNsYXp6O1xufTtcblxuU2VydmljZS5jbG9uZSA9IGZ1bmN0aW9uKHNlcnZpY2UsbmFtZSkge1xuICAgIHZhciBuZXdfc2VydmljZSA9IFNlcnZpY2UuYnVpbGRTZXJ2aWNlKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSk7XG4gICAgbmV3X3NlcnZpY2UuUmVzdWx0ID0gc2VydmljZS5SZXN1bHQ7XG4gICAgbmV3X3NlcnZpY2UucHJvdG90eXBlID0gbmV3IHNlcnZpY2UoKTtcbiAgICBNQVNDUFtuYW1lXSA9IG5ld19zZXJ2aWNlO1xuICAgIG5ld19zZXJ2aWNlLnByb3RvdHlwZVsnX19jbGFzc19fJ10gPSBuZXdfc2VydmljZTtcbiAgICByZXR1cm4gbmV3X3NlcnZpY2U7XG59O1xuXG5cbi8qKlxuICogIEBsZW5kcyBTZXJ2aWNlLnByb3RvdHlwZVxuICogIEBwcm9wZXJ0eSAgIHtTdHJpbmd9ICBhZ2kgICAgICAgICAgICAgICBBR0kgdG8gcmV0cmlldmUgZGF0YSBmb3JcbiAqICBAcHJvcGVydHkgICB7U2VydmljZS5SZXN1bHR9ICByZXN1bHQgIFJlc3VsdCBmcm9tIHRoZSBxdWVyeVxuICogIEBwcm9wZXJ0eSAgIHtCb29sZWFufSBhc3luYyAgICAgICAgICAgICBGbGFnIGZvciB1c2luZyBhc3luY2hyb25vdXMgcmVxdWVzdHMgLSBkZWZhdWx0cyB0byB0cnVlXG4gKi9cblNlcnZpY2UucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbih7XG4gICdhZ2knICAgICA6IG51bGwsXG4gICdyZXN1bHQnICA6IG51bGwsIFxuICAnYXN5bmMnICAgOiB0cnVlXG59LFNlcnZpY2UucHJvdG90eXBlKTtcblxuXG4vKlxuICogSW50ZXJuYWwgY2FsbGJhY2sgZm9yIG5ldyBkYXRhIGNvbWluZyBpbiBmcm9tIGEgWEhSXG4gKiBAcHJpdmF0ZVxuICovXG5cblNlcnZpY2UucHJvdG90eXBlLl9kYXRhUmVjZWl2ZWQgPSBmdW5jdGlvbihkYXRhLHN0YXR1cylcbntcbiAgICBpZiAoISBkYXRhICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBjbGF6eiA9IHRoaXMuUmVzdWx0O1xuICAgIGlmIChkYXRhICYmIGRhdGEuZXJyb3IgJiYgZGF0YS5lcnJvciAhPSAnJyAmJiBkYXRhLmVycm9yICE9PSBudWxsICkge1xuICAgICAgICBiZWFuLmZpcmUodGhpcywnZXJyb3InLFtkYXRhLmVycm9yXSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICBhcmd1bWVudHMuY2FsbGVlLmNhbGwodGhpcyxkYXRhW2ldLHN0YXR1cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0ID0gbmV3IGNsYXp6KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXN1bHQuX3Jhd19kYXRhID0geyAnZGF0YScgOiBkYXRhIH07XG4gICAgfSBlbHNlIGlmICggISB0aGlzLnJlc3VsdCApIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBjbGF6eihkYXRhKTtcbiAgICAgICAgfSBjYXRjaChlcnIyKSB7XG4gICAgICAgICAgICBiZWFuLmZpcmUodGhpcywnZXJyb3InLFtlcnIyXSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCAhIHJlc3VsdC5fcmF3X2RhdGEgKSB7XG4gICAgICAgICAgICByZXN1bHQuX3Jhd19kYXRhID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB2YXIgbmV3X3Jlc3VsdCA9IHt9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2xhenouY2FsbCh0aGlzLnJlc3VsdCxkYXRhKTtcbiAgICAgICAgfSBjYXRjaChlcnIzKSB7XG4gICAgICAgICAgICBiZWFuLmZpcmUodGhpcywnZXJyb3InLFtlcnIzXSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZm9yKHZhciBmaWVsZCBpbiBuZXdfcmVzdWx0KSB7XG4gICAgICAgIC8vICAgICBpZiAodHJ1ZSAmJiBuZXdfcmVzdWx0Lmhhc093blByb3BlcnR5KGZpZWxkKSkge1xuICAgICAgICAvLyAgICAgICAgIHRoaXMucmVzdWx0W2ZpZWxkXSA9IG5ld19yZXN1bHRbZmllbGRdO1xuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyB9XG4gICAgICAgIGlmICghIHRoaXMucmVzdWx0Ll9yYXdfZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHQuX3Jhd19kYXRhID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGlzLnJlc3VsdC5fcmF3X2RhdGEgPSBkYXRhO1xuICAgIH1cblxuICAgIGlmIChkYXRhICYmIGRhdGEucmV0cmlldmVkKSB7XG4gICAgICAgIHRoaXMucmVzdWx0LnJldHJpZXZlZCA9IGRhdGEucmV0cmlldmVkO1xuICAgICAgICB0aGlzLnJlc3VsdC5fcmF3X2RhdGEucmV0cmlldmVkID0gZGF0YS5yZXRyaWV2ZWQ7XG4gICAgfVxuXG4gICAgdGhpcy5yZXN1bHQuYWdpID0gdGhpcy5hZ2k7XG4gICAgXG4gICAgXG4gICAgXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5TZXJ2aWNlLnByb3RvdHlwZS5nb3RSZXN1bHQgPSBmdW5jdGlvbigpXG57XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIFxuICAgIHZhciByZWFkZXJfY2FjaGUgPSBmdW5jdGlvbih0aGluZykge1xuICAgICAgICBpZiAoICEgdGhpbmcucmVhZGVycyApIHtcbiAgICAgICAgICAgIHRoaW5nLnJlYWRlcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGluZy5yZWFkZXJzLnB1c2goc2VsZi50b1N0cmluZygpKTtcbiAgICB9O1xuICAgIFxuICAgIGJlYW4uYWRkKE1BU0NQLCdsYXllclJlZ2lzdGVyZWQnLCByZWFkZXJfY2FjaGUpO1xuICAgIGJlYW4uYWRkKE1BU0NQLCdncm91cFJlZ2lzdGVyZWQnLCByZWFkZXJfY2FjaGUpO1xuICAgIGJlYW4uZmlyZShzZWxmLFwicmVzdWx0UmVjZWl2ZWRcIik7XG4gICAgdHJ5IHtcbiAgICAgICAgYmVhbi5yZW1vdmUoTUFTQ1AsJ2xheWVyUmVnaXN0ZXJlZCcscmVhZGVyX2NhY2hlKTtcbiAgICAgICAgYmVhbi5yZW1vdmUoTUFTQ1AsJ2dyb3VwUmVnaXN0ZXJlZCcscmVhZGVyX2NhY2hlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgfVxuXG4gICAgYmVhbi5maXJlKFNlcnZpY2UsXCJyZXN1bHRSZWNlaXZlZFwiKTtcbn07XG5cblNlcnZpY2UucHJvdG90eXBlLnJlcXVlc3RDb21wbGV0ZSA9IGZ1bmN0aW9uKClcbntcbiAgICBiZWFuLmZpcmUodGhpcywncmVxdWVzdENvbXBsZXRlJyk7XG4gICAgYmVhbi5maXJlKFNlcnZpY2UsJ3JlcXVlc3RDb21wbGV0ZScsW3RoaXNdKTtcbn07XG5cblNlcnZpY2UucHJvdG90eXBlLnJlcXVlc3RJbmNvbXBsZXRlID0gZnVuY3Rpb24oKVxue1xuICAgIGJlYW4uZmlyZSh0aGlzLCdyZXF1ZXN0SW5jb21wbGV0ZScpO1xuICAgIGJlYW4uZmlyZShTZXJ2aWNlLCdyZXF1ZXN0SW5jb21wbGV0ZScsW3RoaXNdKTtcbn07XG5cblxuU2VydmljZS5yZWdpc3RlcmVkTGF5ZXJzID0gZnVuY3Rpb24oc2VydmljZSkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBsYXluYW1lIGluIE1BU0NQLmxheWVycykge1xuICAgICAgICBpZiAoTUFTQ1AubGF5ZXJzLmhhc093blByb3BlcnR5KGxheW5hbWUpKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSBNQVNDUC5sYXllcnNbbGF5bmFtZV07XG4gICAgICAgICAgICBpZiAobGF5ZXIucmVhZGVycyAmJiBsYXllci5yZWFkZXJzLmluZGV4T2Yoc2VydmljZS50b1N0cmluZygpKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobGF5ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5TZXJ2aWNlLnJlZ2lzdGVyZWRHcm91cHMgPSBmdW5jdGlvbihzZXJ2aWNlKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIG5tIGluIE1BU0NQLmdyb3Vwcykge1xuICAgICAgICBpZiAoTUFTQ1AuZ3JvdXBzLmhhc093blByb3BlcnR5KG5tKSkge1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gTUFTQ1AuZ3JvdXBzW25tXTtcbiAgICAgICAgICAgIGlmIChncm91cC5yZWFkZXJzICYmIGdyb3VwLnJlYWRlcnMuaW5kZXhPZihzZXJ2aWNlLnRvU3RyaW5nKCkpID49IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChncm91cCk7XG4gICAgICAgICAgICB9ICAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDsgIFxufTtcblxuLyoqXG4gKiAgQmluZHMgYSBoYW5kbGVyIHRvIG9uZSBvciBtb3JlIGV2ZW50cy4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byBzZWxmLCBzbyB0aGlzIG1ldGhvZFxuICogIGNhbiBiZSBjaGFpbmVkLlxuICpcbiAqICBAcGFyYW0gIHtTdHJpbmd9ICAgIHR5cGUgICAgICAgIEV2ZW50IHR5cGUgdG8gYmluZFxuICogIEBwYXJhbSAge0Z1bmN0aW9ufSAgZnVuY3Rpb24gICAgSGFuZGxlciB0byBleGVjdXRlIG9uIGV2ZW50XG4gKi9cblxuU2VydmljZS5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKHR5cGUsZnVuYylcbntcbiAgICBiZWFuLmFkZCh0aGlzLHR5cGUsZnVuYyk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5TZXJ2aWNlLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSxmdW5jKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB3cmFwcGVkX2Z1bmMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgYmVhbi5yZW1vdmUoc2VsZix0eXBlLHdyYXBwZWRfZnVuYyk7XG4gICAgICAgIGZ1bmMuYXBwbHkoc2VsZixbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH07XG4gICAgc2VsZi5iaW5kKHR5cGUsd3JhcHBlZF9mdW5jKTtcbn07XG5cbi8qKlxuICogIFVuYmluZHMgYSBoYW5kbGVyIGZyb20gb25lIG9yIG1vcmUgZXZlbnRzLiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHNlbGYsIHNvIHRoaXMgbWV0aG9kXG4gKiAgY2FuIGJlIGNoYWluZWQuXG4gKlxuICogIEBwYXJhbSAge1N0cmluZ30gICAgdHlwZSAgICAgICAgRXZlbnQgdHlwZSB0byB1bmJpbmRcbiAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIGZ1bmN0aW9uICAgIEhhbmRsZXIgdG8gdW5iaW5kIGZyb20gZXZlbnRcbiAqL1xuU2VydmljZS5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24odHlwZSxmdW5jKVxue1xuICAgIGJlYW4ucmVtb3ZlKHRoaXMsdHlwZSxmdW5jKTtcbiAgICByZXR1cm4gdGhpczsgICAgXG59O1xuXG4vKipcbiAqIEBuYW1lICAgIFNlcnZpY2UjcmVzdWx0UmVjZWl2ZWRcbiAqIEBldmVudFxuICogQHBhcmFtICAge09iamVjdH0gICAgZVxuICovXG5cbi8qKlxuICogQG5hbWUgICAgU2VydmljZSNlcnJvclxuICogQGV2ZW50XG4gKiBAcGFyYW0gICB7T2JqZWN0fSAgICBlXG4gKi9cblxuLyoqXG4gKiAgQXN5bmNocm9ub3VzbHkgcmV0cmlldmVzIGRhdGEgZnJvbSB0aGUgcmVtb3RlIHNvdXJjZS4gV2hlbiBkYXRhIGlzIHJlY2VpdmVkLCBhIFxuICogIHJlc3VsdFJlY2VpdmVkLm1hc2NwIGV2ZW50IGlzIHRyaWdnZXJlZCB1cG9uIHRoaXMgc2VydmljZSwgd2hpbGUgYW4gZXJyb3IubWFzY3BcbiAqICBldmVudCBpcyB0cmlnZ2VyZWQgd2hlbiBhbiBlcnJvciBvY2N1cnMuIFRoaXMgbWV0aG9kIHJldHVybnMgYSByZWZlcmVuY2UgdG8gc2VsZlxuICogIHNvIGl0IGNhbiBiZSBjaGFpbmVkLlxuICovXG4oZnVuY3Rpb24oYmFzZSkge1xuXG52YXIgbWFrZV9wYXJhbXMgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICB2YXIgcXBvaW50cyA9IFtdO1xuICAgIGZvcih2YXIgZmllbGRuYW1lIGluIHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zLmhhc093blByb3BlcnR5KGZpZWxkbmFtZSkpIHtcbiAgICAgICAgICAgIHFwb2ludHMucHVzaChmaWVsZG5hbWUgKyc9JytwYXJhbXNbZmllbGRuYW1lXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHFwb2ludHMuam9pbignJicpO1xufTtcblxudmFyIGNhY2hlZF9yZXF1ZXN0cyA9IHt9O1xuXG52YXIgZG9fcmVxdWVzdCA9IGZ1bmN0aW9uKHJlcXVlc3RfZGF0YSkge1xuICAgIFxuICAgIHJlcXVlc3RfZGF0YS5hc3luYyA9IHRydWU7XG5cbiAgICB2YXIgZGF0YWJsb2NrID0gbnVsbDtcbiAgICBcbiAgICBpZiAoICEgcmVxdWVzdF9kYXRhLnVybCApIHtcbiAgICAgICAgcmVxdWVzdF9kYXRhLnN1Y2Nlc3MuY2FsbChudWxsLG51bGwpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICBcbiAgICBpZiAocmVxdWVzdF9kYXRhLnR5cGUgPT0gJ0dFVCcgJiYgcmVxdWVzdF9kYXRhLmRhdGEpIHtcbiAgICAgICAgdmFyIGluZGV4X29mX3F1ZXN0ID0gcmVxdWVzdF9kYXRhLnVybC5pbmRleE9mKCc/Jyk7XG5cbiAgICAgICAgaWYgKGluZGV4X29mX3F1ZXN0ID09IChyZXF1ZXN0X2RhdGEudXJsLmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICByZXF1ZXN0X2RhdGEudXJsID0gcmVxdWVzdF9kYXRhLnVybC5zbGljZSgwLC0xKTtcbiAgICAgICAgICAgIGluZGV4X29mX3F1ZXN0ID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhhc19xdWVzdGlvbiA9ICAoaW5kZXhfb2ZfcXVlc3QgPj0gMCkgPyAnJicgOiAnPyc7XG4gICAgICAgIHJlcXVlc3RfZGF0YS51cmwgPSByZXF1ZXN0X2RhdGEudXJsLnJlcGxhY2UoL1xcPyQvLCcnKSArIGhhc19xdWVzdGlvbiArIG1ha2VfcGFyYW1zKHJlcXVlc3RfZGF0YS5kYXRhKTtcbiAgICB9XG4gICAgaWYgKHJlcXVlc3RfZGF0YS50eXBlID09ICdHRVQnICYmIHJlcXVlc3RfZGF0YS5zZXNzaW9uX2NhY2hlKSB7XG4gICAgICAgIGlmIChjYWNoZWRfcmVxdWVzdHNbcmVxdWVzdF9kYXRhLnVybF0pIHtcbiAgICAgICAgICAgIGNhY2hlZF9yZXF1ZXN0c1tyZXF1ZXN0X2RhdGEudXJsXS50aGVuKCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdF9kYXRhLnN1Y2Nlc3MuY2FsbChudWxsLGRhdGEpO1xuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3JfYXJncykge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RfZGF0YS5lcnJvci5hcHBseShudWxsLFtudWxsLHJlcXVlc3QsZXJyb3JfYXJnc10pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgc3VjY2Vzc19jYWxsYmFjayA9IHJlcXVlc3RfZGF0YS5zdWNjZXNzO1xuICAgICAgICAgICAgdmFyIGVycm9yX2NhbGxiYWNrID0gcmVxdWVzdF9kYXRhLmVycm9yO1xuICAgICAgICAgICAgY2FjaGVkX3JlcXVlc3RzW3JlcXVlc3RfZGF0YS51cmxdID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSxyZWplY3QpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0X2RhdGEuc3VjY2VzcyA9IGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVxdWVzdF9kYXRhLmVycm9yID0gZnVuY3Rpb24obWVzc2FnZSxyZXEsZXJyb3Jfb2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChbbWVzc2FnZSxyZXEsZXJyb3Jfb2JqXSk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjYWNoZWRfcmVxdWVzdHNbcmVxdWVzdF9kYXRhLnVybF07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FjaGVkX3JlcXVlc3RzW3JlcXVlc3RfZGF0YS51cmxdLmNhdGNoKGZ1bmN0aW9uKGVycm9yX2FyZ3MpIHtcbiAgICAgICAgICAgICAgICBlcnJvcl9jYWxsYmFjay5hcHBseShudWxsLGVycm9yX2FyZ3MpO1xuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgc3VjY2Vzc19jYWxsYmFjay5jYWxsKG51bGwsZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlcXVlc3Qub3BlbihyZXF1ZXN0X2RhdGEudHlwZSxyZXF1ZXN0X2RhdGEudXJsLHJlcXVlc3RfZGF0YS5hc3luYyk7XG5cbiAgICBpZiAocmVxdWVzdF9kYXRhLnR5cGUgPT0gJ1BPU1QnKSB7XG4gICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLHJlcXVlc3RfZGF0YS5jb250ZW50ID8gcmVxdWVzdF9kYXRhLmNvbnRlbnQgOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKTtcbiAgICAgICAgZGF0YWJsb2NrID0gcmVxdWVzdF9kYXRhLmNvbnRlbnQgPyByZXF1ZXN0X2RhdGEuZGF0YSA6IG1ha2VfcGFyYW1zKHJlcXVlc3RfZGF0YS5kYXRhKTtcbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdC5jdXN0b21VQSkge1xuICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoJ1VzZXItQWdlbnQnLHJlcXVlc3QuY3VzdG9tVUEpO1xuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0X2RhdGEuYXV0aCkge1xuICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoJ0F1dGhvcml6YXRpb24nLCdCZWFyZXIgJytyZXF1ZXN0X2RhdGEuYXV0aCk7XG4gICAgfVxuXG4gICAgaWYgKHJlcXVlc3RfZGF0YS5hcGlfa2V5KSB7XG4gICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcigneC1hcGkta2V5JyxyZXF1ZXN0X2RhdGEuYXBpX2tleSk7XG4gICAgfVxuXG4gICAgdmFyIHJlZGlyZWN0X2NvdW50cyA9IDU7XG5cbiAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBpZiAocmVxdWVzdC5yZWFkeVN0YXRlID09IDQpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA+PSAzMDAgJiYgcmVxdWVzdC5zdGF0dXMgPCA0MDAgJiYgcmVkaXJlY3RfY291bnRzID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBsb2MgPSAocmVxdWVzdC5nZXRSZXNwb25zZUhlYWRlcignbG9jYXRpb24nKSkucmVwbGFjZSgvbG9jYXRpb246XFxzKy8sJycpO1xuICAgICAgICAgICAgICAgIHJlZGlyZWN0X2NvdW50cyA9IHJlZGlyZWN0X2NvdW50cyAtIDE7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vcGVuKCdHRVQnLGxvYyxyZXF1ZXN0X2RhdGEuYXN5bmMpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3Quc2VuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PSA1MDMpIHtcbiAgICAgICAgICAgICAgICAvLyBMZXQncyBlbmNvZGUgYW4gZXhwb25lbnRpYWwgYmFja29mZlxuICAgICAgICAgICAgICAgIHJlcXVlc3QubGFzdF93YWl0ID0gKHJlcXVlc3RfZGF0YS5sYXN0X3dhaXQgfHwgNTAwKSAqIDI7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Lm9wZW4ocmVxdWVzdF9kYXRhLnR5cGUscmVxdWVzdF9kYXRhLnVybCxyZXF1ZXN0X2RhdGEuYXN5bmMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWVzdF9kYXRhLnR5cGUgPT0gJ1BPU1QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIixyZXF1ZXN0X2RhdGEuY29udGVudCA/IHJlcXVlc3RfZGF0YS5jb250ZW50IDogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QuY3VzdG9tVUEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcignVXNlci1BZ2VudCcscmVxdWVzdC5jdXN0b21VQSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5zZW5kKGRhdGFibG9jayk7XG4gICAgICAgICAgICAgICAgfSxyZXF1ZXN0X2RhdGEubGFzdF93YWl0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT0gNDAzKSB7XG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIG91ciBTMyBidWNrZXRzIGV4cG9zZSB0aGUgU2VydmVyIGhlYWRlciBjcm9zcy1vcmlnaW5cbiAgICAgICAgICAgICAgICB2YXIgc2VydmVyID0gcmVxdWVzdC5nZXRSZXNwb25zZUhlYWRlcignU2VydmVyJyk7XG4gICAgICAgICAgICAgICAgaWYgKHNlcnZlciA9PT0gJ0FtYXpvblMzJykge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0X2RhdGEuc3VjY2Vzcy5jYWxsKG51bGwse1wiZXJyb3JcIiA6IFwiTm8gZGF0YVwifSw0MDMscmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPj0gMjAwICYmIHJlcXVlc3Quc3RhdHVzIDwgMzAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFfYmxvY2s7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3RfZGF0YS5kYXRhVHlwZSA9PSAneG1sJykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhX2Jsb2NrID0gdHlwZW9mKGRvY3VtZW50KSAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVEb2N1bWVudChudWxsLCBcIm5vZGF0YVwiLCBudWxsKSA6IHsgJ2dldEVsZW1lbnRzQnlUYWdOYW1lJyA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gW107IH0gfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRhX2Jsb2NrID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gcmVxdWVzdC5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFfYmxvY2sgPSByZXF1ZXN0X2RhdGEuZGF0YVR5cGUgPT0gJ3htbCcgPyByZXF1ZXN0LnJlc3BvbnNlWE1MIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RfZGF0YS5kYXRhVHlwZSA9PSAndHh0JyA/IHJlcXVlc3QucmVzcG9uc2VUZXh0IDogSlNPTi5wYXJzZShyZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS50eXBlID09ICd1bmV4cGVjdGVkX2VvcycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RfZGF0YS5zdWNjZXNzLmNhbGwobnVsbCx7fSxyZXF1ZXN0LnN0YXR1cyxyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RfZGF0YS5lcnJvci5jYWxsKG51bGwscmVxdWVzdC5yZXNwb25zZVRleHQscmVxdWVzdCx7J2Vycm9yJyA6IGUudHlwZSB8fCBlLm1lc3NhZ2UsICdzdGFjaycgOiBlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PSAyMDIgJiYgZGF0YV9ibG9jay5zdGF0dXMgPT0gXCJSVU5OSU5HXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5vcGVuKHJlcXVlc3RfZGF0YS50eXBlLHJlcXVlc3RfZGF0YS51cmwscmVxdWVzdF9kYXRhLmFzeW5jKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0X2RhdGEudHlwZSA9PSAnUE9TVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIixcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LmN1c3RvbVVBKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKCdVc2VyLUFnZW50JyxyZXF1ZXN0LmN1c3RvbVVBKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Quc2VuZChkYXRhYmxvY2spO1xuICAgICAgICAgICAgICAgICAgICB9LDUwMDApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcXVlc3RfZGF0YS5zdWNjZXNzLmNhbGwobnVsbCxkYXRhX2Jsb2NrLHJlcXVlc3Quc3RhdHVzLHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIGRhdGFfYmxvY2sgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0X2RhdGEuZXJyb3IuY2FsbChudWxsLHJlcXVlc3QucmVzcG9uc2VUZXh0LHJlcXVlc3QscmVxdWVzdC5zdGF0dXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBpZiAoTUFTQ1AuTkVUV09SS19GQUlMICYmIE1BU0NQLk5FVFdPUktfRkFJTC5lbmFibGVkKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkNhdXNpbmcgbmV0d29yayBmYWlsdXJlXCIpO1xuICAgICAgICAgICAgcmVxdWVzdCA9IHsgJ29ucmVhZHlzdGF0ZWNoYW5nZScgOiByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZX07XG4gICAgICAgICAgICByZXF1ZXN0LnJlYWR5U3RhdGUgPSA0O1xuICAgICAgICAgICAgcmVxdWVzdC5zdGF0dXMgPSBNQVNDUC5ORVRXT1JLX0ZBSUwuc3RhdHVzIHx8IDUwMDtcbiAgICAgICAgICAgIHJlcXVlc3QucmVzcG9uc2VUZXh0ID0gXCJJbnRlcmNlcHRlZCBieSBOZXR3b3JrIEZhaWx1cmUgc2ltdWxhdG9yXCI7XG4gICAgICAgICAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSgpO1xuICAgICAgICB9LDEwMDApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVxdWVzdC5zZW5kKGRhdGFibG9jayk7XG59O1xuXG5TZXJ2aWNlLnJlcXVlc3QgPSBmdW5jdGlvbih1cmwsY2FsbGJhY2ssbm9wYXJzZSkge1xuICAgIHZhciBtZXRob2QgPSAgTUFTQ1AuSUUgPyBkb19yZXF1ZXN0X2llIDogZG9fcmVxdWVzdDtcbiAgICBpZiAoTUFTQ1AuSUUgJiYgISB1cmwubWF0Y2goL15odHRwcz9cXDovKSkge1xuICAgICAgICBtZXRob2QgPSBkb19yZXF1ZXN0O1xuICAgIH1cbiAgICB2YXIgcGFyYW1zO1xuICAgIGlmICggISB1cmwgKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdXJsID09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhcmFtcyA9ICB7IGFzeW5jOiB0cnVlLCB1cmw6IHVybCwgdGltZW91dDogNTAwMCwgdHlwZSA6IFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24ocmVzcG9uc2UscmVxLHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwobnVsbCx7XCJzdGF0dXNcIiA6IHN0YXR1cyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOmZ1bmN0aW9uKGRhdGEsc3RhdHVzLHhocikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwobnVsbCxudWxsLGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAodXJsLmhhc093blByb3BlcnR5KCd1cmwnKSkge1xuICAgICAgICBwYXJhbXMgPSB1cmw7XG4gICAgICAgIHBhcmFtcy5zdWNjZXNzID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgY2FsbGJhY2suY2FsbChudWxsLG51bGwsZGF0YSk7XG4gICAgICAgIH07XG4gICAgICAgIHBhcmFtcy5lcnJvciA9IGZ1bmN0aW9uKHJlc3AscmVxLHN0YXR1cykge1xuICAgICAgICAgICAgY2FsbGJhY2suY2FsbChudWxsLHtcInN0YXR1c1wiOiBzdGF0dXN9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKG5vcGFyc2UpIHtcbiAgICAgICAgcGFyYW1zLmRhdGFUeXBlID0gJ3R4dCc7XG4gICAgICAgIGlmIChub3BhcnNlID09PSBcInhtbFwiKSB7XG4gICAgICAgICAgICBwYXJhbXMuZGF0YVR5cGUgPSAneG1sJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBtZXRob2QuY2FsbChudWxsLHBhcmFtcyk7XG59O1xuXG4vKipcbiAqIFByaXZhdGUgbWV0aG9kIGZvciBwZXJmb3JtaW5nIGEgY3Jvc3MtZG9tYWluIHJlcXVlc3QgdXNpbmcgSW50ZXJuZXQgRXhwbG9yZXIgOCBhbmQgdXAuIEFkYXB0cyB0aGUgXG4gKiBwYXJhbWV0ZXJzIHBhc3NlZCwgYW5kIGJ1aWxkcyBhbiBYRFIgb2JqZWN0LiBUaGVyZSBpcyBubyBzdXBwb3J0IGZvciBhIGxvY2tpbmdcbiAqIHN5bmNocm9ub3VzIG1ldGhvZCB0byBkbyB0aGVzZSByZXF1ZXN0cyAodGhhdCBpcyByZXF1aXJlZCBmb3IgVW5pdCB0ZXN0aW5nKSBzbyBhbiBhbGVydCBib3ggaXMgdXNlZFxuICogdG8gcHJvdmlkZSB0aGUgbG9ja2luZy5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YUhhc2ggSGFzaCB3aXRoIHRoZSBkYXRhIGFuZCBzZXR0aW5ncyB1c2VkIHRvIGJ1aWxkIHRoZSBxdWVyeS5cbiAqL1xuXG5cbnZhciBkb19yZXF1ZXN0X2llID0gZnVuY3Rpb24oZGF0YUhhc2gpXG57XG4gICAgLy8gVXNlIFhEUlxuICAgIHZhciB4ZHIgPSBuZXcgWERvbWFpblJlcXVlc3QoKTtcbiAgICB2YXIgbG9hZGVkID0gZmFsc2U7XG4gICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgIHhkci5vbmVycm9yID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgZGF0YUhhc2guZXJyb3IoeGRyLHhkcix7XCJtZXNzYWdlXCIgOiBcIlhEb21haW5SZXF1ZXN0IGVycm9yXCJ9KTtcbiAgICB9O1xuICAgIHhkci5vbnByb2dyZXNzID0gZnVuY3Rpb24oKSB7IH07XG4gICAgeGRyLm9wZW4oXCJHRVRcIixkYXRhSGFzaC51cmwrXCI/XCIrbWFrZV9wYXJhbXMoZGF0YUhhc2guZGF0YSkpO1xuICAgIHhkci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKGRhdGFIYXNoLmRhdGFUeXBlID09ICd4bWwnKSB7XG4gICAgICAgICAgICB2YXIgZG9tID0gbmV3IEFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MRE9NXCIpO1xuICAgICAgICAgICAgZG9tLmFzeW5jID0gZmFsc2U7XG4gICAgICAgICAgICBkb20ubG9hZFhNTCh4ZHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgIGRhdGFIYXNoLnN1Y2Nlc3MoZG9tLCAnc3VjY2VzcycseGRyKTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhSGFzaC5kYXRhVHlwZSA9PSAnanNvbicpIHtcbiAgICAgICAgICAgIHZhciBwYXJzZWQgPSBudWxsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYXJzZWQgPSBKU09OLnBhcnNlKHhkci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgICAgICBkYXRhSGFzaC5lcnJvcih4ZHIseGRyLHtcIm1lc3NhZ2VcIiA6IFwiSlNPTiBwYXJzaW5nIGVycm9yXCJ9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICAgICAgICBkYXRhSGFzaC5zdWNjZXNzKHBhcnNlZCwnc3VjY2VzcycseGRyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFIYXNoLnN1Y2Nlc3MoeGRyLnJlc3BvbnNlVGV4dCwgJ3N1Y2Nlc3MnLCB4ZHIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBXZSBjYW4ndCBzZXQgdGhlIGNvbnRlbnQtdHlwZSBvbiB0aGUgcGFyYW1ldGVycyBoZXJlIHRvIHVybC1lbmNvZGVkIGZvcm0gZGF0YS5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgeGRyLnNlbmQoKTtcbiAgICB9LCAwKTtcbiAgICB3aGlsZSAoISBkYXRhSGFzaC5hc3luYyAmJiAhIGxvYWRlZCAmJiBjb3VudGVyIDwgMykge1xuICAgICAgICBhbGVydChcIlRoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHN5bmNocm9ub3VzIHJlcXVlc3RzLCBjbGljayBPSyB3aGlsZSB3ZSdyZSB3YWl0aW5nIGZvciBkYXRhXCIpO1xuICAgICAgICBjb3VudGVyICs9IDE7XG4gICAgfVxuICAgIGlmICggISBkYXRhSGFzaC5hc3luYyAmJiAhIGxvYWRlZCApIHtcbiAgICAgICAgYWxlcnQoXCJObyBkYXRhXCIpO1xuICAgIH1cbn07XG5cbmxldCBoYW5kbGVfcmVxdWVzdF9zdWNjZXNzID0gZnVuY3Rpb24oZGF0YSxzdGF0dXMseGhyKSB7XG4gICAgU2VydmljZS5fY3VycmVudF9yZXFzIC09IDE7XG4gICAgaWYgKCB4aHIgJiYgeGhyLnN0YXR1cyAhPT0gbnVsbCAmJiB4aHIuc3RhdHVzID09PSAwICkge1xuICAgICAgICBiZWFuLmZpcmUodGhpcyxcImVycm9yXCIsW3tcImVycm9yXCI6IFwiWmVybyByZXR1cm4gc3RhdHVzIGZyb20gcmVxdWVzdCBcIn1dKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0Q29tcGxldGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcmVjZWl2ZWRfZmxhZyA9IHRoaXMuX2RhdGFSZWNlaXZlZChkYXRhLHN0YXR1cyk7XG5cbiAgICBpZiAocmVjZWl2ZWRfZmxhZykge1xuICAgICAgICB0aGlzLmdvdFJlc3VsdCgpO1xuICAgIH1cblxuICAgIGlmIChyZWNlaXZlZF9mbGFnICE9PSBudWxsICYmIHR5cGVvZiByZWNlaXZlZF9mbGFnICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLnJlcXVlc3RDb21wbGV0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVxdWVzdEluY29tcGxldGUoKTtcbiAgICB9XG59O1xuXG5sZXQgaGFuZGxlX3JlcXVlc3RfZXJyb3IgPSBmdW5jdGlvbihyZXNwb25zZSxyZXEsc3RhdHVzKSB7XG4gICAgU2VydmljZS5fY3VycmVudF9yZXFzIC09IDE7XG4gICAgaWYgKHR5cGVvZiBzdGF0dXMgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgc3RhdHVzID0geyAnZXJyb3InIDogc3RhdHVzICwgJ3JlcXVlc3QnIDogcmVxIH07XG4gICAgfVxuICAgIGlmICghIGlzTmFOKHN0YXR1cykgKSB7XG4gICAgICAgIHN0YXR1cyA9IHsgXCJlcnJvclwiIDogXCJSZXFldXN0IGVycm9yXCIsIFwic3RhdHVzXCIgOiBzdGF0dXMsICdyZXF1ZXN0JyA6IHJlcSB9O1xuICAgIH1cbiAgICBiZWFuLmZpcmUodGhpcyxcImVycm9yXCIsW3N0YXR1c10pO1xuICAgIGJlYW4uZmlyZShTZXJ2aWNlLCdyZXF1ZXN0Q29tcGxldGUnKTtcbiAgICB0aGlzLnJlcXVlc3RDb21wbGV0ZSgpO1xufTtcblxubGV0IHBlcmZvcm1fcmVxdWVzdCA9IGZ1bmN0aW9uKHJlcXVlc3RfZGF0YSkge1xuXG4gICAgaWYgKHJlcXVlc3RfZGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghIHJlcXVlc3RfZGF0YSApIHtcbiAgICAgICAgYmVhbi5maXJlKHRoaXMsXCJlcnJvclwiLFtcIk5vIHJlcXVlc3QgZGF0YVwiXSk7XG4gICAgICAgIGJlYW4uZmlyZShTZXJ2aWNlLFwicmVxdWVzdENvbXBsZXRlXCIsW3RoaXNdKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0Q29tcGxldGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRfcGFyYW1zID0ge1xuICAgICAgICBhc3luYzogICAgICB0aGlzLmFzeW5jLFxuICAgICAgICB1cmw6ICAgICAgICByZXF1ZXN0X2RhdGEudXJsIHx8IHRoaXMuX2VuZHBvaW50VVJMLFxuICAgICAgICB0aW1lb3V0OiAgICA1MDAwLFxuICAgICAgICBlcnJvcjogICAgICBoYW5kbGVfcmVxdWVzdF9lcnJvci5iaW5kKHRoaXMpLFxuICAgICAgICBzdWNjZXNzOiAgICBoYW5kbGVfcmVxdWVzdF9zdWNjZXNzLmJpbmQodGhpcylcbiAgICB9O1xuICAgIGRlZmF1bHRfcGFyYW1zID0gT2JqZWN0LmFzc2lnbihyZXF1ZXN0X2RhdGEsZGVmYXVsdF9wYXJhbXMpO1xuXG4gICAgZG9fcmVxdWVzdChkZWZhdWx0X3BhcmFtcyk7XG5cbiAgICBTZXJ2aWNlLl9jdXJyZW50X3JlcXMgKz0gMTtcbn07XG5cblxuYmFzZS5yZXRyaWV2ZSA9IGZ1bmN0aW9uKGFnaSxjYWxsYmFjaylcbntcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBTZXJ2aWNlLl9jdXJyZW50X3JlcXMgPSBTZXJ2aWNlLl9jdXJyZW50X3JlcXMgfHwgMDtcbiAgICBTZXJ2aWNlLl93YWl0aW5nX3JlcXMgPSBTZXJ2aWNlLl93YWl0aW5nX3JlcXMgfHwgMDtcbiAgICBcbiAgICBpZiAoU2VydmljZS5NQVhfUkVRVUVTVFMpIHtcbiAgICAgICAgdmFyIG15X2Z1bmMgPSBhcmd1bWVudHMuY2FsbGVlO1xuICAgICAgICBpZiAoU2VydmljZS5fY3VycmVudF9yZXFzID4gU2VydmljZS5NQVhfUkVRVUVTVFMpIHtcbiAgICAgICAgICAgIFNlcnZpY2UuX3dhaXRpbmdfcmVxcyArPSAxO1xuICAgICAgICAgICAgYmVhbi5hZGQoU2VydmljZSwncmVxdWVzdENvbXBsZXRlJyxmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBiZWFuLnJlbW92ZSh0aGlzLCdyZXF1ZXN0Q29tcGxldGUnLGFyZ3VtZW50cy5jYWxsZWUpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIFNlcnZpY2UuX3dhaXRpbmdfcmVxcyAtPSAxO1xuICAgICAgICAgICAgICAgICAgICBteV9mdW5jLmNhbGwoc2VsZixhZ2ksY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH0sMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhZ2kpIHtcbiAgICAgICAgdGhpcy5hZ2kgPSBhZ2k7XG4gICAgfVxuXG4gICAgaWYgKGFnaSAmJiBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmFnaSA9IGFnaTtcblxuICAgICAgICB0aGlzLnJlc3VsdCA9IG51bGw7XG4gICAgICAgIFxuICAgICAgICB2YXIgZG9uZV9yZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGRvbmVfZnVuYyA9IGZ1bmN0aW9uKGVycixvYmopIHtcbiAgICAgICAgICAgIGJlYW4ucmVtb3ZlKHNlbGYsXCJyZXN1bHRSZWNlaXZlZFwiLGRvbmVfZnVuYyk7XG4gICAgICAgICAgICBiZWFuLnJlbW92ZShzZWxmLFwiZXJyb3JcIixkb25lX2Z1bmMpO1xuICAgICAgICAgICAgYmVhbi5yZW1vdmUoc2VsZixcInJlcXVlc3RDb21wbGV0ZVwiLGRvbmVfZnVuYyk7XG4gICAgICAgICAgICBpZiAoICEgZG9uZV9yZXN1bHQgKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHNlbGYsZXJyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHNlbGYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbmVfcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgYmVhbi5hZGQoc2VsZixcInJlc3VsdFJlY2VpdmVkXCIsZG9uZV9mdW5jKTtcbiAgICAgICAgYmVhbi5hZGQoc2VsZixcImVycm9yXCIsZG9uZV9mdW5jKTtcbiAgICAgICAgYmVhbi5hZGQoc2VsZixcInJlcXVlc3RDb21wbGV0ZVwiLGRvbmVfZnVuYyk7XG4gICAgfVxuICAgIHZhciByZXF1ZXN0X2RhdGEgPSB0aGlzLnJlcXVlc3REYXRhKCk7XG4gICAgUHJvbWlzZS5yZXNvbHZlKHJlcXVlc3RfZGF0YSkudGhlbiggcGVyZm9ybV9yZXF1ZXN0LmJpbmQodGhpcykgKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbn0pKFNlcnZpY2UucHJvdG90eXBlKTtcblxuLyoqXG4gKiAgR2V0IHRoZSBwYXJhbWV0ZXJzIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGJ1aWxkIHRoaXMgcmVxdWVzdC4gSW1wbGVtZW50YXRpb25zIG9mIHNlcnZpY2VzIHdpbGxcbiAqICBvdmVycmlkZSB0aGlzIG1ldGhvZCwgcmV0dXJuaW5nIHRoZSBwYXJhbWV0ZXJzIHRvIGJlIHVzZWQgdG8gYnVpbGQgdGhlIFhIUi5cbiAqL1xuXG5TZXJ2aWNlLnByb3RvdHlwZS5yZXF1ZXN0RGF0YSA9IGZ1bmN0aW9uKClcbntcbiAgICBcbn07XG5cblNlcnZpY2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKVxue1xuICAgIGZvciAodmFyIGNsYXp6IGluIE1BU0NQKSB7XG4gICAgICAgIGlmICh0aGlzLl9fY2xhc3NfXyA9PSBNQVNDUFtjbGF6el0pIHtcbiAgICAgICAgICAgIHJldHVybiBcIk1BU0NQLlwiK2NsYXp6O1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBGb3IgdGhpcyBzZXJ2aWNlLCByZWdpc3RlciBhIHNlcXVlbmNlIHJlbmRlcmluZyB2aWV3IHNvIHRoYXQgdGhlIHJlc3VsdHMgY2FuIGJlIG1hcmtlZCB1cCBkaXJlY3RseVxuICogb24gdG8gYSBzZXF1ZW5jZS4gVGhpcyBtZXRob2Qgd2lsbCBkbyBub3RoaW5nIGlmIHRoZSBzZXJ2aWNlIGRvZXMgbm90IGtub3cgaG93IHRvIHJlbmRlciB0aGUgXG4gKiByZXN1bHRzIG9udG8gdGhlIHNlcXVlbmNlLlxuICogQHBhcmFtIHtNQVNDUC5TZXF1ZW5jZVJlbmRlcmVyfSBzZXF1ZW5jZVJlbmRlcmVyIFNlcXVlbmNlIHJlbmRlcmVyIG9iamVjdCB0byByZW5kZXIgcmVzdWx0cyB1cG9uXG4gKi9cblNlcnZpY2UucHJvdG90eXBlLnJlZ2lzdGVyU2VxdWVuY2VSZW5kZXJlciA9IGZ1bmN0aW9uKHNlcXVlbmNlUmVuZGVyZXIsb3B0aW9ucylcbntcbiAgICBpZiAodGhpcy5zZXR1cFNlcXVlbmNlUmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlcnMgPSB0aGlzLnJlbmRlcmVycyB8fCBbXTtcbiAgICAgICAgdGhpcy5zZXR1cFNlcXVlbmNlUmVuZGVyZXIoc2VxdWVuY2VSZW5kZXJlcixvcHRpb25zKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlcnMucHVzaChzZXF1ZW5jZVJlbmRlcmVyKTtcbiAgICB9XG4gICAgc2VxdWVuY2VSZW5kZXJlci50cmlnZ2VyKCdyZWFkZXJSZWdpc3RlcmVkJyxbdGhpc10pO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuU2VydmljZS5wcm90b3R5cGUucmVzZXRPblJlc3VsdCA9IGZ1bmN0aW9uKHNlcXVlbmNlUmVuZGVyZXIscmVuZGVyZWQsdHJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHJlc3VsdF9mdW5jID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYudW5iaW5kKCdyZXN1bHRSZWNlaXZlZCcscmVzdWx0X2Z1bmMpO1xuICAgICAgICBzZXF1ZW5jZVJlbmRlcmVyLmJpbmQoJ3Jlc3VsdHNSZW5kZXJlZCcsY2xlYXJfZnVuYyk7XG4gICAgfTtcblxuICAgIHZhciBjbGVhcl9mdW5jID0gZnVuY3Rpb24ocmVhZGVyKSB7XG4gICAgICAgIGlmIChyZWFkZXIgIT09IHNlbGYpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXF1ZW5jZVJlbmRlcmVyLnVuYmluZCgncmVzdWx0c1JlbmRlcmVkJyxjbGVhcl9mdW5jKTtcbiAgICAgICAgcmVuZGVyZWQuZm9yRWFjaChmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIHNlcXVlbmNlUmVuZGVyZXIucmVtb3ZlKHRyYWNrLG9iaik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5iaW5kKCdyZXN1bHRSZWNlaXZlZCcscmVzdWx0X2Z1bmMpO1xufTtcblxuXG4vKipcbiAqIEZvciB0aGlzIHNlcnZpY2UsIHNldCB1cCBhIHNlcXVlbmNlIHJlbmRlcmVyIHNvIHRoYXQgdGhlIGV2ZW50cyBhcmUgY29ubmVjdGVkIHVwIHdpdGggcmVjZWl2aW5nIGRhdGEuXG4gKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgb3ZlcnJpZGRlbiB0byB3aXJlIHVwIHRoZSBzZXF1ZW5jZSByZW5kZXJlciB0byB0aGUgc2VydmljZS5cbiAqIEBwYXJhbSB7TUFTQ1AuU2VxdWVuY2VSZW5kZXJlcn0gc2VxdWVuY2VSZW5kZXJlciBTZXF1ZW5jZSByZW5kZXJlciBvYmplY3QgdG8gcmVuZGVyIHJlc3VsdHMgdXBvblxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS5zZXR1cFNlcXVlbmNlUmVuZGVyZXIgPSBmdW5jdGlvbihzZXF1ZW5jZVJlbmRlcmVyKVxue1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqIERlZmF1bHQgY29uc3RydWN0b3JcbiAqICBAY2xhc3MgIFN1cGVyLWNsYXNzIGZvciBhbGwgcmVzdWx0cyBmcm9tIE1BU0NQIHNlcnZpY2VzLlxuICovXG5TZXJ2aWNlLlJlc3VsdCA9IGZ1bmN0aW9uKClcbnsgIFxufTtcblxuU2VydmljZS5SZXN1bHQucHJvdG90eXBlID0ge1xuICAgIGFnaSAgICAgOiAgIG51bGwsXG4gICAgcmVhZGVyICA6ICAgbnVsbFxufTtcblxuXG5TZXJ2aWNlLlJlc3VsdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBTZXJ2aWNlOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFFQTtBQUVBOzs7Ozs7OztBQU9BO0FBRUE7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTNCQTtBQTZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBT0E7Ozs7O0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQVFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFPQTtBQUVBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7Ozs7O0FBTUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7Ozs7OztBQVVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTs7Ozs7O0FBS0E7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUdBOzs7Ozs7O0FBS0E7QUFFQTtBQUNBO0FBRUE7Ozs7O0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFLQTtBQUNBO0FBRUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../gator/js/lib/Service.js\n')},"../gator/js/lib/ServiceCaching.js":
/*!*****************************************!*\
  !*** ../gator/js/lib/ServiceCaching.js ***!
  \*****************************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Service */ "../gator/js/lib/Service.js");\n/* harmony import */ var _MASCP__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MASCP */ "../gator/js/lib/MASCP.js");\n\n\nvar get_db_data, store_db_data, search_service, clear_service, find_latest_data, data_timestamps, sweep_cache, cached_accessions, begin_transaction, end_transaction, first_accession;\nvar max_age = 0,\n    min_age = 0;\n\nclass CachingService extends _Service__WEBPACK_IMPORTED_MODULE_0__["default"] {}\n\nCachingService.BeginCaching = function () {\n  CachingService.CacheService(CachingService.prototype);\n}; // To do 7 days ago, you do\n// var date = new Date();\n// date.setDate(date.getDate() - 1);\n// Service.SetMinimumFreshnessAge(date);\n// Set the minimum age if you want nothing OLDER than this date\n\n\nCachingService.SetMinimumAge = function (date) {\n  if (date === 0) {\n    min_age = 0;\n  } else {\n    min_age = date.getTime();\n  }\n}; // Set the maximum age if you want nothing NEWER than this date\n\n\nCachingService.SetMaximumAge = function (date) {\n  if (date === 0) {\n    max_age = 0;\n  } else {\n    max_age = date.getTime();\n  }\n};\n\nCachingService.SweepCache = function (date) {\n  if (!date) {\n    date = new Date();\n  }\n\n  sweep_cache(date.getTime());\n};\n\nCachingService.CacheService = function (reader) {\n  if (reader.prototype && reader.prototype.retrieve.caching || reader.retrieve.caching) {\n    return;\n  }\n\n  var _oldRetrieve = reader.retrieve;\n  var has_avoid;\n\n  reader.retrieve = function (agi, cback) {\n    var self = this;\n    var id = agi ? agi : self.agi;\n\n    if (!id) {\n      _oldRetrieve.call(self, id, cback);\n\n      return self;\n    }\n\n    id = id.toLowerCase();\n    self.agi = id;\n\n    if (self.avoid_database) {\n      if (has_avoid) {\n        return;\n      }\n\n      has_avoid = self._dataReceived;\n\n      self._dataReceived = function () {\n        return function (dat) {\n          var res = has_avoid.call(this, dat);\n          var id = self.agi;\n\n          if (res && this.result && this.result._raw_data !== null) {\n            store_db_data(id, this.toString(), this.result._raw_data || {});\n          }\n\n          dat = {};\n          return res;\n        };\n      }();\n\n      cback.call(self);\n      return;\n    }\n\n    if (has_avoid && !self.avoid_database) {\n      self._dataReceived = has_avoid;\n      has_avoid = null;\n      cback.call(self);\n      return;\n    }\n\n    get_db_data(id, self.toString(), function (err, data) {\n      if (data) {\n        if (cback) {\n          self.result = null;\n\n          var done_func = function done_func(err) {\n            bean.remove(self, "resultReceived", arguments.callee);\n            bean.remove(self, "error", arguments.callee);\n            cback.call(self, err);\n          };\n\n          bean.add(self, "resultReceived", done_func);\n          bean.add(self, "error", done_func);\n        }\n\n        var received_flag = self._dataReceived(data, "db");\n\n        if (received_flag) {\n          self.gotResult();\n        }\n\n        if (received_flag !== null) {\n          self.requestComplete();\n        } else {\n          self.requestIncomplete();\n        }\n      } else {\n        var old_received = self._dataReceived;\n\n        self._dataReceived = function () {\n          return function (dat, source) {\n            var res = old_received.call(this, dat, source);\n\n            if (res && this.result && this.result._raw_data !== null) {\n              store_db_data(id, this.toString(), this.result._raw_data || {});\n            }\n\n            this._dataReceived = null;\n            this._dataReceived = old_received;\n            dat = {};\n            return res;\n          };\n        }();\n\n        var old_url = self._endpointURL; // If we have a maximum age, i.e. we don\'t want anything newer than a date\n        // we should not actually do a request that won\'t respect that.\n        // We can set a minimum age, since the latest data will be, by definition be the latest!\n\n        if (max_age !== 0) {\n          self._endpointURL = null;\n        }\n\n        _oldRetrieve.call(self, id, cback);\n\n        self._endpointURL = old_url;\n      }\n    });\n    return self;\n  };\n\n  reader.retrieve.caching = true;\n};\n\nCachingService.FindCachedService = function (service, cback) {\n  var serviceString = service.toString();\n  search_service(serviceString, cback);\n  return true;\n};\n\nCachingService.CachedAgis = function (service, cback) {\n  var serviceString = service.toString();\n  cached_accessions(serviceString, cback);\n  return true;\n};\n\nCachingService.FirstAgi = function (service, cback) {\n  var serviceString = service.toString();\n  first_accession(serviceString, cback);\n  return true;\n};\n\nCachingService.ClearCache = function (service, agi, callback) {\n  var serviceString = service.toString();\n\n  if (!callback) {\n    callback = function callback() {};\n  }\n\n  clear_service(serviceString, agi, callback);\n  return true;\n};\n\nCachingService.HistoryForService = function (service, cback) {\n  var serviceString = service.toString();\n  data_timestamps(serviceString, null, cback);\n};\n\nCachingService.Snapshot = function (service, date, wanted, cback) {\n  var serviceString = service.toString();\n  get_snapshot(serviceString, null, wanted, cback);\n};\n\nvar transaction_ref_count = 0;\nvar waiting_callbacks = [];\n\nCachingService.BulkOperation = function (callback) {\n  transaction_ref_count++;\n\n  var trans = function trans(callback) {\n    if (!callback) {\n      callback = function callback() {};\n    }\n\n    transaction_ref_count--;\n    waiting_callbacks.push(callback);\n\n    if (transaction_ref_count == 0) {\n      end_transaction(function (err) {\n        waiting_callbacks.forEach(function (cback) {\n          cback(err);\n        });\n        waiting_callbacks = [];\n      });\n    }\n  };\n\n  begin_transaction(callback, trans);\n  return trans;\n};\n\nvar setup_idb = function setup_idb(idb) {\n  var transaction_store_db;\n  var transaction_find_latest;\n  var transaction_data = [];\n\n  begin_transaction = function begin_transaction(callback, trans) {\n    if (transaction_store_db != null) {\n      setTimeout(function () {\n        callback.call({\n          "transaction": trans\n        });\n      }, 0);\n      return false;\n    }\n\n    transaction_store_db = store_db_data;\n\n    store_db_data = function store_db_data(acc, service, data) {\n      transaction_data.push([acc, service, data]);\n    };\n\n    setTimeout(function () {\n      callback.call({\n        "transaction": trans\n      });\n    }, 0);\n    return true;\n  };\n\n  end_transaction = function end_transaction(callback) {\n    if (transaction_store_db === null) {\n      callback(null);\n      return;\n    }\n\n    store_db_data = transaction_store_db;\n    transaction_store_db = null;\n    var trans = idb.transaction(["cached"], "readwrite");\n    var store = trans.objectStore("cached");\n\n    trans.oncomplete = function (event) {\n      callback(null);\n    };\n\n    trans.onerror = function (event) {\n      callback(event.target.errorCode);\n    };\n\n    while (transaction_data.length > 0) {\n      var row = transaction_data.shift();\n      var acc = row[0];\n      var service = row[1];\n      var data = row[2];\n\n      if (typeof data != \'object\' || data.constructor.name !== \'Object\' || typeof Document != \'undefined\' && data instanceof Document) {\n        continue;\n      }\n\n      var dateobj = data.retrieved ? data.retrieved : new Date();\n\n      if (typeof dateobj === \'string\' || typeof dateobj === \'number\') {\n        dateobj = new Date(dateobj);\n      }\n\n      dateobj.setUTCHours(0);\n      dateobj.setUTCMinutes(0);\n      dateobj.setUTCSeconds(0);\n      dateobj.setUTCMilliseconds(0);\n      var reporter = insert_report_func(acc, service);\n      var datetime = dateobj.getTime();\n      data.id = [acc, service, datetime];\n      data.acc = acc;\n      data.service = service;\n\n      if (window.msIndexedDB) {\n        data.serviceacc = service + acc;\n      }\n\n      data.retrieved = datetime;\n      var req = store.put(data);\n      req.onerror = reporter;\n    }\n  };\n\n  var insert_report_func = function insert_report_func(acc, service) {\n    return function (err, rows) {\n      if (!err && rows) {}\n    };\n  };\n\n  store_db_data = function store_db_data(acc, service, data) {\n    var trans = idb.transaction(["cached"], "readwrite");\n    var store = trans.objectStore("cached");\n\n    if (typeof data != \'object\' || typeof Document != \'undefined\' && data instanceof Document) {\n      return;\n    }\n\n    var dateobj = data.retrieved ? data.retrieved : new Date();\n\n    if (typeof dateobj === \'string\' || typeof dateobj === \'number\') {\n      dateobj = new Date(dateobj);\n    }\n\n    dateobj.setUTCHours(0);\n    dateobj.setUTCMinutes(0);\n    dateobj.setUTCSeconds(0);\n    dateobj.setUTCMilliseconds(0);\n    var reporter = insert_report_func(acc, service);\n    var datetime = dateobj.getTime();\n    data.id = [acc, service, datetime];\n    data.acc = acc;\n\n    if (window.msIndexedDB) {\n      data.serviceacc = service + acc;\n    }\n\n    data.service = service;\n    data.retrieved = datetime;\n    var req = store.put(data); // req.onsuccess = reporter;\n\n    req.onerror = reporter;\n  };\n\n  get_db_data = function get_db_data(acc, service, cback) {\n    var timestamps = max_age ? [min_age, max_age] : [min_age, new Date().getTime()];\n    return find_latest_data(acc, service, timestamps, cback);\n  };\n\n  find_latest_data = function find_latest_data(acc, service, timestamps, cback) {\n    if (!acc) {\n      cback.call();\n      return;\n    }\n\n    var trans = idb.transaction(["cached"], "readonly");\n    var store = trans.objectStore("cached");\n    var idx = store.index(window.msIndexedDB ? "entries-ms" : "entries");\n    var max_stamp = -1;\n    var result = null;\n    var range = IDBKeyRange.only(window.msIndexedDB ? service + acc : [acc, service]);\n\n    idx.openCursor(range).onsuccess = function (event) {\n      var cursor = event.target.result;\n\n      if (cursor) {\n        var ts = window.msIndexedDB ? cursor.value.retrieved : cursor.primaryKey[2];\n        var c_acc = window.msIndexedDB ? cursor.value.acc : cursor.primaryKey[0];\n        var serv = window.msIndexedDB ? cursor.value.service : cursor.primaryKey[1];\n\n        if (ts >= timestamps[0] && ts <= timestamps[1]) {\n          if (ts > max_stamp && c_acc == acc && serv == service) {\n            result = cursor.value;\n            max_stamp = ts;\n            result.retrieved = new Date(ts);\n          }\n        }\n\n        cursor.continue();\n      } else {\n        if (result) {// result = result.data\n        }\n\n        cback.call(null, null, result);\n      }\n    };\n  };\n\n  sweep_cache = function sweep_cache(timestamp) {\n    var trans = idb.transaction(["cached"], "readwrite");\n    var store = trans.objectStore("cached");\n    var idx = store.index("timestamps");\n    var results = [];\n\n    idx.openKeyCursor(null, "nextunique").onsuccess = function (event) {\n      var cursor = event.target.result;\n\n      if (cursor) {\n        if (timestamp >= cursor.key[1]) {\n          store.delete(cursor.primaryKey);\n        }\n\n        cursor.continue();\n      }\n    };\n  };\n\n  data_timestamps = function data_timestamps(service, timestamps, cback) {\n    if (!timestamps || typeof timestamps != \'object\' || !timestamps.length) {\n      timestamps = [0, new Date().getTime()];\n    }\n\n    var trans = idb.transaction(["cached"], "readonly");\n    var store = trans.objectStore("cached");\n    var idx = store.index("timestamps");\n    var results = [];\n\n    idx.openKeyCursor(null, "nextunique").onsuccess = function (event) {\n      var cursor = event.target.result;\n\n      if (cursor) {\n        if (cursor.key[0] == service && timestamps[0] <= cursor.key[1] && timestamps[1] >= cursor.key[1]) {\n          results.push(new Date(parseInt(cursor.key[1])));\n        }\n\n        cursor.continue();\n      } else {\n        cback.call(null, results);\n      }\n    };\n  };\n\n  clear_service = function clear_service(service, acc, callback) {\n    var trans = idb.transaction(["cached"], "readwrite");\n    var store = trans.objectStore("cached");\n    var idx = store.index("services");\n    var range = IDBKeyRange.only(service);\n\n    idx.openCursor(range).onsuccess = function (event) {\n      var cursor = event.target.result;\n\n      if (cursor) {\n        if (!acc || cursor.value.acc == acc) {\n          if (window.msIndexedDB) {\n            store.delete(cursor.value.serviceacc);\n          } else {\n            store.delete(cursor.value.id ? cursor.value.id : cursor.primaryKey);\n          }\n        }\n\n        cursor.continue();\n      }\n    };\n\n    trans.oncomplete = function () {\n      callback.call(_Service__WEBPACK_IMPORTED_MODULE_0__["default"]);\n    };\n  };\n\n  search_service = function search_service(service, cback) {\n    var trans = idb.transaction(["cached"], "readonly");\n    var store = trans.objectStore("cached");\n    var idx = store.index("services");\n    var results = [];\n    var range = IDBKeyRange.only(service);\n\n    idx.openKeyCursor(range, "nextunique").onsuccess = function (event) {\n      var cursor = event.target.result;\n\n      if (cursor) {\n        results.push(cursor.key);\n        cursor.continue();\n      } else {\n        cback.call(_Service__WEBPACK_IMPORTED_MODULE_0__["default"], results);\n      }\n    };\n  };\n\n  first_accession = function first_accession(service, cback) {\n    var trans = idb.transaction(["cached"], "readonly");\n    var store = trans.objectStore("cached");\n    var idx = store.index("services");\n    var range = IDBKeyRange.only(service);\n\n    idx.openCursor(range, "nextunique").onsuccess = function (event) {\n      var cursor = event.target.result;\n\n      if (cursor) {\n        cback.call(_Service__WEBPACK_IMPORTED_MODULE_0__["default"], cursor.value.acc);\n      } else {\n        cback.call(_Service__WEBPACK_IMPORTED_MODULE_0__["default"], null);\n      }\n    };\n  };\n\n  cached_accessions = function cached_accessions(service, cback) {\n    var trans = idb.transaction(["cached"], "readonly");\n    var store = trans.objectStore("cached");\n    var idx = store.index("services");\n    var results = [];\n    var range = IDBKeyRange.only(service);\n\n    idx.openCursor(range).onsuccess = function (event) {\n      var cursor = event.target.result;\n\n      if (cursor) {\n        results.push(cursor.value.acc);\n        cursor.continue();\n      } else {\n        cback.call(_Service__WEBPACK_IMPORTED_MODULE_0__["default"], results);\n      }\n    };\n  };\n};\n\nvar setup_websql = function setup_websql(db) {\n  db.all(\'SELECT version from versions where tablename = "datacache"\', function (err, rows) {\n    var version = rows && rows.length > 0 ? rows[0].version : null;\n\n    if (version == 1.3) {\n      if (_MASCP__WEBPACK_IMPORTED_MODULE_1__["default"].events) {\n        _MASCP__WEBPACK_IMPORTED_MODULE_1__["default"].events.emit(\'ready\');\n      }\n\n      if (_MASCP__WEBPACK_IMPORTED_MODULE_1__["default"].ready) {\n        _MASCP__WEBPACK_IMPORTED_MODULE_1__["default"].ready();\n        _MASCP__WEBPACK_IMPORTED_MODULE_1__["default"].ready = true;\n      } else {\n        _MASCP__WEBPACK_IMPORTED_MODULE_1__["default"].ready = true;\n      }\n\n      return;\n    }\n\n    if (!version || version == "" || version < 1.0) {\n      db.exec(\'CREATE TABLE if not exists versions (version REAL, tablename TEXT);\');\n      db.exec(\'CREATE TABLE if not exists "datacache" (agi TEXT,service TEXT,retrieved REAL,data TEXT);\', function (err) {\n        if (err && err != "Error: not an error") {\n          throw err;\n        }\n      });\n      db.exec(\'DELETE FROM versions where tablename = "datacache"\');\n      db.exec(\'INSERT INTO versions(version,tablename) VALUES(1.1,"datacache");\', function (err, rows) {\n        if (!err) {//                        console.log("Upgrade to 1.1 completed");\n        }\n      });\n      version = 1.1;\n    }\n\n    if (version < 1.2) {\n      db.exec(\'DROP TABLE if exists datacache_tmp;\');\n      db.exec(\'CREATE TABLE if not exists datacache_tmp (acc TEXT,service TEXT,retrieved REAL,data TEXT);\');\n      db.exec(\'INSERT INTO datacache_tmp(acc,service,retrieved,data) SELECT agi,service,retrieved,data FROM datacache;\');\n      db.exec(\'DROP TABLE datacache;\');\n      db.exec(\'ALTER TABLE datacache_tmp RENAME TO datacache;\');\n      db.exec(\'CREATE INDEX accessions on datacache(acc);\');\n      db.exec(\'CREATE INDEX accessions_service on datacache(acc,service);\');\n      db.exec(\'DELETE FROM versions where tablename = "datacache"\');\n      db.exec(\'INSERT INTO versions(version,tablename) VALUES(1.2,"datacache");\', function (err, rows) {\n        if (!err) {//                          console.log("Upgrade to 1.2 completed");\n        }\n      });\n      version = 1.2;\n    }\n\n    if (version < 1.3) {\n      db.exec(\'CREATE INDEX if not exists services on datacache(service);\');\n      db.exec(\'DELETE FROM versions where tablename = "datacache"\');\n      db.exec(\'INSERT INTO versions(version,tablename) VALUES(1.3,"datacache");\', function (err, rows) {\n        if (!err) {\n          if (_MASCP__WEBPACK_IMPORTED_MODULE_1__["default"].events) {\n            _MASCP__WEBPACK_IMPORTED_MODULE_1__["default"].events.emit(\'ready\');\n          }\n\n          if (_MASCP__WEBPACK_IMPORTED_MODULE_1__["default"].ready) {\n            _MASCP__WEBPACK_IMPORTED_MODULE_1__["default"].ready();\n            _MASCP__WEBPACK_IMPORTED_MODULE_1__["default"].ready = true;\n          } else {\n            _MASCP__WEBPACK_IMPORTED_MODULE_1__["default"].ready = true;\n          }\n        }\n      });\n      version = 1.3;\n    }\n  });\n\n  begin_transaction = function begin_transaction(callback, trans) {\n    callback.call({\n      "transaction": trans\n    });\n  };\n\n  end_transaction = function end_transaction(callback) {\n    callback();\n  };\n\n  sweep_cache = function sweep_cache(timestamp) {\n    db.all("DELETE from datacache where retrieved <= ? ", [timestamp], function () {});\n  };\n\n  clear_service = function clear_service(service, acc, callback) {\n    var servicename = service;\n    servicename += "%";\n\n    if (!acc) {\n      db.all("DELETE from datacache where service like ? ", [servicename], function () {\n        callback.call(_Service__WEBPACK_IMPORTED_MODULE_0__["default"]);\n      });\n    } else {\n      db.all("DELETE from datacache where service like ? and acc = ?", [servicename, acc.toLowerCase()], function () {\n        callback.call(_Service__WEBPACK_IMPORTED_MODULE_0__["default"]);\n      });\n    }\n  };\n\n  search_service = function search_service(service, cback) {\n    db.all("SELECT distinct service from datacache where service like ? ", [service + "%"], function (err, records) {\n      var results = {};\n\n      if (records && records.length > 0) {\n        records.forEach(function (record) {\n          results[record.service] = true;\n        });\n      }\n\n      var uniques = [];\n\n      for (var k in results) {\n        if (results.hasOwnProperty(k)) {\n          uniques.push(k);\n        }\n      }\n\n      cback.call(_Service__WEBPACK_IMPORTED_MODULE_0__["default"], uniques);\n      return uniques;\n    });\n  };\n\n  first_accession = function first_accession(service, cback) {\n    db.all("SELECT distinct acc from datacache where service = ? limit 1", [service], function (err, records) {\n      if (!records || records.length < 1) {\n        cback.call(_Service__WEBPACK_IMPORTED_MODULE_0__["default"], null);\n      } else {\n        cback.call(_Service__WEBPACK_IMPORTED_MODULE_0__["default"], records[0].acc);\n      }\n    });\n  };\n\n  cached_accessions = function cached_accessions(service, cback) {\n    db.all("SELECT distinct acc from datacache where service = ?", [service], function (err, records) {\n      var results = [];\n\n      for (var i = 0; i < records.length; i++) {\n        results.push(records[i].acc);\n      }\n\n      cback.call(_Service__WEBPACK_IMPORTED_MODULE_0__["default"], results);\n    });\n  };\n\n  get_snapshot = function get_snapshot(service, timestamps, wanted, cback) {\n    if (!timestamps || typeof timestamps != \'object\' || !timestamps.length) {\n      timestamps = [0, new Date().getTime()];\n    }\n\n    var sql;\n    var args = [service, timestamps[0], timestamps[1]];\n\n    if (wanted && Array.isArray(wanted)) {\n      var question_marks = new Array(wanted.length + 1).join(\',?\').substring(1);\n      args = args.concat(wanted);\n      sql = "SELECT * from datacache where service = ? AND retrieved >= ? AND retrieved <= ? AND acc in (" + question_marks + ") ORDER BY retrieved ASC";\n    } else {\n      if (wanted && /^\\d+$/.test(wanted.toString())) {\n        sql = "SELECT * from datacache where service = ? AND retrieved >= ? AND retrieved <= ? LIMIT ? ORDER BY retrieved ASC";\n        args = args.concat(parseInt(wanted.toString()));\n      } else {\n        sql = "SELECT * from datacache where service = ? AND retrieved >= ? AND retrieved <= ? ORDER BY retrieved ASC";\n      }\n    }\n\n    db.all(sql, args, function (err, records) {\n      records = records || [];\n      var results = {};\n      records.forEach(function (record) {\n        var data = typeof record.data === \'string\' ? JSON.parse(record.data) : record.data;\n\n        if (data) {\n          data.retrieved = new Date(parseInt(record.retrieved));\n        }\n\n        if (results[record.acc] && results[record.acc].retrieved > record.retrieved) {\n          return;\n        }\n\n        results[record.acc] = record;\n      });\n      cback.call(null, null, results);\n    });\n  };\n\n  get_db_data = function get_db_data(acc, service, cback) {\n    var timestamps = max_age ? [min_age, max_age] : [min_age, new Date().getTime()];\n    return find_latest_data(acc, service, timestamps, cback);\n  };\n\n  var insert_report_func = function insert_report_func(acc, service) {\n    return function (err, rows) {\n      if (!err && rows) {//                    console.log("Caching result for "+acc+" in "+service);\n      }\n    };\n  };\n\n  store_db_data = function store_db_data(acc, service, data) {\n    if (typeof data != \'object\' || typeof Document != \'undefined\' && data instanceof Document) {\n      return;\n    }\n\n    var str_rep;\n\n    try {\n      str_rep = JSON.stringify(data);\n    } catch (err) {\n      return;\n    }\n\n    var dateobj = data.retrieved ? data.retrieved : new Date();\n\n    if (typeof dateobj == \'string\') {\n      dateobj = new Date();\n    }\n\n    dateobj.setUTCHours(0);\n    dateobj.setUTCMinutes(0);\n    dateobj.setUTCSeconds(0);\n    dateobj.setUTCMilliseconds(0);\n    var datetime = dateobj.getTime();\n    data = {};\n    db.all("INSERT INTO datacache(acc,service,retrieved,data) VALUES(?,?,?,?)", [acc, service, datetime, str_rep], insert_report_func(acc, service));\n  };\n\n  find_latest_data = function find_latest_data(acc, service, timestamps, cback) {\n    var sql = "SELECT * from datacache where acc=? and service=? and retrieved >= ? and retrieved <= ? ORDER BY retrieved DESC LIMIT 1";\n    var args = [acc, service, timestamps[0], timestamps[1]];\n    db.all(sql, args, function (err, records) {\n      if (records && records.length > 0 && typeof records[0] != "undefined") {\n        var data = typeof records[0].data === \'string\' ? JSON.parse(records[0].data) : records[0].data;\n\n        if (data) {\n          data.retrieved = new Date(parseInt(records[0].retrieved));\n        }\n\n        cback.call(null, null, data);\n      } else {\n        cback.call(null, null, null);\n      }\n    });\n  };\n\n  data_timestamps = function data_timestamps(service, timestamps, cback) {\n    if (!timestamps || typeof timestamps != \'object\' || !timestamps.length) {\n      timestamps = [0, new Date().getTime()];\n    }\n\n    var sql = "SELECT distinct retrieved from datacache where service=? and retrieved >= ? and retrieved <= ? ORDER BY retrieved ASC";\n    var args = [service, timestamps[0], timestamps[1]];\n    db.all(sql, args, function (err, records) {\n      var result = [];\n\n      if (records && records.length > 0 && typeof records[0] != "undefined") {\n        for (var i = records.length - 1; i >= 0; i--) {\n          result.push(new Date(parseInt(records[i].retrieved)));\n        }\n      }\n\n      cback.call(null, result);\n    });\n  };\n};\n\nvar setup_localstorage = function setup_localstorage() {\n  sweep_cache = function sweep_cache(timestamp) {\n    if ("localStorage" in window) {\n      var keys = [];\n\n      for (var i = 0, len = localStorage.length; i < len; i++) {\n        keys.push(localStorage.key(i));\n      }\n\n      var key = keys.shift();\n\n      while (key) {\n        if (new RegExp("^MASCP.*").test(key)) {\n          var data = localStorage[key];\n\n          if (data && typeof data === \'string\') {\n            var datablock = JSON.parse(data);\n            datablock.retrieved = timestamp;\n            localStorage.removeItem(key);\n          }\n        }\n\n        key = keys.shift();\n      }\n    }\n  };\n\n  clear_service = function clear_service(service, acc, callback) {\n    if ("localStorage" in window) {\n      var keys = [];\n\n      for (var i = 0, len = localStorage.length; i < len; i++) {\n        keys.push(localStorage.key(i));\n      }\n\n      var key = keys.shift();\n\n      while (key) {\n        if (new RegExp("^" + service + ".*" + (acc ? "#" + acc.toLowerCase() + "$" : "")).test(key)) {\n          localStorage.removeItem(key);\n\n          if (acc) {\n            return;\n          }\n        }\n\n        key = keys.shift();\n      }\n\n      callback.call(_Service__WEBPACK_IMPORTED_MODULE_0__["default"]);\n    }\n  };\n\n  search_service = function search_service(service, cback) {\n    var results = {};\n\n    if ("localStorage" in window) {\n      var key;\n      var re = new RegExp("^" + service + ".*");\n\n      for (var i = 0, len = localStorage.length; i < len; i++) {\n        key = localStorage.key(i);\n\n        if (re.test(key)) {\n          results[key.replace(/\\.#.*$/g, \'\')] = true;\n        }\n      }\n    }\n\n    var uniques = [];\n\n    for (var k in results) {\n      if (results.hasOwnProperty(k)) {\n        uniques.push(k);\n      }\n    }\n\n    cback.call(CachingService, uniques);\n    return uniques;\n  };\n\n  first_accession = function first_accession(service, cback) {\n    if ("localStorage" in window) {\n      var key;\n      var re = new RegExp("^" + service);\n\n      for (var i = 0, len = localStorage.length; i < len; i++) {\n        key = localStorage.key(i);\n\n        if (re.test(key)) {\n          key = key.replace(service, \'\');\n          cback.call(CachingService, key);\n          return;\n        }\n      }\n    }\n\n    cback.call(CachingService, null);\n  };\n\n  cached_accessions = function cached_accessions(service, cback) {\n    if ("localStorage" in window) {\n      var key;\n      var re = new RegExp("^" + service);\n\n      for (var i = 0, len = localStorage.length; i < len; i++) {\n        key = localStorage.key(i);\n\n        if (re.test(key)) {\n          key = key.replace(service, \'\');\n          results[key] = true;\n        }\n      }\n    }\n\n    var uniques = [];\n\n    for (var k in results) {\n      if (results.hasOwnProperty(k)) {\n        uniques.push(k);\n      }\n    }\n\n    cback.call(CachingService, uniques);\n  };\n\n  get_db_data = function get_db_data(acc, service, cback) {\n    var data = localStorage[service.toString() + ".#" + (acc || \'\').toLowerCase()];\n\n    if (data && typeof data === \'string\') {\n      var datablock = JSON.parse(data);\n      datablock.retrieved = new Date(parseInt(datablock.retrieved));\n      cback.call(null, null, datablock);\n    } else {\n      cback.call(null, null, null);\n    }\n  };\n\n  store_db_data = function store_db_data(acc, service, data) {\n    if (data && (typeof data !== \'object\' || data instanceof Document || data.nodeName)) {\n      return;\n    }\n\n    data.retrieved = new Date().getTime();\n    localStorage[service.toString() + ".#" + (acc || \'\').toLowerCase()] = JSON.stringify(data);\n  };\n\n  find_latest_data = function find_latest_data(acc, service, timestamp, cback) {\n    // We don\'t actually retrieve historical data for this\n    return get_db_data(acc, service, cback);\n  };\n\n  data_timestamps = function data_timestamps(service, timestamp, cback) {\n    cback.call(null, []);\n  };\n\n  begin_transaction = function begin_transaction(callback) {\n    // No support for transactions here. Do nothing.\n    setTimeout(function () {\n      callback.call();\n    }, 0);\n  };\n\n  end_transaction = function end_transaction(callback) {\n    // No support for transactions here. Do nothing.\n    setTimeout(function () {\n      callback();\n    }, 0);\n  };\n\n  if (_MASCP__WEBPACK_IMPORTED_MODULE_1__["default"].events) {\n    _MASCP__WEBPACK_IMPORTED_MODULE_1__["default"].events.emit(\'ready\');\n  }\n\n  setTimeout(function () {\n    if (_MASCP__WEBPACK_IMPORTED_MODULE_1__["default"].ready) {\n      _MASCP__WEBPACK_IMPORTED_MODULE_1__["default"].ready();\n      _MASCP__WEBPACK_IMPORTED_MODULE_1__["default"].ready = true;\n    } else {\n      _MASCP__WEBPACK_IMPORTED_MODULE_1__["default"].ready = true;\n    }\n  }, 100);\n};\n\nvar db, idb;\n\nif ("openDatabase" in window || "indexedDB" in window) {\n  if ("indexedDB" in window) {\n    /* Versioning of DB schema */\n    var change_func = function change_func(version, transaction) {\n      var db = transaction.db;\n\n      if (db.objectStoreNames && db.objectStoreNames.contains("cached")) {\n        db.deleteObjectStore("cached");\n      }\n\n      var keypath = window.msIndexedDB ? "serviceacc" : "id";\n      var store = db.createObjectStore("cached", {\n        keyPath: keypath\n      });\n      store.createIndex("entries", ["acc", "service"], {\n        unique: false\n      });\n\n      if (window.msIndexedDB) {\n        store.createIndex("entries-ms", "serviceacc", {\n          unique: false\n        });\n      }\n\n      store.createIndex("timestamps", ["service", "retrieved"], {\n        unique: false\n      });\n      store.createIndex("services", "service", {\n        unique: false\n      });\n\n      transaction.oncomplete = function () {\n        database_ready(db);\n\n        database_ready = function database_ready() {};\n      };\n    };\n\n    idb = true;\n    var db_version = 2;\n    var req = indexedDB.open("datacache", db_version);\n\n    req.onupgradeneeded = function (e) {\n      var transaction = req.transaction;\n      change_func(e.oldVersion, transaction);\n    };\n\n    var database_ready = function database_ready(db) {\n      if (db) {\n        idb = db;\n      }\n\n      setup_idb(idb);\n\n      if (_MASCP__WEBPACK_IMPORTED_MODULE_1__["default"].events) {\n        _MASCP__WEBPACK_IMPORTED_MODULE_1__["default"].events.emit("ready");\n      }\n\n      if (_MASCP__WEBPACK_IMPORTED_MODULE_1__["default"].ready) {\n        _MASCP__WEBPACK_IMPORTED_MODULE_1__["default"].ready();\n        _MASCP__WEBPACK_IMPORTED_MODULE_1__["default"].ready = true;\n      } else {\n        _MASCP__WEBPACK_IMPORTED_MODULE_1__["default"].ready = true;\n      }\n    };\n\n    req.onerror = function (e) {\n      console.log("Error loading Database");\n      setup_localstorage(); // setTimeout(function() {\n      //     indexedDB.deleteDatabase("datacache").onsuccess = function() {\n      //     }\n      // },0);\n    };\n\n    req.onsuccess = function (e) {\n      idb = e.target.result;\n      var version = db_version;\n\n      if (idb.version != Number(version)) {\n        var versionRequest = db.setVersion(ver);\n\n        versionRequest.onsuccess = function (e) {\n          var transaction = versionRequest.result;\n          change_func(oldVersion, transaction);\n        };\n      } else {\n        database_ready();\n      }\n    };\n  } else {\n    try {\n      db = openDatabase("cached", "", "MASCP Gator cache", 1024 * 1024);\n    } catch (err) {\n      throw err;\n    }\n\n    db.all = function (sql, args, callback) {\n      this.exec(sql, args, callback);\n    };\n\n    db.exec = function (sql, args, callback) {\n      var self = this;\n      var sqlargs = args;\n      var cback = callback;\n\n      if (typeof cback == \'undefined\' && sqlargs && Object.prototype.toString.call(sqlargs) != \'[object Array]\') {\n        cback = args;\n        sqlargs = null;\n      }\n\n      self.transaction(function (tx) {\n        tx.executeSql(sql, sqlargs, function (tx, result) {\n          var res = [];\n\n          for (var i = 0; i < result.rows.length; i++) {\n            res.push(result.rows.item(i));\n          }\n\n          if (cback) {\n            cback.call(db, null, res);\n          }\n        }, function (tx, err) {\n          if (cback) {\n            cback.call(db, err);\n          }\n        });\n      });\n    };\n  }\n}\n\nif (typeof idb !== \'undefined\') {// Do nothing\n} else if (typeof db !== \'undefined\') {\n  setup_websql(db);\n} else if ("localStorage" in window) {\n  setup_localstorage();\n} else {\n  sweep_cache = function sweep_cache(timestamp) {};\n\n  clear_service = function clear_service(service, acc) {};\n\n  search_service = function search_service(service, cback) {};\n\n  cached_accessions = function cached_accessions(service, cback) {\n    cback.call(CachingService, []);\n  };\n\n  get_db_data = function get_db_data(acc, service, cback) {\n    cback.call(null, null, null);\n  };\n\n  store_db_data = function store_db_data(acc, service, data) {};\n\n  find_latest_data = function find_latest_data(acc, service, timestamp, cback) {\n    // We don\'t actually retrieve historical data for this\n    cback.call(null, []);\n  };\n\n  data_timestamps = function data_timestamps(service, timestamp, cback) {\n    cback.call(null, []);\n  };\n\n  begin_transaction = function begin_transaction(callback, trans) {\n    // No support for transactions here. Do nothing.\n    setTimeout(function () {\n      callback({\n        "transaction": trans\n      });\n    }, 0);\n  };\n\n  end_transaction = function end_transaction(callback) {\n    // No support for transactions here. Do nothing.\n    setTimeout(function () {\n      callback();\n    }, 0);\n  };\n}\n\n/* harmony default export */ __webpack_exports__["default"] = (CachingService);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vZ2F0b3IvanMvbGliL1NlcnZpY2VDYWNoaW5nLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL2dhdG9yL2pzL2xpYi9TZXJ2aWNlQ2FjaGluZy5qcz9jMjc1Il0sInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IFNlcnZpY2UgZnJvbSAnLi9TZXJ2aWNlJztcbmltcG9ydCBNQVNDUCBmcm9tICcuL01BU0NQJztcblxudmFyIGdldF9kYl9kYXRhLCBzdG9yZV9kYl9kYXRhLCBzZWFyY2hfc2VydmljZSwgY2xlYXJfc2VydmljZSwgZmluZF9sYXRlc3RfZGF0YSwgZGF0YV90aW1lc3RhbXBzLCBzd2VlcF9jYWNoZSwgY2FjaGVkX2FjY2Vzc2lvbnMsIGJlZ2luX3RyYW5zYWN0aW9uLCBlbmRfdHJhbnNhY3Rpb24sZmlyc3RfYWNjZXNzaW9uO1xuXG52YXIgbWF4X2FnZSA9IDAsIG1pbl9hZ2UgPSAwO1xuXG5jbGFzcyBDYWNoaW5nU2VydmljZSBleHRlbmRzIFNlcnZpY2Uge1xufVxuXG5DYWNoaW5nU2VydmljZS5CZWdpbkNhY2hpbmcgPSBmdW5jdGlvbigpIHtcbiAgICBDYWNoaW5nU2VydmljZS5DYWNoZVNlcnZpY2UoQ2FjaGluZ1NlcnZpY2UucHJvdG90eXBlKTtcbn07XG5cbi8vIFRvIGRvIDcgZGF5cyBhZ28sIHlvdSBkb1xuLy8gdmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xuLy8gZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpIC0gMSk7XG4vLyBTZXJ2aWNlLlNldE1pbmltdW1GcmVzaG5lc3NBZ2UoZGF0ZSk7XG5cbi8vIFNldCB0aGUgbWluaW11bSBhZ2UgaWYgeW91IHdhbnQgbm90aGluZyBPTERFUiB0aGFuIHRoaXMgZGF0ZVxuQ2FjaGluZ1NlcnZpY2UuU2V0TWluaW11bUFnZSA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBpZiAoZGF0ZSA9PT0gMCkge1xuICAgICAgICBtaW5fYWdlID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBtaW5fYWdlID0gZGF0ZS5nZXRUaW1lKCk7XG4gICAgfVxufTtcblxuLy8gU2V0IHRoZSBtYXhpbXVtIGFnZSBpZiB5b3Ugd2FudCBub3RoaW5nIE5FV0VSIHRoYW4gdGhpcyBkYXRlXG5DYWNoaW5nU2VydmljZS5TZXRNYXhpbXVtQWdlID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgIGlmIChkYXRlID09PSAwKSB7XG4gICAgICAgIG1heF9hZ2UgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG1heF9hZ2UgPSBkYXRlLmdldFRpbWUoKTtcbiAgICB9XG59O1xuXG5DYWNoaW5nU2VydmljZS5Td2VlcENhY2hlID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgIGlmICghIGRhdGUpIHtcbiAgICAgICAgZGF0ZSA9IChuZXcgRGF0ZSgpKTtcbiAgICB9XG4gICAgc3dlZXBfY2FjaGUoZGF0ZS5nZXRUaW1lKCkpO1xufTtcblxuQ2FjaGluZ1NlcnZpY2UuQ2FjaGVTZXJ2aWNlID0gZnVuY3Rpb24ocmVhZGVyKSB7XG4gICAgaWYgKChyZWFkZXIucHJvdG90eXBlICYmIHJlYWRlci5wcm90b3R5cGUucmV0cmlldmUuY2FjaGluZykgfHwgcmVhZGVyLnJldHJpZXZlLmNhY2hpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgX29sZFJldHJpZXZlID0gcmVhZGVyLnJldHJpZXZlO1xuICAgIHZhciBoYXNfYXZvaWQ7XG4gICAgcmVhZGVyLnJldHJpZXZlID0gZnVuY3Rpb24oYWdpLGNiYWNrKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGlkID0gYWdpID8gYWdpIDogc2VsZi5hZ2k7XG4gICAgICAgIGlmICggISBpZCApIHtcbiAgICAgICAgICAgIF9vbGRSZXRyaWV2ZS5jYWxsKHNlbGYsaWQsY2JhY2spO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH1cblxuICAgICAgICBpZCA9IGlkLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHNlbGYuYWdpID0gaWQ7XG5cbiAgICAgICAgaWYgKHNlbGYuYXZvaWRfZGF0YWJhc2UpIHtcbiAgICAgICAgICAgIGlmIChoYXNfYXZvaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYXNfYXZvaWQgPSBzZWxmLl9kYXRhUmVjZWl2ZWQ7XG4gICAgICAgICAgICBzZWxmLl9kYXRhUmVjZWl2ZWQgPSAoZnVuY3Rpb24oKSB7IHJldHVybiBmdW5jdGlvbihkYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9IGhhc19hdm9pZC5jYWxsKHRoaXMsZGF0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkID0gc2VsZi5hZ2k7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXMgJiYgdGhpcy5yZXN1bHQgJiYgdGhpcy5yZXN1bHQuX3Jhd19kYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZV9kYl9kYXRhKGlkLHRoaXMudG9TdHJpbmcoKSx0aGlzLnJlc3VsdC5fcmF3X2RhdGEgfHwge30pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRhdCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgIH07fSkoKTtcbiAgICAgICAgICAgIGNiYWNrLmNhbGwoc2VsZik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc19hdm9pZCAmJiAhIHNlbGYuYXZvaWRfZGF0YWJhc2UpIHtcbiAgICAgICAgICAgIHNlbGYuX2RhdGFSZWNlaXZlZCA9IGhhc19hdm9pZDtcbiAgICAgICAgICAgIGhhc19hdm9pZCA9IG51bGw7XG4gICAgICAgICAgICBjYmFjay5jYWxsKHNlbGYpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0X2RiX2RhdGEoaWQsc2VsZi50b1N0cmluZygpLGZ1bmN0aW9uKGVycixkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChjYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkb25lX2Z1bmMgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlYW4ucmVtb3ZlKHNlbGYsXCJyZXN1bHRSZWNlaXZlZFwiLGFyZ3VtZW50cy5jYWxsZWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVhbi5yZW1vdmUoc2VsZixcImVycm9yXCIsYXJndW1lbnRzLmNhbGxlZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYmFjay5jYWxsKHNlbGYsZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYmVhbi5hZGQoc2VsZixcInJlc3VsdFJlY2VpdmVkXCIsZG9uZV9mdW5jKTtcbiAgICAgICAgICAgICAgICAgICAgYmVhbi5hZGQoc2VsZixcImVycm9yXCIsIGRvbmVfZnVuYyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHJlY2VpdmVkX2ZsYWcgPSBzZWxmLl9kYXRhUmVjZWl2ZWQoZGF0YSxcImRiXCIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlY2VpdmVkX2ZsYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5nb3RSZXN1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocmVjZWl2ZWRfZmxhZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnJlcXVlc3RDb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucmVxdWVzdEluY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZF9yZWNlaXZlZCA9IHNlbGYuX2RhdGFSZWNlaXZlZDtcbiAgICAgICAgICAgICAgICBzZWxmLl9kYXRhUmVjZWl2ZWQgPSAoZnVuY3Rpb24oKSB7IHJldHVybiBmdW5jdGlvbihkYXQsc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXMgPSBvbGRfcmVjZWl2ZWQuY2FsbCh0aGlzLGRhdCxzb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzICYmIHRoaXMucmVzdWx0ICYmIHRoaXMucmVzdWx0Ll9yYXdfZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVfZGJfZGF0YShpZCx0aGlzLnRvU3RyaW5nKCksdGhpcy5yZXN1bHQuX3Jhd19kYXRhIHx8IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kYXRhUmVjZWl2ZWQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kYXRhUmVjZWl2ZWQgPSBvbGRfcmVjZWl2ZWQ7XG4gICAgICAgICAgICAgICAgICAgIGRhdCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgIH07fSkoKTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkX3VybCA9IHNlbGYuX2VuZHBvaW50VVJMO1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBtYXhpbXVtIGFnZSwgaS5lLiB3ZSBkb24ndCB3YW50IGFueXRoaW5nIG5ld2VyIHRoYW4gYSBkYXRlXG4gICAgICAgICAgICAgICAgLy8gd2Ugc2hvdWxkIG5vdCBhY3R1YWxseSBkbyBhIHJlcXVlc3QgdGhhdCB3b24ndCByZXNwZWN0IHRoYXQuXG4gICAgICAgICAgICAgICAgLy8gV2UgY2FuIHNldCBhIG1pbmltdW0gYWdlLCBzaW5jZSB0aGUgbGF0ZXN0IGRhdGEgd2lsbCBiZSwgYnkgZGVmaW5pdGlvbiBiZSB0aGUgbGF0ZXN0IVxuICAgICAgICAgICAgICAgIGlmICgobWF4X2FnZSAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZW5kcG9pbnRVUkwgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfb2xkUmV0cmlldmUuY2FsbChzZWxmLGlkLGNiYWNrKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9lbmRwb2ludFVSTCA9IG9sZF91cmw7XG4gICAgICAgICAgICB9ICAgICAgICAgICAgIFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICByZWFkZXIucmV0cmlldmUuY2FjaGluZyA9IHRydWU7XG59O1xuXG5DYWNoaW5nU2VydmljZS5GaW5kQ2FjaGVkU2VydmljZSA9IGZ1bmN0aW9uKHNlcnZpY2UsY2JhY2spIHtcbiAgICB2YXIgc2VydmljZVN0cmluZyA9IHNlcnZpY2UudG9TdHJpbmcoKTtcbiAgICBzZWFyY2hfc2VydmljZShzZXJ2aWNlU3RyaW5nLGNiYWNrKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbkNhY2hpbmdTZXJ2aWNlLkNhY2hlZEFnaXMgPSBmdW5jdGlvbihzZXJ2aWNlLGNiYWNrKSB7XG4gICAgdmFyIHNlcnZpY2VTdHJpbmcgPSBzZXJ2aWNlLnRvU3RyaW5nKCk7XG4gICAgY2FjaGVkX2FjY2Vzc2lvbnMoc2VydmljZVN0cmluZyxjYmFjayk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5DYWNoaW5nU2VydmljZS5GaXJzdEFnaSA9IGZ1bmN0aW9uKHNlcnZpY2UsY2JhY2spIHtcbiAgICB2YXIgc2VydmljZVN0cmluZyA9IHNlcnZpY2UudG9TdHJpbmcoKTtcbiAgICBmaXJzdF9hY2Nlc3Npb24oc2VydmljZVN0cmluZyxjYmFjayk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5DYWNoaW5nU2VydmljZS5DbGVhckNhY2hlID0gZnVuY3Rpb24oc2VydmljZSxhZ2ksY2FsbGJhY2spIHtcbiAgICB2YXIgc2VydmljZVN0cmluZyA9IHNlcnZpY2UudG9TdHJpbmcoKTtcbiAgICBpZiAoICEgY2FsbGJhY2sgKSB7XG4gICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gICAgY2xlYXJfc2VydmljZShzZXJ2aWNlU3RyaW5nLGFnaSxjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5DYWNoaW5nU2VydmljZS5IaXN0b3J5Rm9yU2VydmljZSA9IGZ1bmN0aW9uKHNlcnZpY2UsY2JhY2spIHtcbiAgICB2YXIgc2VydmljZVN0cmluZyA9IHNlcnZpY2UudG9TdHJpbmcoKTtcbiAgICBkYXRhX3RpbWVzdGFtcHMoc2VydmljZVN0cmluZyxudWxsLGNiYWNrKTtcbn07XG5cbkNhY2hpbmdTZXJ2aWNlLlNuYXBzaG90ID0gZnVuY3Rpb24oc2VydmljZSxkYXRlLHdhbnRlZCxjYmFjaykge1xuICAgIHZhciBzZXJ2aWNlU3RyaW5nID0gc2VydmljZS50b1N0cmluZygpO1xuICAgIGdldF9zbmFwc2hvdChzZXJ2aWNlU3RyaW5nLG51bGwsd2FudGVkLGNiYWNrKTtcbn07XG5cbnZhciB0cmFuc2FjdGlvbl9yZWZfY291bnQgPSAwO1xudmFyIHdhaXRpbmdfY2FsbGJhY2tzID0gW107XG5DYWNoaW5nU2VydmljZS5CdWxrT3BlcmF0aW9uID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICB0cmFuc2FjdGlvbl9yZWZfY291bnQrKztcbiAgICB2YXIgdHJhbnMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICBpZiAoICEgY2FsbGJhY2sgKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uKCkge307XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNhY3Rpb25fcmVmX2NvdW50LS07XG4gICAgICAgIHdhaXRpbmdfY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICBpZiAodHJhbnNhY3Rpb25fcmVmX2NvdW50ID09IDApIHtcbiAgICAgICAgICAgIGVuZF90cmFuc2FjdGlvbihmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICB3YWl0aW5nX2NhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKGNiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgd2FpdGluZ19jYWxsYmFja3MgPSBbXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBiZWdpbl90cmFuc2FjdGlvbihjYWxsYmFjayx0cmFucyk7XG4gICAgcmV0dXJuIHRyYW5zO1xufTtcblxudmFyIHNldHVwX2lkYiA9IGZ1bmN0aW9uKGlkYikge1xuICAgIHZhciB0cmFuc2FjdGlvbl9zdG9yZV9kYjtcbiAgICB2YXIgdHJhbnNhY3Rpb25fZmluZF9sYXRlc3Q7XG4gICAgdmFyIHRyYW5zYWN0aW9uX2RhdGEgPSBbXTtcbiAgICBiZWdpbl90cmFuc2FjdGlvbiA9IGZ1bmN0aW9uKGNhbGxiYWNrLHRyYW5zKSB7XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbl9zdG9yZV9kYiAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoeyBcInRyYW5zYWN0aW9uXCIgOiB0cmFucyB9KTtcbiAgICAgICAgICAgIH0sMCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNhY3Rpb25fc3RvcmVfZGIgPSBzdG9yZV9kYl9kYXRhO1xuICAgICAgICBzdG9yZV9kYl9kYXRhID0gZnVuY3Rpb24oYWNjLHNlcnZpY2UsZGF0YSkge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25fZGF0YS5wdXNoKFthY2Msc2VydmljZSxkYXRhXSk7XG4gICAgICAgIH07XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKHsgXCJ0cmFuc2FjdGlvblwiIDogdHJhbnMgfSk7XG4gICAgICAgIH0sMCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBlbmRfdHJhbnNhY3Rpb24gPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICBpZiAodHJhbnNhY3Rpb25fc3RvcmVfZGIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0b3JlX2RiX2RhdGEgPSB0cmFuc2FjdGlvbl9zdG9yZV9kYjtcbiAgICAgICAgdHJhbnNhY3Rpb25fc3RvcmVfZGIgPSBudWxsO1xuICAgICAgICB2YXIgdHJhbnMgPSBpZGIudHJhbnNhY3Rpb24oW1wiY2FjaGVkXCJdLCBcInJlYWR3cml0ZVwiKTtcbiAgICAgICAgdmFyIHN0b3JlID0gdHJhbnMub2JqZWN0U3RvcmUoXCJjYWNoZWRcIik7XG4gICAgICAgIHRyYW5zLm9uY29tcGxldGUgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgIH07XG4gICAgICAgIHRyYW5zLm9uZXJyb3IgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgY2FsbGJhY2soZXZlbnQudGFyZ2V0LmVycm9yQ29kZSk7XG4gICAgICAgIH07XG4gICAgICAgIHdoaWxlICh0cmFuc2FjdGlvbl9kYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciByb3cgPSB0cmFuc2FjdGlvbl9kYXRhLnNoaWZ0KCk7XG4gICAgICAgICAgICB2YXIgYWNjID0gcm93WzBdO1xuICAgICAgICAgICAgdmFyIHNlcnZpY2UgPSByb3dbMV07XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHJvd1syXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPSAnb2JqZWN0JyB8fCBkYXRhLmNvbnN0cnVjdG9yLm5hbWUgIT09ICdPYmplY3QnIHx8ICgoKHR5cGVvZiBEb2N1bWVudCkgIT0gJ3VuZGVmaW5lZCcpICYmIGRhdGEgaW5zdGFuY2VvZiBEb2N1bWVudCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkYXRlb2JqID0gZGF0YS5yZXRyaWV2ZWQgPyBkYXRhLnJldHJpZXZlZCA6IChuZXcgRGF0ZSgpKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0ZW9iaiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGRhdGVvYmogPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgZGF0ZW9iaiA9IG5ldyBEYXRlKGRhdGVvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0ZW9iai5zZXRVVENIb3VycygwKTtcbiAgICAgICAgICAgIGRhdGVvYmouc2V0VVRDTWludXRlcygwKTtcbiAgICAgICAgICAgIGRhdGVvYmouc2V0VVRDU2Vjb25kcygwKTtcbiAgICAgICAgICAgIGRhdGVvYmouc2V0VVRDTWlsbGlzZWNvbmRzKDApO1xuICAgICAgICAgICAgdmFyIHJlcG9ydGVyID0gaW5zZXJ0X3JlcG9ydF9mdW5jKGFjYyxzZXJ2aWNlKTtcbiAgICAgICAgICAgIHZhciBkYXRldGltZSA9IGRhdGVvYmouZ2V0VGltZSgpO1xuICAgICAgICAgICAgZGF0YS5pZCA9IFthY2Msc2VydmljZSxkYXRldGltZV07XG4gICAgICAgICAgICBkYXRhLmFjYyA9IGFjYztcbiAgICAgICAgICAgIGRhdGEuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgICAgICAgICBpZiAod2luZG93Lm1zSW5kZXhlZERCKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5zZXJ2aWNlYWNjID0gc2VydmljZSthY2M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhLnJldHJpZXZlZCA9IGRhdGV0aW1lO1xuICAgICAgICAgICAgdmFyIHJlcSA9IHN0b3JlLnB1dChkYXRhKTtcbiAgICAgICAgICAgIHJlcS5vbmVycm9yID0gcmVwb3J0ZXI7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGluc2VydF9yZXBvcnRfZnVuYyA9IGZ1bmN0aW9uKGFjYyxzZXJ2aWNlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihlcnIscm93cykge1xuICAgICAgICAgICAgaWYgKCAhIGVyciAmJiByb3dzKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHN0b3JlX2RiX2RhdGEgPSBmdW5jdGlvbihhY2Msc2VydmljZSxkYXRhKSB7XG4gICAgICAgIHZhciB0cmFucyA9IGlkYi50cmFuc2FjdGlvbihbXCJjYWNoZWRcIl0sIFwicmVhZHdyaXRlXCIpO1xuICAgICAgICB2YXIgc3RvcmUgPSB0cmFucy5vYmplY3RTdG9yZShcImNhY2hlZFwiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9ICdvYmplY3QnIHx8ICgoKHR5cGVvZiBEb2N1bWVudCkgIT0gJ3VuZGVmaW5lZCcpICYmIGRhdGEgaW5zdGFuY2VvZiBEb2N1bWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF0ZW9iaiA9IGRhdGEucmV0cmlldmVkID8gZGF0YS5yZXRyaWV2ZWQgOiAobmV3IERhdGUoKSk7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0ZW9iaiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGRhdGVvYmogPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBkYXRlb2JqID0gbmV3IERhdGUoZGF0ZW9iaik7XG4gICAgICAgIH1cbiAgICAgICAgZGF0ZW9iai5zZXRVVENIb3VycygwKTtcbiAgICAgICAgZGF0ZW9iai5zZXRVVENNaW51dGVzKDApO1xuICAgICAgICBkYXRlb2JqLnNldFVUQ1NlY29uZHMoMCk7XG4gICAgICAgIGRhdGVvYmouc2V0VVRDTWlsbGlzZWNvbmRzKDApO1xuICAgICAgICB2YXIgcmVwb3J0ZXIgPSBpbnNlcnRfcmVwb3J0X2Z1bmMoYWNjLHNlcnZpY2UpO1xuICAgICAgICB2YXIgZGF0ZXRpbWUgPSBkYXRlb2JqLmdldFRpbWUoKTtcbiAgICAgICAgZGF0YS5pZCA9IFthY2Msc2VydmljZSxkYXRldGltZV07XG4gICAgICAgIGRhdGEuYWNjID0gYWNjO1xuICAgICAgICBpZiAod2luZG93Lm1zSW5kZXhlZERCKSB7XG4gICAgICAgICAgICBkYXRhLnNlcnZpY2VhY2MgPSBzZXJ2aWNlK2FjYztcbiAgICAgICAgfVxuICAgICAgICBkYXRhLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgICAgICBkYXRhLnJldHJpZXZlZCA9IGRhdGV0aW1lO1xuICAgICAgICB2YXIgcmVxID0gc3RvcmUucHV0KGRhdGEpO1xuICAgICAgICAvLyByZXEub25zdWNjZXNzID0gcmVwb3J0ZXI7XG4gICAgICAgIHJlcS5vbmVycm9yID0gcmVwb3J0ZXI7XG4gICAgfTtcblxuICAgIGdldF9kYl9kYXRhID0gZnVuY3Rpb24oYWNjLHNlcnZpY2UsY2JhY2spIHtcbiAgICAgICAgdmFyIHRpbWVzdGFtcHMgPSBtYXhfYWdlID8gW21pbl9hZ2UsbWF4X2FnZV0gOiBbbWluX2FnZSwgKG5ldyBEYXRlKCkpLmdldFRpbWUoKV07XG4gICAgICAgIHJldHVybiBmaW5kX2xhdGVzdF9kYXRhKGFjYyxzZXJ2aWNlLHRpbWVzdGFtcHMsY2JhY2spO1xuICAgIH07XG5cbiAgICBmaW5kX2xhdGVzdF9kYXRhID0gZnVuY3Rpb24oYWNjLHNlcnZpY2UsdGltZXN0YW1wcyxjYmFjaykge1xuICAgICAgICBpZiAoICEgYWNjICkge1xuICAgICAgICAgICAgY2JhY2suY2FsbCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0cmFucyA9IGlkYi50cmFuc2FjdGlvbihbXCJjYWNoZWRcIl0sXCJyZWFkb25seVwiKTtcbiAgICAgICAgdmFyIHN0b3JlID0gdHJhbnMub2JqZWN0U3RvcmUoXCJjYWNoZWRcIik7XG4gICAgICAgIHZhciBpZHggPSBzdG9yZS5pbmRleCh3aW5kb3cubXNJbmRleGVkREIgPyBcImVudHJpZXMtbXNcIiA6IFwiZW50cmllc1wiKTtcbiAgICAgICAgdmFyIG1heF9zdGFtcCA9IC0xO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgdmFyIHJhbmdlID0gSURCS2V5UmFuZ2Uub25seSh3aW5kb3cubXNJbmRleGVkREIgPyBzZXJ2aWNlK2FjYyA6IFthY2Msc2VydmljZV0pO1xuICAgICAgICBpZHgub3BlbkN1cnNvcihyYW5nZSkub25zdWNjZXNzID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBjdXJzb3IgPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgICAgICAgaWYgKGN1cnNvcikge1xuICAgICAgICAgICAgICAgIHZhciB0cyA9IHdpbmRvdy5tc0luZGV4ZWREQiA/IGN1cnNvci52YWx1ZS5yZXRyaWV2ZWQgOiBjdXJzb3IucHJpbWFyeUtleVsyXTtcbiAgICAgICAgICAgICAgICB2YXIgY19hY2MgPSB3aW5kb3cubXNJbmRleGVkREIgPyBjdXJzb3IudmFsdWUuYWNjIDogY3Vyc29yLnByaW1hcnlLZXlbMF07XG4gICAgICAgICAgICAgICAgdmFyIHNlcnYgPSB3aW5kb3cubXNJbmRleGVkREIgPyBjdXJzb3IudmFsdWUuc2VydmljZSA6IGN1cnNvci5wcmltYXJ5S2V5WzFdO1xuICAgICAgICAgICAgICAgIGlmICh0cyA+PSB0aW1lc3RhbXBzWzBdICYmIHRzIDw9IHRpbWVzdGFtcHNbMV0gKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cyA+IG1heF9zdGFtcCAmJiBjX2FjYyA9PSBhY2MgJiYgc2VydiA9PSBzZXJ2aWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBjdXJzb3IudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhfc3RhbXAgPSB0cztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5yZXRyaWV2ZWQgPSBuZXcgRGF0ZSh0cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzdWx0ID0gcmVzdWx0LmRhdGFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2JhY2suY2FsbChudWxsLG51bGwscmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgc3dlZXBfY2FjaGUgPSBmdW5jdGlvbih0aW1lc3RhbXApIHtcbiAgICAgICAgdmFyIHRyYW5zID0gaWRiLnRyYW5zYWN0aW9uKFtcImNhY2hlZFwiXSxcInJlYWR3cml0ZVwiKTtcbiAgICAgICAgdmFyIHN0b3JlID0gdHJhbnMub2JqZWN0U3RvcmUoXCJjYWNoZWRcIik7XG4gICAgICAgIHZhciBpZHggPSBzdG9yZS5pbmRleChcInRpbWVzdGFtcHNcIik7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGlkeC5vcGVuS2V5Q3Vyc29yKG51bGwsIFwibmV4dHVuaXF1ZVwiKS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGN1cnNvciA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCB0aW1lc3RhbXAgPj0gY3Vyc29yLmtleVsxXSApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUuZGVsZXRlKGN1cnNvci5wcmltYXJ5S2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGRhdGFfdGltZXN0YW1wcyA9IGZ1bmN0aW9uKHNlcnZpY2UsdGltZXN0YW1wcyxjYmFjaykge1xuXG4gICAgICAgIGlmICghIHRpbWVzdGFtcHMgfHwgdHlwZW9mIHRpbWVzdGFtcHMgIT0gJ29iamVjdCcgfHwgISB0aW1lc3RhbXBzLmxlbmd0aCApIHtcbiAgICAgICAgICAgIHRpbWVzdGFtcHMgPSBbMCwobmV3IERhdGUoKSkuZ2V0VGltZSgpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0cmFucyA9IGlkYi50cmFuc2FjdGlvbihbXCJjYWNoZWRcIl0sXCJyZWFkb25seVwiKTtcbiAgICAgICAgdmFyIHN0b3JlID0gdHJhbnMub2JqZWN0U3RvcmUoXCJjYWNoZWRcIik7XG4gICAgICAgIHZhciBpZHggPSBzdG9yZS5pbmRleChcInRpbWVzdGFtcHNcIik7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGlkeC5vcGVuS2V5Q3Vyc29yKG51bGwsIFwibmV4dHVuaXF1ZVwiKS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGN1cnNvciA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvci5rZXlbMF0gPT0gc2VydmljZSAmJiB0aW1lc3RhbXBzWzBdIDw9IGN1cnNvci5rZXlbMV0gJiYgdGltZXN0YW1wc1sxXSA+PSBjdXJzb3Iua2V5WzFdICkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gobmV3IERhdGUocGFyc2VJbnQoY3Vyc29yLmtleVsxXSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNiYWNrLmNhbGwobnVsbCxyZXN1bHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgY2xlYXJfc2VydmljZSA9IGZ1bmN0aW9uKHNlcnZpY2UsYWNjLGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciB0cmFucyA9IGlkYi50cmFuc2FjdGlvbihbXCJjYWNoZWRcIl0sXCJyZWFkd3JpdGVcIik7XG4gICAgICAgIHZhciBzdG9yZSA9IHRyYW5zLm9iamVjdFN0b3JlKFwiY2FjaGVkXCIpO1xuICAgICAgICB2YXIgaWR4ID0gc3RvcmUuaW5kZXgoXCJzZXJ2aWNlc1wiKTtcbiAgICAgICAgdmFyIHJhbmdlID0gSURCS2V5UmFuZ2Uub25seShzZXJ2aWNlKTtcbiAgICAgICAgaWR4Lm9wZW5DdXJzb3IocmFuZ2UpLm9uc3VjY2VzcyA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgY3Vyc29yID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoKCEgYWNjIHx8IChjdXJzb3IudmFsdWUuYWNjID09IGFjYykgKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAod2luZG93Lm1zSW5kZXhlZERCKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZS5kZWxldGUoY3Vyc29yLnZhbHVlLnNlcnZpY2VhY2MpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmUuZGVsZXRlKGN1cnNvci52YWx1ZS5pZCA/IGN1cnNvci52YWx1ZS5pZCA6IGN1cnNvci5wcmltYXJ5S2V5ICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRyYW5zLm9uY29tcGxldGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoU2VydmljZSk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHNlYXJjaF9zZXJ2aWNlID0gZnVuY3Rpb24oc2VydmljZSxjYmFjaykge1xuICAgICAgICB2YXIgdHJhbnMgPSBpZGIudHJhbnNhY3Rpb24oW1wiY2FjaGVkXCJdLFwicmVhZG9ubHlcIik7XG4gICAgICAgIHZhciBzdG9yZSA9IHRyYW5zLm9iamVjdFN0b3JlKFwiY2FjaGVkXCIpO1xuICAgICAgICB2YXIgaWR4ID0gc3RvcmUuaW5kZXgoXCJzZXJ2aWNlc1wiKTtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgdmFyIHJhbmdlID0gSURCS2V5UmFuZ2Uub25seShzZXJ2aWNlKTtcbiAgICAgICAgaWR4Lm9wZW5LZXlDdXJzb3IocmFuZ2UsIFwibmV4dHVuaXF1ZVwiKS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGN1cnNvciA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGN1cnNvci5rZXkpO1xuICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYmFjay5jYWxsKFNlcnZpY2UscmVzdWx0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBmaXJzdF9hY2Nlc3Npb24gPSBmdW5jdGlvbihzZXJ2aWNlLGNiYWNrKSB7XG4gICAgICAgIHZhciB0cmFucyA9IGlkYi50cmFuc2FjdGlvbihbXCJjYWNoZWRcIl0sXCJyZWFkb25seVwiKTtcbiAgICAgICAgdmFyIHN0b3JlID0gdHJhbnMub2JqZWN0U3RvcmUoXCJjYWNoZWRcIik7XG4gICAgICAgIHZhciBpZHggPSBzdG9yZS5pbmRleChcInNlcnZpY2VzXCIpO1xuICAgICAgICB2YXIgcmFuZ2UgPSBJREJLZXlSYW5nZS5vbmx5KHNlcnZpY2UpO1xuICAgICAgICBpZHgub3BlbkN1cnNvcihyYW5nZSxcIm5leHR1bmlxdWVcIikub25zdWNjZXNzID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBjdXJzb3IgPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgICAgICAgaWYgKGN1cnNvcikge1xuICAgICAgICAgICAgICAgIGNiYWNrLmNhbGwoU2VydmljZSxjdXJzb3IudmFsdWUuYWNjKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2JhY2suY2FsbChTZXJ2aWNlLG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgY2FjaGVkX2FjY2Vzc2lvbnMgPSBmdW5jdGlvbihzZXJ2aWNlLGNiYWNrKSB7XG4gICAgICAgIHZhciB0cmFucyA9IGlkYi50cmFuc2FjdGlvbihbXCJjYWNoZWRcIl0sXCJyZWFkb25seVwiKTtcbiAgICAgICAgdmFyIHN0b3JlID0gdHJhbnMub2JqZWN0U3RvcmUoXCJjYWNoZWRcIik7XG4gICAgICAgIHZhciBpZHggPSBzdG9yZS5pbmRleChcInNlcnZpY2VzXCIpO1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICB2YXIgcmFuZ2UgPSBJREJLZXlSYW5nZS5vbmx5KHNlcnZpY2UpO1xuICAgICAgICBpZHgub3BlbkN1cnNvcihyYW5nZSkub25zdWNjZXNzID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBjdXJzb3IgPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgICAgICAgaWYgKGN1cnNvcikge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChjdXJzb3IudmFsdWUuYWNjKTtcbiAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2JhY2suY2FsbChTZXJ2aWNlLHJlc3VsdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG59O1xudmFyIHNldHVwX3dlYnNxbCA9IGZ1bmN0aW9uKGRiKSB7XG4gICAgZGIuYWxsKCdTRUxFQ1QgdmVyc2lvbiBmcm9tIHZlcnNpb25zIHdoZXJlIHRhYmxlbmFtZSA9IFwiZGF0YWNhY2hlXCInLGZ1bmN0aW9uKGVycixyb3dzKSB7IFxuICAgICAgICB2YXIgdmVyc2lvbiA9IChyb3dzICYmIHJvd3MubGVuZ3RoID4gMCkgPyByb3dzWzBdLnZlcnNpb24gOiBudWxsO1xuICAgICAgICBpZiAodmVyc2lvbiA9PSAxLjMpIHtcbiAgICAgICAgICAgIGlmIChNQVNDUC5ldmVudHMpIHtcbiAgICAgICAgICAgICAgICBNQVNDUC5ldmVudHMuZW1pdCgncmVhZHknKTsgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChNQVNDUC5yZWFkeSkge1xuICAgICAgICAgICAgICAgIE1BU0NQLnJlYWR5KCk7XG4gICAgICAgICAgICAgICAgTUFTQ1AucmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBNQVNDUC5yZWFkeSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47ICAgICAgICAgICAgICAgIFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoISB2ZXJzaW9uIHx8IHZlcnNpb24gPT0gXCJcIiB8fCB2ZXJzaW9uIDwgMS4wICkge1xuICAgICAgICAgICAgZGIuZXhlYygnQ1JFQVRFIFRBQkxFIGlmIG5vdCBleGlzdHMgdmVyc2lvbnMgKHZlcnNpb24gUkVBTCwgdGFibGVuYW1lIFRFWFQpOycpO1xuICAgICAgICAgICAgZGIuZXhlYygnQ1JFQVRFIFRBQkxFIGlmIG5vdCBleGlzdHMgXCJkYXRhY2FjaGVcIiAoYWdpIFRFWFQsc2VydmljZSBURVhULHJldHJpZXZlZCBSRUFMLGRhdGEgVEVYVCk7JyxmdW5jdGlvbihlcnIpIHsgaWYgKGVyciAmJiBlcnIgIT0gXCJFcnJvcjogbm90IGFuIGVycm9yXCIpIHsgdGhyb3cgZXJyOyB9IH0pO1xuICAgICAgICAgICAgZGIuZXhlYygnREVMRVRFIEZST00gdmVyc2lvbnMgd2hlcmUgdGFibGVuYW1lID0gXCJkYXRhY2FjaGVcIicpO1xuICAgICAgICAgICAgZGIuZXhlYygnSU5TRVJUIElOVE8gdmVyc2lvbnModmVyc2lvbix0YWJsZW5hbWUpIFZBTFVFUygxLjEsXCJkYXRhY2FjaGVcIik7JyxmdW5jdGlvbihlcnIscm93cykge1xuICAgICAgICAgICAgICAgIGlmICggISBlcnIgKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVXBncmFkZSB0byAxLjEgY29tcGxldGVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmVyc2lvbiA9IDEuMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmVyc2lvbiA8IDEuMikge1xuICAgICAgICAgICAgZGIuZXhlYygnRFJPUCBUQUJMRSBpZiBleGlzdHMgZGF0YWNhY2hlX3RtcDsnKTtcbiAgICAgICAgICAgIGRiLmV4ZWMoJ0NSRUFURSBUQUJMRSBpZiBub3QgZXhpc3RzIGRhdGFjYWNoZV90bXAgKGFjYyBURVhULHNlcnZpY2UgVEVYVCxyZXRyaWV2ZWQgUkVBTCxkYXRhIFRFWFQpOycpO1xuICAgICAgICAgICAgZGIuZXhlYygnSU5TRVJUIElOVE8gZGF0YWNhY2hlX3RtcChhY2Msc2VydmljZSxyZXRyaWV2ZWQsZGF0YSkgU0VMRUNUIGFnaSxzZXJ2aWNlLHJldHJpZXZlZCxkYXRhIEZST00gZGF0YWNhY2hlOycpO1xuICAgICAgICAgICAgZGIuZXhlYygnRFJPUCBUQUJMRSBkYXRhY2FjaGU7Jyk7XG4gICAgICAgICAgICBkYi5leGVjKCdBTFRFUiBUQUJMRSBkYXRhY2FjaGVfdG1wIFJFTkFNRSBUTyBkYXRhY2FjaGU7Jyk7XG4gICAgICAgICAgICBkYi5leGVjKCdDUkVBVEUgSU5ERVggYWNjZXNzaW9ucyBvbiBkYXRhY2FjaGUoYWNjKTsnKTtcbiAgICAgICAgICAgIGRiLmV4ZWMoJ0NSRUFURSBJTkRFWCBhY2Nlc3Npb25zX3NlcnZpY2Ugb24gZGF0YWNhY2hlKGFjYyxzZXJ2aWNlKTsnKTtcbiAgICAgICAgICAgIGRiLmV4ZWMoJ0RFTEVURSBGUk9NIHZlcnNpb25zIHdoZXJlIHRhYmxlbmFtZSA9IFwiZGF0YWNhY2hlXCInKTtcbiAgICAgICAgICAgIGRiLmV4ZWMoJ0lOU0VSVCBJTlRPIHZlcnNpb25zKHZlcnNpb24sdGFibGVuYW1lKSBWQUxVRVMoMS4yLFwiZGF0YWNhY2hlXCIpOycsZnVuY3Rpb24oZXJyLHJvd3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoICEgZXJyICkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVXBncmFkZSB0byAxLjIgY29tcGxldGVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmVyc2lvbiA9IDEuMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmVyc2lvbiA8IDEuMykge1xuICAgICAgICAgICAgZGIuZXhlYygnQ1JFQVRFIElOREVYIGlmIG5vdCBleGlzdHMgc2VydmljZXMgb24gZGF0YWNhY2hlKHNlcnZpY2UpOycpO1xuICAgICAgICAgICAgZGIuZXhlYygnREVMRVRFIEZST00gdmVyc2lvbnMgd2hlcmUgdGFibGVuYW1lID0gXCJkYXRhY2FjaGVcIicpO1xuICAgICAgICAgICAgZGIuZXhlYygnSU5TRVJUIElOVE8gdmVyc2lvbnModmVyc2lvbix0YWJsZW5hbWUpIFZBTFVFUygxLjMsXCJkYXRhY2FjaGVcIik7JyxmdW5jdGlvbihlcnIscm93cykge1xuICAgICAgICAgICAgICAgIGlmICggISBlcnIgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChNQVNDUC5ldmVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE1BU0NQLmV2ZW50cy5lbWl0KCdyZWFkeScpOyAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChNQVNDUC5yZWFkeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgTUFTQ1AucmVhZHkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIE1BU0NQLnJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE1BU0NQLnJlYWR5ICA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZlcnNpb24gPSAxLjM7ICAgICAgICAgICAgICAgIFxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBiZWdpbl90cmFuc2FjdGlvbiA9IGZ1bmN0aW9uKGNhbGxiYWNrLHRyYW5zKSB7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwoeyBcInRyYW5zYWN0aW9uXCIgOiB0cmFucyB9KTtcbiAgICB9O1xuICAgIGVuZF90cmFuc2FjdGlvbiA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfTtcblxuICAgIHN3ZWVwX2NhY2hlID0gZnVuY3Rpb24odGltZXN0YW1wKSB7XG4gICAgICAgIGRiLmFsbChcIkRFTEVURSBmcm9tIGRhdGFjYWNoZSB3aGVyZSByZXRyaWV2ZWQgPD0gPyBcIixbdGltZXN0YW1wXSxmdW5jdGlvbigpIHt9KTtcbiAgICB9O1xuICAgIFxuICAgIGNsZWFyX3NlcnZpY2UgPSBmdW5jdGlvbihzZXJ2aWNlLGFjYyxjYWxsYmFjaykge1xuICAgICAgICB2YXIgc2VydmljZW5hbWUgPSBzZXJ2aWNlO1xuICAgICAgICBzZXJ2aWNlbmFtZSArPSBcIiVcIjtcbiAgICAgICAgaWYgKCAhIGFjYyApIHtcbiAgICAgICAgICAgIGRiLmFsbChcIkRFTEVURSBmcm9tIGRhdGFjYWNoZSB3aGVyZSBzZXJ2aWNlIGxpa2UgPyBcIixbc2VydmljZW5hbWVdLGZ1bmN0aW9uKCkgeyBjYWxsYmFjay5jYWxsKFNlcnZpY2UpOyB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRiLmFsbChcIkRFTEVURSBmcm9tIGRhdGFjYWNoZSB3aGVyZSBzZXJ2aWNlIGxpa2UgPyBhbmQgYWNjID0gP1wiLFtzZXJ2aWNlbmFtZSxhY2MudG9Mb3dlckNhc2UoKV0sZnVuY3Rpb24oKSB7IGNhbGxiYWNrLmNhbGwoU2VydmljZSk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgIH07XG4gICAgXG4gICAgc2VhcmNoX3NlcnZpY2UgPSBmdW5jdGlvbihzZXJ2aWNlLGNiYWNrKSB7XG4gICAgICAgIGRiLmFsbChcIlNFTEVDVCBkaXN0aW5jdCBzZXJ2aWNlIGZyb20gZGF0YWNhY2hlIHdoZXJlIHNlcnZpY2UgbGlrZSA/IFwiLFtzZXJ2aWNlK1wiJVwiXSxmdW5jdGlvbihlcnIscmVjb3Jkcykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZWNvcmRzICYmIHJlY29yZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJlY29yZHMuZm9yRWFjaChmdW5jdGlvbihyZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tyZWNvcmQuc2VydmljZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHVuaXF1ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gcmVzdWx0cykge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzLmhhc093blByb3BlcnR5KGspKSB7ICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdW5pcXVlcy5wdXNoKGspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNiYWNrLmNhbGwoU2VydmljZSx1bmlxdWVzKTtcbiAgICAgICAgICAgIHJldHVybiB1bmlxdWVzO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZmlyc3RfYWNjZXNzaW9uID0gZnVuY3Rpb24oc2VydmljZSxjYmFjaykge1xuICAgICAgICBkYi5hbGwoXCJTRUxFQ1QgZGlzdGluY3QgYWNjIGZyb20gZGF0YWNhY2hlIHdoZXJlIHNlcnZpY2UgPSA/IGxpbWl0IDFcIixbc2VydmljZV0sZnVuY3Rpb24oZXJyLHJlY29yZHMpIHtcbiAgICAgICAgICAgIGlmICghIHJlY29yZHMgfHwgcmVjb3Jkcy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICAgICAgY2JhY2suY2FsbChTZXJ2aWNlLG51bGwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYmFjay5jYWxsKFNlcnZpY2UscmVjb3Jkc1swXS5hY2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgXG4gICAgY2FjaGVkX2FjY2Vzc2lvbnMgPSBmdW5jdGlvbihzZXJ2aWNlLGNiYWNrKSB7XG4gICAgICAgIGRiLmFsbChcIlNFTEVDVCBkaXN0aW5jdCBhY2MgZnJvbSBkYXRhY2FjaGUgd2hlcmUgc2VydmljZSA9ID9cIixbc2VydmljZV0sZnVuY3Rpb24oZXJyLHJlY29yZHMpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlY29yZHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocmVjb3Jkc1tpXS5hY2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2JhY2suY2FsbChTZXJ2aWNlLHJlc3VsdHMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFxuICAgIGdldF9zbmFwc2hvdCA9IGZ1bmN0aW9uKHNlcnZpY2UsdGltZXN0YW1wcyx3YW50ZWQsY2JhY2spIHtcbiAgICAgICAgaWYgKCEgdGltZXN0YW1wcyB8fCB0eXBlb2YgdGltZXN0YW1wcyAhPSAnb2JqZWN0JyB8fCAhIHRpbWVzdGFtcHMubGVuZ3RoICkge1xuICAgICAgICAgICAgdGltZXN0YW1wcyA9IFswLChuZXcgRGF0ZSgpKS5nZXRUaW1lKCldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzcWw7XG4gICAgICAgIHZhciBhcmdzID0gW3NlcnZpY2UsdGltZXN0YW1wc1swXSx0aW1lc3RhbXBzWzFdXTtcbiAgICAgICAgaWYgKHdhbnRlZCAmJiBBcnJheS5pc0FycmF5KHdhbnRlZCkpIHtcbiAgICAgICAgICAgIHZhciBxdWVzdGlvbl9tYXJrcyA9IChuZXcgQXJyYXkod2FudGVkLmxlbmd0aCsxKS5qb2luKCcsPycpKS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICBhcmdzID0gYXJncy5jb25jYXQod2FudGVkKTtcbiAgICAgICAgICAgIHNxbCA9IFwiU0VMRUNUICogZnJvbSBkYXRhY2FjaGUgd2hlcmUgc2VydmljZSA9ID8gQU5EIHJldHJpZXZlZCA+PSA/IEFORCByZXRyaWV2ZWQgPD0gPyBBTkQgYWNjIGluIChcIitxdWVzdGlvbl9tYXJrcytcIikgT1JERVIgQlkgcmV0cmlldmVkIEFTQ1wiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHdhbnRlZCAmJiAvXlxcZCskLy50ZXN0KHdhbnRlZC50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgIHNxbCA9IFwiU0VMRUNUICogZnJvbSBkYXRhY2FjaGUgd2hlcmUgc2VydmljZSA9ID8gQU5EIHJldHJpZXZlZCA+PSA/IEFORCByZXRyaWV2ZWQgPD0gPyBMSU1JVCA/IE9SREVSIEJZIHJldHJpZXZlZCBBU0NcIjtcbiAgICAgICAgICAgICAgICBhcmdzID0gYXJncy5jb25jYXQocGFyc2VJbnQod2FudGVkLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3FsID0gXCJTRUxFQ1QgKiBmcm9tIGRhdGFjYWNoZSB3aGVyZSBzZXJ2aWNlID0gPyBBTkQgcmV0cmlldmVkID49ID8gQU5EIHJldHJpZXZlZCA8PSA/IE9SREVSIEJZIHJldHJpZXZlZCBBU0NcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkYi5hbGwoc3FsLGFyZ3MsZnVuY3Rpb24oZXJyLHJlY29yZHMpIHtcbiAgICAgICAgICAgIHJlY29yZHMgPSByZWNvcmRzIHx8IFtdO1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgIHJlY29yZHMuZm9yRWFjaChmdW5jdGlvbihyZWNvcmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHR5cGVvZiByZWNvcmQuZGF0YSA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKHJlY29yZC5kYXRhKSA6IHJlY29yZC5kYXRhO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEucmV0cmlldmVkID0gbmV3IERhdGUocGFyc2VJbnQocmVjb3JkLnJldHJpZXZlZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0c1tyZWNvcmQuYWNjXSAmJiByZXN1bHRzW3JlY29yZC5hY2NdLnJldHJpZXZlZCA+IHJlY29yZC5yZXRyaWV2ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzW3JlY29yZC5hY2NdID0gcmVjb3JkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYmFjay5jYWxsKG51bGwsbnVsbCxyZXN1bHRzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGdldF9kYl9kYXRhID0gZnVuY3Rpb24oYWNjLHNlcnZpY2UsY2JhY2spIHtcbiAgICAgICAgdmFyIHRpbWVzdGFtcHMgPSBtYXhfYWdlID8gW21pbl9hZ2UsbWF4X2FnZV0gOiBbbWluX2FnZSwgKG5ldyBEYXRlKCkpLmdldFRpbWUoKV07XG4gICAgICAgIHJldHVybiBmaW5kX2xhdGVzdF9kYXRhKGFjYyxzZXJ2aWNlLHRpbWVzdGFtcHMsY2JhY2spO1xuICAgIH07XG5cbiAgICB2YXIgaW5zZXJ0X3JlcG9ydF9mdW5jID0gZnVuY3Rpb24oYWNjLHNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGVycixyb3dzKSB7XG4gICAgICAgICAgICBpZiAoICEgZXJyICYmIHJvd3MpIHtcbi8vICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkNhY2hpbmcgcmVzdWx0IGZvciBcIithY2MrXCIgaW4gXCIrc2VydmljZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHN0b3JlX2RiX2RhdGEgPSBmdW5jdGlvbihhY2Msc2VydmljZSxkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPSAnb2JqZWN0JyB8fCAoKCh0eXBlb2YgRG9jdW1lbnQpICE9ICd1bmRlZmluZWQnKSAmJiBkYXRhIGluc3RhbmNlb2YgRG9jdW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0cl9yZXA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdHJfcmVwID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRlb2JqID0gZGF0YS5yZXRyaWV2ZWQgPyBkYXRhLnJldHJpZXZlZCA6IChuZXcgRGF0ZSgpKTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRlb2JqID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBkYXRlb2JqID0gbmV3IERhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBkYXRlb2JqLnNldFVUQ0hvdXJzKDApO1xuICAgICAgICBkYXRlb2JqLnNldFVUQ01pbnV0ZXMoMCk7XG4gICAgICAgIGRhdGVvYmouc2V0VVRDU2Vjb25kcygwKTtcbiAgICAgICAgZGF0ZW9iai5zZXRVVENNaWxsaXNlY29uZHMoMCk7XG4gICAgICAgIHZhciBkYXRldGltZSA9IGRhdGVvYmouZ2V0VGltZSgpO1xuICAgICAgICBkYXRhID0ge307XG4gICAgICAgIGRiLmFsbChcIklOU0VSVCBJTlRPIGRhdGFjYWNoZShhY2Msc2VydmljZSxyZXRyaWV2ZWQsZGF0YSkgVkFMVUVTKD8sPyw/LD8pXCIsW2FjYyxzZXJ2aWNlLGRhdGV0aW1lLHN0cl9yZXBdLGluc2VydF9yZXBvcnRfZnVuYyhhY2Msc2VydmljZSkpO1xuICAgIH07XG5cbiAgICBmaW5kX2xhdGVzdF9kYXRhID0gZnVuY3Rpb24oYWNjLHNlcnZpY2UsdGltZXN0YW1wcyxjYmFjaykge1xuICAgICAgICB2YXIgc3FsID0gXCJTRUxFQ1QgKiBmcm9tIGRhdGFjYWNoZSB3aGVyZSBhY2M9PyBhbmQgc2VydmljZT0/IGFuZCByZXRyaWV2ZWQgPj0gPyBhbmQgcmV0cmlldmVkIDw9ID8gT1JERVIgQlkgcmV0cmlldmVkIERFU0MgTElNSVQgMVwiO1xuICAgICAgICB2YXIgYXJncyA9IFthY2Msc2VydmljZSx0aW1lc3RhbXBzWzBdLHRpbWVzdGFtcHNbMV1dOyAgICAgICAgICAgIFxuICAgICAgICBkYi5hbGwoc3FsLGFyZ3MsZnVuY3Rpb24oZXJyLHJlY29yZHMpIHtcbiAgICAgICAgICAgIGlmIChyZWNvcmRzICYmIHJlY29yZHMubGVuZ3RoID4gMCAmJiB0eXBlb2YgcmVjb3Jkc1swXSAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB0eXBlb2YgcmVjb3Jkc1swXS5kYXRhID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UocmVjb3Jkc1swXS5kYXRhKSA6IHJlY29yZHNbMF0uZGF0YTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnJldHJpZXZlZCA9IG5ldyBEYXRlKHBhcnNlSW50KHJlY29yZHNbMF0ucmV0cmlldmVkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNiYWNrLmNhbGwobnVsbCxudWxsLGRhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYmFjay5jYWxsKG51bGwsbnVsbCxudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBcbiAgICBkYXRhX3RpbWVzdGFtcHMgPSBmdW5jdGlvbihzZXJ2aWNlLHRpbWVzdGFtcHMsY2JhY2spIHtcbiAgICAgICAgaWYgKCEgdGltZXN0YW1wcyB8fCB0eXBlb2YgdGltZXN0YW1wcyAhPSAnb2JqZWN0JyB8fCAhIHRpbWVzdGFtcHMubGVuZ3RoICkge1xuICAgICAgICAgICAgdGltZXN0YW1wcyA9IFswLChuZXcgRGF0ZSgpKS5nZXRUaW1lKCldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzcWwgPSBcIlNFTEVDVCBkaXN0aW5jdCByZXRyaWV2ZWQgZnJvbSBkYXRhY2FjaGUgd2hlcmUgc2VydmljZT0/IGFuZCByZXRyaWV2ZWQgPj0gPyBhbmQgcmV0cmlldmVkIDw9ID8gT1JERVIgQlkgcmV0cmlldmVkIEFTQ1wiO1xuICAgICAgICB2YXIgYXJncyA9IFtzZXJ2aWNlLHRpbWVzdGFtcHNbMF0sdGltZXN0YW1wc1sxXV07XG4gICAgICAgIGRiLmFsbChzcWwsYXJncyxmdW5jdGlvbihlcnIscmVjb3Jkcykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgaWYgKHJlY29yZHMgJiYgcmVjb3Jkcy5sZW5ndGggPiAwICYmIHR5cGVvZiByZWNvcmRzWzBdICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gcmVjb3Jkcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgRGF0ZShwYXJzZUludChyZWNvcmRzW2ldLnJldHJpZXZlZCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYmFjay5jYWxsKG51bGwscmVzdWx0KTtcbiAgICAgICAgfSk7ICAgICAgICAgICAgXG4gICAgfTtcbn07XG52YXIgc2V0dXBfbG9jYWxzdG9yYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgc3dlZXBfY2FjaGUgPSBmdW5jdGlvbih0aW1lc3RhbXApIHtcbiAgICAgICAgaWYgKFwibG9jYWxTdG9yYWdlXCIgaW4gd2luZG93KSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxvY2FsU3RvcmFnZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChsb2NhbFN0b3JhZ2Uua2V5KGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzLnNoaWZ0KCk7XG4gICAgICAgICAgICB3aGlsZSAoa2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKG5ldyBSZWdFeHAoXCJeTUFTQ1AuKlwiKS50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBsb2NhbFN0b3JhZ2Vba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEgJiYgdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YWJsb2NrID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFibG9jay5yZXRyaWV2ZWQgPSB0aW1lc3RhbXA7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGtleSA9IGtleXMuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgY2xlYXJfc2VydmljZSA9IGZ1bmN0aW9uKHNlcnZpY2UsYWNjLGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChcImxvY2FsU3RvcmFnZVwiIGluIHdpbmRvdykge1xuICAgICAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsb2NhbFN0b3JhZ2UubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2gobG9jYWxTdG9yYWdlLmtleShpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5cy5zaGlmdCgpO1xuICAgICAgICAgICAgd2hpbGUgKGtleSkge1xuICAgICAgICAgICAgICAgIGlmICgobmV3IFJlZ0V4cChcIl5cIitzZXJ2aWNlK1wiLipcIisoYWNjP1wiI1wiK2FjYy50b0xvd2VyQ2FzZSgpK1wiJFwiIDogXCJcIikpKS50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGtleSA9IGtleXMuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoU2VydmljZSk7XG4gICAgICAgIH0gICAgICAgICAgICBcbiAgICB9O1xuICAgIFxuICAgIHNlYXJjaF9zZXJ2aWNlID0gZnVuY3Rpb24oc2VydmljZSxjYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IHt9O1xuICAgICAgICBpZiAoXCJsb2NhbFN0b3JhZ2VcIiBpbiB3aW5kb3cpIHtcbiAgICAgICAgICAgIHZhciBrZXk7XG4gICAgICAgICAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKFwiXlwiK3NlcnZpY2UrXCIuKlwiKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsb2NhbFN0b3JhZ2UubGVuZ3RoOyBpIDwgbGVuOyBpKyspe1xuICAgICAgICAgICAgICAgIGtleSA9IGxvY2FsU3RvcmFnZS5rZXkoaSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlLnRlc3Qoa2V5KSkgeyAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2tleS5yZXBsYWNlKC9cXC4jLiokL2csJycpXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHVuaXF1ZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgayBpbiByZXN1bHRzKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0cy5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgIHVuaXF1ZXMucHVzaChrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNiYWNrLmNhbGwoQ2FjaGluZ1NlcnZpY2UsdW5pcXVlcyk7XG5cbiAgICAgICAgcmV0dXJuIHVuaXF1ZXM7XG4gICAgfTtcblxuICAgIGZpcnN0X2FjY2Vzc2lvbiA9IGZ1bmN0aW9uKHNlcnZpY2UsY2JhY2spIHtcbiAgICAgICAgaWYgKFwibG9jYWxTdG9yYWdlXCIgaW4gd2luZG93KSB7XG4gICAgICAgICAgICB2YXIga2V5O1xuICAgICAgICAgICAgdmFyIHJlID0gbmV3IFJlZ0V4cChcIl5cIitzZXJ2aWNlKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsb2NhbFN0b3JhZ2UubGVuZ3RoOyBpIDwgbGVuOyBpKyspe1xuICAgICAgICAgICAgICAgIGtleSA9IGxvY2FsU3RvcmFnZS5rZXkoaSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlLnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBrZXkucmVwbGFjZShzZXJ2aWNlLCcnKTtcbiAgICAgICAgICAgICAgICAgICAgY2JhY2suY2FsbChDYWNoaW5nU2VydmljZSxrZXkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNiYWNrLmNhbGwoQ2FjaGluZ1NlcnZpY2UsbnVsbCk7XG4gICAgfTtcblxuICAgIGNhY2hlZF9hY2Nlc3Npb25zID0gZnVuY3Rpb24oc2VydmljZSxjYmFjaykge1xuICAgICAgICBpZiAoXCJsb2NhbFN0b3JhZ2VcIiBpbiB3aW5kb3cpIHtcbiAgICAgICAgICAgIHZhciBrZXk7XG4gICAgICAgICAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKFwiXlwiK3NlcnZpY2UpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxvY2FsU3RvcmFnZS5sZW5ndGg7IGkgPCBsZW47IGkrKyl7XG4gICAgICAgICAgICAgICAga2V5ID0gbG9jYWxTdG9yYWdlLmtleShpKTtcbiAgICAgICAgICAgICAgICBpZiAocmUudGVzdChrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGtleS5yZXBsYWNlKHNlcnZpY2UsJycpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1bmlxdWVzID0gW107XG4gICAgICAgIGZvciAodmFyIGsgaW4gcmVzdWx0cykge1xuICAgICAgICAgICAgaWYgKHJlc3VsdHMuaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICB1bmlxdWVzLnB1c2goayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjYmFjay5jYWxsKENhY2hpbmdTZXJ2aWNlLHVuaXF1ZXMpO1xuICAgIH07XG5cbiAgICBnZXRfZGJfZGF0YSA9IGZ1bmN0aW9uKGFjYyxzZXJ2aWNlLGNiYWNrKSB7XG4gICAgICAgIHZhciBkYXRhID0gbG9jYWxTdG9yYWdlW3NlcnZpY2UudG9TdHJpbmcoKStcIi4jXCIrKGFjYyB8fCAnJykudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIGlmIChkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIGRhdGFibG9jayA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICBkYXRhYmxvY2sucmV0cmlldmVkID0gbmV3IERhdGUocGFyc2VJbnQoZGF0YWJsb2NrLnJldHJpZXZlZCkpO1xuICAgICAgICAgICAgY2JhY2suY2FsbChudWxsLG51bGwsZGF0YWJsb2NrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNiYWNrLmNhbGwobnVsbCxudWxsLG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgIH07XG4gICAgXG4gICAgc3RvcmVfZGJfZGF0YSA9IGZ1bmN0aW9uKGFjYyxzZXJ2aWNlLGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgJiYgKHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0JyB8fCBkYXRhIGluc3RhbmNlb2YgRG9jdW1lbnQgfHwgZGF0YS5ub2RlTmFtZSkpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEucmV0cmlldmVkID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICAgICAgbG9jYWxTdG9yYWdlW3NlcnZpY2UudG9TdHJpbmcoKStcIi4jXCIrKGFjYyB8fCAnJykudG9Mb3dlckNhc2UoKV0gPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICB9O1xuXG4gICAgZmluZF9sYXRlc3RfZGF0YSA9IGZ1bmN0aW9uKGFjYyxzZXJ2aWNlLHRpbWVzdGFtcCxjYmFjaykge1xuICAgICAgICAvLyBXZSBkb24ndCBhY3R1YWxseSByZXRyaWV2ZSBoaXN0b3JpY2FsIGRhdGEgZm9yIHRoaXNcbiAgICAgICAgcmV0dXJuIGdldF9kYl9kYXRhKGFjYyxzZXJ2aWNlLGNiYWNrKTtcbiAgICB9O1xuXG4gICAgZGF0YV90aW1lc3RhbXBzID0gZnVuY3Rpb24oc2VydmljZSx0aW1lc3RhbXAsY2JhY2spIHtcbiAgICAgICAgY2JhY2suY2FsbChudWxsLFtdKTtcbiAgICB9O1xuICAgIFxuICAgIGJlZ2luX3RyYW5zYWN0aW9uID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgLy8gTm8gc3VwcG9ydCBmb3IgdHJhbnNhY3Rpb25zIGhlcmUuIERvIG5vdGhpbmcuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKCk7XG4gICAgICAgIH0sMCk7XG4gICAgfTtcbiAgICBlbmRfdHJhbnNhY3Rpb24gPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAvLyBObyBzdXBwb3J0IGZvciB0cmFuc2FjdGlvbnMgaGVyZS4gRG8gbm90aGluZy5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSwwKTtcbiAgICB9O1xuXG4gICAgaWYgKE1BU0NQLmV2ZW50cykge1xuICAgICAgICBNQVNDUC5ldmVudHMuZW1pdCgncmVhZHknKTtcbiAgICB9XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKE1BU0NQLnJlYWR5KSB7XG4gICAgICAgICAgICBNQVNDUC5yZWFkeSgpO1xuICAgICAgICAgICAgTUFTQ1AucmVhZHkgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgTUFTQ1AucmVhZHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSwxMDApO1xufTtcblxudmFyIGRiLGlkYjtcblxuaWYgKFwib3BlbkRhdGFiYXNlXCIgaW4gd2luZG93IHx8IFwiaW5kZXhlZERCXCIgaW4gd2luZG93KSB7XG5cbiAgICBpZiAoXCJpbmRleGVkREJcIiBpbiB3aW5kb3cpIHtcblxuICAgICAgICAvKiBWZXJzaW9uaW5nIG9mIERCIHNjaGVtYSAqL1xuXG4gICAgICAgIHZhciBjaGFuZ2VfZnVuYyA9IGZ1bmN0aW9uKHZlcnNpb24sdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBkYiA9IHRyYW5zYWN0aW9uLmRiO1xuICAgICAgICAgICAgaWYgKGRiLm9iamVjdFN0b3JlTmFtZXMgJiYgZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucyhcImNhY2hlZFwiKSkge1xuICAgICAgICAgICAgICAgIGRiLmRlbGV0ZU9iamVjdFN0b3JlKFwiY2FjaGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGtleXBhdGggPSB3aW5kb3cubXNJbmRleGVkREIgPyBcInNlcnZpY2VhY2NcIiA6IFwiaWRcIjtcbiAgICAgICAgICAgIHZhciBzdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKFwiY2FjaGVkXCIsIHsga2V5UGF0aDoga2V5cGF0aCB9KTtcbiAgICAgICAgICAgIHN0b3JlLmNyZWF0ZUluZGV4KFwiZW50cmllc1wiLCBbIFwiYWNjXCIgLCBcInNlcnZpY2VcIiBdLCB7IHVuaXF1ZSA6IGZhbHNlIH0pO1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5tc0luZGV4ZWREQikge1xuICAgICAgICAgICAgICAgIHN0b3JlLmNyZWF0ZUluZGV4KFwiZW50cmllcy1tc1wiLFwic2VydmljZWFjY1wiLCB7IHVuaXF1ZSA6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmUuY3JlYXRlSW5kZXgoXCJ0aW1lc3RhbXBzXCIsIFsgXCJzZXJ2aWNlXCIgLCBcInJldHJpZXZlZFwiIF0sIHsgdW5pcXVlIDogZmFsc2UgfSk7XG4gICAgICAgICAgICBzdG9yZS5jcmVhdGVJbmRleChcInNlcnZpY2VzXCIsIFwic2VydmljZVwiLCB7IHVuaXF1ZSA6IGZhbHNlIH0pO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24ub25jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGRhdGFiYXNlX3JlYWR5KGRiKTtcbiAgICAgICAgICAgICAgICBkYXRhYmFzZV9yZWFkeSA9IGZ1bmN0aW9uKCkge307XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgaWRiID0gdHJ1ZTtcbiAgICAgICAgdmFyIGRiX3ZlcnNpb24gPSAyO1xuICAgICAgICB2YXIgcmVxID0gaW5kZXhlZERCLm9wZW4oXCJkYXRhY2FjaGVcIixkYl92ZXJzaW9uKTtcblxuICAgICAgICByZXEub251cGdyYWRlbmVlZGVkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB2YXIgdHJhbnNhY3Rpb24gPSByZXEudHJhbnNhY3Rpb247XG4gICAgICAgICAgY2hhbmdlX2Z1bmMoZS5vbGRWZXJzaW9uLCB0cmFuc2FjdGlvbik7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGRhdGFiYXNlX3JlYWR5ID0gZnVuY3Rpb24oZGIpIHtcbiAgICAgICAgICAgIGlmIChkYikge1xuICAgICAgICAgICAgICAgIGlkYiA9IGRiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0dXBfaWRiKGlkYik7XG5cbiAgICAgICAgICAgIGlmIChNQVNDUC5ldmVudHMpIHtcbiAgICAgICAgICAgICAgICBNQVNDUC5ldmVudHMuZW1pdChcInJlYWR5XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE1BU0NQLnJlYWR5KSB7XG4gICAgICAgICAgICAgICAgTUFTQ1AucmVhZHkoKTtcbiAgICAgICAgICAgICAgICBNQVNDUC5yZWFkeSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIE1BU0NQLnJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmVxLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVycm9yIGxvYWRpbmcgRGF0YWJhc2VcIik7XG4gICAgICAgICAgICBzZXR1cF9sb2NhbHN0b3JhZ2UoKTtcbiAgICAgICAgICAgIC8vIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyAgICAgaW5kZXhlZERCLmRlbGV0ZURhdGFiYXNlKFwiZGF0YWNhY2hlXCIpLm9uc3VjY2VzcyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgLy8gfSwwKTtcbiAgICAgICAgfVxuICAgICAgICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWRiID0gZS50YXJnZXQucmVzdWx0O1xuICAgICAgICAgICAgdmFyIHZlcnNpb24gPSBkYl92ZXJzaW9uO1xuICAgICAgICAgICAgaWYgKGlkYi52ZXJzaW9uICE9IE51bWJlcih2ZXJzaW9uKSkge1xuICAgICAgICAgICAgICAgIHZhciB2ZXJzaW9uUmVxdWVzdCA9IGRiLnNldFZlcnNpb24odmVyKTtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uUmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNhY3Rpb24gPSB2ZXJzaW9uUmVxdWVzdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZV9mdW5jKG9sZFZlcnNpb24sIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhYmFzZV9yZWFkeSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkYiA9IG9wZW5EYXRhYmFzZShcImNhY2hlZFwiLFwiXCIsXCJNQVNDUCBHYXRvciBjYWNoZVwiLDEwMjQqMTAyNCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIGRiLmFsbCA9IGZ1bmN0aW9uKHNxbCxhcmdzLGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLmV4ZWMoc3FsLGFyZ3MsY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgICAgICBkYi5leGVjID0gZnVuY3Rpb24oc3FsLGFyZ3MsY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBzcWxhcmdzID0gYXJncztcbiAgICAgICAgICAgIHZhciBjYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYmFjayA9PSAndW5kZWZpbmVkJyAmJiBzcWxhcmdzICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzcWxhcmdzKSAhPSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgY2JhY2sgPSBhcmdzO1xuICAgICAgICAgICAgICAgIHNxbGFyZ3MgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi50cmFuc2FjdGlvbihmdW5jdGlvbih0eCkge1xuICAgICAgICAgICAgICAgIHR4LmV4ZWN1dGVTcWwoc3FsLHNxbGFyZ3MsZnVuY3Rpb24odHgscmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQucm93cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2gocmVzdWx0LnJvd3MuaXRlbShpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYmFjay5jYWxsKGRiLG51bGwscmVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sZnVuY3Rpb24odHgsZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2JhY2suY2FsbChkYixlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5pZiAodHlwZW9mIGlkYiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBEbyBub3RoaW5nXG59IGVsc2UgaWYgKHR5cGVvZiBkYiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzZXR1cF93ZWJzcWwoZGIpO1xufSBlbHNlIGlmIChcImxvY2FsU3RvcmFnZVwiIGluIHdpbmRvdykge1xuICAgIHNldHVwX2xvY2Fsc3RvcmFnZSgpO1xufSBlbHNlIHtcblxuICAgIHN3ZWVwX2NhY2hlID0gZnVuY3Rpb24odGltZXN0YW1wKSB7XG4gICAgfTtcbiAgICBcbiAgICBjbGVhcl9zZXJ2aWNlID0gZnVuY3Rpb24oc2VydmljZSxhY2MpIHtcbiAgICB9O1xuICAgIFxuICAgIHNlYXJjaF9zZXJ2aWNlID0gZnVuY3Rpb24oc2VydmljZSxjYmFjaykge1xuICAgIH07XG5cbiAgICBjYWNoZWRfYWNjZXNzaW9ucyA9IGZ1bmN0aW9uKHNlcnZpY2UsY2JhY2spIHtcbiAgICAgICAgY2JhY2suY2FsbChDYWNoaW5nU2VydmljZSxbXSk7XG4gICAgfTtcblxuICAgIGdldF9kYl9kYXRhID0gZnVuY3Rpb24oYWNjLHNlcnZpY2UsY2JhY2spIHtcbiAgICAgICAgY2JhY2suY2FsbChudWxsLG51bGwsbnVsbCk7XG4gICAgfTtcbiAgICBcbiAgICBzdG9yZV9kYl9kYXRhID0gZnVuY3Rpb24oYWNjLHNlcnZpY2UsZGF0YSkge1xuICAgIH07XG5cbiAgICBmaW5kX2xhdGVzdF9kYXRhID0gZnVuY3Rpb24oYWNjLHNlcnZpY2UsdGltZXN0YW1wLGNiYWNrKSB7XG4gICAgICAgIC8vIFdlIGRvbid0IGFjdHVhbGx5IHJldHJpZXZlIGhpc3RvcmljYWwgZGF0YSBmb3IgdGhpc1xuICAgICAgICBjYmFjay5jYWxsKG51bGwsW10pO1xuICAgIH07XG5cbiAgICBkYXRhX3RpbWVzdGFtcHMgPSBmdW5jdGlvbihzZXJ2aWNlLHRpbWVzdGFtcCxjYmFjaykge1xuICAgICAgICBjYmFjay5jYWxsKG51bGwsW10pO1xuICAgIH07XG4gICAgXG4gICAgYmVnaW5fdHJhbnNhY3Rpb24gPSBmdW5jdGlvbihjYWxsYmFjayx0cmFucykge1xuICAgICAgICAvLyBObyBzdXBwb3J0IGZvciB0cmFuc2FjdGlvbnMgaGVyZS4gRG8gbm90aGluZy5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgY2FsbGJhY2soe1widHJhbnNhY3Rpb25cIjogdHJhbnN9KTtcbiAgICAgICAgfSwwKTtcbiAgICB9O1xuICAgIGVuZF90cmFuc2FjdGlvbiA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIE5vIHN1cHBvcnQgZm9yIHRyYW5zYWN0aW9ucyBoZXJlLiBEbyBub3RoaW5nLlxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9LDApO1xuICAgIH07XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgQ2FjaGluZ1NlcnZpY2U7Il0sIm1hcHBpbmdzIjoiQUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../gator/js/lib/ServiceCaching.js\n')},"../gator/js/lib/TrackRendererComponent.js":
/*!*************************************************!*\
  !*** ../gator/js/lib/TrackRendererComponent.js ***!
  \*************************************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _GatorComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GatorComponent */ \"../gator/js/lib/GatorComponent.js\");\n/* harmony import */ var _jsandbox__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../jsandbox */ \"../gator/js/jsandbox.js\");\n/* harmony import */ var _MASCP__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MASCP */ \"../gator/js/lib/MASCP.js\");\n\n\n\nconst SANDBOXES = new Map();\n\nlet retrieve_renderer = function retrieve_renderer() {\n  let renderer_url = this.getAttribute('src');\n  return fetch(renderer_url).then(dat => dat.text());\n};\n\nfunction WrapHTML() {\n  return Reflect.construct(HTMLElement, [], Object.getPrototypeOf(this).constructor);\n}\n\nObject.setPrototypeOf(WrapHTML.prototype, HTMLElement.prototype);\nObject.setPrototypeOf(WrapHTML, HTMLElement);\n\nlet get_renderer_sequence = (renderer, accession) => {\n  return new Promise(resolve => {\n    (function () {\n      var obj = {\n        \"gotResult\": function gotResult() {\n          resolve(renderer.sequence);\n        },\n        \"acc\": accession\n      };\n      renderer.trigger('readerRegistered', [obj]);\n      obj.gotResult();\n    })();\n  });\n};\n\nlet set_basic_offset = (objects, basic_offset) => {\n  objects.forEach(function (obj) {\n    if (obj.options) {\n      if (obj.options.offset) {\n        obj.options.offset += basic_offset;\n        return;\n      }\n\n      obj.options.offset = basic_offset;\n    } else {\n      obj.options = {\n        \"offset\": basic_offset\n      };\n    }\n  });\n};\n\nlet apply_rendering = (renderer, default_track, objects) => {\n  if (Array.isArray(objects)) {\n    var temp_objects = {};\n    console.log('No accession provided');\n    temp_objects['DEFAULTACC'] = objects;\n    objects = temp_objects;\n  }\n\n  for (let acc of Object.keys(objects)) {\n    let r = objects[acc];\n    set_basic_offset(r, 0);\n    renderer.renderObjects(default_track, r.filter(function (item) {\n      return !item.track;\n    }));\n    var items_by_track = {};\n    r.filter(function (item) {\n      return item.track;\n    }).forEach(function (item) {\n      items_by_track[item.track] = items_by_track[item.track] || [];\n      items_by_track[item.track].push(item);\n    });\n    Object.keys(items_by_track).forEach(function (track) {\n      if (_MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getLayer(track)) {\n        _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].registerLayer(track, {}, [renderer]); // We force a refresh of the track order\n        // to pick up any layers that have been re-enabled\n\n        renderer.trackOrder = renderer.trackOrder;\n        renderer.renderObjects(track, items_by_track[track]);\n      }\n    });\n    renderer.trigger('resultsRendered', [undefined]);\n    renderer.refresh();\n  }\n};\n\nlet do_rendering = (renderer, script, data, default_track) => {\n  const SANDBOX = SANDBOXES.get(script) || new _jsandbox__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n  SANDBOXES.set(script, SANDBOX);\n  get_renderer_sequence(renderer).then(sequence => {\n    SANDBOX.eval(script, () => {\n      SANDBOX.eval({\n        'data': 'renderData(input.sequence,input.data,input.acc,input.track)',\n        'input': {\n          'sequence': sequence,\n          'data': data,\n          'track': default_track\n        },\n        'onerror': message => {\n          throw new Error(message);\n        },\n        'callback': apply_rendering.bind(null, renderer, default_track)\n      });\n    });\n  });\n};\n\nclass TrackRendererComponent extends WrapHTML {\n  static get observedAttributes() {\n    return ['track', 'src'];\n  }\n\n  constructor() {\n    super();\n  }\n\n  connectedCallback() {\n    this.script = retrieve_renderer.call(this);\n  }\n\n  render(renderer, data, track) {\n    this.script.then(script => {\n      do_rendering(renderer, script, data, track);\n    });\n  }\n\n  get data() {\n    return this._data;\n  }\n\n  set data(data) {\n    this._data = data;\n    this.render(this.ownerDocument.getElementById(this.getAttribute('renderer')).renderer, this._data, this.getAttribute('track'));\n  }\n\n  attributeChangedCallback(name) {\n    if (this.hasAttribute('renderer') && this.data && name === 'track') {\n      this.render(document.getElementById(this.getAttribute('renderer')).renderer, this._data, this.getAttribute('track'));\n    }\n\n    if (name === 'src') {\n      this.script = retrieve_renderer.call(this);\n    }\n  }\n\n}\n\ncustomElements.define('x-trackrenderer', TrackRendererComponent);\n\nlet create_track = function create_track() {\n  _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].registerLayer(this.name, {});\n  _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getLayer(this.name).fullname = this.fullname || this.name;\n  _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getLayer(this.name).scales.clear();\n\n  for (let scale of this.scale) {\n    _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getLayer(this.name).scales.add(scale);\n  }\n};\n\nclass TrackComponent extends WrapHTML {\n  static get observedAttributes() {\n    return ['name', 'fullname', 'scale'];\n  }\n\n  constructor() {\n    super();\n  }\n\n  connectedCallback() {\n    create_track.call(this);\n  }\n\n  get name() {\n    return this.getAttribute('name');\n  }\n\n  set name(name) {\n    return this.setAttribute('name', name);\n  }\n\n  get layer() {\n    return _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getLayer(this.name);\n  }\n\n  get fullname() {\n    return this.getAttribute('fullname');\n  }\n\n  set fullname(name) {\n    return this.setAttribute('fullname', name);\n  }\n\n  get scale() {\n    return (this.getAttribute('scale') || '').split(',');\n  }\n\n  set scale(scale) {\n    return this.setAttribute('scale', scale);\n  }\n\n  attributeChangedCallback(name) {\n    create_track.call(this);\n  }\n\n}\n\ncustomElements.define('x-gatortrack', TrackComponent);\n/* harmony default export */ __webpack_exports__[\"default\"] = (TrackRendererComponent);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vZ2F0b3IvanMvbGliL1RyYWNrUmVuZGVyZXJDb21wb25lbnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vZ2F0b3IvanMvbGliL1RyYWNrUmVuZGVyZXJDb21wb25lbnQuanM/ZjU0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCBHYXRvckNvbXBvbmVudCBmcm9tICcuL0dhdG9yQ29tcG9uZW50JztcbmltcG9ydCBKU2FuZGJveCBmcm9tICcuLi9qc2FuZGJveCc7XG5pbXBvcnQgTUFTQ1AgZnJvbSAnLi9NQVNDUCc7XG5cbmNvbnN0IFNBTkRCT1hFUyA9IG5ldyBNYXAoKTtcblxubGV0IHJldHJpZXZlX3JlbmRlcmVyID0gZnVuY3Rpb24oKSB7XG4gIGxldCByZW5kZXJlcl91cmwgPSB0aGlzLmdldEF0dHJpYnV0ZSgnc3JjJyk7XG4gIHJldHVybiBmZXRjaChyZW5kZXJlcl91cmwpXG4gIC50aGVuKCBkYXQgPT4gZGF0LnRleHQoKSApO1xufTtcblxuZnVuY3Rpb24gV3JhcEhUTUwoKSB7IHJldHVybiBSZWZsZWN0LmNvbnN0cnVjdChIVE1MRWxlbWVudCwgW10sIE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7IH1cbk9iamVjdC5zZXRQcm90b3R5cGVPZihXcmFwSFRNTC5wcm90b3R5cGUsIEhUTUxFbGVtZW50LnByb3RvdHlwZSk7XG5PYmplY3Quc2V0UHJvdG90eXBlT2YoV3JhcEhUTUwsIEhUTUxFbGVtZW50KTtcblxubGV0IGdldF9yZW5kZXJlcl9zZXF1ZW5jZSA9IChyZW5kZXJlcixhY2Nlc3Npb24pID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKCByZXNvbHZlID0+IHtcbiAgKGZ1bmN0aW9uKCkge1xuICAgIHZhciBvYmogPSAoeyBcImdvdFJlc3VsdFwiIDogZnVuY3Rpb24oKSB7XG4gICAgICByZXNvbHZlKHJlbmRlcmVyLnNlcXVlbmNlKTtcbiAgICB9LCBcImFjY1wiIDogYWNjZXNzaW9uIH0pO1xuICAgIHJlbmRlcmVyLnRyaWdnZXIoJ3JlYWRlclJlZ2lzdGVyZWQnLFtvYmpdKTtcbiAgICBvYmouZ290UmVzdWx0KCk7XG4gIH0pKCk7XG4gIH0pO1xufTtcblxubGV0IHNldF9iYXNpY19vZmZzZXQgPSAob2JqZWN0cyxiYXNpY19vZmZzZXQpID0+IHtcbiAgb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmoub3B0aW9ucykge1xuICAgICAgaWYgKG9iai5vcHRpb25zLm9mZnNldCkge1xuICAgICAgICBvYmoub3B0aW9ucy5vZmZzZXQgKz0gYmFzaWNfb2Zmc2V0O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBvYmoub3B0aW9ucy5vZmZzZXQgPSBiYXNpY19vZmZzZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iai5vcHRpb25zID0geyBcIm9mZnNldFwiIDogYmFzaWNfb2Zmc2V0IH07XG4gICAgfVxuICB9KTtcbn07XG5cbmxldCBhcHBseV9yZW5kZXJpbmcgPSAocmVuZGVyZXIsZGVmYXVsdF90cmFjayxvYmplY3RzKSA9PiB7XG4gIGlmICggQXJyYXkuaXNBcnJheShvYmplY3RzKSApIHtcbiAgICB2YXIgdGVtcF9vYmplY3RzID0ge31cbiAgICBjb25zb2xlLmxvZygnTm8gYWNjZXNzaW9uIHByb3ZpZGVkJyk7XG4gICAgdGVtcF9vYmplY3RzWydERUZBVUxUQUNDJ10gPSBvYmplY3RzO1xuICAgIG9iamVjdHMgPSB0ZW1wX29iamVjdHM7XG4gIH1cbiAgZm9yIChsZXQgYWNjIG9mIE9iamVjdC5rZXlzKG9iamVjdHMpKSB7XG4gICAgbGV0IHIgPSBvYmplY3RzW2FjY107XG4gICAgc2V0X2Jhc2ljX29mZnNldChyLDApO1xuXG4gICAgcmVuZGVyZXIucmVuZGVyT2JqZWN0cyhkZWZhdWx0X3RyYWNrLHIuZmlsdGVyKCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICByZXR1cm4gISBpdGVtLnRyYWNrO1xuICAgIH0pKTtcblxuICAgIHZhciBpdGVtc19ieV90cmFjayA9IHt9O1xuICAgIHIuZmlsdGVyKCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbS50cmFjaztcbiAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIGl0ZW1zX2J5X3RyYWNrW2l0ZW0udHJhY2tdID0gaXRlbXNfYnlfdHJhY2tbaXRlbS50cmFja10gfHwgW107XG4gICAgICBpdGVtc19ieV90cmFja1tpdGVtLnRyYWNrXS5wdXNoKGl0ZW0pO1xuICAgIH0pO1xuICAgIE9iamVjdC5rZXlzKGl0ZW1zX2J5X3RyYWNrKS5mb3JFYWNoKGZ1bmN0aW9uKHRyYWNrKSB7XG4gICAgICBpZiAoTUFTQ1AuZ2V0TGF5ZXIodHJhY2spKSB7XG4gICAgICAgIE1BU0NQLnJlZ2lzdGVyTGF5ZXIodHJhY2sse30sW3JlbmRlcmVyXSk7XG4gICAgICAgIC8vIFdlIGZvcmNlIGEgcmVmcmVzaCBvZiB0aGUgdHJhY2sgb3JkZXJcbiAgICAgICAgLy8gdG8gcGljayB1cCBhbnkgbGF5ZXJzIHRoYXQgaGF2ZSBiZWVuIHJlLWVuYWJsZWRcbiAgICAgICAgcmVuZGVyZXIudHJhY2tPcmRlciA9IHJlbmRlcmVyLnRyYWNrT3JkZXI7XG4gICAgICAgIHJlbmRlcmVyLnJlbmRlck9iamVjdHModHJhY2ssaXRlbXNfYnlfdHJhY2tbdHJhY2tdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZW5kZXJlci50cmlnZ2VyKCdyZXN1bHRzUmVuZGVyZWQnLFt0aGlzXSk7XG4gICAgcmVuZGVyZXIucmVmcmVzaCgpO1xuICB9XG59O1xuXG5sZXQgZG9fcmVuZGVyaW5nID0gKHJlbmRlcmVyLHNjcmlwdCxkYXRhLGRlZmF1bHRfdHJhY2spID0+IHtcbiAgY29uc3QgU0FOREJPWCA9IFNBTkRCT1hFUy5nZXQoc2NyaXB0KSB8fCBuZXcgSlNhbmRib3goKTtcbiAgU0FOREJPWEVTLnNldChzY3JpcHQsU0FOREJPWCk7XG4gIGdldF9yZW5kZXJlcl9zZXF1ZW5jZShyZW5kZXJlcilcbiAgLnRoZW4oIHNlcXVlbmNlID0+IHtcbiAgICBTQU5EQk9YLmV2YWwoc2NyaXB0LCAoKSA9PiB7XG4gICAgICBTQU5EQk9YLmV2YWwoeyAnZGF0YScgOiAncmVuZGVyRGF0YShpbnB1dC5zZXF1ZW5jZSxpbnB1dC5kYXRhLGlucHV0LmFjYyxpbnB1dC50cmFjayknLFxuICAgICAgICAgICAgICAgICAgJ2lucHV0JyA6IHsgJ3NlcXVlbmNlJyA6IHNlcXVlbmNlLCAnZGF0YScgOiBkYXRhLCAndHJhY2snIDogZGVmYXVsdF90cmFjayB9LFxuICAgICAgICAgICAgICAgICAgJ29uZXJyb3InOiBtZXNzYWdlID0+IHsgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpIH0sXG4gICAgICAgICAgICAgICAgICAnY2FsbGJhY2snIDogYXBwbHlfcmVuZGVyaW5nLmJpbmQobnVsbCxyZW5kZXJlcixkZWZhdWx0X3RyYWNrKVxuICAgICAgICAgICAgICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5jbGFzcyBUcmFja1JlbmRlcmVyQ29tcG9uZW50IGV4dGVuZHMgV3JhcEhUTUwgIHtcbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsndHJhY2snLCdzcmMnXTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLnNjcmlwdCA9IHJldHJpZXZlX3JlbmRlcmVyLmNhbGwodGhpcyk7XG4gIH1cblxuICByZW5kZXIocmVuZGVyZXIsZGF0YSx0cmFjaykge1xuICAgIHRoaXMuc2NyaXB0XG4gICAgLnRoZW4gKHNjcmlwdCA9PiB7XG4gICAgICBkb19yZW5kZXJpbmcocmVuZGVyZXIsc2NyaXB0LGRhdGEsdHJhY2spO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gIH1cblxuICBzZXQgZGF0YShkYXRhKSB7XG4gICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5yZW5kZXIodGhpcy5vd25lckRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuZ2V0QXR0cmlidXRlKCdyZW5kZXJlcicpKS5yZW5kZXJlcix0aGlzLl9kYXRhLHRoaXMuZ2V0QXR0cmlidXRlKCd0cmFjaycpKTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lKSB7XG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdyZW5kZXJlcicpICYmIHRoaXMuZGF0YSAmJiBuYW1lID09PSAndHJhY2snKSB7XG4gICAgICB0aGlzLnJlbmRlcihkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmdldEF0dHJpYnV0ZSgncmVuZGVyZXInKSkucmVuZGVyZXIsdGhpcy5fZGF0YSx0aGlzLmdldEF0dHJpYnV0ZSgndHJhY2snKSk7XG4gICAgfVxuICAgIGlmIChuYW1lID09PSAnc3JjJykge1xuICAgICAgdGhpcy5zY3JpcHQgPSByZXRyaWV2ZV9yZW5kZXJlci5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ3gtdHJhY2tyZW5kZXJlcicsVHJhY2tSZW5kZXJlckNvbXBvbmVudCk7XG5cbmxldCBjcmVhdGVfdHJhY2sgPSBmdW5jdGlvbigpIHtcbiAgTUFTQ1AucmVnaXN0ZXJMYXllcih0aGlzLm5hbWUse30pO1xuICBNQVNDUC5nZXRMYXllcih0aGlzLm5hbWUpLmZ1bGxuYW1lID0gdGhpcy5mdWxsbmFtZSB8fCB0aGlzLm5hbWU7XG4gIE1BU0NQLmdldExheWVyKHRoaXMubmFtZSkuc2NhbGVzLmNsZWFyKCk7XG4gIGZvciAobGV0IHNjYWxlIG9mIHRoaXMuc2NhbGUpIHtcbiAgICBNQVNDUC5nZXRMYXllcih0aGlzLm5hbWUpLnNjYWxlcy5hZGQoc2NhbGUpO1xuICB9XG59O1xuXG5jbGFzcyBUcmFja0NvbXBvbmVudCBleHRlbmRzIFdyYXBIVE1MICB7XG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ25hbWUnLCdmdWxsbmFtZScsJ3NjYWxlJ107XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgY3JlYXRlX3RyYWNrLmNhbGwodGhpcyk7XG4gIH1cblxuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ25hbWUnKTtcbiAgfVxuXG4gIHNldCBuYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRBdHRyaWJ1dGUoJ25hbWUnLG5hbWUpO1xuICB9XG5cbiAgZ2V0IGxheWVyKCkge1xuICAgIHJldHVybiBNQVNDUC5nZXRMYXllcih0aGlzLm5hbWUpO1xuICB9XG5cbiAgZ2V0IGZ1bGxuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnZnVsbG5hbWUnKTtcbiAgfVxuXG4gIHNldCBmdWxsbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0QXR0cmlidXRlKCdmdWxsbmFtZScsbmFtZSk7XG4gIH1cblxuICBnZXQgc2NhbGUoKSB7XG4gICAgcmV0dXJuICh0aGlzLmdldEF0dHJpYnV0ZSgnc2NhbGUnKSB8fCAnJykuc3BsaXQoJywnKTtcbiAgfVxuXG4gIHNldCBzY2FsZShzY2FsZSkge1xuICAgIHJldHVybiB0aGlzLnNldEF0dHJpYnV0ZSgnc2NhbGUnLHNjYWxlKTtcbiAgfVxuXG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUpIHtcbiAgICBjcmVhdGVfdHJhY2suY2FsbCh0aGlzKTtcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ3gtZ2F0b3J0cmFjaycsVHJhY2tDb21wb25lbnQpO1xuXG5leHBvcnQgZGVmYXVsdCBUcmFja1JlbmRlcmVyQ29tcG9uZW50OyJdLCJtYXBwaW5ncyI6IkFBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUZBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBckNBO0FBQ0E7QUFzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBN0NBO0FBQ0E7QUE4Q0E7QUFFQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../gator/js/lib/TrackRendererComponent.js\n")},"../gator/js/lib/UniprotReader.js":
/*!****************************************!*\
  !*** ../gator/js/lib/UniprotReader.js ***!
  \****************************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Service */ "../gator/js/lib/Service.js");\n/* harmony import */ var _UserdataReader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./UserdataReader */ "../gator/js/lib/UserdataReader.js");\n/* harmony import */ var _bean__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../bean */ "../gator/js/bean.js");\n/* harmony import */ var _MASCP__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MASCP */ "../gator/js/lib/MASCP.js");\n/**\n * @fileOverview    Classes for reading data from Uniprot database\n */\n\n\n\n\n/** Default class constructor\n *  @class      Service class that will retrieve data from Uniprot for a given AGI.\n *  @param      {String} agi            Agi to look up\n *  @param      {String} endpointURL    Endpoint URL for this service\n *  @extends    MASCP.Service\n */\n\nconst UniprotReader = _Service__WEBPACK_IMPORTED_MODULE_0__["default"].buildService(function (data) {\n  if (data && typeof data === \'string\') {\n    var dats = UniprotReader.parseFasta(data);\n    var key;\n\n    for (key in dats) {\n      if (dats.hasOwnProperty(key)) {\n        data = {\n          \'data\': dats[key]\n        };\n        this._raw_data = data;\n      }\n    }\n  }\n\n  this._data = data || {};\n\n  if (!this._data.data) {\n    this._data = {\n      \'data\': [\'\', \'\']\n    };\n  }\n\n  return this;\n});\nUniprotReader.SERVICE_URL = null;\n\nUniprotReader.prototype.requestData = function () {\n  var self = this;\n\n  if (!UniprotReader.SERVICE_URL) {\n    throw new Error(\'No service URL for UniprotReader\');\n  }\n\n  return {\n    type: "GET",\n    dataType: "json",\n    \'auth\': _MASCP__WEBPACK_IMPORTED_MODULE_3__["default"].GATOR_AUTH_TOKEN,\n    \'api_key\': _MASCP__WEBPACK_IMPORTED_MODULE_3__["default"].GATOR_CLIENT_ID,\n    \'url\': UniprotReader.SERVICE_URL + \'/\' + this.agi.toUpperCase()\n  };\n};\n\nUniprotReader.Result.prototype.getDescription = function () {\n  return this._data.data[1];\n};\n\nUniprotReader.Result.prototype.getSequence = function () {\n  return this._data.data[0];\n};\n\nUniprotReader.parseFasta = function (datablock) {\n  var chunks = datablock.split(\'>\');\n  var datas = {};\n  chunks.forEach(function (entry) {\n    var lines = entry.split(/\\n/);\n\n    if (lines.length <= 1) {\n      return;\n    }\n\n    var header = lines.shift();\n    var seq = lines.join("");\n    var header_data = header.split(\'|\');\n    var acc = header_data[1];\n    var desc = header_data[2];\n    datas[acc] = [seq, desc];\n  });\n  return datas;\n};\n\nUniprotReader.readFastaFile = function (datablock, callback) {\n  var datas = UniprotReader.parseFasta(datablock);\n  var writer = new _UserdataReader__WEBPACK_IMPORTED_MODULE_1__["default"]();\n\n  writer.toString = function () {\n    return "UniprotReader";\n  };\n\n  writer.map = function (dat) {\n    return dat.data;\n  };\n\n  writer.datasetname = "UniprotReader";\n  callback(writer);\n  setTimeout(function () {\n    writer.avoid_database = true;\n    writer.setData("UniprotReader", {\n      "data": datas\n    });\n  }, 0);\n  return writer;\n};\n\n/* harmony default export */ __webpack_exports__["default"] = (UniprotReader);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vZ2F0b3IvanMvbGliL1VuaXByb3RSZWFkZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vZ2F0b3IvanMvbGliL1VuaXByb3RSZWFkZXIuanM/MzVkYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlT3ZlcnZpZXcgICAgQ2xhc3NlcyBmb3IgcmVhZGluZyBkYXRhIGZyb20gVW5pcHJvdCBkYXRhYmFzZVxuICovXG5cbmltcG9ydCBTZXJ2aWNlIGZyb20gJy4vU2VydmljZSc7XG5pbXBvcnQgVXNlcmRhdGFSZWFkZXIgZnJvbSAnLi9Vc2VyZGF0YVJlYWRlcic7XG5pbXBvcnQgYmVhbiBmcm9tICcuLi9iZWFuJztcbmltcG9ydCBNQVNDUCBmcm9tICcuL01BU0NQJztcblxuXG4vKiogRGVmYXVsdCBjbGFzcyBjb25zdHJ1Y3RvclxuICogIEBjbGFzcyAgICAgIFNlcnZpY2UgY2xhc3MgdGhhdCB3aWxsIHJldHJpZXZlIGRhdGEgZnJvbSBVbmlwcm90IGZvciBhIGdpdmVuIEFHSS5cbiAqICBAcGFyYW0gICAgICB7U3RyaW5nfSBhZ2kgICAgICAgICAgICBBZ2kgdG8gbG9vayB1cFxuICogIEBwYXJhbSAgICAgIHtTdHJpbmd9IGVuZHBvaW50VVJMICAgIEVuZHBvaW50IFVSTCBmb3IgdGhpcyBzZXJ2aWNlXG4gKiAgQGV4dGVuZHMgICAgTUFTQ1AuU2VydmljZVxuICovXG5jb25zdCBVbmlwcm90UmVhZGVyID0gU2VydmljZS5idWlsZFNlcnZpY2UoZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBkYXRhICYmIHR5cGVvZihkYXRhKSA9PT0gJ3N0cmluZycgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdHMgPSBVbmlwcm90UmVhZGVyLnBhcnNlRmFzdGEoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBkYXRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSB7ICdkYXRhJyA6IGRhdHNba2V5XSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmF3X2RhdGEgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGEgfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICEgdGhpcy5fZGF0YS5kYXRhICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RhdGEgPSB7ICdkYXRhJyA6IFsnJywnJ10gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuVW5pcHJvdFJlYWRlci5TRVJWSUNFX1VSTCA9IG51bGw7XG5cblVuaXByb3RSZWFkZXIucHJvdG90eXBlLnJlcXVlc3REYXRhID0gZnVuY3Rpb24oKVxue1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoICEgVW5pcHJvdFJlYWRlci5TRVJWSUNFX1VSTCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNlcnZpY2UgVVJMIGZvciBVbmlwcm90UmVhZGVyJyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiR0VUXCIsXG4gICAgICAgIGRhdGFUeXBlOiBcImpzb25cIixcbiAgICAgICAgJ2F1dGgnIDogTUFTQ1AuR0FUT1JfQVVUSF9UT0tFTixcbiAgICAgICAgJ2FwaV9rZXknIDogTUFTQ1AuR0FUT1JfQ0xJRU5UX0lELFxuICAgICAgICAndXJsJyAgIDogVW5pcHJvdFJlYWRlci5TRVJWSUNFX1VSTCsnLycrKHRoaXMuYWdpKS50b1VwcGVyQ2FzZSgpXG4gICAgfTtcbn07XG5cblVuaXByb3RSZWFkZXIuUmVzdWx0LnByb3RvdHlwZS5nZXREZXNjcmlwdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLmRhdGFbMV07XG59O1xuXG5Vbmlwcm90UmVhZGVyLlJlc3VsdC5wcm90b3R5cGUuZ2V0U2VxdWVuY2UgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5kYXRhWzBdO1xufTtcblxuVW5pcHJvdFJlYWRlci5wYXJzZUZhc3RhID0gZnVuY3Rpb24oZGF0YWJsb2NrKSB7XG4gICAgdmFyIGNodW5rcyA9IChkYXRhYmxvY2suc3BsaXQoJz4nKSk7XG4gICAgdmFyIGRhdGFzID0ge307XG4gICAgY2h1bmtzLmZvckVhY2goZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgdmFyIGxpbmVzID0gZW50cnkuc3BsaXQoL1xcbi8pO1xuICAgICAgICBpZiAobGluZXMubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGVhZGVyID0gbGluZXMuc2hpZnQoKTtcbiAgICAgICAgdmFyIHNlcSA9IGxpbmVzLmpvaW4oXCJcIik7XG4gICAgICAgIHZhciBoZWFkZXJfZGF0YSA9IGhlYWRlci5zcGxpdCgnfCcpO1xuICAgICAgICB2YXIgYWNjID0gaGVhZGVyX2RhdGFbMV07XG4gICAgICAgIHZhciBkZXNjID0gaGVhZGVyX2RhdGFbMl07XG4gICAgICAgIGRhdGFzW2FjY10gPSBbc2VxLGRlc2NdO1xuICAgIH0pO1xuICAgIHJldHVybiBkYXRhcztcbn1cblxuVW5pcHJvdFJlYWRlci5yZWFkRmFzdGFGaWxlID0gZnVuY3Rpb24oZGF0YWJsb2NrLGNhbGxiYWNrKSB7XG5cbiAgICB2YXIgZGF0YXMgPSBVbmlwcm90UmVhZGVyLnBhcnNlRmFzdGEoZGF0YWJsb2NrKTtcblxuICAgIHZhciB3cml0ZXIgPSBuZXcgVXNlcmRhdGFSZWFkZXIoKTtcbiAgICB3cml0ZXIudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFwiVW5pcHJvdFJlYWRlclwiO1xuICAgIH07XG4gICAgd3JpdGVyLm1hcCA9IGZ1bmN0aW9uKGRhdCkge1xuICAgICAgICByZXR1cm4gZGF0LmRhdGE7XG4gICAgfTtcbiAgICB3cml0ZXIuZGF0YXNldG5hbWUgPSBcIlVuaXByb3RSZWFkZXJcIjtcbiAgICBjYWxsYmFjayh3cml0ZXIpO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHdyaXRlci5hdm9pZF9kYXRhYmFzZSA9IHRydWU7XG4gICAgICAgIHdyaXRlci5zZXREYXRhKFwiVW5pcHJvdFJlYWRlclwiLHtcImRhdGFcIiA6IGRhdGFzfSk7XG4gICAgfSwwKTtcbiAgICByZXR1cm4gd3JpdGVyO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgVW5pcHJvdFJlYWRlcjtcblxuXG5cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../gator/js/lib/UniprotReader.js\n')},"../gator/js/lib/UserdataReader.js":
/*!*****************************************!*\
  !*** ../gator/js/lib/UserdataReader.js ***!
  \*****************************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Service */ "../gator/js/lib/Service.js");\n/* harmony import */ var _ServiceCaching__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ServiceCaching */ "../gator/js/lib/ServiceCaching.js");\n/* harmony import */ var _MASCP__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MASCP */ "../gator/js/lib/MASCP.js");\n/* harmony import */ var _bean__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../bean */ "../gator/js/bean.js");\n/**\n * @fileOverview    Classes for getting arbitrary user data onto the GATOR\n */\n\n\n\n\n/** Default class constructor\n *  @class      Service class that will retrieve sequence data for a given AGI from a given ecotype\n *  @param      {String} agi            Agi to look up\n *  @param      {String} endpointURL    Endpoint URL for this service\n *  @extends    MASCP.Service\n */\n\nconst UserdataReader = _Service__WEBPACK_IMPORTED_MODULE_0__["default"].buildService(function (data) {\n  if (!data) {\n    return this;\n  }\n\n  this._raw_data = data;\n  return this;\n});\n\nUserdataReader.prototype.toString = function () {\n  return \'UserdataReader.\' + this.datasetname;\n};\n\nUserdataReader.prototype.requestData = function () {\n  var agi = this.agi.toUpperCase();\n  return {\n    type: "GET",\n    dataType: "json",\n    data: {\n      \'agi\': agi,\n      \'service\': this.datasetname\n    }\n  };\n};\n\nUserdataReader.prototype.setupSequenceRenderer = function (renderer) {// We don\'t have any default rendering for the UserDataReader\n  // since it\'s all going to be custom stuff anyway\n};\n\nvar apply_map = function apply_map(data_block) {\n  var map = this.map;\n  var databits = data_block.data;\n  var headers = databits.shift();\n  var dataset = {};\n  var id_col = headers.indexOf(map.id);\n  var cols_to_add = [];\n\n  for (var col in map) {\n    if (col == "id") {\n      continue;\n    }\n\n    if (map.hasOwnProperty(col)) {\n      cols_to_add.push({\n        "name": col,\n        "index": headers.indexOf(map[col])\n      });\n    }\n  }\n\n  while (databits.length > 0) {\n    var row = databits.shift();\n    var id = row[id_col].toLowerCase();\n\n    if (!dataset[id]) {\n      dataset[id] = {\n        "data": {}\n      };\n    }\n\n    var obj = dataset[id];\n    var i;\n\n    for (i = cols_to_add.length - 1; i >= 0; i--) {\n      if (!obj.data[cols_to_add[i].name]) {\n        obj.data[cols_to_add[i].name] = [];\n      }\n\n      obj.data[cols_to_add[i].name] = obj.data[cols_to_add[i].name].concat((row[cols_to_add[i].index] || \'\').split(\',\'));\n    }\n\n    obj.retrieved = data_block.retrieved;\n    obj.title = data_block.title;\n\n    if (data_block.etag) {\n      obj.etag = data_block.etag;\n    }\n  }\n\n  return dataset;\n};\n\nUserdataReader.prototype.setData = function (name, data) {\n  if (!data) {\n    return;\n  }\n\n  var self = this; // Call CacheService on this object/class\n  // just to make sure that it has access\n  // to the cache retrieval mechanisms\n\n  _ServiceCaching__WEBPACK_IMPORTED_MODULE_1__["default"].CacheService(this);\n  this.datasetname = name;\n\n  if (!data.retrieved) {\n    data.retrieved = new Date();\n  }\n\n  if (!data.title) {\n    data.title = name;\n  }\n\n  self.title = data.title;\n  var dataset = {}; // Format is { "accession" : { "data" : {}, "retrieved" : "" , "title" : ""  } };\n\n  if (typeof this.map == \'object\') {\n    dataset = apply_map.call(this, data);\n  }\n\n  if (typeof this.map == \'function\') {\n    if (this.map.callback) {\n      var self_func = arguments.callee;\n      this.map(data, function (parsed) {\n        self.map = function (d) {\n          return d;\n        };\n\n        self_func.call(self, name, parsed);\n      });\n      return;\n    }\n\n    dataset = this.map(data);\n  }\n\n  if (!this.map) {\n    return;\n  }\n\n  this.data = dataset;\n  var inserter = new UserdataReader();\n\n  inserter.toString = function () {\n    return self.toString();\n  };\n\n  inserter.data = dataset;\n\n  inserter.retrieve = function (an_acc, cback) {\n    this.agi = an_acc; // this._dataReceived(dataset[this.agi]);\n\n    cback.call(this);\n  };\n\n  _ServiceCaching__WEBPACK_IMPORTED_MODULE_1__["default"].CacheService(inserter);\n  var accs = [];\n  var acc;\n\n  for (acc in dataset) {\n    if (dataset.hasOwnProperty(acc)) {\n      if (acc.match(/[A-Z]/)) {\n        dataset[acc.toLowerCase()] = dataset[acc];\n        delete dataset[acc];\n        acc = acc.toLowerCase();\n      }\n\n      accs.push(acc);\n    }\n  }\n\n  var total = accs.length;\n  var retrieve = this.retrieve;\n\n  this.retrieve = function (id, cback) {\n    console.log("Data not ready! Waiting for ready state");\n    var self = this;\n    _bean__WEBPACK_IMPORTED_MODULE_3__["default"].add(self, \'ready\', function () {\n      _bean__WEBPACK_IMPORTED_MODULE_3__["default"].remove(self, \'ready\', arguments.callee);\n      self.retrieve(id, cback);\n    });\n  };\n\n  if (accs.length < 1) {\n    setTimeout(function () {\n      self.retrieve = retrieve;\n      _bean__WEBPACK_IMPORTED_MODULE_3__["default"].fire(self, \'ready\', [data]);\n    }, 0);\n    return;\n  }\n\n  _ServiceCaching__WEBPACK_IMPORTED_MODULE_1__["default"].BulkOperation(function (err) {\n    if (err) {\n      _bean__WEBPACK_IMPORTED_MODULE_3__["default"].fire(self, \'error\', [err]);\n      return;\n    }\n\n    var trans = this.transaction;\n    inserter.avoid_database = true;\n    inserter.retrieve(accs[0], function () {\n      while (accs.length > 0) {\n        var acc = accs.shift();\n        _bean__WEBPACK_IMPORTED_MODULE_3__["default"].fire(self, \'progress\', [100 * ((total - accs.length) / total), total - accs.length, total]);\n        inserter.agi = acc;\n\n        inserter._dataReceived(dataset[acc]);\n\n        if (accs.length === 0) {\n          self.retrieve = retrieve;\n          trans(function (err) {\n            if (!err) {\n              _bean__WEBPACK_IMPORTED_MODULE_3__["default"].fire(self, \'ready\', [data]);\n            } else {\n              _bean__WEBPACK_IMPORTED_MODULE_3__["default"].fire(self, \'error\');\n            }\n          });\n          return;\n        }\n      }\n    });\n  });\n};\n\nUserdataReader.datasets = function (cback, done) {\n  _ServiceCaching__WEBPACK_IMPORTED_MODULE_1__["default"].FindCachedService(this, function (services) {\n    var result = [];\n\n    for (var i = 0, len = services.length; i < len; i++) {\n      result.push(services[i].replace(/UserdataReader./, \'\'));\n    }\n\n    if (result.forEach) {\n      result.forEach(cback);\n    }\n\n    if (done) {\n      done();\n    }\n  });\n};\n\n/* harmony default export */ __webpack_exports__["default"] = (UserdataReader);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vZ2F0b3IvanMvbGliL1VzZXJkYXRhUmVhZGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL2dhdG9yL2pzL2xpYi9Vc2VyZGF0YVJlYWRlci5qcz84YjAxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVPdmVydmlldyAgICBDbGFzc2VzIGZvciBnZXR0aW5nIGFyYml0cmFyeSB1c2VyIGRhdGEgb250byB0aGUgR0FUT1JcbiAqL1xuXG5pbXBvcnQgU2VydmljZSBmcm9tICcuL1NlcnZpY2UnO1xuaW1wb3J0IENhY2hpbmdTZXJ2aWNlIGZyb20gJy4vU2VydmljZUNhY2hpbmcnO1xuaW1wb3J0IE1BU0NQIGZyb20gJy4vTUFTQ1AnO1xuaW1wb3J0IGJlYW4gZnJvbSAnLi4vYmVhbic7XG5cblxuLyoqIERlZmF1bHQgY2xhc3MgY29uc3RydWN0b3JcbiAqICBAY2xhc3MgICAgICBTZXJ2aWNlIGNsYXNzIHRoYXQgd2lsbCByZXRyaWV2ZSBzZXF1ZW5jZSBkYXRhIGZvciBhIGdpdmVuIEFHSSBmcm9tIGEgZ2l2ZW4gZWNvdHlwZVxuICogIEBwYXJhbSAgICAgIHtTdHJpbmd9IGFnaSAgICAgICAgICAgIEFnaSB0byBsb29rIHVwXG4gKiAgQHBhcmFtICAgICAge1N0cmluZ30gZW5kcG9pbnRVUkwgICAgRW5kcG9pbnQgVVJMIGZvciB0aGlzIHNlcnZpY2VcbiAqICBAZXh0ZW5kcyAgICBNQVNDUC5TZXJ2aWNlXG4gKi9cbmNvbnN0IFVzZXJkYXRhUmVhZGVyID0gU2VydmljZS5idWlsZFNlcnZpY2UoZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhIGRhdGEgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yYXdfZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cblVzZXJkYXRhUmVhZGVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnVXNlcmRhdGFSZWFkZXIuJyt0aGlzLmRhdGFzZXRuYW1lO1xufTtcblxuVXNlcmRhdGFSZWFkZXIucHJvdG90eXBlLnJlcXVlc3REYXRhID0gZnVuY3Rpb24oKVxue1xuICAgIHZhciBhZ2kgPSB0aGlzLmFnaS50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiR0VUXCIsXG4gICAgICAgIGRhdGFUeXBlOiBcImpzb25cIixcbiAgICAgICAgZGF0YTogeyAnYWdpJyAgICAgICA6IGFnaSxcbiAgICAgICAgICAgICAgICAnc2VydmljZScgICA6IHRoaXMuZGF0YXNldG5hbWUgXG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuXG5Vc2VyZGF0YVJlYWRlci5wcm90b3R5cGUuc2V0dXBTZXF1ZW5jZVJlbmRlcmVyID0gZnVuY3Rpb24ocmVuZGVyZXIpIHtcbi8vIFdlIGRvbid0IGhhdmUgYW55IGRlZmF1bHQgcmVuZGVyaW5nIGZvciB0aGUgVXNlckRhdGFSZWFkZXJcbi8vIHNpbmNlIGl0J3MgYWxsIGdvaW5nIHRvIGJlIGN1c3RvbSBzdHVmZiBhbnl3YXlcbn07XG5cbnZhciBhcHBseV9tYXAgPSBmdW5jdGlvbihkYXRhX2Jsb2NrKSB7XG4gICAgdmFyIG1hcCA9IHRoaXMubWFwO1xuICAgIHZhciBkYXRhYml0cyA9IGRhdGFfYmxvY2suZGF0YTtcbiAgICB2YXIgaGVhZGVycyA9IGRhdGFiaXRzLnNoaWZ0KCk7XG4gICAgdmFyIGRhdGFzZXQgPSB7fTtcbiAgICB2YXIgaWRfY29sID0gaGVhZGVycy5pbmRleE9mKG1hcC5pZCk7XG4gICAgdmFyIGNvbHNfdG9fYWRkID0gW107XG4gICAgZm9yICh2YXIgY29sIGluIG1hcCkge1xuICAgICAgICBpZiAoY29sID09IFwiaWRcIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcC5oYXNPd25Qcm9wZXJ0eShjb2wpKSB7XG4gICAgICAgICAgICBjb2xzX3RvX2FkZC5wdXNoKHsgXCJuYW1lXCIgOiBjb2wsIFwiaW5kZXhcIiA6IGhlYWRlcnMuaW5kZXhPZihtYXBbY29sXSkgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKGRhdGFiaXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHJvdyA9IGRhdGFiaXRzLnNoaWZ0KCk7XG4gICAgICAgIHZhciBpZCA9IHJvd1tpZF9jb2xdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICggISBkYXRhc2V0W2lkXSApIHtcbiAgICAgICAgICAgIGRhdGFzZXRbaWRdID0ge1wiZGF0YVwiIDoge319O1xuICAgICAgICB9XG4gICAgICAgIHZhciBvYmogPSBkYXRhc2V0W2lkXTtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvciAoaSA9IGNvbHNfdG9fYWRkLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAoICEgb2JqLmRhdGFbY29sc190b19hZGRbaV0ubmFtZV0gKSB7XG4gICAgICAgICAgICAgICAgb2JqLmRhdGFbY29sc190b19hZGRbaV0ubmFtZV0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9iai5kYXRhW2NvbHNfdG9fYWRkW2ldLm5hbWVdID0gb2JqLmRhdGFbY29sc190b19hZGRbaV0ubmFtZV0uY29uY2F0KChyb3dbY29sc190b19hZGRbaV0uaW5kZXhdIHx8ICcnKS5zcGxpdCgnLCcpKTtcbiAgICAgICAgfVxuICAgICAgICBvYmoucmV0cmlldmVkID0gZGF0YV9ibG9jay5yZXRyaWV2ZWQ7XG4gICAgICAgIG9iai50aXRsZSA9IGRhdGFfYmxvY2sudGl0bGU7XG4gICAgICAgIGlmIChkYXRhX2Jsb2NrLmV0YWcpIHtcbiAgICAgICAgICAgIG9iai5ldGFnID0gZGF0YV9ibG9jay5ldGFnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhc2V0O1xufTtcblxuVXNlcmRhdGFSZWFkZXIucHJvdG90eXBlLnNldERhdGEgPSBmdW5jdGlvbihuYW1lLGRhdGEpIHtcbiAgICBcbiAgICBpZiAoICEgZGF0YSApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBcbiAgICAvLyBDYWxsIENhY2hlU2VydmljZSBvbiB0aGlzIG9iamVjdC9jbGFzc1xuICAgIC8vIGp1c3QgdG8gbWFrZSBzdXJlIHRoYXQgaXQgaGFzIGFjY2Vzc1xuICAgIC8vIHRvIHRoZSBjYWNoZSByZXRyaWV2YWwgbWVjaGFuaXNtc1xuXG4gICAgQ2FjaGluZ1NlcnZpY2UuQ2FjaGVTZXJ2aWNlKHRoaXMpO1xuICAgIFxuICAgIHRoaXMuZGF0YXNldG5hbWUgPSBuYW1lO1xuXG4gICAgaWYgKCAhIGRhdGEucmV0cmlldmVkICkge1xuICAgICAgICBkYXRhLnJldHJpZXZlZCA9IG5ldyBEYXRlKCk7XG4gICAgfVxuICAgIGlmICggISBkYXRhLnRpdGxlICkge1xuICAgICAgICBkYXRhLnRpdGxlID0gbmFtZTtcbiAgICB9XG5cbiAgICBzZWxmLnRpdGxlID0gZGF0YS50aXRsZTtcblxuICAgIHZhciBkYXRhc2V0ID0ge307IC8vIEZvcm1hdCBpcyB7IFwiYWNjZXNzaW9uXCIgOiB7IFwiZGF0YVwiIDoge30sIFwicmV0cmlldmVkXCIgOiBcIlwiICwgXCJ0aXRsZVwiIDogXCJcIiAgfSB9O1xuXG4gICAgaWYgKHR5cGVvZiB0aGlzLm1hcCA9PSAnb2JqZWN0Jykge1xuICAgICAgICBkYXRhc2V0ID0gYXBwbHlfbWFwLmNhbGwodGhpcyxkYXRhKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLm1hcCA9PSAnZnVuY3Rpb24nKSB7XG5cbiAgICAgICAgaWYgKHRoaXMubWFwLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgc2VsZl9mdW5jID0gYXJndW1lbnRzLmNhbGxlZTtcbiAgICAgICAgICAgIHRoaXMubWFwKGRhdGEsZnVuY3Rpb24ocGFyc2VkKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5tYXAgPSBmdW5jdGlvbihkKSB7IHJldHVybiAoZCk7IH07XG4gICAgICAgICAgICAgICAgc2VsZl9mdW5jLmNhbGwoc2VsZixuYW1lLHBhcnNlZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkYXRhc2V0ID0gdGhpcy5tYXAoZGF0YSk7XG4gICAgfVxuXG4gICAgaWYgKCAhIHRoaXMubWFwICkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZGF0YSA9IGRhdGFzZXQ7XG4gICAgXG4gICAgdmFyIGluc2VydGVyID0gbmV3IFVzZXJkYXRhUmVhZGVyKCk7XG5cbiAgICBpbnNlcnRlci50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc2VsZi50b1N0cmluZygpO1xuICAgIH07XG5cbiAgICBpbnNlcnRlci5kYXRhID0gZGF0YXNldDtcbiAgICBcbiAgICBpbnNlcnRlci5yZXRyaWV2ZSA9IGZ1bmN0aW9uKGFuX2FjYyxjYmFjaykge1xuICAgICAgICB0aGlzLmFnaSA9IGFuX2FjYztcbiAgICAgICAgLy8gdGhpcy5fZGF0YVJlY2VpdmVkKGRhdGFzZXRbdGhpcy5hZ2ldKTtcbiAgICAgICAgY2JhY2suY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIFxuICAgIENhY2hpbmdTZXJ2aWNlLkNhY2hlU2VydmljZShpbnNlcnRlcik7XG5cbiAgICB2YXIgYWNjcyA9IFtdO1xuICAgIHZhciBhY2M7XG4gICAgZm9yIChhY2MgaW4gZGF0YXNldCkge1xuICAgICAgICBpZiAoZGF0YXNldC5oYXNPd25Qcm9wZXJ0eShhY2MpKSB7XG4gICAgICAgICAgICBpZiAoYWNjLm1hdGNoKC9bQS1aXS8pKSB7XG4gICAgICAgICAgICAgICAgZGF0YXNldFthY2MudG9Mb3dlckNhc2UoKV0gPSBkYXRhc2V0W2FjY107XG4gICAgICAgICAgICAgICAgZGVsZXRlIGRhdGFzZXRbYWNjXTtcbiAgICAgICAgICAgICAgICBhY2MgPSBhY2MudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjY3MucHVzaChhY2MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciB0b3RhbCA9IGFjY3MubGVuZ3RoO1xuXG4gICAgdmFyIHJldHJpZXZlID0gdGhpcy5yZXRyaWV2ZTtcblxuICAgIHRoaXMucmV0cmlldmUgPSBmdW5jdGlvbihpZCxjYmFjaykge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkRhdGEgbm90IHJlYWR5ISBXYWl0aW5nIGZvciByZWFkeSBzdGF0ZVwiKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzOyAgICAgICAgXG4gICAgICAgIGJlYW4uYWRkKHNlbGYsJ3JlYWR5JyxmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGJlYW4ucmVtb3ZlKHNlbGYsJ3JlYWR5Jyxhcmd1bWVudHMuY2FsbGVlKTtcbiAgICAgICAgICAgIHNlbGYucmV0cmlldmUoaWQsY2JhY2spO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGlmIChhY2NzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYucmV0cmlldmUgPSByZXRyaWV2ZTtcbiAgICAgICAgICAgIGJlYW4uZmlyZShzZWxmLCdyZWFkeScsW2RhdGFdKTtcbiAgICAgICAgfSwwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBDYWNoaW5nU2VydmljZS5CdWxrT3BlcmF0aW9uKGZ1bmN0aW9uKGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBiZWFuLmZpcmUoc2VsZiwnZXJyb3InLFtlcnJdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdHJhbnMgPSB0aGlzLnRyYW5zYWN0aW9uO1xuICAgICAgICBpbnNlcnRlci5hdm9pZF9kYXRhYmFzZSA9IHRydWU7XG4gICAgICAgIGluc2VydGVyLnJldHJpZXZlKGFjY3NbMF0sZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB3aGlsZSAoYWNjcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFjYyA9IGFjY3Muc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBiZWFuLmZpcmUoc2VsZiwncHJvZ3Jlc3MnLFsxMDAgKiAoKHRvdGFsIC0gYWNjcy5sZW5ndGgpIC8gdG90YWwpLCB0b3RhbCAtIGFjY3MubGVuZ3RoLCB0b3RhbF0pO1xuICAgICAgICAgICAgICAgIGluc2VydGVyLmFnaSA9IGFjYztcbiAgICAgICAgICAgICAgICBpbnNlcnRlci5fZGF0YVJlY2VpdmVkKGRhdGFzZXRbYWNjXSk7XG4gICAgICAgICAgICAgICAgaWYgKGFjY3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucmV0cmlldmUgPSByZXRyaWV2ZTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnMoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICEgZXJyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlYW4uZmlyZShzZWxmLCdyZWFkeScsW2RhdGFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVhbi5maXJlKHNlbGYsJ2Vycm9yJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcblxuXG59O1xuXG5Vc2VyZGF0YVJlYWRlci5kYXRhc2V0cyA9IGZ1bmN0aW9uKGNiYWNrLGRvbmUpIHtcbiAgICBDYWNoaW5nU2VydmljZS5GaW5kQ2FjaGVkU2VydmljZSh0aGlzLGZ1bmN0aW9uKHNlcnZpY2VzKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNlcnZpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKXtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNlcnZpY2VzW2ldLnJlcGxhY2UoL1VzZXJkYXRhUmVhZGVyLi8sJycpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0LmZvckVhY2gpIHtcbiAgICAgICAgICAgIHJlc3VsdC5mb3JFYWNoKGNiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBVc2VyZGF0YVJlYWRlcjsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBSEE7QUFPQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../gator/js/lib/UserdataReader.js\n')},"./js/SeqViewer.js":
/*!*************************!*\
  !*** ./js/SeqViewer.js ***!
  \*************************/
/*! no exports provided */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _gator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gator */ \"./js/gator.js\");\n/* harmony import */ var mascp_jstools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mascp-jstools */ \"../gator/js/index.js\");\n\n\n\nconst retrieve_uniprot = function retrieve_uniprot(uniprot) {\n  return mascp_jstools__WEBPACK_IMPORTED_MODULE_1__[\"default\"].GatorDataReader.authenticate().then(function (url_base) {\n    let a_reader = new mascp_jstools__WEBPACK_IMPORTED_MODULE_1__[\"default\"].UniprotReader();\n    return new Promise((resolve, reject) => {\n      a_reader.retrieve(uniprot, function (err) {\n        resolve(this.result._raw_data.data[0]);\n      });\n    });\n  });\n};\n\nconst session_ready = new Promise((resolve, reject) => {\n  if (HTMLWidgets.shinyMode) {\n    $(document).on('shiny:sessioninitialized', resolve);\n  } else {\n    reject();\n  }\n});\n\nconst notify_sequence = function notify_sequence(el, seq) {\n  if (HTMLWidgets.shinyMode) {\n    let el_id = el.getAttribute('id');\n    Shiny.setInputValue(\"sequenceChange_\".concat(el_id), seq, {\n      priority: \"event\"\n    });\n  }\n};\n\nconst set_sequence = function set_sequence(el, uniprot) {\n  return retrieve_uniprot(uniprot).then(seq => {\n    let viewer = el.querySelector('x-protviewer');\n    viewer.uniprot = uniprot;\n    return new Promise(resolve => {\n      let resolver = () => {\n        viewer.renderer.unbind('sequenceChange', resolver);\n        viewer.refreshTracks();\n        viewer.fitToZoom();\n\n        for (let track of viewer.querySelectorAll('x-gatortrack')) {\n          track.setAttribute('scale', uniprot);\n        }\n\n        session_ready.then(() => {\n          notify_sequence(el, seq);\n        });\n        resolve();\n      };\n\n      viewer.renderer.bind('sequenceChange', resolver);\n      viewer.renderer.setSequence(seq);\n    });\n  });\n};\n\nconst tmpl = document.createElement('template');\ntmpl.innerHTML = \"\\n<x-protviewer id=\\\"protview\\\" interactive>\\n    <x-gatortrack name=\\\"domains\\\" fullname=\\\"Domains\\\" scale=\\\"uniprot\\\" ></x-gatortrack>\\n    <x-gatortrack name=\\\"ptms\\\" fullname=\\\"PTMS\\\" scale=\\\"uniprot\\\" ></x-gatortrack>\\n    <x-gatortrack name=\\\"data\\\" fullname=\\\"Data\\\" scale=\\\"uniprot\\\" ></x-gatortrack>\\n</x-protviewer>\\n<x-trackrenderer track=\\\"domains\\\" renderer=\\\"protview\\\"></x-trackrenderer>\\n<x-trackrenderer track=\\\"ptms\\\" renderer=\\\"protview\\\"></x-trackrenderer>\\n<x-trackrenderer track=\\\"data\\\" renderer=\\\"protview\\\"></x-trackrenderer>\\n\";\n\nconst render_domains = (el, value) => {\n  return Object(_gator__WEBPACK_IMPORTED_MODULE_0__[\"getData\"])('glycodomain', value).then(dat => {\n    el.querySelector('x-trackrenderer[track=\"domains\"]').data = dat._raw_data.data;\n  });\n};\n\nconst render_ptm_data = (el, value) => {\n  return Object(_gator__WEBPACK_IMPORTED_MODULE_0__[\"getData\"])('combined', value).then(dat => {\n    el.querySelector('x-trackrenderer[track=\"ptms\"]').data = dat._raw_data.data;\n  });\n};\n\nconst pan_listener = function pan_listener(viewer) {\n  console.log('Pan listener', viewer);\n  let el_id = viewer.parentNode.getAttribute('id');\n  let leftvis = viewer.renderer.leftVisibleResidue();\n  let rightvis = viewer.renderer.rightVisibleResidue();\n\n  if (HTMLWidgets.shinyMode) {\n    Shiny.setInputValue('pan_${el_id}', {\n      left: leftvis,\n      right: rightvis\n    }, {\n      priority: \"event\"\n    });\n  } // Send message back to R\n\n};\n\nconst enable_pan_listener = function enable_pan_listener(viewer) {\n  let listener = pan_listener.bind(null, viewer);\n  viewer.addEventListener('pandone', listener);\n  viewer.renderer.bind('zoomChange', listener);\n  return listener;\n};\n\nconst METHODS = {\n  setUniprot: (el, params) => {\n    let value_uc = params.uniprot.toUpperCase();\n    return set_sequence(el, value_uc).then(() => {\n      render_domains(el, value_uc);\n      render_ptm_data(el, value_uc);\n    });\n  },\n  showRange: (el, params) => {\n    let viewer = el.querySelector('x-protviewer');\n\n    if (!viewer.renderer.sequence) {\n      return;\n    }\n\n    viewer.removeEventListener('pandone', viewer.pan_listener);\n    viewer.renderer.unbind('zoomChange', viewer.pan_listener);\n    el.querySelector('x-protviewer').renderer.showResidues(params.min, params.max).then(() => {\n      viewer.pan_listener = enable_pan_listener(viewer);\n    });\n  },\n  addTrack: (el, params) => {\n    let datapoints = HTMLWidgets.dataframeToD3(params.dataframe);\n\n    if (params.track) {\n      datapoints.forEach(point => point.track = params.track);\n    } else {\n      params.track = 'data';\n    }\n\n    el.querySelector(\"x-trackrenderer[track=\\\"\".concat(params.track, \"\\\"]\")).data = datapoints;\n  }\n};\nHTMLWidgets.widget({\n  name: 'SeqViewer',\n  type: 'output',\n  factory: function factory(el, width, height) {\n    let viewer = null;\n    return {\n      renderValue: function renderValue(input) {\n        if (!viewer) {\n          let new_viewer = tmpl.content.cloneNode(true);\n          el.appendChild(new_viewer);\n          viewer = el.getElementsByTagName('x-protviewer').protview;\n          viewer.setAttribute('id', 'protviewer-' + el.getAttribute('id'));\n\n          for (let renderer of el.querySelectorAll('x-trackrenderer')) {\n            renderer.setAttribute('renderer', 'protviewer-' + el.getAttribute('id'));\n          }\n        }\n\n        let params = input.message;\n\n        if (params.interactive) {\n          viewer.setAttribute('interactive', '');\n          viewer.removeAttribute('selecting');\n        } else {\n          viewer.removeAttribute('interactive');\n        }\n\n        if (!params.ptms) {\n          let ptm_track = el.querySelector('x-gatortrack[name=\"ptms\"]');\n          ptm_track.parentNode.removeChild(ptm_track);\n        }\n\n        if (!params.domains) {\n          let domain_track = el.querySelector('x-gatortrack[name=\"domains\"]');\n          domain_track.parentNode.removeChild(domain_track);\n        } // https://github.com/ramnathv/htmlwidgets/issues/71\n\n\n        el.querySelector('x-trackrenderer[track=\"domains\"]').setAttribute('src', HTMLWidgets.getAttachmentUrl('renderers', 'glycodomain.packed'));\n        el.querySelector('x-trackrenderer[track=\"ptms\"]').setAttribute('src', HTMLWidgets.getAttachmentUrl('renderers', 'msdata.packed'));\n        el.querySelector('x-trackrenderer[track=\"data\"]').setAttribute('src', HTMLWidgets.getAttachmentUrl('renderers', 'customdata.packed'));\n\n        if (HTMLWidgets.shinyMode) {\n          for (let method of Object.keys(METHODS)) {\n            Shiny.addCustomMessageHandler(\"seqviewer:\".concat(method), message => {\n              var el = document.getElementById(message.id);\n\n              if (el) {\n                METHODS[method](el, message);\n              }\n            });\n          }\n\n          viewer.pan_listener = enable_pan_listener(viewer);\n        }\n\n        let seqset = Promise.resolve();\n\n        if (params.uniprot) {\n          seqset = METHODS['setUniprot'](el, params);\n        }\n\n        if (params.dataframe) {\n          seqset.then(() => METHODS['addTrack'](el, params));\n        }\n\n        if (input.api) {\n          input.api.map(message => {\n            message.method = message.method.split(':')[1];\n            return message;\n          }).sort((a, b) => {\n            if (a.method == 'setUniprot') {\n              return -1;\n            }\n\n            return 1;\n          }).forEach(message => {\n            if (message.method == 'setUniprot') {\n              seqset = seqset.then(() => {\n                return METHODS[message.method](el, message);\n              });\n            } else {\n              seqset.then(() => METHODS[message.method](el, message));\n            }\n          });\n        }\n      },\n      resize: function resize(width, height) {// TODO: code to re-render the widget with a new size\n      }\n    };\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9qcy9TZXFWaWV3ZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9TZXFWaWV3ZXIuanM/YjJkMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXREYXRhIH0gZnJvbSAnLi9nYXRvcic7XG5cbmltcG9ydCBNQVNDUCBmcm9tICdtYXNjcC1qc3Rvb2xzJztcblxuY29uc3QgcmV0cmlldmVfdW5pcHJvdCA9IGZ1bmN0aW9uKHVuaXByb3QpIHtcbiAgcmV0dXJuIE1BU0NQLkdhdG9yRGF0YVJlYWRlci5hdXRoZW50aWNhdGUoKS50aGVuKGZ1bmN0aW9uKHVybF9iYXNlKSB7XG4gICAgbGV0IGFfcmVhZGVyID0gbmV3IE1BU0NQLlVuaXByb3RSZWFkZXIoKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUscmVqZWN0KSA9PiB7XG4gICAgYV9yZWFkZXIucmV0cmlldmUodW5pcHJvdCwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICByZXNvbHZlKHRoaXMucmVzdWx0Ll9yYXdfZGF0YS5kYXRhWzBdKTtcbiAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5jb25zdCBzZXNzaW9uX3JlYWR5ID0gbmV3IFByb21pc2UoIChyZXNvbHZlLHJlamVjdCkgPT4ge1xuICBpZiAoSFRNTFdpZGdldHMuc2hpbnlNb2RlKSB7XG4gICAgJChkb2N1bWVudCkub24oJ3NoaW55OnNlc3Npb25pbml0aWFsaXplZCcsIHJlc29sdmUpO1xuICB9IGVsc2Uge1xuICAgIHJlamVjdCgpO1xuICB9XG59KTtcblxuY29uc3Qgbm90aWZ5X3NlcXVlbmNlID0gZnVuY3Rpb24oZWwsc2VxKSB7XG4gIGlmIChIVE1MV2lkZ2V0cy5zaGlueU1vZGUpIHtcbiAgICBsZXQgZWxfaWQgPSBlbC5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgU2hpbnkuc2V0SW5wdXRWYWx1ZShgc2VxdWVuY2VDaGFuZ2VfJHtlbF9pZH1gLHNlcSwgeyBwcmlvcml0eTogXCJldmVudFwifSk7XG4gIH1cbn07XG5cbmNvbnN0IHNldF9zZXF1ZW5jZSA9IGZ1bmN0aW9uKGVsLHVuaXByb3QpIHtcbiAgcmV0dXJuIHJldHJpZXZlX3VuaXByb3QodW5pcHJvdCkudGhlbiAoc2VxID0+IHtcbiAgICBsZXQgdmlld2VyID0gZWwucXVlcnlTZWxlY3RvcigneC1wcm90dmlld2VyJyk7XG4gICAgdmlld2VyLnVuaXByb3QgPSB1bmlwcm90O1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSggcmVzb2x2ZSA9PiB7XG4gICAgICBsZXQgcmVzb2x2ZXIgPSAoKSA9PiB7XG4gICAgICAgIHZpZXdlci5yZW5kZXJlci51bmJpbmQoJ3NlcXVlbmNlQ2hhbmdlJyxyZXNvbHZlcik7XG4gICAgICAgIHZpZXdlci5yZWZyZXNoVHJhY2tzKCk7XG4gICAgICAgIHZpZXdlci5maXRUb1pvb20oKTtcbiAgICAgICAgZm9yIChsZXQgdHJhY2sgb2Ygdmlld2VyLnF1ZXJ5U2VsZWN0b3JBbGwoJ3gtZ2F0b3J0cmFjaycpKSB7XG4gICAgICAgICAgdHJhY2suc2V0QXR0cmlidXRlKCdzY2FsZScsdW5pcHJvdCk7XG4gICAgICAgIH1cbiAgICAgICAgc2Vzc2lvbl9yZWFkeS50aGVuKCAoKSA9PiB7XG4gICAgICAgICAgbm90aWZ5X3NlcXVlbmNlKGVsLHNlcSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9O1xuICAgICAgdmlld2VyLnJlbmRlcmVyLmJpbmQoJ3NlcXVlbmNlQ2hhbmdlJyxyZXNvbHZlcik7XG4gICAgICB2aWV3ZXIucmVuZGVyZXIuc2V0U2VxdWVuY2Uoc2VxKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5cblxuY29uc3QgdG1wbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG5cbnRtcGwuaW5uZXJIVE1MID0gYFxuPHgtcHJvdHZpZXdlciBpZD1cInByb3R2aWV3XCIgaW50ZXJhY3RpdmU+XG4gICAgPHgtZ2F0b3J0cmFjayBuYW1lPVwiZG9tYWluc1wiIGZ1bGxuYW1lPVwiRG9tYWluc1wiIHNjYWxlPVwidW5pcHJvdFwiID48L3gtZ2F0b3J0cmFjaz5cbiAgICA8eC1nYXRvcnRyYWNrIG5hbWU9XCJwdG1zXCIgZnVsbG5hbWU9XCJQVE1TXCIgc2NhbGU9XCJ1bmlwcm90XCIgPjwveC1nYXRvcnRyYWNrPlxuICAgIDx4LWdhdG9ydHJhY2sgbmFtZT1cImRhdGFcIiBmdWxsbmFtZT1cIkRhdGFcIiBzY2FsZT1cInVuaXByb3RcIiA+PC94LWdhdG9ydHJhY2s+XG48L3gtcHJvdHZpZXdlcj5cbjx4LXRyYWNrcmVuZGVyZXIgdHJhY2s9XCJkb21haW5zXCIgcmVuZGVyZXI9XCJwcm90dmlld1wiPjwveC10cmFja3JlbmRlcmVyPlxuPHgtdHJhY2tyZW5kZXJlciB0cmFjaz1cInB0bXNcIiByZW5kZXJlcj1cInByb3R2aWV3XCI+PC94LXRyYWNrcmVuZGVyZXI+XG48eC10cmFja3JlbmRlcmVyIHRyYWNrPVwiZGF0YVwiIHJlbmRlcmVyPVwicHJvdHZpZXdcIj48L3gtdHJhY2tyZW5kZXJlcj5cbmA7XG5cbmNvbnN0IHJlbmRlcl9kb21haW5zID0gKGVsLHZhbHVlKSA9PiB7XG4gIHJldHVybiBnZXREYXRhKCdnbHljb2RvbWFpbicsdmFsdWUpLnRoZW4oIGRhdCA9PiB7XG4gICAgZWwucXVlcnlTZWxlY3RvcigneC10cmFja3JlbmRlcmVyW3RyYWNrPVwiZG9tYWluc1wiXScpLmRhdGEgPSBkYXQuX3Jhd19kYXRhLmRhdGE7XG4gIH0pO1xufTtcblxuY29uc3QgcmVuZGVyX3B0bV9kYXRhID0gKGVsLHZhbHVlKSA9PiB7XG4gIHJldHVybiBnZXREYXRhKCdjb21iaW5lZCcsdmFsdWUpLnRoZW4oIGRhdCA9PiB7XG4gICAgZWwucXVlcnlTZWxlY3RvcigneC10cmFja3JlbmRlcmVyW3RyYWNrPVwicHRtc1wiXScpLmRhdGEgPSBkYXQuX3Jhd19kYXRhLmRhdGE7XG4gIH0pO1xufTtcblxuXG5cbmNvbnN0IHBhbl9saXN0ZW5lciA9IGZ1bmN0aW9uKHZpZXdlcikge1xuICBjb25zb2xlLmxvZygnUGFuIGxpc3RlbmVyJyx2aWV3ZXIpO1xuICBsZXQgZWxfaWQgPSB2aWV3ZXIucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG4gIGxldCBsZWZ0dmlzID0gdmlld2VyLnJlbmRlcmVyLmxlZnRWaXNpYmxlUmVzaWR1ZSgpO1xuICBsZXQgcmlnaHR2aXMgPSB2aWV3ZXIucmVuZGVyZXIucmlnaHRWaXNpYmxlUmVzaWR1ZSgpO1xuICBpZiAoSFRNTFdpZGdldHMuc2hpbnlNb2RlKSB7XG4gICAgU2hpbnkuc2V0SW5wdXRWYWx1ZSgncGFuXyR7ZWxfaWR9Jyx7IGxlZnQ6IGxlZnR2aXMsIHJpZ2h0OiByaWdodHZpcyAgfSwgeyBwcmlvcml0eTogXCJldmVudFwifSk7XG4gIH1cbiAgLy8gU2VuZCBtZXNzYWdlIGJhY2sgdG8gUlxufTtcblxuY29uc3QgZW5hYmxlX3Bhbl9saXN0ZW5lciA9IGZ1bmN0aW9uKHZpZXdlcil7XG4gIGxldCBsaXN0ZW5lciA9IHBhbl9saXN0ZW5lci5iaW5kKG51bGwsdmlld2VyKTtcbiAgdmlld2VyLmFkZEV2ZW50TGlzdGVuZXIoJ3BhbmRvbmUnLGxpc3RlbmVyKTtcbiAgdmlld2VyLnJlbmRlcmVyLmJpbmQoJ3pvb21DaGFuZ2UnLGxpc3RlbmVyKTtcbiAgcmV0dXJuIGxpc3RlbmVyO1xufTtcblxuXG5jb25zdCBNRVRIT0RTID0ge1xuICBzZXRVbmlwcm90OiAoZWwscGFyYW1zKSA9PiB7XG4gICAgbGV0IHZhbHVlX3VjID0gcGFyYW1zLnVuaXByb3QudG9VcHBlckNhc2UoKTtcbiAgICByZXR1cm4gc2V0X3NlcXVlbmNlKGVsLHZhbHVlX3VjKS50aGVuKCAoKSA9PiB7XG4gICAgICByZW5kZXJfZG9tYWlucyhlbCx2YWx1ZV91Yyk7XG4gICAgICByZW5kZXJfcHRtX2RhdGEoZWwsdmFsdWVfdWMpO1xuICAgIH0pO1xuICB9LFxuICBzaG93UmFuZ2U6IChlbCxwYXJhbXMpID0+IHtcbiAgICBsZXQgdmlld2VyID0gZWwucXVlcnlTZWxlY3RvcigneC1wcm90dmlld2VyJyk7XG4gICAgaWYgKCAhIHZpZXdlci5yZW5kZXJlci5zZXF1ZW5jZSApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmlld2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BhbmRvbmUnLHZpZXdlci5wYW5fbGlzdGVuZXIpO1xuICAgIHZpZXdlci5yZW5kZXJlci51bmJpbmQoJ3pvb21DaGFuZ2UnLHZpZXdlci5wYW5fbGlzdGVuZXIpO1xuICAgIGVsLnF1ZXJ5U2VsZWN0b3IoJ3gtcHJvdHZpZXdlcicpLnJlbmRlcmVyLnNob3dSZXNpZHVlcyhwYXJhbXMubWluLHBhcmFtcy5tYXgpXG4gICAgLnRoZW4oICgpID0+IHtcbiAgICAgIHZpZXdlci5wYW5fbGlzdGVuZXIgPSBlbmFibGVfcGFuX2xpc3RlbmVyKHZpZXdlcik7XG4gICAgfSlcbiAgfSxcbiAgYWRkVHJhY2s6IChlbCxwYXJhbXMpID0+IHtcbiAgICBsZXQgZGF0YXBvaW50cyA9IEhUTUxXaWRnZXRzLmRhdGFmcmFtZVRvRDMocGFyYW1zLmRhdGFmcmFtZSk7XG4gICAgaWYgKHBhcmFtcy50cmFjaykge1xuICAgICAgZGF0YXBvaW50cy5mb3JFYWNoKCBwb2ludCA9PiBwb2ludC50cmFjayA9IHBhcmFtcy50cmFjayApO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJhbXMudHJhY2sgPSAnZGF0YSc7XG4gICAgfVxuICAgIGVsLnF1ZXJ5U2VsZWN0b3IoYHgtdHJhY2tyZW5kZXJlclt0cmFjaz1cIiR7cGFyYW1zLnRyYWNrfVwiXWApLmRhdGEgPSBkYXRhcG9pbnRzO1xuICB9XG59O1xuXG5cbkhUTUxXaWRnZXRzLndpZGdldCh7XG5cbiAgbmFtZTogJ1NlcVZpZXdlcicsXG5cbiAgdHlwZTogJ291dHB1dCcsXG5cbiAgZmFjdG9yeTogZnVuY3Rpb24oZWwsIHdpZHRoLCBoZWlnaHQpIHtcblxuICAgIGxldCB2aWV3ZXIgPSBudWxsO1xuXG4gICAgcmV0dXJuIHtcblxuICAgICAgcmVuZGVyVmFsdWU6IGZ1bmN0aW9uKGlucHV0KSB7XG5cbiAgICAgICAgaWYgKCAhIHZpZXdlciApIHtcbiAgICAgICAgICBsZXQgbmV3X3ZpZXdlciA9IHRtcGwuY29udGVudC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgICAgZWwuYXBwZW5kQ2hpbGQobmV3X3ZpZXdlcik7XG4gICAgICAgICAgdmlld2VyID0gZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3gtcHJvdHZpZXdlcicpLnByb3R2aWV3O1xuICAgICAgICAgIHZpZXdlci5zZXRBdHRyaWJ1dGUoJ2lkJywncHJvdHZpZXdlci0nK2VsLmdldEF0dHJpYnV0ZSgnaWQnKSk7XG4gICAgICAgICAgZm9yIChsZXQgcmVuZGVyZXIgb2YgZWwucXVlcnlTZWxlY3RvckFsbCgneC10cmFja3JlbmRlcmVyJykpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLnNldEF0dHJpYnV0ZSgncmVuZGVyZXInLCdwcm90dmlld2VyLScrZWwuZ2V0QXR0cmlidXRlKCdpZCcpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcGFyYW1zID0gaW5wdXQubWVzc2FnZTtcblxuICAgICAgICBpZiAocGFyYW1zLmludGVyYWN0aXZlKSB7XG4gICAgICAgICAgdmlld2VyLnNldEF0dHJpYnV0ZSgnaW50ZXJhY3RpdmUnLCcnKTtcbiAgICAgICAgICB2aWV3ZXIucmVtb3ZlQXR0cmlidXRlKCdzZWxlY3RpbmcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2aWV3ZXIucmVtb3ZlQXR0cmlidXRlKCdpbnRlcmFjdGl2ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCAhIHBhcmFtcy5wdG1zICkge1xuICAgICAgICAgIGxldCBwdG1fdHJhY2sgPSBlbC5xdWVyeVNlbGVjdG9yKCd4LWdhdG9ydHJhY2tbbmFtZT1cInB0bXNcIl0nKTtcbiAgICAgICAgICBwdG1fdHJhY2sucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwdG1fdHJhY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCAhIHBhcmFtcy5kb21haW5zICkge1xuICAgICAgICAgIGxldCBkb21haW5fdHJhY2sgPSBlbC5xdWVyeVNlbGVjdG9yKCd4LWdhdG9ydHJhY2tbbmFtZT1cImRvbWFpbnNcIl0nKTtcbiAgICAgICAgICBkb21haW5fdHJhY2sucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkb21haW5fdHJhY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3JhbW5hdGh2L2h0bWx3aWRnZXRzL2lzc3Vlcy83MVxuXG4gICAgICAgIGVsLnF1ZXJ5U2VsZWN0b3IoJ3gtdHJhY2tyZW5kZXJlclt0cmFjaz1cImRvbWFpbnNcIl0nKS5zZXRBdHRyaWJ1dGUoJ3NyYycsSFRNTFdpZGdldHMuZ2V0QXR0YWNobWVudFVybCgncmVuZGVyZXJzJywgJ2dseWNvZG9tYWluLnBhY2tlZCcpKTtcbiAgICAgICAgZWwucXVlcnlTZWxlY3RvcigneC10cmFja3JlbmRlcmVyW3RyYWNrPVwicHRtc1wiXScpLnNldEF0dHJpYnV0ZSgnc3JjJyxIVE1MV2lkZ2V0cy5nZXRBdHRhY2htZW50VXJsKCdyZW5kZXJlcnMnLCAnbXNkYXRhLnBhY2tlZCcpKTtcbiAgICAgICAgZWwucXVlcnlTZWxlY3RvcigneC10cmFja3JlbmRlcmVyW3RyYWNrPVwiZGF0YVwiXScpLnNldEF0dHJpYnV0ZSgnc3JjJyxIVE1MV2lkZ2V0cy5nZXRBdHRhY2htZW50VXJsKCdyZW5kZXJlcnMnLCAnY3VzdG9tZGF0YS5wYWNrZWQnKSk7XG5cbiAgICAgICAgaWYgKEhUTUxXaWRnZXRzLnNoaW55TW9kZSkge1xuICAgICAgICAgIGZvciAobGV0IG1ldGhvZCBvZiBPYmplY3Qua2V5cyhNRVRIT0RTKSkge1xuICAgICAgICAgICAgU2hpbnkuYWRkQ3VzdG9tTWVzc2FnZUhhbmRsZXIoYHNlcXZpZXdlcjoke21ldGhvZH1gLCBtZXNzYWdlID0+IHtcbiAgICAgICAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobWVzc2FnZS5pZCk7XG4gICAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICAgIE1FVEhPRFNbbWV0aG9kXShlbCxtZXNzYWdlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmlld2VyLnBhbl9saXN0ZW5lciA9IGVuYWJsZV9wYW5fbGlzdGVuZXIodmlld2VyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzZXFzZXQgPSBQcm9taXNlLnJlc29sdmUoKTtcblxuICAgICAgICBpZiAocGFyYW1zLnVuaXByb3QpIHtcbiAgICAgICAgICBzZXFzZXQgPSBNRVRIT0RTWydzZXRVbmlwcm90J10oZWwscGFyYW1zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbXMuZGF0YWZyYW1lKSB7XG4gICAgICAgICAgc2Vxc2V0LnRoZW4oICgpID0+IE1FVEhPRFNbJ2FkZFRyYWNrJ10oZWwscGFyYW1zKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5wdXQuYXBpKSB7XG4gICAgICAgICAgaW5wdXQuYXBpLm1hcChtZXNzYWdlID0+IHtcbiAgICAgICAgICAgIG1lc3NhZ2UubWV0aG9kID0gbWVzc2FnZS5tZXRob2Quc3BsaXQoJzonKVsxXTtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgIH0pLnNvcnQoIChhLGIpID0+IHtcbiAgICAgICAgICAgIGlmIChhLm1ldGhvZCA9PSAnc2V0VW5pcHJvdCcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgfSkuZm9yRWFjaCggbWVzc2FnZSA9PiB7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tZXRob2QgPT0gJ3NldFVuaXByb3QnKSB7XG4gICAgICAgICAgICAgIHNlcXNldCA9IHNlcXNldC50aGVuKCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1FVEhPRFNbbWVzc2FnZS5tZXRob2RdKGVsLG1lc3NhZ2UpOyAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZXFzZXQudGhlbiggKCkgPT4gTUVUSE9EU1ttZXNzYWdlLm1ldGhvZF0oZWwsbWVzc2FnZSkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgfSxcblxuICAgICAgcmVzaXplOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG5cbiAgICAgICAgLy8gVE9ETzogY29kZSB0byByZS1yZW5kZXIgdGhlIHdpZGdldCB3aXRoIGEgbmV3IHNpemVcblxuICAgICAgfVxuXG4gICAgfTtcbiAgfVxufSk7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBNUJBO0FBZ0NBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBSUE7QUF4RkE7QUEyRkE7QUFyR0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./js/SeqViewer.js\n")},"./js/gator.js":
/*!*********************!*\
  !*** ./js/gator.js ***!
  \*********************/
/*! exports provided: getMetadata, getData, getExpression */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMetadata", function() { return getMetadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getData", function() { return getData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getExpression", function() { return getExpression; });\n/* harmony import */ var mascp_jstools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mascp-jstools */ "../gator/js/index.js");\n\nmascp_jstools__WEBPACK_IMPORTED_MODULE_0__["default"].GatorDataReader.anonymous = true;\nmascp_jstools__WEBPACK_IMPORTED_MODULE_0__["default"].GatorDataReader.server = \'https://glycodomain.glycomics.ku.dk\';\nmascp_jstools__WEBPACK_IMPORTED_MODULE_0__["default"].AUTH0_CLIENT_ID = \'fNED1UGvPaP0XlrcEvWsHXIODIKy6WVB\';\nmascp_jstools__WEBPACK_IMPORTED_MODULE_0__["default"].GATOR_CLIENT_ID = mascp_jstools__WEBPACK_IMPORTED_MODULE_0__["default"].AUTH0_CLIENT_ID;\n\nlet getData = function getData(dataset, accession) {\n  return mascp_jstools__WEBPACK_IMPORTED_MODULE_0__["default"].GatorDataReader.authenticate().then(function (url_base) {\n    let a_reader = mascp_jstools__WEBPACK_IMPORTED_MODULE_0__["default"].GatorDataReader.createReader(dataset);\n    a_reader.datasetname = dataset;\n    return new Promise((resolve, reject) => {\n      a_reader.retrieve(accession, function (err) {\n        resolve(this.result);\n      });\n    });\n  });\n};\n\nlet getMetadata = function getMetadata(dataset) {\n  return mascp_jstools__WEBPACK_IMPORTED_MODULE_0__["default"].GatorDataReader.authenticate().then(function (url_base) {\n    let headers = new Headers();\n    headers.append(\'Authorization\', \'Bearer \' + mascp_jstools__WEBPACK_IMPORTED_MODULE_0__["default"].GATOR_AUTH_TOKEN);\n    headers.append(\'x-api-key\', mascp_jstools__WEBPACK_IMPORTED_MODULE_0__["default"].GATOR_CLIENT_ID);\n    let req_params = {\n      method: \'GET\',\n      headers: headers\n    };\n    let req = new Request("".concat(url_base, "/metadata/").concat(dataset), req_params);\n    return fetch(req).then(resp => resp.json());\n  });\n};\n\nlet hydrate_expression = (metadata, dat) => {\n  let values = dat._raw_data.data;\n  let locations = metadata.locations;\n  locations.forEach((loc, idx) => loc.expression = values[idx]);\n  return locations;\n};\n\nlet getExpression = (dataset, geneid) => {\n  return getMetadata(dataset).then(meta => {\n    return getData(dataset, geneid).then(hydrate_expression.bind(null, meta));\n  });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9qcy9nYXRvci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2pzL2dhdG9yLmpzPzMzYzMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE1BU0NQIGZyb20gJ21hc2NwLWpzdG9vbHMnO1xuXG5NQVNDUC5HYXRvckRhdGFSZWFkZXIuYW5vbnltb3VzID0gdHJ1ZTtcblxuTUFTQ1AuR2F0b3JEYXRhUmVhZGVyLnNlcnZlciA9ICdodHRwczovL2dseWNvZG9tYWluLmdseWNvbWljcy5rdS5kayc7XG5cbk1BU0NQLkFVVEgwX0NMSUVOVF9JRD0nZk5FRDFVR3ZQYVAwWGxyY0V2V3NIWElPRElLeTZXVkInO1xuTUFTQ1AuR0FUT1JfQ0xJRU5UX0lEPU1BU0NQLkFVVEgwX0NMSUVOVF9JRDtcblxubGV0IGdldERhdGEgPSBmdW5jdGlvbihkYXRhc2V0LGFjY2Vzc2lvbikge1xuICByZXR1cm4gTUFTQ1AuR2F0b3JEYXRhUmVhZGVyLmF1dGhlbnRpY2F0ZSgpLnRoZW4oZnVuY3Rpb24odXJsX2Jhc2UpIHtcbiAgICBsZXQgYV9yZWFkZXIgPSBNQVNDUC5HYXRvckRhdGFSZWFkZXIuY3JlYXRlUmVhZGVyKGRhdGFzZXQpO1xuICAgIGFfcmVhZGVyLmRhdGFzZXRuYW1lID0gZGF0YXNldDtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUscmVqZWN0KSA9PiB7XG4gICAgICBhX3JlYWRlci5yZXRyaWV2ZShhY2Nlc3Npb24sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICByZXNvbHZlKHRoaXMucmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbmxldCBnZXRNZXRhZGF0YSA9IGZ1bmN0aW9uKGRhdGFzZXQpIHtcbiAgcmV0dXJuIE1BU0NQLkdhdG9yRGF0YVJlYWRlci5hdXRoZW50aWNhdGUoKS50aGVuKGZ1bmN0aW9uKHVybF9iYXNlKSB7XG4gICAgbGV0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgIGhlYWRlcnMuYXBwZW5kKCdBdXRob3JpemF0aW9uJywnQmVhcmVyICcrTUFTQ1AuR0FUT1JfQVVUSF9UT0tFTik7XG4gICAgaGVhZGVycy5hcHBlbmQoJ3gtYXBpLWtleScsTUFTQ1AuR0FUT1JfQ0xJRU5UX0lEKTtcbiAgICBsZXQgcmVxX3BhcmFtcyA9IHtcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICBoZWFkZXJzOiBoZWFkZXJzXG4gICAgfTtcbiAgICBsZXQgcmVxID0gbmV3IFJlcXVlc3QoYCR7dXJsX2Jhc2V9L21ldGFkYXRhLyR7ZGF0YXNldH1gLCByZXFfcGFyYW1zKTtcbiAgICByZXR1cm4gZmV0Y2gocmVxKS50aGVuKCByZXNwID0+IHJlc3AuanNvbigpKTtcbiAgfSk7XG59O1xuXG5sZXQgaHlkcmF0ZV9leHByZXNzaW9uID0gKG1ldGFkYXRhLGRhdCkgPT4ge1xuICBsZXQgdmFsdWVzID0gZGF0Ll9yYXdfZGF0YS5kYXRhO1xuICBsZXQgbG9jYXRpb25zID0gbWV0YWRhdGEubG9jYXRpb25zO1xuICBsb2NhdGlvbnMuZm9yRWFjaCggKGxvYyxpZHgpID0+IGxvYy5leHByZXNzaW9uID0gdmFsdWVzW2lkeF0gKTtcbiAgcmV0dXJuIGxvY2F0aW9ucztcbn1cblxubGV0IGdldEV4cHJlc3Npb24gPSAoZGF0YXNldCxnZW5laWQpID0+IHtcbiAgcmV0dXJuIGdldE1ldGFkYXRhKGRhdGFzZXQpLnRoZW4oIG1ldGEgPT4ge1xuICAgIHJldHVybiBnZXREYXRhKGRhdGFzZXQsZ2VuZWlkKS50aGVuKCBoeWRyYXRlX2V4cHJlc3Npb24uYmluZChudWxsLG1ldGEpICk7XG4gIH0pO1xufVxuXG5cbmV4cG9ydCB7IGdldE1ldGFkYXRhLCBnZXREYXRhLCBnZXRFeHByZXNzaW9uIH07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./js/gator.js\n')},"./node_modules/.registry.npmjs.org/webpack/4.29.6/node_modules/webpack/buildin/amd-options.js":
/*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
/*! no static exports found */function(module,exports){eval("/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */\nmodule.exports = __webpack_amd_options__;\n\n/* WEBPACK VAR INJECTION */}.call(this, {}))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy93ZWJwYWNrLzQuMjkuNi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2FtZC1vcHRpb25zLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2FtZC1vcHRpb25zLmpzPzAwODYiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFscyBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXyAqL1xubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXztcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.registry.npmjs.org/webpack/4.29.6/node_modules/webpack/buildin/amd-options.js\n")},"./node_modules/.registry.npmjs.org/webpack/4.29.6/node_modules/webpack/buildin/harmony-module.js":
/*!*******************************************!*\
  !*** (webpack)/buildin/harmony-module.js ***!
  \*******************************************/
/*! no static exports found */function(module,exports){eval('module.exports = function (originalModule) {\n  if (!originalModule.webpackPolyfill) {\n    var module = Object.create(originalModule); // module.parent = undefined by default\n\n    if (!module.children) module.children = [];\n    Object.defineProperty(module, "loaded", {\n      enumerable: true,\n      get: function get() {\n        return module.l;\n      }\n    });\n    Object.defineProperty(module, "id", {\n      enumerable: true,\n      get: function get() {\n        return module.i;\n      }\n    });\n    Object.defineProperty(module, "exports", {\n      enumerable: true\n    });\n    module.webpackPolyfill = 1;\n  }\n\n  return module;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnJlZ2lzdHJ5Lm5wbWpzLm9yZy93ZWJwYWNrLzQuMjkuNi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2hhcm1vbnktbW9kdWxlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2hhcm1vbnktbW9kdWxlLmpzPzgyYjAiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcmlnaW5hbE1vZHVsZSkge1xuXHRpZiAoIW9yaWdpbmFsTW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdHZhciBtb2R1bGUgPSBPYmplY3QuY3JlYXRlKG9yaWdpbmFsTW9kdWxlKTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJleHBvcnRzXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWVcblx0XHR9KTtcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcblx0fVxuXHRyZXR1cm4gbW9kdWxlO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/.registry.npmjs.org/webpack/4.29.6/node_modules/webpack/buildin/harmony-module.js\n')},0:
/*!*******************************!*\
  !*** multi ./js/SeqViewer.js ***!
  \*******************************/
/*! no static exports found */function(g,I,C){g.exports=C(/*! ./js/SeqViewer.js */"./js/SeqViewer.js")}});